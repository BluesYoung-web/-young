var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports2, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a3 = "day", o2 = "week", f2 = "month", h29 = "quarter", c2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m3 = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v3 = { s: m3, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m3(r2, 2, "0") + ":" + m3(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f2), s3 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s3 ? -1 : 1), f2);
        return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f2, y: c2, w: o2, d: a3, D: d2, h: u2, m: s2, s: i, ms: r, Q: h29 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D3 = {};
      D3[g] = M3;
      var p2 = function(t2) {
        return t2 instanceof _2;
      }, S3 = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s3 = e2.toLowerCase();
          D3[s3] && (i2 = s3), n2 && (D3[s3] = n2, i2 = s3);
          var u3 = e2.split("-");
          if (!i2 && u3.length > 1)
            return t2(u3[0]);
        } else {
          var a4 = e2.name;
          D3[a4] = e2, i2 = a4;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, w3 = function(t2, e2) {
        if (p2(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _2(n2);
      }, O3 = v3;
      O3.l = S3, O3.i = p2, O3.w = function(t2, e2) {
        return w3(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _2 = function() {
        function M4(t2) {
          this.$L = S3(t2.locale, null, true), this.parse(t2);
        }
        var m4 = M4.prototype;
        return m4.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (O3.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($2);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m4.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m4.$utils = function() {
          return O3;
        }, m4.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m4.isSame = function(t2, e2) {
          var n2 = w3(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m4.isAfter = function(t2, e2) {
          return w3(t2) < this.startOf(e2);
        }, m4.isBefore = function(t2, e2) {
          return this.endOf(e2) < w3(t2);
        }, m4.$g = function(t2, e2, n2) {
          return O3.u(t2) ? this[e2] : this.set(n2, t2);
        }, m4.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m4.valueOf = function() {
          return this.$d.getTime();
        }, m4.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O3.u(e2) || e2, h30 = O3.p(t2), l3 = function(t3, e3) {
            var i2 = O3.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a3);
          }, $3 = function(t3, e3) {
            return O3.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y3 = this.$W, M5 = this.$M, m5 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
          switch (h30) {
            case c2:
              return r2 ? l3(1, 0) : l3(31, 11);
            case f2:
              return r2 ? l3(1, M5) : l3(0, M5 + 1);
            case o2:
              var g2 = this.$locale().weekStart || 0, D4 = (y3 < g2 ? y3 + 7 : y3) - g2;
              return l3(r2 ? m5 - D4 : m5 + (6 - D4), M5);
            case a3:
            case d2:
              return $3(v4 + "Hours", 0);
            case u2:
              return $3(v4 + "Minutes", 1);
            case s2:
              return $3(v4 + "Seconds", 2);
            case i:
              return $3(v4 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m4.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m4.$set = function(t2, e2) {
          var n2, o3 = O3.p(t2), h30 = "set" + (this.$u ? "UTC" : ""), l3 = (n2 = {}, n2[a3] = h30 + "Date", n2[d2] = h30 + "Date", n2[f2] = h30 + "Month", n2[c2] = h30 + "FullYear", n2[u2] = h30 + "Hours", n2[s2] = h30 + "Minutes", n2[i] = h30 + "Seconds", n2[r] = h30 + "Milliseconds", n2)[o3], $3 = o3 === a3 ? this.$D + (e2 - this.$W) : e2;
          if (o3 === f2 || o3 === c2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($3);
          return this.init(), this;
        }, m4.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m4.get = function(t2) {
          return this[O3.p(t2)]();
        }, m4.add = function(r2, h30) {
          var d3, l3 = this;
          r2 = Number(r2);
          var $3 = O3.p(h30), y3 = function(t2) {
            var e2 = w3(l3);
            return O3.w(e2.date(e2.date() + Math.round(t2 * r2)), l3);
          };
          if ($3 === f2)
            return this.set(f2, this.$M + r2);
          if ($3 === c2)
            return this.set(c2, this.$y + r2);
          if ($3 === a3)
            return y3(1);
          if ($3 === o2)
            return y3(7);
          var M5 = (d3 = {}, d3[s2] = e, d3[u2] = n, d3[i] = t, d3)[$3] || 1, m5 = this.$d.getTime() + r2 * M5;
          return O3.w(m5, this);
        }, m4.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m4.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l2;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O3.z(this), s3 = this.$H, u3 = this.$m, a4 = this.$M, o3 = n2.weekdays, f3 = n2.months, h30 = function(t3, n3, i3, s4) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s4);
          }, c3 = function(t3) {
            return O3.s(s3 % 12 || 12, t3, "0");
          }, d3 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, $3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a4 + 1, MM: O3.s(a4 + 1, 2, "0"), MMM: h30(n2.monthsShort, a4, f3, 3), MMMM: h30(f3, a4), D: this.$D, DD: O3.s(this.$D, 2, "0"), d: String(this.$W), dd: h30(n2.weekdaysMin, this.$W, o3, 2), ddd: h30(n2.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O3.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O3.s(u3, 2, "0"), s: String(this.$s), ss: O3.s(this.$s, 2, "0"), SSS: O3.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y2, function(t3, e3) {
            return e3 || $3[t3] || i2.replace(":", "");
          });
        }, m4.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m4.diff = function(r2, d3, l3) {
          var $3, y3 = O3.p(d3), M5 = w3(r2), m5 = (M5.utcOffset() - this.utcOffset()) * e, v4 = this - M5, g2 = O3.m(this, M5);
          return g2 = ($3 = {}, $3[c2] = g2 / 12, $3[f2] = g2, $3[h29] = g2 / 3, $3[o2] = (v4 - m5) / 6048e5, $3[a3] = (v4 - m5) / 864e5, $3[u2] = v4 / n, $3[s2] = v4 / e, $3[i] = v4 / t, $3)[y3] || v4, l3 ? g2 : O3.a(g2);
        }, m4.daysInMonth = function() {
          return this.endOf(f2).$D;
        }, m4.$locale = function() {
          return D3[this.$L];
        }, m4.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S3(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m4.clone = function() {
          return O3.w(this.$d, this);
        }, m4.toDate = function() {
          return new Date(this.valueOf());
        }, m4.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m4.toISOString = function() {
          return this.$d.toISOString();
        }, m4.toString = function() {
          return this.$d.toUTCString();
        }, M4;
      }(), T3 = _2.prototype;
      return w3.prototype = T3, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a3], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t2) {
        T3[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w3.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _2, w3), t2.$i = true), w3;
      }, w3.locale = S3, w3.isDayjs = p2, w3.unix = function(t2) {
        return w3(1e3 * t2);
      }, w3.en = D3[g], w3.Ls = D3, w3.p = {}, w3;
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/customParseFormat.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports2, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var a3 = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3)
            return 0;
          if ("Z" === e3)
            return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], h29 = function(e2) {
        var t2 = o2[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, u2 = function(e2, t2) {
        var n2, r2 = o2.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e2.indexOf(r2(i2, 0, t2)) > -1) {
              n2 = i2 > 12;
              break;
            }
        } else
          n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, d2 = { A: [i, function(e2) {
        this.afternoon = u2(e2, false);
      }], a: [i, function(e2) {
        this.afternoon = u2(e2, true);
      }], S: [/\d/, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [n, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [r, a3("seconds")], ss: [r, a3("seconds")], m: [r, a3("minutes")], mm: [r, a3("minutes")], H: [r, a3("hours")], h: [r, a3("hours")], HH: [r, a3("hours")], hh: [r, a3("hours")], D: [r, a3("day")], DD: [n, a3("day")], Do: [i, function(e2) {
        var t2 = o2.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2)
          for (var r2 = 1; r2 <= 31; r2 += 1)
            t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], M: [r, a3("month")], MM: [n, a3("month")], MMM: [i, function(e2) {
        var t2 = h29("months"), n2 = (h29("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1)
          throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [i, function(e2) {
        var t2 = h29("months").indexOf(e2) + 1;
        if (t2 < 1)
          throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, a3("year")], YY: [n, function(e2) {
        this.year = s2(e2);
      }], YYYY: [/\d{4}/, a3("year")], Z: f2, ZZ: f2 };
      function c2(n2) {
        var r2, i2;
        r2 = n2, i2 = o2 && o2.formats;
        for (var s3 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a4 = s3.length, f3 = 0; f3 < a4; f3 += 1) {
          var h30 = s3[f3], u3 = d2[h30], c3 = u3 && u3[0], l2 = u3 && u3[1];
          s3[f3] = l2 ? { regex: c3, parser: l2 } : h30.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a4; n3 += 1) {
            var i3 = s3[n3];
            if ("string" == typeof i3)
              r3 += i3.length;
            else {
              var o3 = i3.regex, f4 = i3.parser, h31 = e2.slice(r3), u4 = o3.exec(h31)[0];
              f4.call(t2, u4), e2 = e2.replace(u4, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s2 = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, s3 = e3.args;
          this.$u = r3;
          var a4 = s3[1];
          if ("string" == typeof a4) {
            var f3 = true === s3[2], h30 = true === s3[3], u3 = f3 || h30, d3 = s3[2];
            h30 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n2.Ls[d3]), this.$d = function(e4, t4, n3) {
              try {
                if (["x", "X"].indexOf(t4) > -1)
                  return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var r4 = c2(t4)(e4), i3 = r4.year, o3 = r4.month, s4 = r4.day, a5 = r4.hours, f4 = r4.minutes, h31 = r4.seconds, u4 = r4.milliseconds, d4 = r4.zone, l3 = /* @__PURE__ */ new Date(), m4 = s4 || (i3 || o3 ? 1 : l3.getDate()), M4 = i3 || l3.getFullYear(), Y3 = 0;
                i3 && !o3 || (Y3 = o3 > 0 ? o3 - 1 : l3.getMonth());
                var p2 = a5 || 0, v3 = f4 || 0, D3 = h31 || 0, g = u4 || 0;
                return d4 ? new Date(Date.UTC(M4, Y3, m4, p2, v3, D3, g + 60 * d4.offset * 1e3)) : n3 ? new Date(Date.UTC(M4, Y3, m4, p2, v3, D3, g)) : new Date(M4, Y3, m4, p2, v3, D3, g);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a4, r3), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t3 != this.format(a4) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
          } else if (a4 instanceof Array)
            for (var l2 = a4.length, m3 = 1; m3 <= l2; m3 += 1) {
              s3[1] = a4[m3 - 1];
              var M3 = n2.apply(this, s3);
              if (M3.isValid()) {
                this.$d = M3.$d, this.$L = M3.$L, this.init();
                break;
              }
              m3 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e3);
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/localeData.js"(exports2, module2) {
    !function(n, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (n = "undefined" != typeof globalThis ? globalThis : n || self).dayjs_plugin_localeData = e();
    }(exports2, function() {
      "use strict";
      return function(n, e, t) {
        var r = e.prototype, o2 = function(n2) {
          return n2 && (n2.indexOf ? n2 : n2.s);
        }, u2 = function(n2, e2, t2, r2, u3) {
          var i2 = n2.name ? n2 : n2.$locale(), a4 = o2(i2[e2]), s3 = o2(i2[t2]), f2 = a4 || s3.map(function(n3) {
            return n3.slice(0, r2);
          });
          if (!u3)
            return f2;
          var d2 = i2.weekStart;
          return f2.map(function(n3, e3) {
            return f2[(e3 + (d2 || 0)) % 7];
          });
        }, i = function() {
          return t.Ls[t.locale()];
        }, a3 = function(n2, e2) {
          return n2.formats[e2] || function(n3) {
            return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
              return e3 || t2.slice(1);
            });
          }(n2.formats[e2.toUpperCase()]);
        }, s2 = function() {
          var n2 = this;
          return { months: function(e2) {
            return e2 ? e2.format("MMMM") : u2(n2, "months");
          }, monthsShort: function(e2) {
            return e2 ? e2.format("MMM") : u2(n2, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n2.$locale().weekStart || 0;
          }, weekdays: function(e2) {
            return e2 ? e2.format("dddd") : u2(n2, "weekdays");
          }, weekdaysMin: function(e2) {
            return e2 ? e2.format("dd") : u2(n2, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e2) {
            return e2 ? e2.format("ddd") : u2(n2, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e2) {
            return a3(n2.$locale(), e2);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        r.localeData = function() {
          return s2.bind(this)();
        }, t.localeData = function() {
          var n2 = i();
          return { firstDayOfWeek: function() {
            return n2.weekStart || 0;
          }, weekdays: function() {
            return t.weekdays();
          }, weekdaysShort: function() {
            return t.weekdaysShort();
          }, weekdaysMin: function() {
            return t.weekdaysMin();
          }, months: function() {
            return t.months();
          }, monthsShort: function() {
            return t.monthsShort();
          }, longDateFormat: function(e2) {
            return a3(n2, e2);
          }, meridiem: n2.meridiem, ordinal: n2.ordinal };
        }, t.months = function() {
          return u2(i(), "months");
        }, t.monthsShort = function() {
          return u2(i(), "monthsShort", "months", 3);
        }, t.weekdays = function(n2) {
          return u2(i(), "weekdays", null, null, n2);
        }, t.weekdaysShort = function(n2) {
          return u2(i(), "weekdaysShort", "weekdays", 3, n2);
        }, t.weekdaysMin = function(n2) {
          return u2(i(), "weekdaysMin", "weekdays", 2, n2);
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/advancedFormat.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_advancedFormat = t();
    }(exports2, function() {
      "use strict";
      return function(e, t) {
        var r = t.prototype, n = r.format;
        r.format = function(e2) {
          var t2 = this, r2 = this.$locale();
          if (!this.isValid())
            return n.bind(this)(e2);
          var s2 = this.$utils(), a3 = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
            switch (e3) {
              case "Q":
                return Math.ceil((t2.$M + 1) / 3);
              case "Do":
                return r2.ordinal(t2.$D);
              case "gggg":
                return t2.weekYear();
              case "GGGG":
                return t2.isoWeekYear();
              case "wo":
                return r2.ordinal(t2.week(), "W");
              case "w":
              case "ww":
                return s2.s(t2.week(), "w" === e3 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s2.s(t2.isoWeek(), "W" === e3 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s2.s(String(0 === t2.$H ? 24 : t2.$H), "k" === e3 ? 1 : 2, "0");
              case "X":
                return Math.floor(t2.$d.getTime() / 1e3);
              case "x":
                return t2.$d.getTime();
              case "z":
                return "[" + t2.offsetName() + "]";
              case "zzz":
                return "[" + t2.offsetName("long") + "]";
              default:
                return e3;
            }
          });
          return n.bind(this)(a3);
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/weekOfYear.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekOfYear = t();
    }(exports2, function() {
      "use strict";
      var e = "week", t = "year";
      return function(i, n, r) {
        var f2 = n.prototype;
        f2.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2)
            return this.add(7 * (i2 - this.week()), "day");
          var n2 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f3 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e);
            if (f3.isBefore(s2))
              return 1;
          }
          var a3 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o2 = this.diff(a3, e, true);
          return o2 < 0 ? r(this).startOf("week").week() : Math.ceil(o2);
        }, f2.weeks = function(e2) {
          return void 0 === e2 && (e2 = null), this.week(e2);
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/weekYear.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekYear = t();
    }(exports2, function() {
      "use strict";
      return function(e, t) {
        t.prototype.weekYear = function() {
          var e2 = this.month(), t2 = this.week(), n = this.year();
          return 1 === t2 && 11 === e2 ? n + 1 : 0 === e2 && t2 >= 52 ? n - 1 : n;
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/dayOfYear.js
var require_dayOfYear = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/dayOfYear.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_dayOfYear = t();
    }(exports2, function() {
      "use strict";
      return function(e, t, n) {
        t.prototype.dayOfYear = function(e2) {
          var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
          return null == e2 ? t2 : this.add(e2 - t2, "day");
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/isSameOrAfter.js
var require_isSameOrAfter = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/isSameOrAfter.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isSameOrAfter = t();
    }(exports2, function() {
      "use strict";
      return function(e, t) {
        t.prototype.isSameOrAfter = function(e2, t2) {
          return this.isSame(e2, t2) || this.isAfter(e2, t2);
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/isSameOrBefore.js
var require_isSameOrBefore = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/plugin/isSameOrBefore.js"(exports2, module2) {
    !function(e, i) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = i() : "function" == typeof define && define.amd ? define(i) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isSameOrBefore = i();
    }(exports2, function() {
      "use strict";
      return function(e, i) {
        i.prototype.isSameOrBefore = function(e2, i2) {
          return this.isSame(e2, i2) || this.isBefore(e2, i2);
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml2;
    function escapeHtml2(string3) {
      var str = "" + string3;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape;
      var html = "";
      var index2 = 0;
      var lastIndex = 0;
      for (index2 = match.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escape = "&quot;";
            break;
          case 38:
            escape = "&amp;";
            break;
          case 39:
            escape = "&#39;";
            break;
          case 60:
            escape = "&lt;";
            break;
          case 62:
            escape = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.substring(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escape;
      }
      return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
    }
  }
});

// ../../node_modules/.pnpm/sortablejs@1.15.0/node_modules/sortablejs/modular/sortable.esm.js
var sortable_esm_exports = {};
__export(sortable_esm_exports, {
  MultiDrag: () => MultiDragPlugin,
  Sortable: () => Sortable,
  Swap: () => SwapPlugin,
  default: () => sortable_esm_default
});
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n = Object.prototype.toString.call(o2).slice(8, -1);
  if (n === "Object" && o2.constructor)
    n = o2.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o2);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function userAgent(pattern4) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern4);
  }
}
function on2(el, event, fn2) {
  el.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off(el, event, fn2) {
  el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left2, bottom, right2, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left2 = elRect.left;
    bottom = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left2 = 0;
    bottom = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left2 /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right2 = left2 + width;
    }
  }
  return {
    top,
    left: left2,
    bottom,
    right: right2,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
function throttle2(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x3, y2) {
  el.scrollLeft += x3;
  el.scrollTop += y2;
}
function clone2(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, "position", "absolute");
  css(el, "top", rect.top);
  css(el, "left", rect.left);
  css(el, "width", rect.width);
  css(el, "height", rect.height);
}
function unsetRect(el) {
  css(el, "position", "");
  css(el, "top", "");
  css(el, "left", "");
  css(el, "width", "");
  css(el, "height", "");
}
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends2({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction2() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on2(el, "pointerdown", this._onTapStart);
  } else {
    on2(el, "mousedown", this._onTapStart);
    on2(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on2(el, "dragover", this);
    on2(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends2(this, AnimationStateManager());
}
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum2 = 0;
  while (i--) {
    sum2 += str.charCodeAt(i);
  }
  return sum2.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted2(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on2(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on2(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on2(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on2(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x3, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x3 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x3, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x3;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends2(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
function Revert() {
}
function Remove() {
}
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: "sortable-swap-highlight"
    };
  }
  Swap.prototype = {
    dragStart: function dragStart2(_ref) {
      var dragEl2 = _ref.dragEl;
      lastSwapEl = dragEl2;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed, target = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
      if (!activeSortable.options.swap)
        return;
      var el = this.sortable.el, options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop3(_ref3) {
      var activeSortable = _ref3.activeSortable, putSortable2 = _ref3.putSortable, dragEl2 = _ref3.dragEl;
      var toSortable = putSortable2 || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable2 && putSortable2.options.swap)) {
        if (dragEl2 !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable)
            activeSortable.captureAnimationState();
          swapNodes(dragEl2, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable)
            activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends2(Swap, {
    pluginName: "swap",
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1))
    return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on2(document, "pointerup", this._deselectMultiDrag);
      } else {
        on2(document, "mouseup", this._deselectMultiDrag);
        on2(document, "touchend", this._deselectMultiDrag);
      }
    }
    on2(document, "keydown", this._checkKeyDown);
    on2(document, "keyup", this._checkKeyUp);
    this.defaults = {
      selectedClass: "sortable-selected",
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl2) {
        var data = "";
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function(multiDragElement, i) {
            data += (!i ? "" : ", ") + multiDragElement.textContent;
          });
        } else {
          data = dragEl2.textContent;
        }
        dataTransfer.setData("Text", data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable, cancel = _ref2.cancel;
      if (!this.isMultiDrag)
        return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone2(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style["will-change"] = "";
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone3(_ref3) {
      var sortable = _ref3.sortable, rootEl2 = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
      if (!this.isMultiDrag)
        return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl2);
          dispatchSortableEvent("clone");
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown, rootEl2 = _ref4.rootEl, cancel = _ref4.cancel;
      if (!this.isMultiDrag)
        return;
      insertMultiDragClones(false, rootEl2);
      multiDragClones.forEach(function(clone3) {
        css(clone3, "display", "");
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var sortable = _ref5.sortable, cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
      if (!this.isMultiDrag)
        return;
      multiDragClones.forEach(function(clone3) {
        css(clone3, "display", "none");
        if (_this.options.removeCloneOnHide && clone3.parentNode) {
          clone3.parentNode.removeChild(clone3);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function(multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });
      multiDragElements = multiDragElements.sort(function(a3, b3) {
        return a3.sortableIndex - b3.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted2(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag)
        return;
      if (this.options.sort) {
        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            css(multiDragElement, "position", "absolute");
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function() {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function(multiDragElement) {
            unsetRect(multiDragElement);
          });
        }
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable, rootEl2 = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        multiDragElements.forEach(function(multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl2);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl2 = _ref10.parentEl, putSortable2 = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable2)) {
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            setRect(multiDragElement, dragRectAbsolute);
            parentEl2.appendChild(multiDragElement);
          });
          folding = true;
        }
        if (!isOwner) {
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function(clone3) {
                activeSortable.addAnimationState({
                  target: clone3,
                  rect: clonesFromRect
                });
                clone3.fromRect = clonesFromRect;
                clone3.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function(multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends2({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop3(_ref12) {
      var evt = _ref12.originalEvent, rootEl2 = _ref12.rootEl, parentEl2 = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex2 = _ref12.oldIndex, putSortable2 = _ref12.putSortable;
      var toSortable = putSortable2 || this.sortable;
      if (!evt)
        return;
      var options = this.options, children = parentEl2.children;
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable,
            rootEl: rootEl2,
            name: "select",
            targetEl: dragEl$1,
            originalEvent: evt
          });
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              var n, i;
              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }
              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i]))
                  continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable,
                  rootEl: rootEl2,
                  name: "select",
                  targetEl: children[i],
                  originalEvent: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable,
            rootEl: rootEl2,
            name: "deselect",
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        if ((parentEl2[expando].options.sort || parentEl2 !== rootEl2) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
          if (!initialFolding && options.animation)
            dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function(multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect
                  });
                }
              });
            }
            removeMultiDragElements();
            multiDragElements.forEach(function(multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl2.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl2.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });
            if (oldIndex2 === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent("update");
              }
            }
          }
          multiDragElements.forEach(function(multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }
      if (rootEl2 === parentEl2 || putSortable2 && putSortable2.lastPutMode !== "clone") {
        multiDragClones.forEach(function(clone3) {
          clone3.parentNode && clone3.parentNode.removeChild(clone3);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, "pointerup", this._deselectMultiDrag);
      off(document, "mouseup", this._deselectMultiDrag);
      off(document, "touchend", this._deselectMultiDrag);
      off(document, "keydown", this._checkKeyDown);
      off(document, "keyup", this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted)
        return;
      if (multiDragSortable !== this.sortable)
        return;
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false))
        return;
      if (evt && evt.button !== 0)
        return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: "deselect",
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends2(MultiDrag, {
    // Static methods & properties
    pluginName: "multiDrag",
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el))
          return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando], index2 = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index2)
          return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index2, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [], newIndicies = [];
      multiDragElements.forEach(function(multiDragElement) {
        oldIndicies.push({
          multiDragElement,
          index: multiDragElement.sortableIndex
        });
        var newIndex2;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex2 = -1;
        } else if (folding) {
          newIndex2 = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
        } else {
          newIndex2 = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement,
          index: newIndex2
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies,
        newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === "ctrl") {
          key = "Control";
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl2) {
  multiDragElements.forEach(function(multiDragElement, i) {
    var target = rootEl2.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl2.insertBefore(multiDragElement, target);
    } else {
      rootEl2.appendChild(multiDragElement);
    }
  });
}
function insertMultiDragClones(elementsInserted, rootEl2) {
  multiDragClones.forEach(function(clone3, i) {
    var target = rootEl2.children[clone3.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl2.insertBefore(clone3, target);
    } else {
      rootEl2.appendChild(clone3);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function(multiDragElement) {
    if (multiDragElement === dragEl$1)
      return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}
var version4, IE11OrLess, Edge, FireFox, Safari, IOS, ChromeForAndroid, captureMode, R_SPACE, _throttleTimeout, expando, plugins, defaults, PluginManager, _excluded, pluginEvent2, dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted, ignoreNextClick, sortables, tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh, isCircumstantialInvert, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll, _silent, savedInputChecked, documentExists, PositionGhostAbsolutely, CSSFloatProperty, supportDraggable, supportCssPointerEvents, _detectDirection, _dragElInRowColumn, _detectNearestEmptySortable, _prepareGroup, _hideGhostForTarget, _unhideGhostForTarget, nearestEmptyInsertDetectEvent, _checkOutsideTargetEl, autoScrolls, scrollEl, scrollRootEl, scrolling, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval, autoScroll, drop, lastSwapEl, multiDragElements, multiDragClones, lastMultiDragSelect, multiDragSortable, initialFolding, folding, dragStarted, dragEl$1, clonesFromRect, clonesHidden, sortable_esm_default;
var init_sortable_esm = __esm({
  "../../node_modules/.pnpm/sortablejs@1.15.0/node_modules/sortablejs/modular/sortable.esm.js"() {
    version4 = "1.15.0";
    IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
    Edge = userAgent(/Edge/i);
    FireFox = userAgent(/firefox/i);
    Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
    IOS = userAgent(/iP(ad|od|hone)/i);
    ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
    captureMode = {
      capture: false,
      passive: false
    };
    R_SPACE = /\s+/g;
    expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
    plugins = [];
    defaults = {
      initializeByDefault: true
    };
    PluginManager = {
      mount: function mount(plugin) {
        for (var option2 in defaults) {
          if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
            plugin[option2] = defaults[option2];
          }
        }
        plugins.forEach(function(p2) {
          if (p2.pluginName === plugin.pluginName) {
            throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
          }
        });
        plugins.push(plugin);
      },
      pluginEvent: function pluginEvent(eventName, sortable, evt) {
        var _this = this;
        this.eventCanceled = false;
        evt.cancel = function() {
          _this.eventCanceled = true;
        };
        var eventNameGlobal = eventName + "Global";
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (sortable[plugin.pluginName][eventNameGlobal]) {
            sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
              sortable
            }, evt));
          }
          if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
            sortable[plugin.pluginName][eventName](_objectSpread2({
              sortable
            }, evt));
          }
        });
      },
      initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
        plugins.forEach(function(plugin) {
          var pluginName = plugin.pluginName;
          if (!sortable.options[pluginName] && !plugin.initializeByDefault)
            return;
          var initialized = new plugin(sortable, el, sortable.options);
          initialized.sortable = sortable;
          initialized.options = sortable.options;
          sortable[pluginName] = initialized;
          _extends2(defaults2, initialized.defaults);
        });
        for (var option2 in sortable.options) {
          if (!sortable.options.hasOwnProperty(option2))
            continue;
          var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
          if (typeof modified !== "undefined") {
            sortable.options[option2] = modified;
          }
        }
      },
      getEventProperties: function getEventProperties(name, sortable) {
        var eventProperties = {};
        plugins.forEach(function(plugin) {
          if (typeof plugin.eventProperties !== "function")
            return;
          _extends2(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
        });
        return eventProperties;
      },
      modifyOption: function modifyOption(sortable, name, value) {
        var modifiedValue;
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
            modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
          }
        });
        return modifiedValue;
      }
    };
    _excluded = ["evt"];
    pluginEvent2 = function pluginEvent3(eventName, sortable) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
      PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
        dragEl,
        parentEl,
        ghostEl,
        rootEl,
        nextEl,
        lastDownEl,
        cloneEl,
        cloneHidden,
        dragStarted: moved,
        putSortable,
        activeSortable: Sortable.active,
        originalEvent,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex,
        hideGhostForTarget: _hideGhostForTarget,
        unhideGhostForTarget: _unhideGhostForTarget,
        cloneNowHidden: function cloneNowHidden() {
          cloneHidden = true;
        },
        cloneNowShown: function cloneNowShown() {
          cloneHidden = false;
        },
        dispatchSortableEvent: function dispatchSortableEvent(name) {
          _dispatchEvent({
            sortable,
            name,
            originalEvent
          });
        }
      }, data));
    };
    awaitingDragStarted = false;
    ignoreNextClick = false;
    sortables = [];
    pastFirstInvertThresh = false;
    isCircumstantialInvert = false;
    ghostRelativeParentInitialScroll = [];
    _silent = false;
    savedInputChecked = [];
    documentExists = typeof document !== "undefined";
    PositionGhostAbsolutely = IOS;
    CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
    supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
    supportCssPointerEvents = function() {
      if (!documentExists)
        return;
      if (IE11OrLess) {
        return false;
      }
      var el = document.createElement("x");
      el.style.cssText = "pointer-events:auto";
      return el.style.pointerEvents === "auto";
    }();
    _detectDirection = function _detectDirection2(el, options) {
      var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
      if (elCSS.display === "flex") {
        return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
      }
      if (elCSS.display === "grid") {
        return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
      }
      if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
        var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
        return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
      }
      return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
    };
    _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
      return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
    };
    _detectNearestEmptySortable = function _detectNearestEmptySortable2(x3, y2) {
      var ret;
      sortables.some(function(sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable))
          return;
        var rect = getRect(sortable), insideHorizontally = x3 >= rect.left - threshold && x3 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
        if (insideHorizontally && insideVertically) {
          return ret = sortable;
        }
      });
      return ret;
    };
    _prepareGroup = function _prepareGroup2(options) {
      function toFn(value, pull) {
        return function(to, from, dragEl2, evt) {
          var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
          if (value == null && (pull || sameGroup)) {
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === "clone") {
            return value;
          } else if (typeof value === "function") {
            return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
          } else {
            var otherGroup = (pull ? to : from).options.group.name;
            return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
          }
        };
      }
      var group = {};
      var originalGroup = options.group;
      if (!originalGroup || _typeof(originalGroup) != "object") {
        originalGroup = {
          name: originalGroup
        };
      }
      group.name = originalGroup.name;
      group.checkPull = toFn(originalGroup.pull, true);
      group.checkPut = toFn(originalGroup.put);
      group.revertClone = originalGroup.revertClone;
      options.group = group;
    };
    _hideGhostForTarget = function _hideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "none");
      }
    };
    _unhideGhostForTarget = function _unhideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "");
      }
    };
    if (documentExists && !ChromeForAndroid) {
      document.addEventListener("click", function(evt) {
        if (ignoreNextClick) {
          evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          evt.stopImmediatePropagation && evt.stopImmediatePropagation();
          ignoreNextClick = false;
          return false;
        }
      }, true);
    }
    nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
      if (dragEl) {
        evt = evt.touches ? evt.touches[0] : evt;
        var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
        if (nearest) {
          var event = {};
          for (var i in evt) {
            if (evt.hasOwnProperty(i)) {
              event[i] = evt[i];
            }
          }
          event.target = event.rootEl = nearest;
          event.preventDefault = void 0;
          event.stopPropagation = void 0;
          nearest[expando]._onDragOver(event);
        }
      }
    };
    _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
      if (dragEl) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
      }
    };
    Sortable.prototype = /** @lends Sortable.prototype */
    {
      constructor: Sortable,
      _isOutsideThisEl: function _isOutsideThisEl(target) {
        if (!this.el.contains(target) && target !== this.el) {
          lastTarget = null;
        }
      },
      _getDirection: function _getDirection(evt, target) {
        return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
      },
      _onTapStart: function _onTapStart(evt) {
        if (!evt.cancelable)
          return;
        var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type4 = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
        _saveInputCheckedState(el);
        if (dragEl) {
          return;
        }
        if (/mousedown|pointerdown/.test(type4) && evt.button !== 0 || options.disabled) {
          return;
        }
        if (originalTarget.isContentEditable) {
          return;
        }
        if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
          return;
        }
        target = closest(target, options.draggable, el, false);
        if (target && target.animated) {
          return;
        }
        if (lastDownEl === target) {
          return;
        }
        oldIndex = index(target);
        oldDraggableIndex = index(target, options.draggable);
        if (typeof filter === "function") {
          if (filter.call(this, evt, target, this)) {
            _dispatchEvent({
              sortable: _this,
              rootEl: originalTarget,
              name: "filter",
              targetEl: target,
              toEl: el,
              fromEl: el
            });
            pluginEvent2("filter", _this, {
              evt
            });
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        } else if (filter) {
          filter = filter.split(",").some(function(criteria) {
            criteria = closest(originalTarget, criteria.trim(), el, false);
            if (criteria) {
              _dispatchEvent({
                sortable: _this,
                rootEl: criteria,
                name: "filter",
                targetEl: target,
                fromEl: el,
                toEl: el
              });
              pluginEvent2("filter", _this, {
                evt
              });
              return true;
            }
          });
          if (filter) {
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        }
        if (options.handle && !closest(originalTarget, options.handle, el, false)) {
          return;
        }
        this._prepareDragStart(evt, touch, target);
      },
      _prepareDragStart: function _prepareDragStart(evt, touch, target) {
        var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
        if (target && !dragEl && target.parentNode === el) {
          var dragRect = getRect(target);
          rootEl = el;
          dragEl = target;
          parentEl = dragEl.parentNode;
          nextEl = dragEl.nextSibling;
          lastDownEl = target;
          activeGroup = options.group;
          Sortable.dragged = dragEl;
          tapEvt = {
            target: dragEl,
            clientX: (touch || evt).clientX,
            clientY: (touch || evt).clientY
          };
          tapDistanceLeft = tapEvt.clientX - dragRect.left;
          tapDistanceTop = tapEvt.clientY - dragRect.top;
          this._lastX = (touch || evt).clientX;
          this._lastY = (touch || evt).clientY;
          dragEl.style["will-change"] = "all";
          dragStartFn = function dragStartFn2() {
            pluginEvent2("delayEnded", _this, {
              evt
            });
            if (Sortable.eventCanceled) {
              _this._onDrop();
              return;
            }
            _this._disableDelayedDragEvents();
            if (!FireFox && _this.nativeDraggable) {
              dragEl.draggable = true;
            }
            _this._triggerDragStart(evt, touch);
            _dispatchEvent({
              sortable: _this,
              name: "choose",
              originalEvent: evt
            });
            toggleClass(dragEl, options.chosenClass, true);
          };
          options.ignore.split(",").forEach(function(criteria) {
            find(dragEl, criteria.trim(), _disableDraggable);
          });
          on2(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
          on2(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
          on2(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
          on2(ownerDocument, "mouseup", _this._onDrop);
          on2(ownerDocument, "touchend", _this._onDrop);
          on2(ownerDocument, "touchcancel", _this._onDrop);
          if (FireFox && this.nativeDraggable) {
            this.options.touchStartThreshold = 4;
            dragEl.draggable = true;
          }
          pluginEvent2("delayStart", this, {
            evt
          });
          if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
            if (Sortable.eventCanceled) {
              this._onDrop();
              return;
            }
            on2(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on2(ownerDocument, "touchend", _this._disableDelayedDrag);
            on2(ownerDocument, "touchcancel", _this._disableDelayedDrag);
            on2(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
            on2(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
            options.supportPointer && on2(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
            _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
          } else {
            dragStartFn();
          }
        }
      },
      _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
        var touch = e.touches ? e.touches[0] : e;
        if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
          this._disableDelayedDrag();
        }
      },
      _disableDelayedDrag: function _disableDelayedDrag() {
        dragEl && _disableDraggable(dragEl);
        clearTimeout(this._dragStartTimer);
        this._disableDelayedDragEvents();
      },
      _disableDelayedDragEvents: function _disableDelayedDragEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._disableDelayedDrag);
        off(ownerDocument, "touchend", this._disableDelayedDrag);
        off(ownerDocument, "touchcancel", this._disableDelayedDrag);
        off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
      },
      _triggerDragStart: function _triggerDragStart(evt, touch) {
        touch = touch || evt.pointerType == "touch" && evt;
        if (!this.nativeDraggable || touch) {
          if (this.options.supportPointer) {
            on2(document, "pointermove", this._onTouchMove);
          } else if (touch) {
            on2(document, "touchmove", this._onTouchMove);
          } else {
            on2(document, "mousemove", this._onTouchMove);
          }
        } else {
          on2(dragEl, "dragend", this);
          on2(rootEl, "dragstart", this._onDragStart);
        }
        try {
          if (document.selection) {
            _nextTick(function() {
              document.selection.empty();
            });
          } else {
            window.getSelection().removeAllRanges();
          }
        } catch (err) {
        }
      },
      _dragStarted: function _dragStarted(fallback, evt) {
        awaitingDragStarted = false;
        if (rootEl && dragEl) {
          pluginEvent2("dragStarted", this, {
            evt
          });
          if (this.nativeDraggable) {
            on2(document, "dragover", _checkOutsideTargetEl);
          }
          var options = this.options;
          !fallback && toggleClass(dragEl, options.dragClass, false);
          toggleClass(dragEl, options.ghostClass, true);
          Sortable.active = this;
          fallback && this._appendGhost();
          _dispatchEvent({
            sortable: this,
            name: "start",
            originalEvent: evt
          });
        } else {
          this._nulling();
        }
      },
      _emulateDragOver: function _emulateDragOver() {
        if (touchEvt) {
          this._lastX = touchEvt.clientX;
          this._lastY = touchEvt.clientY;
          _hideGhostForTarget();
          var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          var parent = target;
          while (target && target.shadowRoot) {
            target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            if (target === parent)
              break;
            parent = target;
          }
          dragEl.parentNode[expando]._isOutsideThisEl(target);
          if (parent) {
            do {
              if (parent[expando]) {
                var inserted = void 0;
                inserted = parent[expando]._onDragOver({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target,
                  rootEl: parent
                });
                if (inserted && !this.options.dragoverBubble) {
                  break;
                }
              }
              target = parent;
            } while (parent = parent.parentNode);
          }
          _unhideGhostForTarget();
        }
      },
      _onTouchMove: function _onTouchMove(evt) {
        if (tapEvt) {
          var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
          if (!Sortable.active && !awaitingDragStarted) {
            if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
              return;
            }
            this._onDragStart(evt, true);
          }
          if (ghostEl) {
            if (ghostMatrix) {
              ghostMatrix.e += dx - (lastDx || 0);
              ghostMatrix.f += dy - (lastDy || 0);
            } else {
              ghostMatrix = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: dx,
                f: dy
              };
            }
            var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
            css(ghostEl, "webkitTransform", cssMatrix);
            css(ghostEl, "mozTransform", cssMatrix);
            css(ghostEl, "msTransform", cssMatrix);
            css(ghostEl, "transform", cssMatrix);
            lastDx = dx;
            lastDy = dy;
            touchEvt = touch;
          }
          evt.cancelable && evt.preventDefault();
        }
      },
      _appendGhost: function _appendGhost() {
        if (!ghostEl) {
          var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
          if (PositionGhostAbsolutely) {
            ghostRelativeParent = container;
            while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
              ghostRelativeParent = ghostRelativeParent.parentNode;
            }
            if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
              if (ghostRelativeParent === document)
                ghostRelativeParent = getWindowScrollingElement();
              rect.top += ghostRelativeParent.scrollTop;
              rect.left += ghostRelativeParent.scrollLeft;
            } else {
              ghostRelativeParent = getWindowScrollingElement();
            }
            ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
          }
          ghostEl = dragEl.cloneNode(true);
          toggleClass(ghostEl, options.ghostClass, false);
          toggleClass(ghostEl, options.fallbackClass, true);
          toggleClass(ghostEl, options.dragClass, true);
          css(ghostEl, "transition", "");
          css(ghostEl, "transform", "");
          css(ghostEl, "box-sizing", "border-box");
          css(ghostEl, "margin", 0);
          css(ghostEl, "top", rect.top);
          css(ghostEl, "left", rect.left);
          css(ghostEl, "width", rect.width);
          css(ghostEl, "height", rect.height);
          css(ghostEl, "opacity", "0.8");
          css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
          css(ghostEl, "zIndex", "100000");
          css(ghostEl, "pointerEvents", "none");
          Sortable.ghost = ghostEl;
          container.appendChild(ghostEl);
          css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
        }
      },
      _onDragStart: function _onDragStart(evt, fallback) {
        var _this = this;
        var dataTransfer = evt.dataTransfer;
        var options = _this.options;
        pluginEvent2("dragStart", this, {
          evt
        });
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        pluginEvent2("setupClone", this);
        if (!Sortable.eventCanceled) {
          cloneEl = clone2(dragEl);
          cloneEl.removeAttribute("id");
          cloneEl.draggable = false;
          cloneEl.style["will-change"] = "";
          this._hideClone();
          toggleClass(cloneEl, this.options.chosenClass, false);
          Sortable.clone = cloneEl;
        }
        _this.cloneId = _nextTick(function() {
          pluginEvent2("clone", _this);
          if (Sortable.eventCanceled)
            return;
          if (!_this.options.removeCloneOnHide) {
            rootEl.insertBefore(cloneEl, dragEl);
          }
          _this._hideClone();
          _dispatchEvent({
            sortable: _this,
            name: "clone"
          });
        });
        !fallback && toggleClass(dragEl, options.dragClass, true);
        if (fallback) {
          ignoreNextClick = true;
          _this._loopId = setInterval(_this._emulateDragOver, 50);
        } else {
          off(document, "mouseup", _this._onDrop);
          off(document, "touchend", _this._onDrop);
          off(document, "touchcancel", _this._onDrop);
          if (dataTransfer) {
            dataTransfer.effectAllowed = "move";
            options.setData && options.setData.call(_this, dataTransfer, dragEl);
          }
          on2(document, "drop", _this);
          css(dragEl, "transform", "translateZ(0)");
        }
        awaitingDragStarted = true;
        _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
        on2(document, "selectstart", _this);
        moved = true;
        if (Safari) {
          css(document.body, "user-select", "none");
        }
      },
      // Returns true - if no further action is needed (either inserted or another condition)
      _onDragOver: function _onDragOver(evt) {
        var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
        if (_silent)
          return;
        function dragOverEvent(name, extra) {
          pluginEvent2(name, _this, _objectSpread2({
            evt,
            isOwner,
            axis: vertical ? "vertical" : "horizontal",
            revert,
            dragRect,
            targetRect,
            canSort,
            fromSortable,
            target,
            completed,
            onMove: function onMove(target2, after2) {
              return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
            },
            changed
          }, extra));
        }
        function capture() {
          dragOverEvent("dragOverAnimationCapture");
          _this.captureAnimationState();
          if (_this !== fromSortable) {
            fromSortable.captureAnimationState();
          }
        }
        function completed(insertion) {
          dragOverEvent("dragOverCompleted", {
            insertion
          });
          if (insertion) {
            if (isOwner) {
              activeSortable._hideClone();
            } else {
              activeSortable._showClone(_this);
            }
            if (_this !== fromSortable) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
              toggleClass(dragEl, options.ghostClass, true);
            }
            if (putSortable !== _this && _this !== Sortable.active) {
              putSortable = _this;
            } else if (_this === Sortable.active && putSortable) {
              putSortable = null;
            }
            if (fromSortable === _this) {
              _this._ignoreWhileAnimating = target;
            }
            _this.animateAll(function() {
              dragOverEvent("dragOverAnimationComplete");
              _this._ignoreWhileAnimating = null;
            });
            if (_this !== fromSortable) {
              fromSortable.animateAll();
              fromSortable._ignoreWhileAnimating = null;
            }
          }
          if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
            lastTarget = null;
          }
          if (!options.dragoverBubble && !evt.rootEl && target !== document) {
            dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
            !insertion && nearestEmptyInsertDetectEvent(evt);
          }
          !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
          return completedFired = true;
        }
        function changed() {
          newIndex = index(dragEl);
          newDraggableIndex = index(dragEl, options.draggable);
          _dispatchEvent({
            sortable: _this,
            name: "change",
            toEl: el,
            newIndex,
            newDraggableIndex,
            originalEvent: evt
          });
        }
        if (evt.preventDefault !== void 0) {
          evt.cancelable && evt.preventDefault();
        }
        target = closest(target, options.draggable, el, true);
        dragOverEvent("dragOver");
        if (Sortable.eventCanceled)
          return completedFired;
        if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
          return completed(false);
        }
        ignoreNextClick = false;
        if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
          vertical = this._getDirection(evt, target) === "vertical";
          dragRect = getRect(dragEl);
          dragOverEvent("dragOverValid");
          if (Sortable.eventCanceled)
            return completedFired;
          if (revert) {
            parentEl = rootEl;
            capture();
            this._hideClone();
            dragOverEvent("revert");
            if (!Sortable.eventCanceled) {
              if (nextEl) {
                rootEl.insertBefore(dragEl, nextEl);
              } else {
                rootEl.appendChild(dragEl);
              }
            }
            return completed(true);
          }
          var elLastChild = lastChild(el, options.draggable);
          if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
            if (elLastChild === dragEl) {
              return completed(false);
            }
            if (elLastChild && el === evt.target) {
              target = elLastChild;
            }
            if (target) {
              targetRect = getRect(target);
            }
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
              capture();
              if (elLastChild && elLastChild.nextSibling) {
                el.insertBefore(dragEl, elLastChild.nextSibling);
              } else {
                el.appendChild(dragEl);
              }
              parentEl = el;
              changed();
              return completed(true);
            }
          } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
            var firstChild = getChild(el, 0, options, true);
            if (firstChild === dragEl) {
              return completed(false);
            }
            target = firstChild;
            targetRect = getRect(target);
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
              capture();
              el.insertBefore(dragEl, firstChild);
              parentEl = el;
              changed();
              return completed(true);
            }
          } else if (target.parentNode === el) {
            targetRect = getRect(target);
            var direction2 = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
            if (lastTarget !== target) {
              targetBeforeFirstSwap = targetRect[side1];
              pastFirstInvertThresh = false;
              isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
            }
            direction2 = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
            var sibling;
            if (direction2 !== 0) {
              var dragIndex = index(dragEl);
              do {
                dragIndex -= direction2;
                sibling = parentEl.children[dragIndex];
              } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
            }
            if (direction2 === 0 || sibling === target) {
              return completed(false);
            }
            lastTarget = target;
            lastDirection = direction2;
            var nextSibling = target.nextElementSibling, after = false;
            after = direction2 === 1;
            var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
            if (moveVector !== false) {
              if (moveVector === 1 || moveVector === -1) {
                after = moveVector === 1;
              }
              _silent = true;
              setTimeout(_unsilent, 30);
              capture();
              if (after && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
              }
              if (scrolledPastTop) {
                scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
              }
              parentEl = dragEl.parentNode;
              if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
                targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
              }
              changed();
              return completed(true);
            }
          }
          if (el.contains(dragEl)) {
            return completed(false);
          }
        }
        return false;
      },
      _ignoreWhileAnimating: null,
      _offMoveEvents: function _offMoveEvents() {
        off(document, "mousemove", this._onTouchMove);
        off(document, "touchmove", this._onTouchMove);
        off(document, "pointermove", this._onTouchMove);
        off(document, "dragover", nearestEmptyInsertDetectEvent);
        off(document, "mousemove", nearestEmptyInsertDetectEvent);
        off(document, "touchmove", nearestEmptyInsertDetectEvent);
      },
      _offUpEvents: function _offUpEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._onDrop);
        off(ownerDocument, "touchend", this._onDrop);
        off(ownerDocument, "pointerup", this._onDrop);
        off(ownerDocument, "touchcancel", this._onDrop);
        off(document, "selectstart", this);
      },
      _onDrop: function _onDrop(evt) {
        var el = this.el, options = this.options;
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        pluginEvent2("drop", this, {
          evt
        });
        parentEl = dragEl && dragEl.parentNode;
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        if (Sortable.eventCanceled) {
          this._nulling();
          return;
        }
        awaitingDragStarted = false;
        isCircumstantialInvert = false;
        pastFirstInvertThresh = false;
        clearInterval(this._loopId);
        clearTimeout(this._dragStartTimer);
        _cancelNextTick(this.cloneId);
        _cancelNextTick(this._dragStartId);
        if (this.nativeDraggable) {
          off(document, "drop", this);
          off(el, "dragstart", this._onDragStart);
        }
        this._offMoveEvents();
        this._offUpEvents();
        if (Safari) {
          css(document.body, "user-select", "");
        }
        css(dragEl, "transform", "");
        if (evt) {
          if (moved) {
            evt.cancelable && evt.preventDefault();
            !options.dropBubble && evt.stopPropagation();
          }
          ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
          if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
            cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
          }
          if (dragEl) {
            if (this.nativeDraggable) {
              off(dragEl, "dragend", this);
            }
            _disableDraggable(dragEl);
            dragEl.style["will-change"] = "";
            if (moved && !awaitingDragStarted) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
            }
            toggleClass(dragEl, this.options.chosenClass, false);
            _dispatchEvent({
              sortable: this,
              name: "unchoose",
              toEl: parentEl,
              newIndex: null,
              newDraggableIndex: null,
              originalEvent: evt
            });
            if (rootEl !== parentEl) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "add",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "remove",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "sort",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
              putSortable && putSortable.save();
            } else {
              if (newIndex !== oldIndex) {
                if (newIndex >= 0) {
                  _dispatchEvent({
                    sortable: this,
                    name: "update",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    sortable: this,
                    name: "sort",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                }
              }
            }
            if (Sortable.active) {
              if (newIndex == null || newIndex === -1) {
                newIndex = oldIndex;
                newDraggableIndex = oldDraggableIndex;
              }
              _dispatchEvent({
                sortable: this,
                name: "end",
                toEl: parentEl,
                originalEvent: evt
              });
              this.save();
            }
          }
        }
        this._nulling();
      },
      _nulling: function _nulling() {
        pluginEvent2("nulling", this);
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
        savedInputChecked.forEach(function(el) {
          el.checked = true;
        });
        savedInputChecked.length = lastDx = lastDy = 0;
      },
      handleEvent: function handleEvent(evt) {
        switch (evt.type) {
          case "drop":
          case "dragend":
            this._onDrop(evt);
            break;
          case "dragenter":
          case "dragover":
            if (dragEl) {
              this._onDragOver(evt);
              _globalDragOver(evt);
            }
            break;
          case "selectstart":
            evt.preventDefault();
            break;
        }
      },
      /**
       * Serializes the item into an array of string.
       * @returns {String[]}
       */
      toArray: function toArray() {
        var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
        for (; i < n; i++) {
          el = children[i];
          if (closest(el, options.draggable, this.el, false)) {
            order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
          }
        }
        return order;
      },
      /**
       * Sorts the elements according to the array.
       * @param  {String[]}  order  order of the items
       */
      sort: function sort(order, useAnimation) {
        var items = {}, rootEl2 = this.el;
        this.toArray().forEach(function(id2, i) {
          var el = rootEl2.children[i];
          if (closest(el, this.options.draggable, rootEl2, false)) {
            items[id2] = el;
          }
        }, this);
        useAnimation && this.captureAnimationState();
        order.forEach(function(id2) {
          if (items[id2]) {
            rootEl2.removeChild(items[id2]);
            rootEl2.appendChild(items[id2]);
          }
        });
        useAnimation && this.animateAll();
      },
      /**
       * Save the current sorting
       */
      save: function save() {
        var store = this.options.store;
        store && store.set && store.set(this);
      },
      /**
       * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
       * @param   {HTMLElement}  el
       * @param   {String}       [selector]  default: `options.draggable`
       * @returns {HTMLElement|null}
       */
      closest: function closest$1(el, selector) {
        return closest(el, selector || this.options.draggable, this.el, false);
      },
      /**
       * Set/get option
       * @param   {string} name
       * @param   {*}      [value]
       * @returns {*}
       */
      option: function option(name, value) {
        var options = this.options;
        if (value === void 0) {
          return options[name];
        } else {
          var modifiedValue = PluginManager.modifyOption(this, name, value);
          if (typeof modifiedValue !== "undefined") {
            options[name] = modifiedValue;
          } else {
            options[name] = value;
          }
          if (name === "group") {
            _prepareGroup(options);
          }
        }
      },
      /**
       * Destroy
       */
      destroy: function destroy() {
        pluginEvent2("destroy", this);
        var el = this.el;
        el[expando] = null;
        off(el, "mousedown", this._onTapStart);
        off(el, "touchstart", this._onTapStart);
        off(el, "pointerdown", this._onTapStart);
        if (this.nativeDraggable) {
          off(el, "dragover", this);
          off(el, "dragenter", this);
        }
        Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
          el2.removeAttribute("draggable");
        });
        this._onDrop();
        this._disableDelayedDragEvents();
        sortables.splice(sortables.indexOf(this.el), 1);
        this.el = el = null;
      },
      _hideClone: function _hideClone() {
        if (!cloneHidden) {
          pluginEvent2("hideClone", this);
          if (Sortable.eventCanceled)
            return;
          css(cloneEl, "display", "none");
          if (this.options.removeCloneOnHide && cloneEl.parentNode) {
            cloneEl.parentNode.removeChild(cloneEl);
          }
          cloneHidden = true;
        }
      },
      _showClone: function _showClone(putSortable2) {
        if (putSortable2.lastPutMode !== "clone") {
          this._hideClone();
          return;
        }
        if (cloneHidden) {
          pluginEvent2("showClone", this);
          if (Sortable.eventCanceled)
            return;
          if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
            rootEl.insertBefore(cloneEl, dragEl);
          } else if (nextEl) {
            rootEl.insertBefore(cloneEl, nextEl);
          } else {
            rootEl.appendChild(cloneEl);
          }
          if (this.options.group.revertClone) {
            this.animate(dragEl, cloneEl);
          }
          css(cloneEl, "display", "");
          cloneHidden = false;
        }
      }
    };
    if (documentExists) {
      on2(document, "touchmove", function(evt) {
        if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
          evt.preventDefault();
        }
      });
    }
    Sortable.utils = {
      on: on2,
      off,
      css,
      find,
      is: function is(el, selector) {
        return !!closest(el, selector, el, false);
      },
      extend,
      throttle: throttle2,
      closest,
      toggleClass,
      clone: clone2,
      index,
      nextTick: _nextTick,
      cancelNextTick: _cancelNextTick,
      detectDirection: _detectDirection,
      getChild
    };
    Sortable.get = function(element) {
      return element[expando];
    };
    Sortable.mount = function() {
      for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins2[_key] = arguments[_key];
      }
      if (plugins2[0].constructor === Array)
        plugins2 = plugins2[0];
      plugins2.forEach(function(plugin) {
        if (!plugin.prototype || !plugin.prototype.constructor) {
          throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
        }
        if (plugin.utils)
          Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
        PluginManager.mount(plugin);
      });
    };
    Sortable.create = function(el, options) {
      return new Sortable(el, options);
    };
    Sortable.version = version4;
    autoScrolls = [];
    scrolling = false;
    autoScroll = throttle2(function(evt, options, rootEl2, isFallback) {
      if (!options.scroll)
        return;
      var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
      var scrollThisInstance = false, scrollCustomFn;
      if (scrollRootEl !== rootEl2) {
        scrollRootEl = rootEl2;
        clearAutoScrolls();
        scrollEl = options.scroll;
        scrollCustomFn = options.scrollFn;
        if (scrollEl === true) {
          scrollEl = getParentAutoScrollElement(rootEl2, true);
        }
      }
      var layersOut = 0;
      var currentParent = scrollEl;
      do {
        var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
        if (el === winScroller) {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
        } else {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
        }
        var vx = canScrollX && (Math.abs(right2 - x3) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x3) <= sens && !!scrollPosX);
        var vy = canScrollY && (Math.abs(bottom - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y2) <= sens && !!scrollPosY);
        if (!autoScrolls[layersOut]) {
          for (var i = 0; i <= layersOut; i++) {
            if (!autoScrolls[i]) {
              autoScrolls[i] = {};
            }
          }
        }
        if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
          autoScrolls[layersOut].el = el;
          autoScrolls[layersOut].vx = vx;
          autoScrolls[layersOut].vy = vy;
          clearInterval(autoScrolls[layersOut].pid);
          if (vx != 0 || vy != 0) {
            scrollThisInstance = true;
            autoScrolls[layersOut].pid = setInterval(function() {
              if (isFallback && this.layer === 0) {
                Sortable.active._onTouchMove(touchEvt$1);
              }
              var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
              var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
              if (typeof scrollCustomFn === "function") {
                if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                  return;
                }
              }
              scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
            }.bind({
              layer: layersOut
            }), 24);
          }
        }
        layersOut++;
      } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
      scrolling = scrollThisInstance;
    }, 30);
    drop = function drop2(_ref) {
      var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
      if (!originalEvent)
        return;
      var toSortable = putSortable2 || activeSortable;
      hideGhostForTarget();
      var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
      var target = document.elementFromPoint(touch.clientX, touch.clientY);
      unhideGhostForTarget();
      if (toSortable && !toSortable.el.contains(target)) {
        dispatchSortableEvent("spill");
        this.onSpill({
          dragEl: dragEl2,
          putSortable: putSortable2
        });
      }
    };
    Revert.prototype = {
      startIndex: null,
      dragStart: function dragStart(_ref2) {
        var oldDraggableIndex2 = _ref2.oldDraggableIndex;
        this.startIndex = oldDraggableIndex2;
      },
      onSpill: function onSpill(_ref3) {
        var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
        this.sortable.captureAnimationState();
        if (putSortable2) {
          putSortable2.captureAnimationState();
        }
        var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
        if (nextSibling) {
          this.sortable.el.insertBefore(dragEl2, nextSibling);
        } else {
          this.sortable.el.appendChild(dragEl2);
        }
        this.sortable.animateAll();
        if (putSortable2) {
          putSortable2.animateAll();
        }
      },
      drop
    };
    _extends2(Revert, {
      pluginName: "revertOnSpill"
    });
    Remove.prototype = {
      onSpill: function onSpill2(_ref4) {
        var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
        var parentSortable = putSortable2 || this.sortable;
        parentSortable.captureAnimationState();
        dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
        parentSortable.animateAll();
      },
      drop
    };
    _extends2(Remove, {
      pluginName: "removeOnSpill"
    });
    multiDragElements = [];
    multiDragClones = [];
    initialFolding = false;
    folding = false;
    dragStarted = false;
    Sortable.mount(new AutoScrollPlugin());
    Sortable.mount(Remove, Revert);
    sortable_esm_default = Sortable;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  YoungDateRange: () => YoungDateRange_default,
  YoungDialog: () => YoungDialog_default,
  YoungImageViewer: () => YoungImageViewer_default,
  YoungPagination: () => YoungPagination_default,
  YoungRotateTip: () => YoungRotateTip_default,
  YoungSearchForm: () => YoungSearchForm_default,
  YoungSelect: () => YoungSelect_default,
  YoungTable: () => YoungTable_default,
  YoungTablePro: () => YoungTablePro_default,
  YoungTimeRange: () => YoungTimeRange_default,
  YoungUpload: () => YoungUpload_default,
  YoungWeekday: () => YoungWeekday_default,
  useAutoLoad: () => useAutoLoad,
  useExport2Excel: () => useExport2Excel,
  useFormMode: () => useFormMode,
  useImagePreview: () => useImagePreview,
  useKeyUp: () => useKeyUp,
  useQuery: () => useQuery,
  useRemoteSearch: () => useRemoteSearch,
  useVerifyCode: () => useVerifyCode
});
module.exports = __toCommonJS(src_exports);

// src/components/YoungTable.tsx
var import_vue608 = require("vue");

// ../utils/dist/index.es.js
var a = (e, t) => Object.prototype.toString.call(e) === `[object ${t.name}]`;
var m = (e) => a(e, Array);
var I = (e) => {
  if ([null, void 0, NaN, false].includes(e) || typeof e != "object")
    return e;
  const t = m(e) ? [] : {}, n = [
    {
      parent: t,
      key: void 0,
      data: e
    }
  ];
  for (; n.length; ) {
    const { parent: s2, key: o2, data: r } = n.pop();
    let c2 = s2;
    typeof o2 < "u" && (c2 = s2[o2] = m(r) ? [] : {});
    for (let [d2, l2] of Object.entries(r))
      typeof l2 == "object" && l2 !== null && ![Date, RegExp, Function].some((y2) => l2 instanceof y2) ? n.push({
        parent: c2,
        key: d2,
        data: l2
      }) : c2[d2] = l2;
  }
  return t;
};
var w = () => {
  const e = /* @__PURE__ */ new Date();
  e.setDate(e.getDate() - 1), e.setHours(0, 0, 0, 0);
  const t = new Date(e.getTime() + 1e3 * 60 * 60 * 24);
  return t.setHours(23, 59, 59), [e, t];
};
var K = [
  {
    text: "\u4ECA\u5929",
    value: (() => {
      const e = /* @__PURE__ */ new Date();
      return [/* @__PURE__ */ new Date(), e];
    })()
  },
  {
    text: "\u6628\u5929",
    value: (() => {
      const e = /* @__PURE__ */ new Date(), t = /* @__PURE__ */ new Date();
      return e.setTime(t.getTime() - 3600 * 1e3 * 24 * 1), t.setTime(t.getTime() - 3600 * 1e3 * 24 * 1), [t, e];
    })()
  },
  {
    text: "\u672C\u5468",
    value: (() => {
      const e = /* @__PURE__ */ new Date(), t = /* @__PURE__ */ new Date();
      var n = t.getDay() || 7;
      return t.setDate(t.getDate() - n + 1), [t, e];
    })()
  },
  {
    text: "\u4E0A\u5468",
    value: (() => {
      let e = /* @__PURE__ */ new Date(), t = new Date(e.getTime() - 7 * 24 * 3600 * 1e3), n = new Date(e.getTime() - 7 * 24 * 3600 * 1e3), s2 = t.getDay(), o2 = t.getDate() - s2 + (s2 === 0 ? -6 : 1), r = new Date(t.setDate(o2)), c2 = new Date(n.setDate(o2 + 6));
      return [r, c2];
    })()
  },
  {
    text: "\u672C\u6708",
    value: (() => {
      const e = /* @__PURE__ */ new Date(), t = /* @__PURE__ */ new Date();
      return t.setDate(1), t.setHours(0), t.setSeconds(0), t.setMinutes(0), [t, e];
    })()
  },
  {
    text: "\u4E0A\u6708",
    value: (() => {
      let e = 864e5, t = /* @__PURE__ */ new Date(), n = new Date(t.getFullYear(), t.getMonth() - 1, 1), o2 = new Date(t.getFullYear(), t.getMonth(), 1).getTime() - 1 * e, r = new Date(o2);
      return [n, r];
    })()
  },
  {
    text: "\u6700\u8FD17\u5929",
    value: (() => {
      const e = /* @__PURE__ */ new Date(), t = /* @__PURE__ */ new Date();
      return t.setTime(t.getTime() - 3600 * 1e3 * 24 * 6), [t, e];
    })()
  },
  {
    text: "\u6700\u8FD130\u5929",
    value: (() => {
      const e = /* @__PURE__ */ new Date(), t = /* @__PURE__ */ new Date();
      return t.setTime(t.getTime() - 3600 * 1e3 * 24 * 30), [t, e];
    })()
  }
];
var ne = () => Math.random().toString(36).slice(8);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-attrs/index.mjs
var import_vue297 = require("vue");

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js
function arrayMap(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array4[index2], index2, array4);
  }
  return result;
}
var arrayMap_default = arrayMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex_default(string3) + 1).replace(reTrimStart, "") : string3;
}
var baseTrim_default = baseTrim;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var isObject_default = isObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern4 = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object4, key) {
  return object4 == null ? void 0 : object4[key];
}
var getValue_default = getValue;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object4, key) {
  var value = getValue_default(object4, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result = new object4();
    object4.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyArray.js
function copyArray(source, array4) {
  var index2 = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source[index2];
  }
  return array4;
}
var copyArray_default = copyArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string3) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string3),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEach.js
function arrayEach(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
var arrayEach_default = arrayEach;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length = array4.length;
  while (++index2 < length) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array4, value, fromIndex) {
  return value === value ? strictIndexOf_default(array4, value, fromIndex) : baseFindIndex_default(array4, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf_default(array4, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object4, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object4, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object4, key, value) {
  var objValue = object4[key];
  if (!(hasOwnProperty3.call(object4, key) && eq_default(objValue, value)) || value === void 0 && !(key in object4)) {
    baseAssignValue_default(object4, key, value);
  }
}
var assignValue_default = assignValue;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object4, key, newValue);
    } else {
      assignValue_default(object4, key, newValue);
    }
  }
  return object4;
}
var copyObject_default = copyObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array4 = Array(length);
    while (++index2 < length) {
      array4[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array4);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object4) {
  if (!isObject_default(object4)) {
    return false;
  }
  var type4 = typeof index2;
  if (type4 == "number" ? isArrayLike_default(object4) && isIndex_default(index2, object4.length) : type4 == "string" && index2 in object4) {
    return eq_default(object4[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object4, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object4 = Object(object4);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object4, source, index2, customizer);
      }
    }
    return object4;
  });
}
var createAssigner_default = createAssigner;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var baseTimes_default = baseTimes;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object4) {
  if (!isPrototype_default(object4)) {
    return nativeKeys_default(object4);
  }
  var result = [];
  for (var key in Object(object4)) {
    if (hasOwnProperty6.call(object4, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js
function keys(object4) {
  return isArrayLike_default(object4) ? arrayLikeKeys_default(object4) : baseKeys_default(object4);
}
var keys_default = keys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object4) {
  var result = [];
  if (object4 != null) {
    for (var key in Object(object4)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object4) {
  if (!isObject_default(object4)) {
    return nativeKeysIn_default(object4);
  }
  var isProto = isPrototype_default(object4), result = [];
  for (var key in object4) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object4, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keysIn.js
function keysIn(object4) {
  return isArrayLike_default(object4) ? arrayLikeKeys_default(object4, true) : baseKeysIn_default(object4);
}
var keysIn_default = keysIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object4) {
  if (isArray_default(value)) {
    return false;
  }
  var type4 = typeof value;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
}
var isKey_default = isKey;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array4, key) {
  var length = array4.length;
  while (length--) {
    if (eq_default(array4[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string3) {
  var result = [];
  if (string3.charCodeAt(0) === 46) {
    result.push("");
  }
  string3.replace(rePropName, function(match, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js
function castPath(value, object4) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object4) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js
function baseGet(object4, path) {
  path = castPath_default(path, object4);
  var index2 = 0, length = path.length;
  while (object4 != null && index2 < length) {
    object4 = object4[toKey_default(path[index2++])];
  }
  return index2 && index2 == length ? object4 : void 0;
}
var baseGet_default = baseGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js
function get(object4, path, defaultValue) {
  var result = object4 == null ? void 0 : baseGet_default(object4, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js
function arrayPush(array4, values) {
  var index2 = -1, length = values.length, offset2 = array4.length;
  while (++index2 < length) {
    array4[offset2 + index2] = values[index2];
  }
  return array4;
}
var arrayPush_default = arrayPush;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array4, depth, predicate, isStrict, result) {
  var index2 = -1, length = array4.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index2 < length) {
    var value = array4[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default = baseFlatten;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatten.js
function flatten(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten_default(array4, 1) : [];
}
var flatten_default = flatten;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssign.js
function baseAssign(object4, source) {
  return object4 && copyObject_default(source, keys_default(source), object4);
}
var baseAssign_default = baseAssign;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object4, source) {
  return object4 && copyObject_default(source, keysIn_default(source), object4);
}
var baseAssignIn_default = baseAssignIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter_default(nativeGetSymbols(object4), function(symbol) {
    return propertyIsEnumerable2.call(object4, symbol);
  });
};
var getSymbols_default = getSymbols;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object4) {
  return copyObject_default(source, getSymbols_default(source), object4);
}
var copySymbols_default = copySymbols;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object4) {
  var result = [];
  while (object4) {
    arrayPush_default(result, getSymbols_default(object4));
    object4 = getPrototype_default(object4);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object4) {
  return copyObject_default(source, getSymbolsIn_default(source), object4);
}
var copySymbolsIn_default = copySymbolsIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray_default(object4) ? result : arrayPush_default(result, symbolsFunc(object4));
}
var baseGetAllKeys_default = baseGetAllKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object4) {
  return baseGetAllKeys_default(object4, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object4) {
  return baseGetAllKeys_default(object4, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneArray.js
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function initCloneArray(array4) {
  var length = array4.length, result = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty11.call(array4, "index")) {
    result.index = array4.index;
    result.input = array4.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp4) {
  var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result.lastIndex = regexp4.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object4, tag, isDeep) {
  var Ctor = object4.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object4);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object4);
    case dataViewTag3:
      return cloneDataView_default(object4, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object4, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object4);
    case regexpTag2:
      return cloneRegExp_default(object4);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object4);
  }
}
var initCloneByTag_default = initCloneByTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object4) {
  return typeof object4.constructor == "function" && !isPrototype_default(object4) ? baseCreate_default(getPrototype_default(object4)) : {};
}
var initCloneObject_default = initCloneObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object4, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object4 ? customizer(value, key, object4, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object4) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object4 ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js
function arraySome(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag3 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object4), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object4, +other);
    case errorTag3:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object4 == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object4, other);
      var result = equalArrays_default(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object4) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object4), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object4[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto16 = Object.prototype;
var hasOwnProperty13 = objectProto16.hasOwnProperty;
function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object4), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object4), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object4)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object4) ? equalArrays_default(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty13.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object4, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object4, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object4 == null) {
    return !length;
  }
  object4 = Object(object4);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object4[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object4)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object4, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js
function getMatchData(object4) {
  var result = keys_default(object4), length = result.length;
  while (length--) {
    var key = result[length], value = object4[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object4) {
    if (object4 == null) {
      return false;
    }
    return object4[key] === srcValue && (srcValue !== void 0 || key in Object(object4));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object4) {
    return object4 === source || baseIsMatch_default(object4, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object4, key) {
  return object4 != null && key in Object(object4);
}
var baseHasIn_default = baseHasIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js
function hasPath(object4, path, hasFunc) {
  path = castPath_default(path, object4);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey_default(path[index2]);
    if (!(result = object4 != null && hasFunc(object4, key))) {
      break;
    }
    object4 = object4[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object4 == null ? 0 : object4.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object4) || isArguments_default(object4));
}
var hasPath_default = hasPath;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js
function hasIn(object4, path) {
  return object4 != null && hasPath_default(object4, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object4) {
    var objValue = get_default(object4, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object4, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object4) {
    return object4 == null ? void 0 : object4[key];
  };
}
var baseProperty_default = baseProperty;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object4) {
    return baseGet_default(object4, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object4, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object4), props = keysFunc(object4), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object4;
  };
}
var createBaseFor_default = createBaseFor;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object4, iteratee) {
  return object4 && baseFor_default(object4, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax2(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object4, key, value) {
  if (value !== void 0 && !eq_default(object4[key], value) || value === void 0 && !(key in object4)) {
    baseAssignValue_default(object4, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_safeGet.js
function safeGet(object4, key) {
  if (key === "constructor" && typeof object4[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object4[key];
}
var safeGet_default = safeGet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object4, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object4, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object4, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMerge.js
function baseMerge(object4, source, srcIndex, customizer, stack) {
  if (object4 === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object4, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object4, key), srcValue, key + "", object4, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object4, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array4, value, comparator) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (comparator(value, array4[index2])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/map.js
function map(collection, iteratee) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee, 3));
}
var map_default = map;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee) {
  return baseFlatten_default(map_default(collection, iteratee), 1);
}
var flatMap_default = flatMap;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flattenDeep.js
var INFINITY3 = 1 / 0;
function flattenDeep(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten_default(array4, INFINITY3) : [];
}
var flattenDeep_default = flattenDeep;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/fromPairs.js
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
var fromPairs_default = fromPairs;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object4, source, srcIndex) {
  baseMerge_default(object4, source, srcIndex);
});
var merge_default = merge;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSet.js
function baseSet(object4, path, value, customizer) {
  if (!isObject_default(object4)) {
    return object4;
  }
  path = castPath_default(path, object4);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object4;
  while (nested != null && ++index2 < length) {
    var key = toKey_default(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object4;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object4;
}
var baseSet_default = baseSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePickBy.js
function basePickBy(object4, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet_default(object4, path);
    if (predicate(value, path)) {
      baseSet_default(result, castPath_default(path, object4), value);
    }
  }
  return result;
}
var basePickBy_default = basePickBy;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePick.js
function basePick(object4, paths) {
  return basePickBy_default(object4, paths, function(value, path) {
    return hasIn_default(object4, path);
  });
}
var basePick_default = basePick;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object4, paths) {
  return object4 == null ? {} : basePick_default(object4, paths);
});
var pick_default = pick;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/set.js
function set(object4, path, value) {
  return object4 == null ? object4 : baseSet_default(object4, path, value);
}
var set_default = set;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createSet.js
var INFINITY4 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values) {
  return new Set_default(values);
};
var createSet_default = createSet;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array4, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes_default, length = array4.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE2) {
    var set3 = iteratee ? null : createSet_default(array4);
    if (set3) {
      return setToArray_default(set3);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed185 = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed185 === computed185) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed185) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed185);
        }
        result.push(value);
      } else if (!includes(seen, computed185, comparator)) {
        if (seen !== result) {
          seen.push(computed185);
        }
        result.push(value);
      }
    }
  return result;
}
var baseUniq_default = baseUniq;

// ../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/union.js
var union = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/dom/aria.mjs
var FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
var isVisible = (element) => {
  if (process.env.NODE_ENV === "test")
    return true;
  const computed185 = getComputedStyle(element);
  return computed185.position === "fixed" ? false : element.offsetParent !== null;
};
var obtainAllFocusableElements = (element) => {
  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
};
var isFocusable = (element) => {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.disabled) {
    return false;
  }
  switch (element.nodeName) {
    case "A": {
      return !!element.href && element.rel !== "ignore";
    }
    case "INPUT": {
      return !(element.type === "hidden" || element.type === "file");
    }
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA": {
      return true;
    }
    default: {
      return false;
    }
  }
};
var triggerEvent = function(elm, name, ...opts) {
  let eventName;
  if (name.includes("mouse") || name.includes("click")) {
    eventName = "MouseEvents";
  } else if (name.includes("key")) {
    eventName = "KeyboardEvent";
  } else {
    eventName = "HTMLEvents";
  }
  const evt = document.createEvent(eventName);
  evt.initEvent(name, ...opts);
  elm.dispatchEvent(evt);
  return elm;
};
var isLeaf = (el) => !el.getAttribute("aria-owns");
var getSibling = (el, distance, elClass) => {
  const { parentNode } = el;
  if (!parentNode)
    return null;
  const siblings = parentNode.querySelectorAll(elClass);
  const index2 = Array.prototype.indexOf.call(siblings, el);
  return siblings[index2 + distance] || null;
};
var focusNode = (el) => {
  if (!el)
    return;
  el.focus();
  !isLeaf(el) && el.click();
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/dom/event.mjs
var composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
  const handleEvent2 = (event) => {
    const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
    if (checkForDefaultPrevented === false || !shouldPrevent) {
      return oursHandler == null ? void 0 : oursHandler(event);
    }
  };
  return handleEvent2;
};
var whenMouse = (handler) => {
  return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
};

// ../../node_modules/.pnpm/vue-demi@0.13.11_vue@3.2.45/node_modules/vue-demi/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  Vue: () => Vue,
  Vue2: () => Vue2,
  del: () => del,
  install: () => install,
  isVue2: () => isVue2,
  isVue3: () => isVue3,
  set: () => set2
});
var Vue = __toESM(require("vue"), 1);
__reExport(lib_exports, require("vue"));
var isVue2 = false;
var isVue3 = true;
var Vue2 = void 0;
function install() {
}
function set2(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}

// ../../node_modules/.pnpm/@vueuse+shared@9.10.0_vue@3.2.45/node_modules/@vueuse/shared/index.mjs
var __defProp$9 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp$b.call(b3, prop))
      __defNormalProp$9(a3, prop, b3[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b3)) {
      if (__propIsEnum$b.call(b3, prop))
        __defNormalProp$9(a3, prop, b3[prop]);
    }
  return a3;
};
var __spreadProps$6 = (a3, b3) => __defProps$6(a3, __getOwnPropDescs$6(b3));
function computedEager(fn2, options) {
  var _a2;
  const result = (0, lib_exports.shallowRef)();
  (0, lib_exports.watchEffect)(() => {
    result.value = fn2();
  }, __spreadProps$6(__spreadValues$9({}, options), {
    flush: (_a2 = options == null ? void 0 : options.flush) != null ? _a2 : "sync"
  }));
  return (0, lib_exports.readonly)(result);
}
var _a;
var isClient = typeof window !== "undefined";
var isDef = (val) => typeof val !== "undefined";
var isBoolean = (val) => typeof val === "boolean";
var isFunction2 = (val) => typeof val === "function";
var isNumber = (val) => typeof val === "number";
var isString = (val) => typeof val === "string";
var noop2 = () => {
};
var isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r) {
  return typeof r === "function" ? r() : (0, lib_exports.unref)(r);
}
function createFilterWrapper(filter, fn2) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop2;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop2;
  };
  const filter = (invoke) => {
    const duration = resolveUnref(ms);
    const maxDuration = resolveUnref(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop2;
  let lastValue;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop2;
    }
  };
  const filter = (_invoke) => {
    const duration = resolveUnref(ms);
    const elapsed = Date.now() - lastExec;
    const invoke = () => {
      return lastValue = _invoke();
    };
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      return new Promise((resolve, reject) => {
        lastRejector = rejectOnCancel ? reject : resolve;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          resolve(invoke());
          clear();
        }, duration - elapsed);
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = (0, lib_exports.ref)(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function identity2(arg) {
  return arg;
}
function tryOnScopeDispose(fn2) {
  if ((0, lib_exports.getCurrentScope)()) {
    (0, lib_exports.onScopeDispose)(fn2);
    return true;
  }
  return false;
}
function useDebounceFn(fn2, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn2);
}
function refDebounced(value, ms = 200, options = {}) {
  const debounced = (0, lib_exports.ref)(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  (0, lib_exports.watch)(value, () => updater());
  return debounced;
}
function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn2);
}
function resolveRef(r) {
  return typeof r === "function" ? (0, lib_exports.computed)(r) : (0, lib_exports.ref)(r);
}
function tryOnMounted(fn2, sync = true) {
  if ((0, lib_exports.getCurrentInstance)())
    (0, lib_exports.onMounted)(fn2);
  else if (sync)
    fn2();
  else
    (0, lib_exports.nextTick)(fn2);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = (0, lib_exports.ref)(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, resolveUnref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending,
    start,
    stop
  };
}
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return (0, lib_exports.watch)(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp$2.call(b3, prop))
      __defNormalProp$2(a3, prop, b3[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b3)) {
      if (__propIsEnum$2.call(b3, prop))
        __defNormalProp$2(a3, prop, b3[prop]);
    }
  return a3;
};
var __spreadProps$2 = (a3, b3) => __defProps$2(a3, __getOwnPropDescs$2(b3));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter: filter
  } = _a2, watchOptions = __objRest$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop, pause, resume, isActive };
}

// ../../node_modules/.pnpm/@vueuse+core@9.10.0_vue@3.2.45/node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop2;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn2) => fn2());
    cleanups.length = 0;
  };
  const register2 = (el, event, listener) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const stopWatch = (0, lib_exports.watch)(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register2(el, event, listener));
    }));
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
  if (!window2)
    return;
  let shouldListen = true;
  let fallback;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  const listener = (event) => {
    window2.clearTimeout(fallback);
    const el = unrefElement(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      if (el)
        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
    }, { passive: true }),
    useEventListener(window2, "pointerup", (e) => {
      if (e.button === 0) {
        const path = e.composedPath();
        e.composedPath = () => path;
        fallback = window2.setTimeout(() => listener(e), 50);
      }
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      var _a2;
      const el = unrefElement(target);
      if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
        handler(event);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn2) => fn2());
  return stop;
}
function useSupported(callback, sync = false) {
  const isSupported = (0, lib_exports.ref)();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches2 = (0, lib_exports.ref)(false);
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", update);
    else
      mediaQuery.removeListener(update);
  };
  const update = () => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(resolveRef(query).value);
    matches2.value = mediaQuery.matches;
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update);
    else
      mediaQuery.addListener(update);
  };
  (0, lib_exports.watchEffect)(update);
  tryOnScopeDispose(() => cleanup());
  return matches2;
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp$l.call(b3, prop))
      __defNormalProp$j(a3, prop, b3[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b3)) {
      if (__propIsEnum$l.call(b3, prop))
        __defNormalProp$j(a3, prop, b3[prop]);
    }
  return a3;
};
var StorageSerializers = {
  boolean: {
    read: (v3) => v3 === "true",
    write: (v3) => String(v3)
  },
  object: {
    read: (v3) => JSON.parse(v3),
    write: (v3) => JSON.stringify(v3)
  },
  number: {
    read: (v3) => Number.parseFloat(v3),
    write: (v3) => String(v3)
  },
  any: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  string: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  map: {
    read: (v3) => new Map(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3.entries()))
  },
  set: {
    read: (v3) => new Set(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3))
  },
  date: {
    read: (v3) => new Date(v3),
    write: (v3) => v3.toISOString()
  }
};
function useStorage(key, defaults2, storage, options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const data = (shallow ? lib_exports.shallowRef : lib_exports.ref)(defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = resolveUnref(defaults2);
  const type4 = guessSerializerType(rawInit);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type4];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write2(data.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", update);
  update();
  return data;
  function write2(v3) {
    try {
      if (v3 == null) {
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v3);
        const oldValue = storage.getItem(key);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          if (window2) {
            window2 == null ? void 0 : window2.dispatchEvent(new StorageEvent("storage", {
              key,
              oldValue,
              newValue: serialized,
              storageArea: storage
            }));
          }
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit !== null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (isFunction2(mergeDefaults))
        return mergeDefaults(value, rawInit);
      else if (type4 === "object" && !Array.isArray(value))
        return __spreadValues$j(__spreadValues$j({}, rawInit), value);
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      data.value = read(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        (0, lib_exports.nextTick)(resumeWatch);
      else
        resumeWatch();
    }
  }
}
function useCssVar(prop, target, { window: window2 = defaultWindow, initialValue = "" } = {}) {
  const variable = (0, lib_exports.ref)(initialValue);
  const elRef = (0, lib_exports.computed)(() => {
    var _a2;
    return unrefElement(target) || ((_a2 = window2 == null ? void 0 : window2.document) == null ? void 0 : _a2.documentElement);
  });
  (0, lib_exports.watch)([elRef, () => resolveUnref(prop)], ([el, prop2]) => {
    var _a2;
    if (el && window2) {
      const value = (_a2 = window2.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a2.trim();
      variable.value = value || initialValue;
    }
  }, { immediate: true });
  (0, lib_exports.watch)(variable, (val) => {
    var _a2;
    if ((_a2 = elRef.value) == null ? void 0 : _a2.style)
      elRef.value.style.setProperty(resolveUnref(prop), val);
  });
  return variable;
}
function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
  if (!document2)
    return (0, lib_exports.ref)("visible");
  const visibility = (0, lib_exports.ref)(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    visibility.value = document2.visibilityState;
  });
  return visibility;
}
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = (0, lib_exports.watch)(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported.value && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = (0, lib_exports.ref)(0);
  const bottom = (0, lib_exports.ref)(0);
  const left2 = (0, lib_exports.ref)(0);
  const right2 = (0, lib_exports.ref)(0);
  const top = (0, lib_exports.ref)(0);
  const width = (0, lib_exports.ref)(0);
  const x3 = (0, lib_exports.ref)(0);
  const y2 = (0, lib_exports.ref)(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left2.value = 0;
        right2.value = 0;
        top.value = 0;
        width.value = 0;
        x3.value = 0;
        y2.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left2.value = rect.left;
    right2.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x3.value = rect.x;
    y2.value = rect.y;
  }
  useResizeObserver(target, update);
  (0, lib_exports.watch)(() => unrefElement(target), (ele) => !ele && update());
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left: left2,
    right: right2,
    top,
    width,
    x: x3,
    y: y2,
    update
  };
}
function useIntersectionObserver(target, callback, options = {}) {
  const {
    root: root2,
    rootMargin = "0px",
    threshold = 0.1,
    window: window2 = defaultWindow
  } = options;
  const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
  let cleanup = noop2;
  const stopWatch = isSupported.value ? (0, lib_exports.watch)(() => ({
    el: unrefElement(target),
    root: unrefElement(root2)
  }), ({ el, root: root22 }) => {
    cleanup();
    if (!el)
      return;
    const observer = new IntersectionObserver(callback, {
      root: root22,
      rootMargin,
      threshold
    });
    observer.observe(el);
    cleanup = () => {
      observer.disconnect();
      cleanup = noop2;
    };
  }, { immediate: true, flush: "post" }) : noop2;
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp(a3, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    }
  return a3;
};
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = __spreadValues({
  linear: identity2
}, _TransitionPresets);
function useVModel(props, key, emit, options = {}) {
  var _a2, _b, _c, _d, _e;
  const {
    clone: clone3 = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue
  } = options;
  const vm = (0, lib_exports.getCurrentInstance)();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    if (isVue2) {
      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;
      key = (modelOptions == null ? void 0 : modelOptions.value) || "value";
      if (!eventName)
        event = (modelOptions == null ? void 0 : modelOptions.event) || "input";
    } else {
      key = "modelValue";
    }
  }
  event = eventName || event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone3 ? val : isFunction2(clone3) ? clone3(val) : cloneFnJSON(val);
  const getValue3 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  if (passive) {
    const initialValue = getValue3();
    const proxy = (0, lib_exports.ref)(initialValue);
    (0, lib_exports.watch)(() => props[key], (v3) => proxy.value = cloneFn(v3));
    (0, lib_exports.watch)(proxy, (v3) => {
      if (v3 !== props[key] || deep)
        _emit(event, v3);
    }, { deep });
    return proxy;
  } else {
    return (0, lib_exports.computed)({
      get() {
        return getValue3();
      },
      set(value) {
        _emit(event, value);
      }
    });
  }
}
function useWindowFocus({ window: window2 = defaultWindow } = {}) {
  if (!window2)
    return (0, lib_exports.ref)(false);
  const focused = (0, lib_exports.ref)(window2.document.hasFocus());
  useEventListener(window2, "blur", () => {
    focused.value = false;
  });
  useEventListener(window2, "focus", () => {
    focused.value = true;
  });
  return focused;
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Infinity,
    initialHeight = Infinity,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = (0, lib_exports.ref)(initialWidth);
  const height = (0, lib_exports.ref)(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation)
    useEventListener("orientationchange", update, { passive: true });
  return { width, height };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/dom/position.mjs
var isInContainer = (el, container) => {
  if (!isClient || !el || !container)
    return false;
  const elRect = el.getBoundingClientRect();
  let containerRect;
  if (container instanceof Element) {
    containerRect = container.getBoundingClientRect();
  } else {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  }
  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};
var getOffsetTop = (el) => {
  let offset2 = 0;
  let parent = el;
  while (parent) {
    offset2 += parent.offsetTop;
    parent = parent.offsetParent;
  }
  return offset2;
};
var getOffsetTopDistance = (el, containerEl) => {
  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
};
var getClientXY = (event) => {
  let clientX;
  let clientY;
  if (event.type === "touchend") {
    clientY = event.changedTouches[0].clientY;
    clientX = event.changedTouches[0].clientX;
  } else if (event.type.startsWith("touch")) {
    clientY = event.touches[0].clientY;
    clientX = event.touches[0].clientX;
  } else {
    clientY = event.clientY;
    clientX = event.clientX;
  }
  return {
    clientX,
    clientY
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/types.mjs
var import_shared2 = require("@vue/shared");
var import_shared3 = require("@vue/shared");
var import_vue = require("vue");
var isUndefined = (val) => val === void 0;
var isEmpty = (val) => !val && val !== 0 || (0, import_shared2.isArray)(val) && val.length === 0 || (0, import_shared2.isObject)(val) && !Object.keys(val).length;
var isElement = (e) => {
  if (typeof Element === "undefined")
    return false;
  return e instanceof Element;
};
var isPropAbsent = (prop) => {
  return isNil_default(prop);
};
var isStringNumber = (val) => {
  if (!(0, import_shared2.isString)(val)) {
    return false;
  }
  return !Number.isNaN(Number(val));
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/strings.mjs
var import_shared4 = require("@vue/shared");
var import_shared5 = require("@vue/shared");
var escapeStringRegexp = (string3 = "") => string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
var capitalize = (str) => (0, import_shared4.capitalize)(str);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/objects.mjs
var import_shared6 = require("@vue/shared");
var keysOf = (arr) => Object.keys(arr);
var entriesOf = (arr) => Object.entries(arr);
var getProp = (obj, path, defaultValue) => {
  return {
    get value() {
      return get_default(obj, path, defaultValue);
    },
    set value(val) {
      set_default(obj, path, val);
    }
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/error.mjs
var import_shared7 = require("@vue/shared");
var ElementPlusError = class extends Error {
  constructor(m3) {
    super(m3);
    this.name = "ElementPlusError";
  }
};
function throwError(scope, m3) {
  throw new ElementPlusError(`[${scope}] ${m3}`);
}
function debugWarn(scope, message2) {
  if (process.env.NODE_ENV !== "production") {
    const error = (0, import_shared7.isString)(scope) ? new ElementPlusError(`[${scope}] ${message2}`) : scope;
    console.warn(error);
  }
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/dom/style.mjs
var import_shared8 = require("@vue/shared");
var SCOPE = "utils/dom/style";
var classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
var hasClass = (el, cls) => {
  if (!el || !cls)
    return false;
  if (cls.includes(" "))
    throw new Error("className should not contain space.");
  return el.classList.contains(cls);
};
var addClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.add(...classNameToArray(cls));
};
var removeClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.remove(...classNameToArray(cls));
};
var getStyle = (element, styleName) => {
  var _a2;
  if (!isClient || !element || !styleName)
    return "";
  let key = (0, import_shared8.camelize)(styleName);
  if (key === "float")
    key = "cssFloat";
  try {
    const style = element.style[key];
    if (style)
      return style;
    const computed185 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
    return computed185 ? computed185[key] : "";
  } catch (e) {
    return element.style[key];
  }
};
function addUnit(value, defaultUnit = "px") {
  if (!value)
    return "";
  if (isNumber(value) || isStringNumber(value)) {
    return `${value}${defaultUnit}`;
  } else if ((0, import_shared8.isString)(value)) {
    return value;
  }
  debugWarn(SCOPE, "binding value must be a string or number");
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/dom/scroll.mjs
var isScroll = (el, isVertical) => {
  if (!isClient)
    return false;
  const key = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(isVertical)];
  const overflow = getStyle(el, key);
  return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
};
var getScrollContainer = (el, isVertical) => {
  if (!isClient)
    return;
  let parent = el;
  while (parent) {
    if ([window, document, document.documentElement].includes(parent))
      return window;
    if (isScroll(parent, isVertical))
      return parent;
    parent = parent.parentNode;
  }
  return parent;
};
var scrollBarWidth;
var getScrollBarWidth = (namespace) => {
  var _a2;
  if (!isClient)
    return 0;
  if (scrollBarWidth !== void 0)
    return scrollBarWidth;
  const outer = document.createElement("div");
  outer.className = `${namespace}-scrollbar__wrap`;
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style.position = "absolute";
  outer.style.top = "-9999px";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner = document.createElement("div");
  inner.style.width = "100%";
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
};
function scrollIntoView(container, selected) {
  if (!isClient)
    return;
  if (!selected) {
    container.scrollTop = 0;
    return;
  }
  const offsetParents = [];
  let pointer = selected.offsetParent;
  while (pointer !== null && container !== pointer && container.contains(pointer)) {
    offsetParents.push(pointer);
    pointer = pointer.offsetParent;
  }
  const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
  const bottom = top + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;
  if (top < viewRectTop) {
    container.scrollTop = top;
  } else if (bottom > viewRectBottom) {
    container.scrollTop = bottom - container.clientHeight;
  }
}

// ../../node_modules/.pnpm/@element-plus+icons-vue@2.0.10_vue@3.2.45/node_modules/@element-plus/icons-vue/dist/index.js
var import_vue2 = require("vue");
var import_vue3 = require("vue");
var import_vue4 = require("vue");
var import_vue5 = require("vue");
var import_vue6 = require("vue");
var import_vue7 = require("vue");
var import_vue8 = require("vue");
var import_vue9 = require("vue");
var import_vue10 = require("vue");
var import_vue11 = require("vue");
var import_vue12 = require("vue");
var import_vue13 = require("vue");
var import_vue14 = require("vue");
var import_vue15 = require("vue");
var import_vue16 = require("vue");
var import_vue17 = require("vue");
var import_vue18 = require("vue");
var import_vue19 = require("vue");
var import_vue20 = require("vue");
var import_vue21 = require("vue");
var import_vue22 = require("vue");
var import_vue23 = require("vue");
var import_vue24 = require("vue");
var import_vue25 = require("vue");
var import_vue26 = require("vue");
var import_vue27 = require("vue");
var import_vue28 = require("vue");
var import_vue29 = require("vue");
var import_vue30 = require("vue");
var import_vue31 = require("vue");
var import_vue32 = require("vue");
var import_vue33 = require("vue");
var import_vue34 = require("vue");
var import_vue35 = require("vue");
var import_vue36 = require("vue");
var import_vue37 = require("vue");
var import_vue38 = require("vue");
var import_vue39 = require("vue");
var import_vue40 = require("vue");
var import_vue41 = require("vue");
var import_vue42 = require("vue");
var import_vue43 = require("vue");
var import_vue44 = require("vue");
var import_vue45 = require("vue");
var import_vue46 = require("vue");
var import_vue47 = require("vue");
var import_vue48 = require("vue");
var import_vue49 = require("vue");
var import_vue50 = require("vue");
var import_vue51 = require("vue");
var import_vue52 = require("vue");
var import_vue53 = require("vue");
var import_vue54 = require("vue");
var import_vue55 = require("vue");
var import_vue56 = require("vue");
var import_vue57 = require("vue");
var import_vue58 = require("vue");
var import_vue59 = require("vue");
var import_vue60 = require("vue");
var import_vue61 = require("vue");
var import_vue62 = require("vue");
var import_vue63 = require("vue");
var import_vue64 = require("vue");
var import_vue65 = require("vue");
var import_vue66 = require("vue");
var import_vue67 = require("vue");
var import_vue68 = require("vue");
var import_vue69 = require("vue");
var import_vue70 = require("vue");
var import_vue71 = require("vue");
var import_vue72 = require("vue");
var import_vue73 = require("vue");
var import_vue74 = require("vue");
var import_vue75 = require("vue");
var import_vue76 = require("vue");
var import_vue77 = require("vue");
var import_vue78 = require("vue");
var import_vue79 = require("vue");
var import_vue80 = require("vue");
var import_vue81 = require("vue");
var import_vue82 = require("vue");
var import_vue83 = require("vue");
var import_vue84 = require("vue");
var import_vue85 = require("vue");
var import_vue86 = require("vue");
var import_vue87 = require("vue");
var import_vue88 = require("vue");
var import_vue89 = require("vue");
var import_vue90 = require("vue");
var import_vue91 = require("vue");
var import_vue92 = require("vue");
var import_vue93 = require("vue");
var import_vue94 = require("vue");
var import_vue95 = require("vue");
var import_vue96 = require("vue");
var import_vue97 = require("vue");
var import_vue98 = require("vue");
var import_vue99 = require("vue");
var import_vue100 = require("vue");
var import_vue101 = require("vue");
var import_vue102 = require("vue");
var import_vue103 = require("vue");
var import_vue104 = require("vue");
var import_vue105 = require("vue");
var import_vue106 = require("vue");
var import_vue107 = require("vue");
var import_vue108 = require("vue");
var import_vue109 = require("vue");
var import_vue110 = require("vue");
var import_vue111 = require("vue");
var import_vue112 = require("vue");
var import_vue113 = require("vue");
var import_vue114 = require("vue");
var import_vue115 = require("vue");
var import_vue116 = require("vue");
var import_vue117 = require("vue");
var import_vue118 = require("vue");
var import_vue119 = require("vue");
var import_vue120 = require("vue");
var import_vue121 = require("vue");
var import_vue122 = require("vue");
var import_vue123 = require("vue");
var import_vue124 = require("vue");
var import_vue125 = require("vue");
var import_vue126 = require("vue");
var import_vue127 = require("vue");
var import_vue128 = require("vue");
var import_vue129 = require("vue");
var import_vue130 = require("vue");
var import_vue131 = require("vue");
var import_vue132 = require("vue");
var import_vue133 = require("vue");
var import_vue134 = require("vue");
var import_vue135 = require("vue");
var import_vue136 = require("vue");
var import_vue137 = require("vue");
var import_vue138 = require("vue");
var import_vue139 = require("vue");
var import_vue140 = require("vue");
var import_vue141 = require("vue");
var import_vue142 = require("vue");
var import_vue143 = require("vue");
var import_vue144 = require("vue");
var import_vue145 = require("vue");
var import_vue146 = require("vue");
var import_vue147 = require("vue");
var import_vue148 = require("vue");
var import_vue149 = require("vue");
var import_vue150 = require("vue");
var import_vue151 = require("vue");
var import_vue152 = require("vue");
var import_vue153 = require("vue");
var import_vue154 = require("vue");
var import_vue155 = require("vue");
var import_vue156 = require("vue");
var import_vue157 = require("vue");
var import_vue158 = require("vue");
var import_vue159 = require("vue");
var import_vue160 = require("vue");
var import_vue161 = require("vue");
var import_vue162 = require("vue");
var import_vue163 = require("vue");
var import_vue164 = require("vue");
var import_vue165 = require("vue");
var import_vue166 = require("vue");
var import_vue167 = require("vue");
var import_vue168 = require("vue");
var import_vue169 = require("vue");
var import_vue170 = require("vue");
var import_vue171 = require("vue");
var import_vue172 = require("vue");
var import_vue173 = require("vue");
var import_vue174 = require("vue");
var import_vue175 = require("vue");
var import_vue176 = require("vue");
var import_vue177 = require("vue");
var import_vue178 = require("vue");
var import_vue179 = require("vue");
var import_vue180 = require("vue");
var import_vue181 = require("vue");
var import_vue182 = require("vue");
var import_vue183 = require("vue");
var import_vue184 = require("vue");
var import_vue185 = require("vue");
var import_vue186 = require("vue");
var import_vue187 = require("vue");
var import_vue188 = require("vue");
var import_vue189 = require("vue");
var import_vue190 = require("vue");
var import_vue191 = require("vue");
var import_vue192 = require("vue");
var import_vue193 = require("vue");
var import_vue194 = require("vue");
var import_vue195 = require("vue");
var import_vue196 = require("vue");
var import_vue197 = require("vue");
var import_vue198 = require("vue");
var import_vue199 = require("vue");
var import_vue200 = require("vue");
var import_vue201 = require("vue");
var import_vue202 = require("vue");
var import_vue203 = require("vue");
var import_vue204 = require("vue");
var import_vue205 = require("vue");
var import_vue206 = require("vue");
var import_vue207 = require("vue");
var import_vue208 = require("vue");
var import_vue209 = require("vue");
var import_vue210 = require("vue");
var import_vue211 = require("vue");
var import_vue212 = require("vue");
var import_vue213 = require("vue");
var import_vue214 = require("vue");
var import_vue215 = require("vue");
var import_vue216 = require("vue");
var import_vue217 = require("vue");
var import_vue218 = require("vue");
var import_vue219 = require("vue");
var import_vue220 = require("vue");
var import_vue221 = require("vue");
var import_vue222 = require("vue");
var import_vue223 = require("vue");
var import_vue224 = require("vue");
var import_vue225 = require("vue");
var import_vue226 = require("vue");
var import_vue227 = require("vue");
var import_vue228 = require("vue");
var import_vue229 = require("vue");
var import_vue230 = require("vue");
var import_vue231 = require("vue");
var import_vue232 = require("vue");
var import_vue233 = require("vue");
var import_vue234 = require("vue");
var import_vue235 = require("vue");
var import_vue236 = require("vue");
var import_vue237 = require("vue");
var import_vue238 = require("vue");
var import_vue239 = require("vue");
var import_vue240 = require("vue");
var import_vue241 = require("vue");
var import_vue242 = require("vue");
var import_vue243 = require("vue");
var import_vue244 = require("vue");
var import_vue245 = require("vue");
var import_vue246 = require("vue");
var import_vue247 = require("vue");
var import_vue248 = require("vue");
var import_vue249 = require("vue");
var import_vue250 = require("vue");
var import_vue251 = require("vue");
var import_vue252 = require("vue");
var import_vue253 = require("vue");
var import_vue254 = require("vue");
var import_vue255 = require("vue");
var import_vue256 = require("vue");
var import_vue257 = require("vue");
var import_vue258 = require("vue");
var import_vue259 = require("vue");
var import_vue260 = require("vue");
var import_vue261 = require("vue");
var import_vue262 = require("vue");
var import_vue263 = require("vue");
var import_vue264 = require("vue");
var import_vue265 = require("vue");
var import_vue266 = require("vue");
var import_vue267 = require("vue");
var import_vue268 = require("vue");
var import_vue269 = require("vue");
var import_vue270 = require("vue");
var import_vue271 = require("vue");
var import_vue272 = require("vue");
var import_vue273 = require("vue");
var import_vue274 = require("vue");
var import_vue275 = require("vue");
var import_vue276 = require("vue");
var import_vue277 = require("vue");
var import_vue278 = require("vue");
var import_vue279 = require("vue");
var import_vue280 = require("vue");
var import_vue281 = require("vue");
var import_vue282 = require("vue");
var import_vue283 = require("vue");
var import_vue284 = require("vue");
var import_vue285 = require("vue");
var import_vue286 = require("vue");
var import_vue287 = require("vue");
var import_vue288 = require("vue");
var import_vue289 = require("vue");
var import_vue290 = require("vue");
var import_vue291 = require("vue");
var import_vue292 = require("vue");
var import_vue293 = require("vue");
var import_vue294 = require("vue");
var export_helper_default = (sfc, props) => {
  let target = sfc.__vccOpts || sfc;
  for (let [key, val] of props)
    target[key] = val;
  return target;
};
var arrow_down_vue_vue_type_script_lang_default = {
  name: "ArrowDown"
};
var _hoisted_16 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_26 = /* @__PURE__ */ (0, import_vue7.createElementVNode)("path", {
  fill: "currentColor",
  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
}, null, -1);
var _hoisted_36 = [
  _hoisted_26
];
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue7.openBlock)(), (0, import_vue7.createElementBlock)("svg", _hoisted_16, _hoisted_36);
}
var arrow_down_default = /* @__PURE__ */ export_helper_default(arrow_down_vue_vue_type_script_lang_default, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
var arrow_left_vue_vue_type_script_lang_default = {
  name: "ArrowLeft"
};
var _hoisted_18 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_28 = /* @__PURE__ */ (0, import_vue9.createElementVNode)("path", {
  fill: "currentColor",
  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
}, null, -1);
var _hoisted_38 = [
  _hoisted_28
];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue9.openBlock)(), (0, import_vue9.createElementBlock)("svg", _hoisted_18, _hoisted_38);
}
var arrow_left_default = /* @__PURE__ */ export_helper_default(arrow_left_vue_vue_type_script_lang_default, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
var arrow_right_vue_vue_type_script_lang_default = {
  name: "ArrowRight"
};
var _hoisted_110 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_210 = /* @__PURE__ */ (0, import_vue11.createElementVNode)("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
}, null, -1);
var _hoisted_310 = [
  _hoisted_210
];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue11.openBlock)(), (0, import_vue11.createElementBlock)("svg", _hoisted_110, _hoisted_310);
}
var arrow_right_default = /* @__PURE__ */ export_helper_default(arrow_right_vue_vue_type_script_lang_default, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
var arrow_up_vue_vue_type_script_lang_default = {
  name: "ArrowUp"
};
var _hoisted_112 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_212 = /* @__PURE__ */ (0, import_vue13.createElementVNode)("path", {
  fill: "currentColor",
  d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
}, null, -1);
var _hoisted_312 = [
  _hoisted_212
];
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue13.openBlock)(), (0, import_vue13.createElementBlock)("svg", _hoisted_112, _hoisted_312);
}
var arrow_up_default = /* @__PURE__ */ export_helper_default(arrow_up_vue_vue_type_script_lang_default, [["render", _sfc_render12], ["__file", "arrow-up.vue"]]);
var back_vue_vue_type_script_lang_default = {
  name: "Back"
};
var _hoisted_114 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_214 = /* @__PURE__ */ (0, import_vue15.createElementVNode)("path", {
  fill: "currentColor",
  d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
}, null, -1);
var _hoisted_314 = /* @__PURE__ */ (0, import_vue15.createElementVNode)("path", {
  fill: "currentColor",
  d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
}, null, -1);
var _hoisted_44 = [
  _hoisted_214,
  _hoisted_314
];
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue15.openBlock)(), (0, import_vue15.createElementBlock)("svg", _hoisted_114, _hoisted_44);
}
var back_default = /* @__PURE__ */ export_helper_default(back_vue_vue_type_script_lang_default, [["render", _sfc_render14], ["__file", "back.vue"]]);
var calendar_vue_vue_type_script_lang_default = {
  name: "Calendar"
};
var _hoisted_129 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_229 = /* @__PURE__ */ (0, import_vue30.createElementVNode)("path", {
  fill: "currentColor",
  d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
}, null, -1);
var _hoisted_328 = [
  _hoisted_229
];
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue30.openBlock)(), (0, import_vue30.createElementBlock)("svg", _hoisted_129, _hoisted_328);
}
var calendar_default = /* @__PURE__ */ export_helper_default(calendar_vue_vue_type_script_lang_default, [["render", _sfc_render29], ["__file", "calendar.vue"]]);
var caret_right_vue_vue_type_script_lang_default = {
  name: "CaretRight"
};
var _hoisted_134 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_234 = /* @__PURE__ */ (0, import_vue35.createElementVNode)("path", {
  fill: "currentColor",
  d: "M384 192v640l384-320.064z"
}, null, -1);
var _hoisted_333 = [
  _hoisted_234
];
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue35.openBlock)(), (0, import_vue35.createElementBlock)("svg", _hoisted_134, _hoisted_333);
}
var caret_right_default = /* @__PURE__ */ export_helper_default(caret_right_vue_vue_type_script_lang_default, [["render", _sfc_render34], ["__file", "caret-right.vue"]]);
var caret_top_vue_vue_type_script_lang_default = {
  name: "CaretTop"
};
var _hoisted_135 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_235 = /* @__PURE__ */ (0, import_vue36.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 320 192 704h639.936z"
}, null, -1);
var _hoisted_334 = [
  _hoisted_235
];
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue36.openBlock)(), (0, import_vue36.createElementBlock)("svg", _hoisted_135, _hoisted_334);
}
var caret_top_default = /* @__PURE__ */ export_helper_default(caret_top_vue_vue_type_script_lang_default, [["render", _sfc_render35], ["__file", "caret-top.vue"]]);
var check_vue_vue_type_script_lang_default = {
  name: "Check"
};
var _hoisted_143 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_243 = /* @__PURE__ */ (0, import_vue44.createElementVNode)("path", {
  fill: "currentColor",
  d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
}, null, -1);
var _hoisted_342 = [
  _hoisted_243
];
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue44.openBlock)(), (0, import_vue44.createElementBlock)("svg", _hoisted_143, _hoisted_342);
}
var check_default = /* @__PURE__ */ export_helper_default(check_vue_vue_type_script_lang_default, [["render", _sfc_render43], ["__file", "check.vue"]]);
var circle_check_filled_vue_vue_type_script_lang_default = {
  name: "CircleCheckFilled"
};
var _hoisted_148 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_248 = /* @__PURE__ */ (0, import_vue49.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1);
var _hoisted_347 = [
  _hoisted_248
];
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue49.openBlock)(), (0, import_vue49.createElementBlock)("svg", _hoisted_148, _hoisted_347);
}
var circle_check_filled_default = /* @__PURE__ */ export_helper_default(circle_check_filled_vue_vue_type_script_lang_default, [["render", _sfc_render48], ["__file", "circle-check-filled.vue"]]);
var circle_check_vue_vue_type_script_lang_default = {
  name: "CircleCheck"
};
var _hoisted_149 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_249 = /* @__PURE__ */ (0, import_vue50.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
var _hoisted_348 = /* @__PURE__ */ (0, import_vue50.createElementVNode)("path", {
  fill: "currentColor",
  d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
}, null, -1);
var _hoisted_415 = [
  _hoisted_249,
  _hoisted_348
];
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue50.openBlock)(), (0, import_vue50.createElementBlock)("svg", _hoisted_149, _hoisted_415);
}
var circle_check_default = /* @__PURE__ */ export_helper_default(circle_check_vue_vue_type_script_lang_default, [["render", _sfc_render49], ["__file", "circle-check.vue"]]);
var circle_close_filled_vue_vue_type_script_lang_default = {
  name: "CircleCloseFilled"
};
var _hoisted_150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_250 = /* @__PURE__ */ (0, import_vue51.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
}, null, -1);
var _hoisted_349 = [
  _hoisted_250
];
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue51.openBlock)(), (0, import_vue51.createElementBlock)("svg", _hoisted_150, _hoisted_349);
}
var circle_close_filled_default = /* @__PURE__ */ export_helper_default(circle_close_filled_vue_vue_type_script_lang_default, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
var circle_close_vue_vue_type_script_lang_default = {
  name: "CircleClose"
};
var _hoisted_151 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_251 = /* @__PURE__ */ (0, import_vue52.createElementVNode)("path", {
  fill: "currentColor",
  d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
}, null, -1);
var _hoisted_350 = /* @__PURE__ */ (0, import_vue52.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
var _hoisted_416 = [
  _hoisted_251,
  _hoisted_350
];
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue52.openBlock)(), (0, import_vue52.createElementBlock)("svg", _hoisted_151, _hoisted_416);
}
var circle_close_default = /* @__PURE__ */ export_helper_default(circle_close_vue_vue_type_script_lang_default, [["render", _sfc_render51], ["__file", "circle-close.vue"]]);
var clock_vue_vue_type_script_lang_default = {
  name: "Clock"
};
var _hoisted_154 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_254 = /* @__PURE__ */ (0, import_vue55.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
var _hoisted_353 = /* @__PURE__ */ (0, import_vue55.createElementVNode)("path", {
  fill: "currentColor",
  d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
}, null, -1);
var _hoisted_418 = /* @__PURE__ */ (0, import_vue55.createElementVNode)("path", {
  fill: "currentColor",
  d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
}, null, -1);
var _hoisted_56 = [
  _hoisted_254,
  _hoisted_353,
  _hoisted_418
];
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue55.openBlock)(), (0, import_vue55.createElementBlock)("svg", _hoisted_154, _hoisted_56);
}
var clock_default = /* @__PURE__ */ export_helper_default(clock_vue_vue_type_script_lang_default, [["render", _sfc_render54], ["__file", "clock.vue"]]);
var close_vue_vue_type_script_lang_default = {
  name: "Close"
};
var _hoisted_156 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_256 = /* @__PURE__ */ (0, import_vue57.createElementVNode)("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1);
var _hoisted_355 = [
  _hoisted_256
];
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue57.openBlock)(), (0, import_vue57.createElementBlock)("svg", _hoisted_156, _hoisted_355);
}
var close_default = /* @__PURE__ */ export_helper_default(close_vue_vue_type_script_lang_default, [["render", _sfc_render56], ["__file", "close.vue"]]);
var d_arrow_left_vue_vue_type_script_lang_default = {
  name: "DArrowLeft"
};
var _hoisted_172 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_272 = /* @__PURE__ */ (0, import_vue73.createElementVNode)("path", {
  fill: "currentColor",
  d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
}, null, -1);
var _hoisted_371 = [
  _hoisted_272
];
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue73.openBlock)(), (0, import_vue73.createElementBlock)("svg", _hoisted_172, _hoisted_371);
}
var d_arrow_left_default = /* @__PURE__ */ export_helper_default(d_arrow_left_vue_vue_type_script_lang_default, [["render", _sfc_render72], ["__file", "d-arrow-left.vue"]]);
var d_arrow_right_vue_vue_type_script_lang_default = {
  name: "DArrowRight"
};
var _hoisted_173 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_273 = /* @__PURE__ */ (0, import_vue74.createElementVNode)("path", {
  fill: "currentColor",
  d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
}, null, -1);
var _hoisted_372 = [
  _hoisted_273
];
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue74.openBlock)(), (0, import_vue74.createElementBlock)("svg", _hoisted_173, _hoisted_372);
}
var d_arrow_right_default = /* @__PURE__ */ export_helper_default(d_arrow_right_vue_vue_type_script_lang_default, [["render", _sfc_render73], ["__file", "d-arrow-right.vue"]]);
var delete_vue_vue_type_script_lang_default = {
  name: "Delete"
};
var _hoisted_180 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_280 = /* @__PURE__ */ (0, import_vue81.createElementVNode)("path", {
  fill: "currentColor",
  d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
}, null, -1);
var _hoisted_379 = [
  _hoisted_280
];
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue81.openBlock)(), (0, import_vue81.createElementBlock)("svg", _hoisted_180, _hoisted_379);
}
var delete_default = /* @__PURE__ */ export_helper_default(delete_vue_vue_type_script_lang_default, [["render", _sfc_render80], ["__file", "delete.vue"]]);
var document_vue_vue_type_script_lang_default = {
  name: "Document"
};
var _hoisted_190 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_290 = /* @__PURE__ */ (0, import_vue91.createElementVNode)("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
var _hoisted_389 = [
  _hoisted_290
];
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue91.openBlock)(), (0, import_vue91.createElementBlock)("svg", _hoisted_190, _hoisted_389);
}
var document_default = /* @__PURE__ */ export_helper_default(document_vue_vue_type_script_lang_default, [["render", _sfc_render90], ["__file", "document.vue"]]);
var full_screen_vue_vue_type_script_lang_default = {
  name: "FullScreen"
};
var _hoisted_1118 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2118 = /* @__PURE__ */ (0, import_vue119.createElementVNode)("path", {
  fill: "currentColor",
  d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
}, null, -1);
var _hoisted_3117 = [
  _hoisted_2118
];
function _sfc_render118(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue119.openBlock)(), (0, import_vue119.createElementBlock)("svg", _hoisted_1118, _hoisted_3117);
}
var full_screen_default = /* @__PURE__ */ export_helper_default(full_screen_vue_vue_type_script_lang_default, [["render", _sfc_render118], ["__file", "full-screen.vue"]]);
var hide_vue_vue_type_script_lang_default = {
  name: "Hide"
};
var _hoisted_1133 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2133 = /* @__PURE__ */ (0, import_vue134.createElementVNode)("path", {
  d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_3132 = /* @__PURE__ */ (0, import_vue134.createElementVNode)("path", {
  d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_438 = [
  _hoisted_2133,
  _hoisted_3132
];
function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue134.openBlock)(), (0, import_vue134.createElementBlock)("svg", _hoisted_1133, _hoisted_438);
}
var hide_default = /* @__PURE__ */ export_helper_default(hide_vue_vue_type_script_lang_default, [["render", _sfc_render133], ["__file", "hide.vue"]]);
var info_filled_vue_vue_type_script_lang_default = {
  name: "InfoFilled"
};
var _hoisted_1143 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2143 = /* @__PURE__ */ (0, import_vue144.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1);
var _hoisted_3142 = [
  _hoisted_2143
];
function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue144.openBlock)(), (0, import_vue144.createElementBlock)("svg", _hoisted_1143, _hoisted_3142);
}
var info_filled_default = /* @__PURE__ */ export_helper_default(info_filled_vue_vue_type_script_lang_default, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
var loading_vue_vue_type_script_lang_default = {
  name: "Loading"
};
var _hoisted_1150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2150 = /* @__PURE__ */ (0, import_vue151.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
}, null, -1);
var _hoisted_3149 = [
  _hoisted_2150
];
function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue151.openBlock)(), (0, import_vue151.createElementBlock)("svg", _hoisted_1150, _hoisted_3149);
}
var loading_default = /* @__PURE__ */ export_helper_default(loading_vue_vue_type_script_lang_default, [["render", _sfc_render150], ["__file", "loading.vue"]]);
var minus_vue_vue_type_script_lang_default = {
  name: "Minus"
};
var _hoisted_1169 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2169 = /* @__PURE__ */ (0, import_vue170.createElementVNode)("path", {
  fill: "currentColor",
  d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
}, null, -1);
var _hoisted_3168 = [
  _hoisted_2169
];
function _sfc_render169(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue170.openBlock)(), (0, import_vue170.createElementBlock)("svg", _hoisted_1169, _hoisted_3168);
}
var minus_default = /* @__PURE__ */ export_helper_default(minus_vue_vue_type_script_lang_default, [["render", _sfc_render169], ["__file", "minus.vue"]]);
var more_filled_vue_vue_type_script_lang_default = {
  name: "MoreFilled"
};
var _hoisted_1174 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2174 = /* @__PURE__ */ (0, import_vue175.createElementVNode)("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"
}, null, -1);
var _hoisted_3173 = [
  _hoisted_2174
];
function _sfc_render174(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue175.openBlock)(), (0, import_vue175.createElementBlock)("svg", _hoisted_1174, _hoisted_3173);
}
var more_filled_default = /* @__PURE__ */ export_helper_default(more_filled_vue_vue_type_script_lang_default, [["render", _sfc_render174], ["__file", "more-filled.vue"]]);
var more_vue_vue_type_script_lang_default = {
  name: "More"
};
var _hoisted_1175 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2175 = /* @__PURE__ */ (0, import_vue176.createElementVNode)("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"
}, null, -1);
var _hoisted_3174 = [
  _hoisted_2175
];
function _sfc_render175(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue176.openBlock)(), (0, import_vue176.createElementBlock)("svg", _hoisted_1175, _hoisted_3174);
}
var more_default = /* @__PURE__ */ export_helper_default(more_vue_vue_type_script_lang_default, [["render", _sfc_render175], ["__file", "more.vue"]]);
var picture_filled_vue_vue_type_script_lang_default = {
  name: "PictureFilled"
};
var _hoisted_1195 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2195 = /* @__PURE__ */ (0, import_vue196.createElementVNode)("path", {
  fill: "currentColor",
  d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z"
}, null, -1);
var _hoisted_3194 = [
  _hoisted_2195
];
function _sfc_render195(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue196.openBlock)(), (0, import_vue196.createElementBlock)("svg", _hoisted_1195, _hoisted_3194);
}
var picture_filled_default = /* @__PURE__ */ export_helper_default(picture_filled_vue_vue_type_script_lang_default, [["render", _sfc_render195], ["__file", "picture-filled.vue"]]);
var plus_vue_vue_type_script_lang_default = {
  name: "Plus"
};
var _hoisted_1201 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2201 = /* @__PURE__ */ (0, import_vue202.createElementVNode)("path", {
  fill: "currentColor",
  d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
}, null, -1);
var _hoisted_3200 = [
  _hoisted_2201
];
function _sfc_render201(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue202.openBlock)(), (0, import_vue202.createElementBlock)("svg", _hoisted_1201, _hoisted_3200);
}
var plus_default = /* @__PURE__ */ export_helper_default(plus_vue_vue_type_script_lang_default, [["render", _sfc_render201], ["__file", "plus.vue"]]);
var question_filled_vue_vue_type_script_lang_default = {
  name: "QuestionFilled"
};
var _hoisted_1211 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2211 = /* @__PURE__ */ (0, import_vue212.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
}, null, -1);
var _hoisted_3210 = [
  _hoisted_2211
];
function _sfc_render211(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue212.openBlock)(), (0, import_vue212.createElementBlock)("svg", _hoisted_1211, _hoisted_3210);
}
var question_filled_default = /* @__PURE__ */ export_helper_default(question_filled_vue_vue_type_script_lang_default, [["render", _sfc_render211], ["__file", "question-filled.vue"]]);
var refresh_left_vue_vue_type_script_lang_default = {
  name: "RefreshLeft"
};
var _hoisted_1215 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2215 = /* @__PURE__ */ (0, import_vue216.createElementVNode)("path", {
  fill: "currentColor",
  d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
}, null, -1);
var _hoisted_3214 = [
  _hoisted_2215
];
function _sfc_render215(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue216.openBlock)(), (0, import_vue216.createElementBlock)("svg", _hoisted_1215, _hoisted_3214);
}
var refresh_left_default = /* @__PURE__ */ export_helper_default(refresh_left_vue_vue_type_script_lang_default, [["render", _sfc_render215], ["__file", "refresh-left.vue"]]);
var refresh_right_vue_vue_type_script_lang_default = {
  name: "RefreshRight"
};
var _hoisted_1216 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2216 = /* @__PURE__ */ (0, import_vue217.createElementVNode)("path", {
  fill: "currentColor",
  d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
}, null, -1);
var _hoisted_3215 = [
  _hoisted_2216
];
function _sfc_render216(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue217.openBlock)(), (0, import_vue217.createElementBlock)("svg", _hoisted_1216, _hoisted_3215);
}
var refresh_right_default = /* @__PURE__ */ export_helper_default(refresh_right_vue_vue_type_script_lang_default, [["render", _sfc_render216], ["__file", "refresh-right.vue"]]);
var scale_to_original_vue_vue_type_script_lang_default = {
  name: "ScaleToOriginal"
};
var _hoisted_1222 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2222 = /* @__PURE__ */ (0, import_vue223.createElementVNode)("path", {
  fill: "currentColor",
  d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
}, null, -1);
var _hoisted_3221 = [
  _hoisted_2222
];
function _sfc_render222(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue223.openBlock)(), (0, import_vue223.createElementBlock)("svg", _hoisted_1222, _hoisted_3221);
}
var scale_to_original_default = /* @__PURE__ */ export_helper_default(scale_to_original_vue_vue_type_script_lang_default, [["render", _sfc_render222], ["__file", "scale-to-original.vue"]]);
var search_vue_vue_type_script_lang_default = {
  name: "Search"
};
var _hoisted_1225 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2225 = /* @__PURE__ */ (0, import_vue226.createElementVNode)("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
}, null, -1);
var _hoisted_3224 = [
  _hoisted_2225
];
function _sfc_render225(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue226.openBlock)(), (0, import_vue226.createElementBlock)("svg", _hoisted_1225, _hoisted_3224);
}
var search_default = /* @__PURE__ */ export_helper_default(search_vue_vue_type_script_lang_default, [["render", _sfc_render225], ["__file", "search.vue"]]);
var sort_down_vue_vue_type_script_lang_default = {
  name: "SortDown"
};
var _hoisted_1242 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2242 = /* @__PURE__ */ (0, import_vue243.createElementVNode)("path", {
  fill: "currentColor",
  d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z"
}, null, -1);
var _hoisted_3241 = [
  _hoisted_2242
];
function _sfc_render242(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue243.openBlock)(), (0, import_vue243.createElementBlock)("svg", _hoisted_1242, _hoisted_3241);
}
var sort_down_default = /* @__PURE__ */ export_helper_default(sort_down_vue_vue_type_script_lang_default, [["render", _sfc_render242], ["__file", "sort-down.vue"]]);
var sort_up_vue_vue_type_script_lang_default = {
  name: "SortUp"
};
var _hoisted_1243 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2243 = /* @__PURE__ */ (0, import_vue244.createElementVNode)("path", {
  fill: "currentColor",
  d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z"
}, null, -1);
var _hoisted_3242 = [
  _hoisted_2243
];
function _sfc_render243(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue244.openBlock)(), (0, import_vue244.createElementBlock)("svg", _hoisted_1243, _hoisted_3242);
}
var sort_up_default = /* @__PURE__ */ export_helper_default(sort_up_vue_vue_type_script_lang_default, [["render", _sfc_render243], ["__file", "sort-up.vue"]]);
var star_filled_vue_vue_type_script_lang_default = {
  name: "StarFilled"
};
var _hoisted_1246 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2246 = /* @__PURE__ */ (0, import_vue247.createElementVNode)("path", {
  fill: "currentColor",
  d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
}, null, -1);
var _hoisted_3245 = [
  _hoisted_2246
];
function _sfc_render246(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue247.openBlock)(), (0, import_vue247.createElementBlock)("svg", _hoisted_1246, _hoisted_3245);
}
var star_filled_default = /* @__PURE__ */ export_helper_default(star_filled_vue_vue_type_script_lang_default, [["render", _sfc_render246], ["__file", "star-filled.vue"]]);
var star_vue_vue_type_script_lang_default = {
  name: "Star"
};
var _hoisted_1247 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2247 = /* @__PURE__ */ (0, import_vue248.createElementVNode)("path", {
  fill: "currentColor",
  d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
}, null, -1);
var _hoisted_3246 = [
  _hoisted_2247
];
function _sfc_render247(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue248.openBlock)(), (0, import_vue248.createElementBlock)("svg", _hoisted_1247, _hoisted_3246);
}
var star_default = /* @__PURE__ */ export_helper_default(star_vue_vue_type_script_lang_default, [["render", _sfc_render247], ["__file", "star.vue"]]);
var success_filled_vue_vue_type_script_lang_default = {
  name: "SuccessFilled"
};
var _hoisted_1249 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2249 = /* @__PURE__ */ (0, import_vue250.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1);
var _hoisted_3248 = [
  _hoisted_2249
];
function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue250.openBlock)(), (0, import_vue250.createElementBlock)("svg", _hoisted_1249, _hoisted_3248);
}
var success_filled_default = /* @__PURE__ */ export_helper_default(success_filled_vue_vue_type_script_lang_default, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
var view_vue_vue_type_script_lang_default = {
  name: "View"
};
var _hoisted_1283 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2283 = /* @__PURE__ */ (0, import_vue284.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1);
var _hoisted_3282 = [
  _hoisted_2283
];
function _sfc_render283(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue284.openBlock)(), (0, import_vue284.createElementBlock)("svg", _hoisted_1283, _hoisted_3282);
}
var view_default = /* @__PURE__ */ export_helper_default(view_vue_vue_type_script_lang_default, [["render", _sfc_render283], ["__file", "view.vue"]]);
var warning_filled_vue_vue_type_script_lang_default = {
  name: "WarningFilled"
};
var _hoisted_1287 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2287 = /* @__PURE__ */ (0, import_vue288.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
}, null, -1);
var _hoisted_3286 = [
  _hoisted_2287
];
function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue288.openBlock)(), (0, import_vue288.createElementBlock)("svg", _hoisted_1287, _hoisted_3286);
}
var warning_filled_default = /* @__PURE__ */ export_helper_default(warning_filled_vue_vue_type_script_lang_default, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
var zoom_in_vue_vue_type_script_lang_default = {
  name: "ZoomIn"
};
var _hoisted_1292 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2292 = /* @__PURE__ */ (0, import_vue293.createElementVNode)("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
}, null, -1);
var _hoisted_3291 = [
  _hoisted_2292
];
function _sfc_render292(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue293.openBlock)(), (0, import_vue293.createElementBlock)("svg", _hoisted_1292, _hoisted_3291);
}
var zoom_in_default = /* @__PURE__ */ export_helper_default(zoom_in_vue_vue_type_script_lang_default, [["render", _sfc_render292], ["__file", "zoom-in.vue"]]);
var zoom_out_vue_vue_type_script_lang_default = {
  name: "ZoomOut"
};
var _hoisted_1293 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2293 = /* @__PURE__ */ (0, import_vue294.createElementVNode)("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
}, null, -1);
var _hoisted_3292 = [
  _hoisted_2293
];
function _sfc_render293(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue294.openBlock)(), (0, import_vue294.createElementBlock)("svg", _hoisted_1293, _hoisted_3292);
}
var zoom_out_default = /* @__PURE__ */ export_helper_default(zoom_out_vue_vue_type_script_lang_default, [["render", _sfc_render293], ["__file", "zoom-out.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/props/runtime.mjs
var import_vue295 = require("vue");
var import_shared9 = require("@vue/shared");
var epPropKey = "__epPropKey";
var definePropType = (val) => val;
var isEpProp = (val) => (0, import_shared9.isObject)(val) && !!val[epPropKey];
var buildProp = (prop, key) => {
  if (!(0, import_shared9.isObject)(prop) || isEpProp(prop))
    return prop;
  const { values, required: required4, default: defaultValue, type: type4, validator } = prop;
  const _validator = values || validator ? (val) => {
    let valid = false;
    let allowedValues = [];
    if (values) {
      allowedValues = Array.from(values);
      if ((0, import_shared9.hasOwn)(prop, "default")) {
        allowedValues.push(defaultValue);
      }
      valid || (valid = allowedValues.includes(val));
    }
    if (validator)
      valid || (valid = validator(val));
    if (!valid && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      (0, import_vue295.warn)(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }
    return valid;
  } : void 0;
  const epProp = {
    type: type4,
    required: !!required4,
    validator: _validator,
    [epPropKey]: true
  };
  if ((0, import_shared9.hasOwn)(prop, "default"))
    epProp.default = defaultValue;
  return epProp;
};
var buildProps = (props) => fromPairs_default(Object.entries(props).map(([key, option2]) => [
  key,
  buildProp(option2, key)
]));

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/icon.mjs
var iconPropType = definePropType([
  String,
  Object,
  Function
]);
var CloseComponents = {
  Close: close_default
};
var TypeComponents = {
  Close: close_default,
  SuccessFilled: success_filled_default,
  InfoFilled: info_filled_default,
  WarningFilled: warning_filled_default,
  CircleCloseFilled: circle_close_filled_default
};
var TypeComponentsMap = {
  success: success_filled_default,
  warning: warning_filled_default,
  error: circle_close_filled_default,
  info: info_filled_default
};
var ValidateComponentsMap = {
  validating: loading_default,
  success: circle_check_default,
  error: circle_close_default
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/install.mjs
var import_shared10 = require("@vue/shared");
var withInstall = (main, extra) => {
  ;
  main.install = (app) => {
    for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key, comp] of Object.entries(extra)) {
      ;
      main[key] = comp;
    }
  }
  return main;
};
var withInstallFunction = (fn2, name) => {
  ;
  fn2.install = (app) => {
    ;
    fn2._context = app._context;
    app.config.globalProperties[name] = fn2;
  };
  return fn2;
};
var withInstallDirective = (directive, name) => {
  ;
  directive.install = (app) => {
    app.directive(name, directive);
  };
  return directive;
};
var withNoopInstall = (component2) => {
  ;
  component2.install = import_shared10.NOOP;
  return component2;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/refs.mjs
var import_shared11 = require("@vue/shared");
var composeRefs = (...refs) => {
  return (el) => {
    refs.forEach((ref162) => {
      if ((0, import_shared11.isFunction)(ref162)) {
        ref162(el);
      } else {
        ref162.value = el;
      }
    });
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/constants/aria.mjs
var EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/constants/date.mjs
var datePickTypes = [
  "year",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
];
var WEEK_DAYS = [
  "sun",
  "mon",
  "tue",
  "wed",
  "thu",
  "fri",
  "sat"
];

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/constants/event.mjs
var UPDATE_MODEL_EVENT = "update:modelValue";
var CHANGE_EVENT = "change";
var INPUT_EVENT = "input";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/constants/key.mjs
var INSTALLED_KEY = Symbol("INSTALLED_KEY");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/constants/size.mjs
var componentSizes = ["", "default", "small", "large"];
var componentSizeMap = {
  large: 40,
  default: 32,
  small: 24
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/size.mjs
var getComponentSize = (size2) => {
  return componentSizeMap[size2 || "default"];
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/validator.mjs
var isValidComponentSize = (val) => ["", ...componentSizes].includes(val);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/vue/vnode.mjs
var import_vue296 = require("vue");
var import_shared12 = require("@vue/shared");
var SCOPE2 = "utils/vue/vnode";
var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
  return PatchFlags2;
})(PatchFlags || {});
function isFragment(node) {
  return (0, import_vue296.isVNode)(node) && node.type === import_vue296.Fragment;
}
function isComment(node) {
  return (0, import_vue296.isVNode)(node) && node.type === import_vue296.Comment;
}
function isValidElementNode(node) {
  return (0, import_vue296.isVNode)(node) && !isFragment(node) && !isComment(node);
}
var getNormalizedProps = (node) => {
  if (!(0, import_vue296.isVNode)(node)) {
    debugWarn(SCOPE2, "[getNormalizedProps] must be a VNode");
    return {};
  }
  const raw = node.props || {};
  const type4 = ((0, import_vue296.isVNode)(node.type) ? node.type.props : void 0) || {};
  const props = {};
  Object.keys(type4).forEach((key) => {
    if ((0, import_shared12.hasOwn)(type4[key], "default")) {
      props[key] = type4[key].default;
    }
  });
  Object.keys(raw).forEach((key) => {
    props[(0, import_shared12.camelize)(key)] = raw[key];
  });
  return props;
};
var ensureOnlyChild = (children) => {
  if (!(0, import_shared12.isArray)(children) || children.length > 1) {
    throw new Error("expect to receive a single Vue element child");
  }
  return children[0];
};
var flattedChildren = (children) => {
  const vNodes = (0, import_shared12.isArray)(children) ? children : [children];
  const result = [];
  vNodes.forEach((child) => {
    var _a2;
    if ((0, import_shared12.isArray)(child)) {
      result.push(...flattedChildren(child));
    } else if ((0, import_vue296.isVNode)(child) && (0, import_shared12.isArray)(child.children)) {
      result.push(...flattedChildren(child.children));
    } else {
      result.push(child);
      if ((0, import_vue296.isVNode)(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
        result.push(...flattedChildren(child.component.subTree));
      }
    }
  });
  return result;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/animation.mjs
var cubic = (value) => {
  return value ** 3;
};
var easeInOutCubic = (value) => value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/arrays.mjs
var unique = (arr) => [...new Set(arr)];
var castArray2 = (arr) => {
  if (!arr && arr !== 0)
    return [];
  return Array.isArray(arr) ? arr : [arr];
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/browser.mjs
var isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/i18n.mjs
var isKorean = (text) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/raf.mjs
var rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
var cAF = (handle) => isClient ? window.cancelAnimationFrame(handle) : clearTimeout(handle);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/rand.mjs
var generateId = () => Math.floor(Math.random() * 1e4);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/utils/typescript.mjs
var mutable = (val) => val;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-attrs/index.mjs
var DEFAULT_EXCLUDE_KEYS = ["class", "style"];
var LISTENER_PREFIX = /^on[A-Z]/;
var useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys } = params;
  const allExcludeKeys = (0, import_vue297.computed)(() => {
    return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
  });
  const instance = (0, import_vue297.getCurrentInstance)();
  if (!instance) {
    debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
    return (0, import_vue297.computed)(() => ({}));
  }
  return (0, import_vue297.computed)(() => {
    var _a2;
    return fromPairs_default(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-common-props/index.mjs
var import_vue300 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/breadcrumb.mjs
var breadcrumbKey = Symbol("breadcrumbKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/button.mjs
var buttonGroupContextKey = Symbol("buttonGroupContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/carousel.mjs
var carouselContextKey = Symbol("carouselContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/checkbox.mjs
var checkboxGroupContextKey = Symbol("checkboxGroupContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/collapse.mjs
var collapseContextKey = Symbol("collapseContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/config-provider.mjs
var configProviderContextKey = Symbol();

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/dialog.mjs
var dialogInjectionKey = Symbol("dialogInjectionKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/form.mjs
var formContextKey = Symbol("formContextKey");
var formItemContextKey = Symbol("formItemContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/pagination.mjs
var elPaginationKey = Symbol("elPaginationKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/radio.mjs
var radioGroupKey = Symbol("radioGroupKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/row.mjs
var rowContextKey = Symbol("rowContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/scrollbar.mjs
var scrollbarContextKey = Symbol("scrollbarContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/slider.mjs
var sliderContextKey = Symbol("sliderContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/tabs.mjs
var tabsRootContextKey = Symbol("tabsRootContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/upload.mjs
var uploadContextKey = Symbol("uploadContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/popper.mjs
var POPPER_INJECTION_KEY = Symbol("popper");
var POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/tooltip.mjs
var TOOLTIP_INJECTION_KEY = Symbol("elTooltip");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/tooltip-v2.mjs
var tooltipV2RootKey = Symbol("tooltipV2");
var tooltipV2ContentKey = Symbol("tooltipV2Content");
var TOOLTIP_V2_OPEN = "tooltip_v2.open";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/tokens/date-picker.mjs
var ROOT_PICKER_INJECTION_KEY = Symbol();

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-prop/index.mjs
var import_vue298 = require("vue");
var useProp = (name) => {
  const vm = (0, import_vue298.getCurrentInstance)();
  return (0, import_vue298.computed)(() => {
    var _a2, _b;
    return (_b = ((_a2 = vm.proxy) == null ? void 0 : _a2.$props)[name]) != null ? _b : void 0;
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-global-config/index.mjs
var import_vue299 = require("vue");
var globalConfig = (0, import_vue299.ref)();
function useGlobalConfig(key, defaultValue = void 0) {
  const config = (0, import_vue299.getCurrentInstance)() ? (0, import_vue299.inject)(configProviderContextKey, globalConfig) : globalConfig;
  if (key) {
    return (0, import_vue299.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
    });
  } else {
    return config;
  }
}
var provideGlobalConfig = (config, app, global2 = false) => {
  var _a2;
  const inSetup = !!(0, import_vue299.getCurrentInstance)();
  const oldConfig = inSetup ? useGlobalConfig() : void 0;
  const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? import_vue299.provide : void 0;
  if (!provideFn) {
    debugWarn("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const context = (0, import_vue299.computed)(() => {
    const cfg = (0, import_vue299.unref)(config);
    if (!(oldConfig == null ? void 0 : oldConfig.value))
      return cfg;
    return mergeConfig(oldConfig.value, cfg);
  });
  provideFn(configProviderContextKey, context);
  if (global2 || !globalConfig.value) {
    globalConfig.value = context.value;
  }
  return context;
};
var mergeConfig = (a3, b3) => {
  var _a2;
  const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a3), ...keysOf(b3)])];
  const obj = {};
  for (const key of keys2) {
    obj[key] = (_a2 = b3[key]) != null ? _a2 : a3[key];
  }
  return obj;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-common-props/index.mjs
var useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});
var useSize = (fallback, ignore = {}) => {
  const emptyRef = (0, import_vue300.ref)(void 0);
  const size2 = ignore.prop ? emptyRef : useProp("size");
  const globalConfig2 = ignore.global ? emptyRef : useGlobalConfig("size");
  const form = ignore.form ? { size: void 0 } : (0, import_vue300.inject)(formContextKey, void 0);
  const formItem = ignore.formItem ? { size: void 0 } : (0, import_vue300.inject)(formItemContextKey, void 0);
  return (0, import_vue300.computed)(() => size2.value || (0, import_vue300.unref)(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
};
var useDisabled = (fallback) => {
  const disabled = useProp("disabled");
  const form = (0, import_vue300.inject)(formContextKey, void 0);
  return (0, import_vue300.computed)(() => disabled.value || (0, import_vue300.unref)(fallback) || (form == null ? void 0 : form.disabled) || false);
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-deprecated/index.mjs
var import_vue301 = require("vue");
var useDeprecated = ({ from, replacement, scope, version: version5, ref: ref162, type: type4 = "API" }, condition) => {
  (0, import_vue301.watch)(() => (0, import_vue301.unref)(condition), (val) => {
    if (val) {
      debugWarn(scope, `[${type4}] ${from} is about to be deprecated in version ${version5}, please use ${replacement} instead.
For more detail, please visit: ${ref162}
`);
    }
  }, {
    immediate: true
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-draggable/index.mjs
var import_vue302 = require("vue");
var useDraggable = (targetRef, dragRef, draggable2) => {
  let transform = {
    offsetX: 0,
    offsetY: 0
  };
  const onMousedown = (e) => {
    const downX = e.clientX;
    const downY = e.clientY;
    const { offsetX, offsetY } = transform;
    const targetRect = targetRef.value.getBoundingClientRect();
    const targetLeft = targetRect.left;
    const targetTop = targetRect.top;
    const targetWidth = targetRect.width;
    const targetHeight = targetRect.height;
    const clientWidth = document.documentElement.clientWidth;
    const clientHeight = document.documentElement.clientHeight;
    const minLeft = -targetLeft + offsetX;
    const minTop = -targetTop + offsetY;
    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
    const maxTop = clientHeight - targetTop - targetHeight + offsetY;
    const onMousemove = (e2) => {
      const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
      const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
      transform = {
        offsetX: moveX,
        offsetY: moveY
      };
      targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
    };
    const onMouseup = () => {
      document.removeEventListener("mousemove", onMousemove);
      document.removeEventListener("mouseup", onMouseup);
    };
    document.addEventListener("mousemove", onMousemove);
    document.addEventListener("mouseup", onMouseup);
  };
  const onDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.addEventListener("mousedown", onMousedown);
    }
  };
  const offDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.removeEventListener("mousedown", onMousedown);
    }
  };
  (0, import_vue302.onMounted)(() => {
    (0, import_vue302.watchEffect)(() => {
      if (draggable2.value) {
        onDraggable();
      } else {
        offDraggable();
      }
    });
  });
  (0, import_vue302.onBeforeUnmount)(() => {
    offDraggable();
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-focus/index.mjs
var useFocus = (el) => {
  return {
    focus: () => {
      var _a2, _b;
      (_b = (_a2 = el.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    }
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-form-item/index.mjs
var import_vue304 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-id/index.mjs
var import_vue303 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-namespace/index.mjs
var defaultNamespace = "el";
var statePrefix = "is-";
var _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;
  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
};
var useNamespace = (block) => {
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const b3 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
  const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
  const m3 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
  const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
  const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
  const is2 = (name, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name && state ? `${statePrefix}${name}` : "";
  };
  const cssVar = (object4) => {
    const styles = {};
    for (const key in object4) {
      if (object4[key]) {
        styles[`--${namespace.value}-${key}`] = object4[key];
      }
    }
    return styles;
  };
  const cssVarBlock = (object4) => {
    const styles = {};
    for (const key in object4) {
      if (object4[key]) {
        styles[`--${namespace.value}-${block}-${key}`] = object4[key];
      }
    }
    return styles;
  };
  const cssVarName = (name) => `--${namespace.value}-${name}`;
  const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
  return {
    namespace,
    b: b3,
    e,
    m: m3,
    be: be2,
    em,
    bm,
    bem,
    is: is2,
    cssVar,
    cssVarName,
    cssVarBlock,
    cssVarBlockName
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-id/index.mjs
var defaultIdInjection = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
};
var ID_INJECTION_KEY = Symbol("elIdInjection");
var useIdInjection = () => {
  return (0, import_vue303.getCurrentInstance)() ? (0, import_vue303.inject)(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
};
var useId = (deterministicId) => {
  const idInjection = useIdInjection();
  if (!isClient && idInjection === defaultIdInjection) {
    debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  }
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const idRef = (0, import_vue303.computed)(() => (0, import_vue303.unref)(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
  return idRef;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-form-item/index.mjs
var useFormItem = () => {
  const form = (0, import_vue304.inject)(formContextKey, void 0);
  const formItem = (0, import_vue304.inject)(formItemContextKey, void 0);
  return {
    form,
    formItem
  };
};
var useFormItemInputId = (props, {
  formItemContext,
  disableIdGeneration,
  disableIdManagement
}) => {
  if (!disableIdGeneration) {
    disableIdGeneration = (0, import_vue304.ref)(false);
  }
  if (!disableIdManagement) {
    disableIdManagement = (0, import_vue304.ref)(false);
  }
  const inputId = (0, import_vue304.ref)();
  let idUnwatch = void 0;
  const isLabeledByFormItem = (0, import_vue304.computed)(() => {
    var _a2;
    return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
  });
  (0, import_vue304.onMounted)(() => {
    idUnwatch = (0, import_vue304.watch)([(0, import_vue304.toRef)(props, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
      const newId = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
      if (newId !== inputId.value) {
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
          if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
            formItemContext.addInputId(newId);
          }
        }
        inputId.value = newId;
      }
    }, { immediate: true });
  });
  (0, import_vue304.onUnmounted)(() => {
    idUnwatch && idUnwatch();
    if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
      inputId.value && formItemContext.removeInputId(inputId.value);
    }
  });
  return {
    isLabeledByFormItem,
    inputId
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-locale/index.mjs
var import_vue305 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/locale/lang/en.mjs
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-locale/index.mjs
var buildTranslator = (locale) => (path, option2) => translate(path, option2, (0, import_vue305.unref)(locale));
var translate = (path, option2, locale) => get_default(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
  var _a2;
  return `${(_a2 = option2 == null ? void 0 : option2[key]) != null ? _a2 : `{${key}}`}`;
});
var buildLocaleContext = (locale) => {
  const lang = (0, import_vue305.computed)(() => (0, import_vue305.unref)(locale).name);
  const localeRef = (0, import_vue305.isRef)(locale) ? locale : (0, import_vue305.ref)(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale)
  };
};
var useLocale = () => {
  const locale = useGlobalConfig("locale");
  return buildLocaleContext((0, import_vue305.computed)(() => locale.value || English));
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-lockscreen/index.mjs
var import_vue306 = require("vue");
var import_reactivity = require("@vue/reactivity");
var useLockscreen = (trigger) => {
  if (!(0, import_vue306.isRef)(trigger)) {
    throwError("[useLockscreen]", "You need to pass a ref param to this function");
  }
  const ns2 = useNamespace("popup");
  const hiddenCls = (0, import_reactivity.computed)(() => ns2.bm("parent", "hidden"));
  if (!isClient || hasClass(document.body, hiddenCls.value)) {
    return;
  }
  let scrollBarWidth2 = 0;
  let withoutHiddenClass = false;
  let bodyWidth = "0";
  const cleanup = () => {
    setTimeout(() => {
      removeClass(document.body, hiddenCls.value);
      if (withoutHiddenClass) {
        document.body.style.width = bodyWidth;
      }
    }, 200);
  };
  (0, import_vue306.watch)(trigger, (val) => {
    if (!val) {
      cleanup();
      return;
    }
    withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
    if (withoutHiddenClass) {
      bodyWidth = document.body.style.width;
    }
    scrollBarWidth2 = getScrollBarWidth(ns2.namespace.value);
    const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
    const bodyOverflowY = getStyle(document.body, "overflowY");
    if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
      document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
    }
    addClass(document.body, hiddenCls.value);
  });
  (0, import_vue306.onScopeDispose)(() => cleanup());
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-model-toggle/index.mjs
var import_vue307 = require("vue");
var import_shared13 = require("@vue/shared");
var _prop = buildProp({
  type: definePropType(Boolean),
  default: null
});
var _event = buildProp({
  type: definePropType(Function)
});
var createModelToggleComposable = (name) => {
  const updateEventKey = `update:${name}`;
  const updateEventKeyRaw2 = `onUpdate:${name}`;
  const useModelToggleEmits2 = [updateEventKey];
  const useModelToggleProps2 = {
    [name]: _prop,
    [updateEventKeyRaw2]: _event
  };
  const useModelToggle2 = ({
    indicator,
    toggleReason,
    shouldHideWhenRouteChanges,
    shouldProceed,
    onShow,
    onHide
  }) => {
    const instance = (0, import_vue307.getCurrentInstance)();
    const { emit } = instance;
    const props = instance.props;
    const hasUpdateHandler = (0, import_vue307.computed)(() => (0, import_shared13.isFunction)(props[updateEventKeyRaw2]));
    const isModelBindingAbsent = (0, import_vue307.computed)(() => props[name] === null);
    const doShow = (event) => {
      if (indicator.value === true) {
        return;
      }
      indicator.value = true;
      if (toggleReason) {
        toggleReason.value = event;
      }
      if ((0, import_shared13.isFunction)(onShow)) {
        onShow(event);
      }
    };
    const doHide = (event) => {
      if (indicator.value === false) {
        return;
      }
      indicator.value = false;
      if (toggleReason) {
        toggleReason.value = event;
      }
      if ((0, import_shared13.isFunction)(onHide)) {
        onHide(event);
      }
    };
    const show = (event) => {
      if (props.disabled === true || (0, import_shared13.isFunction)(shouldProceed) && !shouldProceed())
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, true);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doShow(event);
      }
    };
    const hide2 = (event) => {
      if (props.disabled === true || !isClient)
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, false);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doHide(event);
      }
    };
    const onChange = (val) => {
      if (!isBoolean(val))
        return;
      if (props.disabled && val) {
        if (hasUpdateHandler.value) {
          emit(updateEventKey, false);
        }
      } else if (indicator.value !== val) {
        if (val) {
          doShow();
        } else {
          doHide();
        }
      }
    };
    const toggle = () => {
      if (indicator.value) {
        hide2();
      } else {
        show();
      }
    };
    (0, import_vue307.watch)(() => props[name], onChange);
    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
      (0, import_vue307.watch)(() => ({
        ...instance.proxy.$route
      }), () => {
        if (shouldHideWhenRouteChanges.value && indicator.value) {
          hide2();
        }
      });
    }
    (0, import_vue307.onMounted)(() => {
      onChange(props[name]);
    });
    return {
      hide: hide2,
      show,
      toggle,
      hasUpdateHandler
    };
  };
  return {
    useModelToggle: useModelToggle2,
    useModelToggleProps: useModelToggleProps2,
    useModelToggleEmits: useModelToggleEmits2
  };
};
var { useModelToggle, useModelToggleProps, useModelToggleEmits } = createModelToggleComposable("modelValue");

// ../../node_modules/.pnpm/@sxzz+popperjs-es@2.11.7/node_modules/@sxzz/popperjs-es/dist/index.mjs
var E = "top";
var R = "bottom";
var W = "right";
var P = "left";
var me = "auto";
var G = [E, R, W, P];
var U = "start";
var J = "end";
var Xe = "clippingParents";
var je = "viewport";
var K2 = "popper";
var Ye = "reference";
var De = G.reduce(function(t, e) {
  return t.concat([e + "-" + U, e + "-" + J]);
}, []);
var Ee = [].concat(G, [me]).reduce(function(t, e) {
  return t.concat([e, e + "-" + U, e + "-" + J]);
}, []);
var Ge = "beforeRead";
var Je = "read";
var Ke = "afterRead";
var Qe = "beforeMain";
var Ze = "main";
var et = "afterMain";
var tt = "beforeWrite";
var nt = "write";
var rt = "afterWrite";
var ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
function C(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function H(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Q(t) {
  var e = H(t).Element;
  return t instanceof e || t instanceof Element;
}
function B(t) {
  var e = H(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Pe(t) {
  if (typeof ShadowRoot == "undefined")
    return false;
  var e = H(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function Mt(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
    !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a3) {
      var s2 = o2[a3];
      s2 === false ? i.removeAttribute(a3) : i.setAttribute(a3, s2 === true ? "" : s2);
    }));
  });
}
function Rt(t) {
  var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var o2 = e.elements[r], i = e.attributes[r] || {}, a3 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a3.reduce(function(f2, c2) {
        return f2[c2] = "", f2;
      }, {});
      !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
        o2.removeAttribute(f2);
      }));
    });
  };
}
var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
function q(t) {
  return t.split("-")[0];
}
var X = Math.max;
var ve = Math.min;
var Z = Math.round;
function ee(t, e) {
  e === void 0 && (e = false);
  var n = t.getBoundingClientRect(), r = 1, o2 = 1;
  if (B(t) && e) {
    var i = t.offsetHeight, a3 = t.offsetWidth;
    a3 > 0 && (r = Z(n.width) / a3 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
  }
  return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
}
function ke(t) {
  var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
}
function it(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return true;
  if (n && Pe(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return true;
      r = r.parentNode || r.host;
    } while (r);
  }
  return false;
}
function N(t) {
  return H(t).getComputedStyle(t);
}
function Wt(t) {
  return ["table", "td", "th"].indexOf(C(t)) >= 0;
}
function I2(t) {
  return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function ge(t) {
  return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I2(t);
}
function at(t) {
  return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
}
function Bt(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && B(t)) {
    var r = N(t);
    if (r.position === "fixed")
      return null;
  }
  var o2 = ge(t);
  for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
    var i = N(o2);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
      return o2;
    o2 = o2.parentNode;
  }
  return null;
}
function se(t) {
  for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; )
    n = at(n);
  return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
}
function Le(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function fe(t, e, n) {
  return X(t, ve(e, n));
}
function St(t, e, n) {
  var r = fe(t, e, n);
  return r > n ? n : r;
}
function st() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function ft(t) {
  return Object.assign({}, st(), t);
}
function ct(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var Tt = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
};
function Ht(t) {
  var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a3 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
  if (!(!i || !a3)) {
    var m3 = Tt(o2.padding, n), v3 = ke(i), l2 = f2 === "y" ? E : P, h29 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a3[f2] - n.rects.popper[u2], g = a3[f2] - n.rects.reference[f2], x3 = se(i), y2 = x3 ? f2 === "y" ? x3.clientHeight || 0 : x3.clientWidth || 0 : 0, $2 = p2 / 2 - g / 2, d2 = m3[l2], b3 = y2 - v3[u2] - m3[h29], w3 = y2 / 2 - v3[u2] / 2 + $2, O3 = fe(d2, w3, b3), j = f2;
    n.modifiersData[r] = (e = {}, e[j] = O3, e.centerOffset = O3 - w3, e);
  }
}
function Ct(t) {
  var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
  o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
}
var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function te(t) {
  return t.split("-")[1];
}
var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function Vt(t) {
  var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
  return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
}
function ut(t) {
  var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a3 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m3 = t.isFixed, v3 = a3.x, l2 = v3 === void 0 ? 0 : v3, h29 = a3.y, p2 = h29 === void 0 ? 0 : h29, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
  l2 = g.x, p2 = g.y;
  var x3 = a3.hasOwnProperty("x"), y2 = a3.hasOwnProperty("y"), $2 = P, d2 = E, b3 = window;
  if (c2) {
    var w3 = se(n), O3 = "clientHeight", j = "clientWidth";
    if (w3 === H(n) && (w3 = I2(n), N(w3).position !== "static" && s2 === "absolute" && (O3 = "scrollHeight", j = "scrollWidth")), w3 = w3, o2 === E || (o2 === P || o2 === W) && i === J) {
      d2 = R;
      var A3 = m3 && w3 === b3 && b3.visualViewport ? b3.visualViewport.height : w3[O3];
      p2 -= A3 - r.height, p2 *= f2 ? 1 : -1;
    }
    if (o2 === P || (o2 === E || o2 === R) && i === J) {
      $2 = W;
      var k2 = m3 && w3 === b3 && b3.visualViewport ? b3.visualViewport.width : w3[j];
      l2 -= k2 - r.width, l2 *= f2 ? 1 : -1;
    }
  }
  var D3 = Object.assign({ position: s2 }, c2 && qt), S3 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
  if (l2 = S3.x, p2 = S3.y, f2) {
    var L2;
    return Object.assign({}, D3, (L2 = {}, L2[d2] = y2 ? "0" : "", L2[$2] = x3 ? "0" : "", L2.transform = (b3.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L2));
  }
  return Object.assign({}, D3, (e = {}, e[d2] = y2 ? p2 + "px" : "", e[$2] = x3 ? l2 + "px" : "", e.transform = "", e));
}
function Nt(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a3 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a3, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} };
var ye = { passive: true };
function It(t) {
  var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a3 = r.resize, s2 = a3 === void 0 ? true : a3, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c2.forEach(function(u2) {
    u2.addEventListener("scroll", n.update, ye);
  }), s2 && f2.addEventListener("resize", n.update, ye), function() {
    i && c2.forEach(function(u2) {
      u2.removeEventListener("scroll", n.update, ye);
    }), s2 && f2.removeEventListener("resize", n.update, ye);
  };
}
var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
}, effect: It, data: {} };
var _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
function be(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return _t[e];
  });
}
var zt = { start: "end", end: "start" };
function lt(t) {
  return t.replace(/start|end/g, function(e) {
    return zt[e];
  });
}
function We(t) {
  var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function Be(t) {
  return ee(I2(t)).left + We(t).scrollLeft;
}
function Ft(t) {
  var e = H(t), n = I2(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a3 = 0, s2 = 0;
  return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a3 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a3 + Be(t), y: s2 };
}
function Ut(t) {
  var e, n = I2(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a3 = X(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
  return N(o2 || n).direction === "rtl" && (s2 += X(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a3, x: s2, y: f2 };
}
function Se(t) {
  var e = N(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o2 + r);
}
function dt(t) {
  return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
}
function ce(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a3 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a3);
  return o2 ? s2 : s2.concat(ce(ge(a3)));
}
function Te(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function Xt(t) {
  var e = ee(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function ht(t, e) {
  return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I2(t)));
}
function Yt(t) {
  var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
  return Q(r) ? e.filter(function(o2) {
    return Q(o2) && it(o2, r) && C(o2) !== "body";
  }) : [];
}
function Gt(t, e, n) {
  var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a3 = o2.reduce(function(s2, f2) {
    var c2 = ht(t, f2);
    return s2.top = X(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X(c2.left, s2.left), s2;
  }, ht(t, i));
  return a3.width = a3.right - a3.left, a3.height = a3.bottom - a3.top, a3.x = a3.left, a3.y = a3.top, a3;
}
function mt(t) {
  var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a3 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
  switch (o2) {
    case E:
      f2 = { x: a3, y: e.y - n.height };
      break;
    case R:
      f2 = { x: a3, y: e.y + e.height };
      break;
    case W:
      f2 = { x: e.x + e.width, y: s2 };
      break;
    case P:
      f2 = { x: e.x - n.width, y: s2 };
      break;
    default:
      f2 = { x: e.x, y: e.y };
  }
  var c2 = o2 ? Le(o2) : null;
  if (c2 != null) {
    var u2 = c2 === "y" ? "height" : "width";
    switch (i) {
      case U:
        f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
        break;
      case J:
        f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
        break;
    }
  }
  return f2;
}
function ne2(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a3 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K2 : c2, m3 = n.altBoundary, v3 = m3 === void 0 ? false : m3, l2 = n.padding, h29 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h29 != "number" ? h29 : ct(h29, G)), g = u2 === K2 ? Ye : K2, x3 = t.rects.popper, y2 = t.elements[v3 ? g : u2], $2 = Gt(Q(y2) ? y2 : y2.contextElement || I2(t.elements.popper), a3, f2), d2 = ee(t.elements.reference), b3 = mt({ reference: d2, element: x3, strategy: "absolute", placement: o2 }), w3 = Te(Object.assign({}, x3, b3)), O3 = u2 === K2 ? w3 : d2, j = { top: $2.top - O3.top + p2.top, bottom: O3.bottom - $2.bottom + p2.bottom, left: $2.left - O3.left + p2.left, right: O3.right - $2.right + p2.right }, A3 = t.modifiersData.offset;
  if (u2 === K2 && A3) {
    var k2 = A3[o2];
    Object.keys(j).forEach(function(D3) {
      var S3 = [W, R].indexOf(D3) >= 0 ? 1 : -1, L2 = [E, R].indexOf(D3) >= 0 ? "y" : "x";
      j[D3] += k2[L2] * S3;
    });
  }
  return j;
}
function Jt(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a3 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m3 = u2 ? s2 ? De : De.filter(function(h29) {
    return te(h29) === u2;
  }) : G, v3 = m3.filter(function(h29) {
    return c2.indexOf(h29) >= 0;
  });
  v3.length === 0 && (v3 = m3);
  var l2 = v3.reduce(function(h29, p2) {
    return h29[p2] = ne2(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a3 })[q(p2)], h29;
  }, {});
  return Object.keys(l2).sort(function(h29, p2) {
    return l2[h29] - l2[p2];
  });
}
function Kt(t) {
  if (q(t) === me)
    return [];
  var e = be(t);
  return [lt(t), e, lt(e)];
}
function Qt(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a3 = n.altAxis, s2 = a3 === void 0 ? true : a3, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m3 = n.rootBoundary, v3 = n.altBoundary, l2 = n.flipVariations, h29 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x3 = q(g), y2 = x3 === g, $2 = f2 || (y2 || !h29 ? [be(g)] : Kt(g)), d2 = [g].concat($2).reduce(function(z2, V) {
      return z2.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m3, padding: c2, flipVariations: h29, allowedAutoPlacements: p2 }) : V);
    }, []), b3 = e.rects.reference, w3 = e.rects.popper, O3 = /* @__PURE__ */ new Map(), j = true, A3 = d2[0], k2 = 0; k2 < d2.length; k2++) {
      var D3 = d2[k2], S3 = q(D3), L2 = te(D3) === U, re = [E, R].indexOf(S3) >= 0, oe = re ? "width" : "height", M3 = ne2(e, { placement: D3, boundary: u2, rootBoundary: m3, altBoundary: v3, padding: c2 }), T3 = re ? L2 ? W : P : L2 ? R : E;
      b3[oe] > w3[oe] && (T3 = be(T3));
      var pe = be(T3), _2 = [];
      if (i && _2.push(M3[S3] <= 0), s2 && _2.push(M3[T3] <= 0, M3[pe] <= 0), _2.every(function(z2) {
        return z2;
      })) {
        A3 = D3, j = false;
        break;
      }
      O3.set(D3, _2);
    }
    if (j)
      for (var ue = h29 ? 3 : 1, xe = function(z2) {
        var V = d2.find(function(de) {
          var ae = O3.get(de);
          if (ae)
            return ae.slice(0, z2).every(function(Y3) {
              return Y3;
            });
        });
        if (V)
          return A3 = V, "break";
      }, ie = ue; ie > 0; ie--) {
        var le = xe(ie);
        if (le === "break")
          break;
      }
    e.placement !== A3 && (e.modifiersData[r]._skip = true, e.placement = A3, e.reset = true);
  }
}
var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
function gt(t, e, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
}
function yt(t) {
  return [E, W, R, P].some(function(e) {
    return t[e] >= 0;
  });
}
function Zt(t) {
  var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a3 = ne2(e, { elementContext: "reference" }), s2 = ne2(e, { altBoundary: true }), f2 = gt(a3, r), c2 = gt(s2, o2, i), u2 = yt(f2), m3 = yt(c2);
  e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m3 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m3 });
}
var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
function en(t, e, n) {
  var r = q(t), o2 = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a3 = i[0], s2 = i[1];
  return a3 = a3 || 0, s2 = (s2 || 0) * o2, [P, W].indexOf(r) >= 0 ? { x: s2, y: a3 } : { x: a3, y: s2 };
}
function tn(t) {
  var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a3 = Ee.reduce(function(u2, m3) {
    return u2[m3] = en(m3, e.rects, i), u2;
  }, {}), s2 = a3[e.placement], f2 = s2.x, c2 = s2.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a3;
}
var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
function nn(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
function rn(t) {
  return t === "x" ? "y" : "x";
}
function on(t) {
  var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a3 = n.altAxis, s2 = a3 === void 0 ? false : a3, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m3 = n.padding, v3 = n.tether, l2 = v3 === void 0 ? true : v3, h29 = n.tetherOffset, p2 = h29 === void 0 ? 0 : h29, g = ne2(e, { boundary: f2, rootBoundary: c2, padding: m3, altBoundary: u2 }), x3 = q(e.placement), y2 = te(e.placement), $2 = !y2, d2 = Le(x3), b3 = rn(d2), w3 = e.modifiersData.popperOffsets, O3 = e.rects.reference, j = e.rects.popper, A3 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k2 = typeof A3 == "number" ? { mainAxis: A3, altAxis: A3 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A3), D3 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S3 = { x: 0, y: 0 };
  if (w3) {
    if (i) {
      var L2, re = d2 === "y" ? E : P, oe = d2 === "y" ? R : W, M3 = d2 === "y" ? "height" : "width", T3 = w3[d2], pe = T3 + g[re], _2 = T3 - g[oe], ue = l2 ? -j[M3] / 2 : 0, xe = y2 === U ? O3[M3] : j[M3], ie = y2 === U ? -j[M3] : -O3[M3], le = e.elements.arrow, z2 = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y3 = fe(0, O3[M3], z2[M3]), jt = $2 ? O3[M3] / 2 - ue - Y3 - de - k2.mainAxis : xe - Y3 - de - k2.mainAxis, Dt = $2 ? -O3[M3] / 2 + ue + Y3 + ae + k2.mainAxis : ie + Y3 + ae + k2.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L2 = D3 == null ? void 0 : D3[d2]) != null ? L2 : 0, Pt = T3 + jt - Ce - Et, At = T3 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T3, l2 ? X(_2, At) : _2);
      w3[d2] = qe, S3[d2] = qe - T3;
    }
    if (s2) {
      var Ve, kt = d2 === "x" ? E : P, Lt = d2 === "x" ? R : W, F2 = w3[b3], he = b3 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E, P].indexOf(x3) !== -1, _e = (Ve = D3 == null ? void 0 : D3[b3]) != null ? Ve : 0, ze = $e ? Ne : F2 - O3[he] - j[he] - _e + k2.altAxis, Fe = $e ? F2 + O3[he] + j[he] - _e - k2.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
      w3[b3] = Ue, S3[b3] = Ue - F2;
    }
    e.modifiersData[r] = S3;
  }
}
var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
function an(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function sn(t) {
  return t === H(t) || !B(t) ? We(t) : an(t);
}
function fn(t) {
  var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function cn(t, e, n) {
  n === void 0 && (n = false);
  var r = B(e), o2 = B(e) && fn(e), i = I2(e), a3 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
  return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a3.left + s2.scrollLeft - f2.x, y: a3.top + s2.scrollTop - f2.y, width: a3.width, height: a3.height };
}
function pn(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(i) {
    e.set(i.name, i);
  });
  function o2(i) {
    n.add(i.name);
    var a3 = [].concat(i.requires || [], i.requiresIfExists || []);
    a3.forEach(function(s2) {
      if (!n.has(s2)) {
        var f2 = e.get(s2);
        f2 && o2(f2);
      }
    }), r.push(i);
  }
  return t.forEach(function(i) {
    n.has(i.name) || o2(i);
  }), r;
}
function un(t) {
  var e = pn(t);
  return ot.reduce(function(n, r) {
    return n.concat(e.filter(function(o2) {
      return o2.phase === r;
    }));
  }, []);
}
function ln(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function dn(t) {
  var e = t.reduce(function(n, r) {
    var o2 = n[r.name];
    return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
function $t() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function we(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
  return function(a3, s2, f2) {
    f2 === void 0 && (f2 = i);
    var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a3, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m3 = false, v3 = { state: c2, setOptions: function(p2) {
      var g = typeof p2 == "function" ? p2(c2.options) : p2;
      h29(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a3) ? ce(a3) : a3.contextElement ? ce(a3.contextElement) : [], popper: ce(s2) };
      var x3 = un(dn([].concat(r, c2.options.modifiers)));
      return c2.orderedModifiers = x3.filter(function(y2) {
        return y2.enabled;
      }), l2(), v3.update();
    }, forceUpdate: function() {
      if (!m3) {
        var p2 = c2.elements, g = p2.reference, x3 = p2.popper;
        if ($t(g, x3)) {
          c2.rects = { reference: cn(g, se(x3), c2.options.strategy === "fixed"), popper: ke(x3) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
            return c2.modifiersData[j.name] = Object.assign({}, j.data);
          });
          for (var y2 = 0; y2 < c2.orderedModifiers.length; y2++) {
            if (c2.reset === true) {
              c2.reset = false, y2 = -1;
              continue;
            }
            var $2 = c2.orderedModifiers[y2], d2 = $2.fn, b3 = $2.options, w3 = b3 === void 0 ? {} : b3, O3 = $2.name;
            typeof d2 == "function" && (c2 = d2({ state: c2, options: w3, name: O3, instance: v3 }) || c2);
          }
        }
      }
    }, update: ln(function() {
      return new Promise(function(p2) {
        v3.forceUpdate(), p2(c2);
      });
    }), destroy: function() {
      h29(), m3 = true;
    } };
    if (!$t(a3, s2))
      return v3;
    v3.setOptions(f2).then(function(p2) {
      !m3 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
    });
    function l2() {
      c2.orderedModifiers.forEach(function(p2) {
        var g = p2.name, x3 = p2.options, y2 = x3 === void 0 ? {} : x3, $2 = p2.effect;
        if (typeof $2 == "function") {
          var d2 = $2({ state: c2, name: g, instance: v3, options: y2 }), b3 = function() {
          };
          u2.push(d2 || b3);
        }
      });
    }
    function h29() {
      u2.forEach(function(p2) {
        return p2();
      }), u2 = [];
    }
    return v3;
  };
}
var hn = we();
var mn = [Re, He, Me, Ae];
var vn = we({ defaultModifiers: mn });
var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt];
var yn = we({ defaultModifiers: gn });

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-restore-active/index.mjs
var import_vue308 = require("vue");
var useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  (0, import_vue308.watch)(() => toggle.value, (val) => {
    var _a2, _b;
    if (val) {
      previousActive = document.activeElement;
      if ((0, import_vue308.isRef)(initialFocus)) {
        (_b = (_a2 = initialFocus.value).focus) == null ? void 0 : _b.call(_a2);
      }
    } else {
      if (process.env.NODE_ENV === "test") {
        previousActive.focus.call(previousActive);
      } else {
        previousActive.focus();
      }
    }
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-same-target/index.mjs
var import_shared14 = require("@vue/shared");
var useSameTarget = (handleClick) => {
  if (!handleClick) {
    return { onClick: import_shared14.NOOP, onMousedown: import_shared14.NOOP, onMouseup: import_shared14.NOOP };
  }
  let mousedownTarget = false;
  let mouseupTarget = false;
  const onClick = (e) => {
    if (mousedownTarget && mouseupTarget) {
      handleClick(e);
    }
    mousedownTarget = mouseupTarget = false;
  };
  const onMousedown = (e) => {
    mousedownTarget = e.target === e.currentTarget;
  };
  const onMouseup = (e) => {
    mouseupTarget = e.target === e.currentTarget;
  };
  return { onClick, onMousedown, onMouseup };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-throttle-render/index.mjs
var import_vue309 = require("vue");
var useThrottleRender = (loading, throttle3 = 0) => {
  if (throttle3 === 0)
    return loading;
  const throttled = (0, import_vue309.ref)(false);
  let timeoutHandle = 0;
  const dispatchThrottling = () => {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      throttled.value = loading.value;
    }, throttle3);
  };
  (0, import_vue309.onMounted)(dispatchThrottling);
  (0, import_vue309.watch)(() => loading.value, (val) => {
    if (val) {
      dispatchThrottling();
    } else {
      throttled.value = val;
    }
  });
  return throttled;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-timeout/index.mjs
function useTimeout() {
  let timeoutHandle;
  const registerTimeout = (fn2, delay) => {
    cancelTimeout();
    timeoutHandle = window.setTimeout(fn2, delay);
  };
  const cancelTimeout = () => window.clearTimeout(timeoutHandle);
  tryOnScopeDispose(() => cancelTimeout());
  return {
    registerTimeout,
    cancelTimeout
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-escape-keydown/index.mjs
var import_vue310 = require("vue");
var registeredEscapeHandlers = [];
var cachedHandler = (e) => {
  const event = e;
  if (event.key === EVENT_CODE.esc) {
    registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
  }
};
var useEscapeKeydown = (handler) => {
  (0, import_vue310.onMounted)(() => {
    if (registeredEscapeHandlers.length === 0) {
      document.addEventListener("keydown", cachedHandler);
    }
    if (isClient)
      registeredEscapeHandlers.push(handler);
  });
  (0, import_vue310.onBeforeUnmount)(() => {
    registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
    if (registeredEscapeHandlers.length === 0) {
      if (isClient)
        document.removeEventListener("keydown", cachedHandler);
    }
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-popper-container/index.mjs
var import_vue311 = require("vue");
var cachedContainer;
var usePopperContainerId = () => {
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const idInjection = useIdInjection();
  const id2 = (0, import_vue311.computed)(() => {
    return `${namespace.value}-popper-container-${idInjection.prefix}`;
  });
  const selector = (0, import_vue311.computed)(() => `#${id2.value}`);
  return {
    id: id2,
    selector
  };
};
var createContainer = (id2) => {
  const container = document.createElement("div");
  container.id = id2;
  document.body.appendChild(container);
  return container;
};
var usePopperContainer = () => {
  (0, import_vue311.onBeforeMount)(() => {
    if (!isClient)
      return;
    const { id: id2, selector } = usePopperContainerId();
    if (process.env.NODE_ENV === "test" || !cachedContainer && !document.body.querySelector(selector.value)) {
      cachedContainer = createContainer(id2.value);
    }
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-delayed-toggle/index.mjs
var import_vue312 = require("vue");
var useDelayedToggleProps = buildProps({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  }
});
var useDelayedToggle = ({
  showAfter,
  hideAfter,
  open,
  close: close2
}) => {
  const { registerTimeout } = useTimeout();
  const onOpen = (event) => {
    registerTimeout(() => {
      open(event);
    }, (0, import_vue312.unref)(showAfter));
  };
  const onClose = (event) => {
    registerTimeout(() => {
      close2(event);
    }, (0, import_vue312.unref)(hideAfter));
  };
  return {
    onOpen,
    onClose
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-forward-ref/index.mjs
var import_vue313 = require("vue");
var FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
var useForwardRef = (forwardRef) => {
  const setForwardRef = (el) => {
    forwardRef.value = el;
  };
  (0, import_vue313.provide)(FORWARD_REF_INJECTION_KEY, {
    setForwardRef
  });
};
var useForwardRefDirective = (setForwardRef) => {
  return {
    mounted(el) {
      setForwardRef(el);
    },
    updated(el) {
      setForwardRef(el);
    },
    unmounted() {
      setForwardRef(null);
    }
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-z-index/index.mjs
var import_vue314 = require("vue");
var zIndex = (0, import_vue314.ref)(0);
var useZIndex = () => {
  const initialZIndex = useGlobalConfig("zIndex", 2e3);
  const currentZIndex = (0, import_vue314.computed)(() => initialZIndex.value + zIndex.value);
  const nextZIndex = () => {
    zIndex.value++;
    return currentZIndex.value;
  };
  return {
    initialZIndex,
    currentZIndex,
    nextZIndex
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-floating/index.mjs
var import_vue315 = require("vue");

// ../../node_modules/.pnpm/@floating-ui+core@1.1.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  if (process.env.NODE_ENV !== "production") {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (validMiddleware.filter((_ref) => {
      let {
        name
      } = _ref;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    }
    if (!reference || !floating) {
      console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x3,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x3,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x3 = nextX != null ? nextX : x3;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (process.env.NODE_ENV !== "production") {
      if (resetCount > 50) {
        console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" "));
      }
    }
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x3,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x: x3,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x: x3,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      if (process.env.NODE_ENV !== "production") {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x: x3,
      y: y2
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min4 = paddingObject[minProp];
    const max4 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min4, center, max4);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min4 ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min4 ? min4 - center : max4 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = middlewareArguments;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x: x3,
        y: y2
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x3 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

// ../../node_modules/.pnpm/@floating-ui+dom@1.1.0/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "";
}
var uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
    return uaString;
  }
  return navigator.userAgent;
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement2(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox2 = /firefox/i.test(getUAString());
  const css2 = getComputedStyle$1(element);
  const backdropFilter = css2.backdropFilter || css2.WebkitBackdropFilter;
  return css2.transform !== "none" || css2.perspective !== "none" || (backdropFilter ? backdropFilter !== "none" : false) || isFirefox2 && css2.willChange === "filter" || isFirefox2 && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective"].some((value) => css2.willChange.includes(value)) || ["paint", "layout", "strict", "content"].some(
    // TS 4.1 compat
    (value) => {
      const contain = css2.contain;
      return contain != null ? contain.includes(value) : false;
    }
  );
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width);
  let height = parseFloat(css2.height);
  const offsetWidth = element.offsetWidth;
  const offsetHeight = element.offsetHeight;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
var FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x3 = (fallback ? round(rect.width) : rect.width) / width;
  let y2 = (fallback ? round(rect.height) : rect.height) / height;
  if (!x3 || !Number.isFinite(x3)) {
    x3 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x3,
    y: y2
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow(domElement) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  let x3 = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y2 = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win2 = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win2.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win2) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x3 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x3 += iframeRect.x;
      y2 += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return {
    width,
    height,
    top: y2,
    right: x3 + width,
    bottom: y2 + height,
    left: x3,
    x: x3,
    y: y2
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === "fixed", offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node
    node.assignedSlot || // DOM Element detected
    node.parentNode || // ShadowRoot detected
    (isShadowRoot(node) ? node.host : null) || // Fallback
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x3 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x3 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x3 += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x3 = left2 * scale.x;
  const y2 = top * scale.y;
  return {
    top: y2,
    left: x3,
    right: x3 + width,
    bottom: y2 + height,
    x: x3,
    y: y2,
    width,
    height
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  if (clippingAncestor === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement2(clippingAncestor)) {
    return getInnerBoundingClientRect(clippingAncestor, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement: isElement2,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...await getDimensionsFn(floating)
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-floating/index.mjs
var useFloatingProps = buildProps({});
var unrefReference = (elRef) => {
  if (!isClient)
    return;
  if (!elRef)
    return elRef;
  const unrefEl = unrefElement(elRef);
  if (unrefEl)
    return unrefEl;
  return (0, import_vue315.isRef)(elRef) ? unrefEl : elRef;
};
var useFloating = ({
  middleware,
  placement,
  strategy
}) => {
  const referenceRef = (0, import_vue315.ref)();
  const contentRef = (0, import_vue315.ref)();
  const x3 = (0, import_vue315.ref)();
  const y2 = (0, import_vue315.ref)();
  const middlewareData = (0, import_vue315.ref)({});
  const states = {
    x: x3,
    y: y2,
    placement,
    strategy,
    middlewareData
  };
  const update = async () => {
    if (!isClient)
      return;
    const referenceEl = unrefReference(referenceRef);
    const contentEl = unrefElement(contentRef);
    if (!referenceEl || !contentEl)
      return;
    const data = await computePosition2(referenceEl, contentEl, {
      placement: (0, import_vue315.unref)(placement),
      strategy: (0, import_vue315.unref)(strategy),
      middleware: (0, import_vue315.unref)(middleware)
    });
    keysOf(states).forEach((key) => {
      states[key].value = data[key];
    });
  };
  (0, import_vue315.onMounted)(() => {
    (0, import_vue315.watchEffect)(() => {
      update();
    });
  });
  return {
    ...states,
    update,
    referenceRef,
    contentRef
  };
};
var arrowMiddleware = ({
  arrowRef,
  padding
}) => {
  return {
    name: "arrow",
    options: {
      element: arrowRef,
      padding
    },
    fn(args) {
      const arrowEl = (0, import_vue315.unref)(arrowRef);
      if (!arrowEl)
        return {};
      return arrow({
        element: arrowEl,
        padding
      }).fn(args);
    }
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-cursor/index.mjs
var import_vue316 = require("vue");
function useCursor(input) {
  const selectionRef = (0, import_vue316.ref)();
  function recordCursor() {
    if (input.value == void 0)
      return;
    const { selectionStart, selectionEnd, value } = input.value;
    if (selectionStart == null || selectionEnd == null)
      return;
    const beforeTxt = value.slice(0, Math.max(0, selectionStart));
    const afterTxt = value.slice(Math.max(0, selectionEnd));
    selectionRef.value = {
      selectionStart,
      selectionEnd,
      value,
      beforeTxt,
      afterTxt
    };
  }
  function setCursor() {
    if (input.value == void 0 || selectionRef.value == void 0)
      return;
    const { value } = input.value;
    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
    if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
      return;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else {
      const beforeLastChar = beforeTxt[selectionStart - 1];
      const newIndex2 = value.indexOf(beforeLastChar, selectionStart - 1);
      if (newIndex2 !== -1) {
        startPos = newIndex2 + 1;
      }
    }
    input.value.setSelectionRange(startPos, startPos);
  }
  return [recordCursor, setCursor];
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/hooks/use-ordered-children/index.mjs
var import_vue317 = require("vue");
var getOrderedChildren = (vm, childComponentName, children) => {
  const nodes = flattedChildren(vm.subTree).filter((n) => {
    var _a2;
    return (0, import_vue317.isVNode)(n) && ((_a2 = n.type) == null ? void 0 : _a2.name) === childComponentName && !!n.component;
  });
  const uids = nodes.map((n) => n.component.uid);
  return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
};
var useOrderedChildren = (vm, childComponentName) => {
  const children = {};
  const orderedChildren = (0, import_vue317.shallowRef)([]);
  const addChild = (child) => {
    children[child.uid] = child;
    orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
  };
  const removeChild = (uid2) => {
    delete children[uid2];
    orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid2);
  };
  return {
    children: orderedChildren,
    addChild,
    removeChild
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/version.mjs
var version2 = "2.2.28";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/make-installer.mjs
var makeInstaller = (components = []) => {
  const install3 = (app, options) => {
    if (app[INSTALLED_KEY])
      return;
    app[INSTALLED_KEY] = true;
    components.forEach((c2) => app.use(c2));
    if (options)
      provideGlobalConfig(options, app, true);
  };
  return {
    version: version2,
    install: install3
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/affix/src/affix2.mjs
var import_vue318 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/affix/src/affix.mjs
var affixProps = buildProps({
  zIndex: {
    type: definePropType([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  }
});
var affixEmits = {
  scroll: ({ scrollTop, fixed }) => isNumber(scrollTop) && isBoolean(fixed),
  [CHANGE_EVENT]: (fixed) => isBoolean(fixed)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/_virtual/plugin-vue_export-helper.mjs
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/affix/src/affix2.mjs
var COMPONENT_NAME = "ElAffix";
var __default__ = (0, import_vue318.defineComponent)({
  name: COMPONENT_NAME
});
var _sfc_main = /* @__PURE__ */ (0, import_vue318.defineComponent)({
  ...__default__,
  props: affixProps,
  emits: affixEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("affix");
    const target = (0, import_vue318.shallowRef)();
    const root2 = (0, import_vue318.shallowRef)();
    const scrollContainer = (0, import_vue318.shallowRef)();
    const { height: windowHeight } = useWindowSize();
    const {
      height: rootHeight,
      width: rootWidth,
      top: rootTop,
      bottom: rootBottom,
      update: updateRoot
    } = useElementBounding(root2, { windowScroll: false });
    const targetRect = useElementBounding(target);
    const fixed = (0, import_vue318.ref)(false);
    const scrollTop = (0, import_vue318.ref)(0);
    const transform = (0, import_vue318.ref)(0);
    const rootStyle = (0, import_vue318.computed)(() => {
      return {
        height: fixed.value ? `${rootHeight.value}px` : "",
        width: fixed.value ? `${rootWidth.value}px` : ""
      };
    });
    const affixStyle = (0, import_vue318.computed)(() => {
      if (!fixed.value)
        return {};
      const offset2 = props.offset ? addUnit(props.offset) : 0;
      return {
        height: `${rootHeight.value}px`,
        width: `${rootWidth.value}px`,
        top: props.position === "top" ? offset2 : "",
        bottom: props.position === "bottom" ? offset2 : "",
        transform: transform.value ? `translateY(${transform.value}px)` : "",
        zIndex: props.zIndex
      };
    });
    const update = () => {
      if (!scrollContainer.value)
        return;
      scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;
      if (props.position === "top") {
        if (props.target) {
          const difference = targetRect.bottom.value - props.offset - rootHeight.value;
          fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0;
          transform.value = difference < 0 ? difference : 0;
        } else {
          fixed.value = props.offset > rootTop.value;
        }
      } else if (props.target) {
        const difference = windowHeight.value - targetRect.top.value - props.offset - rootHeight.value;
        fixed.value = windowHeight.value - props.offset < rootBottom.value && windowHeight.value > targetRect.top.value;
        transform.value = difference < 0 ? -difference : 0;
      } else {
        fixed.value = windowHeight.value - props.offset < rootBottom.value;
      }
    };
    const handleScroll2 = () => {
      updateRoot();
      emit("scroll", {
        scrollTop: scrollTop.value,
        fixed: fixed.value
      });
    };
    (0, import_vue318.watch)(fixed, (val) => emit("change", val));
    (0, import_vue318.onMounted)(() => {
      var _a2;
      if (props.target) {
        target.value = (_a2 = document.querySelector(props.target)) != null ? _a2 : void 0;
        if (!target.value)
          throwError(COMPONENT_NAME, `Target is not existed: ${props.target}`);
      } else {
        target.value = document.documentElement;
      }
      scrollContainer.value = getScrollContainer(root2.value, true);
      updateRoot();
    });
    useEventListener(scrollContainer, "scroll", handleScroll2);
    (0, import_vue318.watchEffect)(update);
    expose({
      update,
      updateRoot
    });
    return (_ctx, _cache) => {
      return (0, import_vue318.openBlock)(), (0, import_vue318.createElementBlock)("div", {
        ref_key: "root",
        ref: root2,
        class: (0, import_vue318.normalizeClass)((0, import_vue318.unref)(ns2).b()),
        style: (0, import_vue318.normalizeStyle)((0, import_vue318.unref)(rootStyle))
      }, [
        (0, import_vue318.createElementVNode)("div", {
          class: (0, import_vue318.normalizeClass)({ [(0, import_vue318.unref)(ns2).m("fixed")]: fixed.value }),
          style: (0, import_vue318.normalizeStyle)((0, import_vue318.unref)(affixStyle))
        }, [
          (0, import_vue318.renderSlot)(_ctx.$slots, "default")
        ], 6)
      ], 6);
    };
  }
});
var Affix = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/affix/index.mjs
var ElAffix = withInstall(Affix);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/alert/src/alert2.mjs
var import_vue320 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/icon/src/icon2.mjs
var import_vue319 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/icon/src/icon.mjs
var iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/icon/src/icon2.mjs
var __default__2 = (0, import_vue319.defineComponent)({
  name: "ElIcon",
  inheritAttrs: false
});
var _sfc_main2 = /* @__PURE__ */ (0, import_vue319.defineComponent)({
  ...__default__2,
  props: iconProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("icon");
    const style = (0, import_vue319.computed)(() => {
      const { size: size2, color } = props;
      if (!size2 && !color)
        return {};
      return {
        fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
        "--color": color
      };
    });
    return (_ctx, _cache) => {
      return (0, import_vue319.openBlock)(), (0, import_vue319.createElementBlock)("i", (0, import_vue319.mergeProps)({
        class: (0, import_vue319.unref)(ns2).b(),
        style: (0, import_vue319.unref)(style)
      }, _ctx.$attrs), [
        (0, import_vue319.renderSlot)(_ctx.$slots, "default")
      ], 16);
    };
  }
});
var Icon = /* @__PURE__ */ _export_sfc(_sfc_main2, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/icon/index.mjs
var ElIcon = withInstall(Icon);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/alert/src/alert.mjs
var alertEffects = ["light", "dark"];
var alertProps = buildProps({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: keysOf(TypeComponentsMap),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: true
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: alertEffects,
    default: "light"
  }
});
var alertEmits = {
  close: (evt) => evt instanceof MouseEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/alert/src/alert2.mjs
var __default__3 = (0, import_vue320.defineComponent)({
  name: "ElAlert"
});
var _sfc_main3 = /* @__PURE__ */ (0, import_vue320.defineComponent)({
  ...__default__3,
  props: alertProps,
  emits: alertEmits,
  setup(__props, { emit }) {
    const props = __props;
    const { Close } = TypeComponents;
    const slots = (0, import_vue320.useSlots)();
    const ns2 = useNamespace("alert");
    const visible = (0, import_vue320.ref)(true);
    const iconComponent = (0, import_vue320.computed)(() => TypeComponentsMap[props.type]);
    const iconClass = (0, import_vue320.computed)(() => [
      ns2.e("icon"),
      { [ns2.is("big")]: !!props.description || !!slots.default }
    ]);
    const isBoldTitle = (0, import_vue320.computed)(() => {
      return { [ns2.is("bold")]: props.description || slots.default };
    });
    const close2 = (evt) => {
      visible.value = false;
      emit("close", evt);
    };
    return (_ctx, _cache) => {
      return (0, import_vue320.openBlock)(), (0, import_vue320.createBlock)(import_vue320.Transition, {
        name: (0, import_vue320.unref)(ns2).b("fade"),
        persisted: ""
      }, {
        default: (0, import_vue320.withCtx)(() => [
          (0, import_vue320.withDirectives)((0, import_vue320.createElementVNode)("div", {
            class: (0, import_vue320.normalizeClass)([(0, import_vue320.unref)(ns2).b(), (0, import_vue320.unref)(ns2).m(_ctx.type), (0, import_vue320.unref)(ns2).is("center", _ctx.center), (0, import_vue320.unref)(ns2).is(_ctx.effect)]),
            role: "alert"
          }, [
            _ctx.showIcon && (0, import_vue320.unref)(iconComponent) ? ((0, import_vue320.openBlock)(), (0, import_vue320.createBlock)((0, import_vue320.unref)(ElIcon), {
              key: 0,
              class: (0, import_vue320.normalizeClass)((0, import_vue320.unref)(iconClass))
            }, {
              default: (0, import_vue320.withCtx)(() => [
                ((0, import_vue320.openBlock)(), (0, import_vue320.createBlock)((0, import_vue320.resolveDynamicComponent)((0, import_vue320.unref)(iconComponent))))
              ]),
              _: 1
            }, 8, ["class"])) : (0, import_vue320.createCommentVNode)("v-if", true),
            (0, import_vue320.createElementVNode)("div", {
              class: (0, import_vue320.normalizeClass)((0, import_vue320.unref)(ns2).e("content"))
            }, [
              _ctx.title || _ctx.$slots.title ? ((0, import_vue320.openBlock)(), (0, import_vue320.createElementBlock)("span", {
                key: 0,
                class: (0, import_vue320.normalizeClass)([(0, import_vue320.unref)(ns2).e("title"), (0, import_vue320.unref)(isBoldTitle)])
              }, [
                (0, import_vue320.renderSlot)(_ctx.$slots, "title", {}, () => [
                  (0, import_vue320.createTextVNode)((0, import_vue320.toDisplayString)(_ctx.title), 1)
                ])
              ], 2)) : (0, import_vue320.createCommentVNode)("v-if", true),
              _ctx.$slots.default || _ctx.description ? ((0, import_vue320.openBlock)(), (0, import_vue320.createElementBlock)("p", {
                key: 1,
                class: (0, import_vue320.normalizeClass)((0, import_vue320.unref)(ns2).e("description"))
              }, [
                (0, import_vue320.renderSlot)(_ctx.$slots, "default", {}, () => [
                  (0, import_vue320.createTextVNode)((0, import_vue320.toDisplayString)(_ctx.description), 1)
                ])
              ], 2)) : (0, import_vue320.createCommentVNode)("v-if", true),
              _ctx.closable ? ((0, import_vue320.openBlock)(), (0, import_vue320.createElementBlock)(import_vue320.Fragment, { key: 2 }, [
                _ctx.closeText ? ((0, import_vue320.openBlock)(), (0, import_vue320.createElementBlock)("div", {
                  key: 0,
                  class: (0, import_vue320.normalizeClass)([(0, import_vue320.unref)(ns2).e("close-btn"), (0, import_vue320.unref)(ns2).is("customed")]),
                  onClick: close2
                }, (0, import_vue320.toDisplayString)(_ctx.closeText), 3)) : ((0, import_vue320.openBlock)(), (0, import_vue320.createBlock)((0, import_vue320.unref)(ElIcon), {
                  key: 1,
                  class: (0, import_vue320.normalizeClass)((0, import_vue320.unref)(ns2).e("close-btn")),
                  onClick: close2
                }, {
                  default: (0, import_vue320.withCtx)(() => [
                    (0, import_vue320.createVNode)((0, import_vue320.unref)(Close))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : (0, import_vue320.createCommentVNode)("v-if", true)
            ], 2)
          ], 2), [
            [import_vue320.vShow, visible.value]
          ])
        ]),
        _: 3
      }, 8, ["name"]);
    };
  }
});
var Alert = /* @__PURE__ */ _export_sfc(_sfc_main3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/alert/index.mjs
var ElAlert = withInstall(Alert);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/autocomplete/src/autocomplete2.mjs
var import_vue336 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input/src/input2.mjs
var import_vue321 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input/src/utils.mjs
var hiddenTextarea = void 0;
var HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
var CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a2;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea.scrollHeight;
  const result = {};
  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }
  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
  if (isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }
  if (isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = `${height}px`;
  (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
  hiddenTextarea = void 0;
  return result;
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input/src/input.mjs
var import_shared15 = require("@vue/shared");
var inputProps = buildProps({
  id: {
    type: String,
    default: void 0
  },
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: definePropType([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: definePropType([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  suffixIcon: {
    type: iconPropType
  },
  prefixIcon: {
    type: iconPropType
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: definePropType([Object, Array, String]),
    default: () => mutable({})
  }
});
var inputEmits = {
  [UPDATE_MODEL_EVENT]: (value) => (0, import_shared15.isString)(value),
  input: (value) => (0, import_shared15.isString)(value),
  change: (value) => (0, import_shared15.isString)(value),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  clear: () => true,
  mouseleave: (evt) => evt instanceof MouseEvent,
  mouseenter: (evt) => evt instanceof MouseEvent,
  keydown: (evt) => evt instanceof Event,
  compositionstart: (evt) => evt instanceof CompositionEvent,
  compositionupdate: (evt) => evt instanceof CompositionEvent,
  compositionend: (evt) => evt instanceof CompositionEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input/src/input2.mjs
var import_shared16 = require("@vue/shared");
var _hoisted_1 = ["role"];
var _hoisted_2 = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"];
var _hoisted_3 = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"];
var __default__4 = (0, import_vue321.defineComponent)({
  name: "ElInput",
  inheritAttrs: false
});
var _sfc_main4 = /* @__PURE__ */ (0, import_vue321.defineComponent)({
  ...__default__4,
  props: inputProps,
  emits: inputEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const rawAttrs = (0, import_vue321.useAttrs)();
    const slots = (0, import_vue321.useSlots)();
    const containerAttrs = (0, import_vue321.computed)(() => {
      const comboBoxAttrs = {};
      if (props.containerRole === "combobox") {
        comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
        comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
        comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
      }
      return comboBoxAttrs;
    });
    const containerKls = (0, import_vue321.computed)(() => [
      props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
      nsInput.m(inputSize.value),
      nsInput.is("disabled", inputDisabled.value),
      nsInput.is("exceed", inputExceed.value),
      {
        [nsInput.b("group")]: slots.prepend || slots.append,
        [nsInput.bm("group", "append")]: slots.append,
        [nsInput.bm("group", "prepend")]: slots.prepend,
        [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
        [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
        [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
      },
      rawAttrs.class
    ]);
    const wrapperKls = (0, import_vue321.computed)(() => [
      nsInput.e("wrapper"),
      nsInput.is("focus", focused.value)
    ]);
    const attrs = useAttrs({
      excludeKeys: (0, import_vue321.computed)(() => {
        return Object.keys(containerAttrs.value);
      })
    });
    const { form, formItem } = useFormItem();
    const { inputId } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const inputSize = useSize();
    const inputDisabled = useDisabled();
    const nsInput = useNamespace("input");
    const nsTextarea = useNamespace("textarea");
    const input = (0, import_vue321.shallowRef)();
    const textarea = (0, import_vue321.shallowRef)();
    const focused = (0, import_vue321.ref)(false);
    const hovering = (0, import_vue321.ref)(false);
    const isComposing = (0, import_vue321.ref)(false);
    const passwordVisible = (0, import_vue321.ref)(false);
    const countStyle = (0, import_vue321.ref)();
    const textareaCalcStyle = (0, import_vue321.shallowRef)(props.inputStyle);
    const _ref = (0, import_vue321.computed)(() => input.value || textarea.value);
    const needStatusIcon = (0, import_vue321.computed)(() => {
      var _a2;
      return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
    });
    const validateState = (0, import_vue321.computed)(() => (formItem == null ? void 0 : formItem.validateState) || "");
    const validateIcon = (0, import_vue321.computed)(() => validateState.value && ValidateComponentsMap[validateState.value]);
    const passwordIcon = (0, import_vue321.computed)(() => passwordVisible.value ? view_default : hide_default);
    const containerStyle = (0, import_vue321.computed)(() => [
      rawAttrs.style,
      props.inputStyle
    ]);
    const textareaStyle = (0, import_vue321.computed)(() => [
      props.inputStyle,
      textareaCalcStyle.value,
      { resize: props.resize }
    ]);
    const nativeInputValue = (0, import_vue321.computed)(() => isNil_default(props.modelValue) ? "" : String(props.modelValue));
    const showClear = (0, import_vue321.computed)(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
    const showPwdVisible = (0, import_vue321.computed)(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || focused.value));
    const isWordLimitVisible = (0, import_vue321.computed)(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
    const textLength = (0, import_vue321.computed)(() => Array.from(nativeInputValue.value).length);
    const inputExceed = (0, import_vue321.computed)(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
    const suffixVisible = (0, import_vue321.computed)(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
    const [recordCursor, setCursor] = useCursor(input);
    useResizeObserver(textarea, (entries) => {
      if (!isWordLimitVisible.value || props.resize !== "both")
        return;
      const entry = entries[0];
      const { width } = entry.contentRect;
      countStyle.value = {
        right: `calc(100% - ${width + 15 + 6}px)`
      };
    });
    const resizeTextarea = () => {
      const { type: type4, autosize } = props;
      if (!isClient || type4 !== "textarea")
        return;
      if (autosize) {
        const minRows = (0, import_shared16.isObject)(autosize) ? autosize.minRows : void 0;
        const maxRows = (0, import_shared16.isObject)(autosize) ? autosize.maxRows : void 0;
        textareaCalcStyle.value = {
          ...calcTextareaHeight(textarea.value, minRows, maxRows)
        };
      } else {
        textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };
    const setNativeInputValue = () => {
      const input2 = _ref.value;
      if (!input2 || input2.value === nativeInputValue.value)
        return;
      input2.value = nativeInputValue.value;
    };
    const handleInput = async (event) => {
      recordCursor();
      let { value } = event.target;
      if (props.formatter) {
        value = props.parser ? props.parser(value) : value;
        value = props.formatter(value);
      }
      if (isComposing.value)
        return;
      if (value === nativeInputValue.value) {
        setNativeInputValue();
        return;
      }
      emit(UPDATE_MODEL_EVENT, value);
      emit("input", value);
      await (0, import_vue321.nextTick)();
      setNativeInputValue();
      setCursor();
    };
    const handleChange = (event) => {
      emit("change", event.target.value);
    };
    const handleCompositionStart = (event) => {
      emit("compositionstart", event);
      isComposing.value = true;
    };
    const handleCompositionUpdate = (event) => {
      var _a2;
      emit("compositionupdate", event);
      const text = (_a2 = event.target) == null ? void 0 : _a2.value;
      const lastCharacter = text[text.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event) => {
      emit("compositionend", event);
      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event);
      }
    };
    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus();
    };
    const focus = async () => {
      var _a2;
      await (0, import_vue321.nextTick)();
      (_a2 = _ref.value) == null ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
    };
    const handleFocus = (event) => {
      focused.value = true;
      emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a2;
      focused.value = false;
      emit("blur", event);
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn(err));
      }
    };
    const handleMouseLeave = (evt) => {
      hovering.value = false;
      emit("mouseleave", evt);
    };
    const handleMouseEnter = (evt) => {
      hovering.value = true;
      emit("mouseenter", evt);
    };
    const handleKeydown = (evt) => {
      emit("keydown", evt);
    };
    const select = () => {
      var _a2;
      (_a2 = _ref.value) == null ? void 0 : _a2.select();
    };
    const clear = () => {
      emit(UPDATE_MODEL_EVENT, "");
      emit("change", "");
      emit("clear");
      emit("input", "");
    };
    (0, import_vue321.watch)(() => props.modelValue, () => {
      var _a2;
      (0, import_vue321.nextTick)(() => resizeTextarea());
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn(err));
      }
    });
    (0, import_vue321.watch)(nativeInputValue, () => setNativeInputValue());
    (0, import_vue321.watch)(() => props.type, async () => {
      await (0, import_vue321.nextTick)();
      setNativeInputValue();
      resizeTextarea();
    });
    (0, import_vue321.onMounted)(() => {
      if (!props.formatter && props.parser) {
        debugWarn("ElInput", "If you set the parser, you also need to set the formatter.");
      }
      setNativeInputValue();
      (0, import_vue321.nextTick)(resizeTextarea);
    });
    expose({
      input,
      textarea,
      ref: _ref,
      textareaStyle,
      autosize: (0, import_vue321.toRef)(props, "autosize"),
      focus,
      blur,
      select,
      clear,
      resizeTextarea
    });
    return (_ctx, _cache) => {
      return (0, import_vue321.withDirectives)(((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("div", (0, import_vue321.mergeProps)((0, import_vue321.unref)(containerAttrs), {
        class: (0, import_vue321.unref)(containerKls),
        style: (0, import_vue321.unref)(containerStyle),
        role: _ctx.containerRole,
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }), [
        (0, import_vue321.createCommentVNode)(" input "),
        _ctx.type !== "textarea" ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)(import_vue321.Fragment, { key: 0 }, [
          (0, import_vue321.createCommentVNode)(" prepend slot "),
          _ctx.$slots.prepend ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).be("group", "prepend"))
          }, [
            (0, import_vue321.renderSlot)(_ctx.$slots, "prepend")
          ], 2)) : (0, import_vue321.createCommentVNode)("v-if", true),
          (0, import_vue321.createElementVNode)("div", {
            class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(wrapperKls))
          }, [
            (0, import_vue321.createCommentVNode)(" prefix slot "),
            _ctx.$slots.prefix || _ctx.prefixIcon ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("span", {
              key: 0,
              class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("prefix"))
            }, [
              (0, import_vue321.createElementVNode)("span", {
                class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("prefix-inner")),
                onClick: focus
              }, [
                (0, import_vue321.renderSlot)(_ctx.$slots, "prefix"),
                _ctx.prefixIcon ? ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.unref)(ElIcon), {
                  key: 0,
                  class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("icon"))
                }, {
                  default: (0, import_vue321.withCtx)(() => [
                    ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.resolveDynamicComponent)(_ctx.prefixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : (0, import_vue321.createCommentVNode)("v-if", true)
              ], 2)
            ], 2)) : (0, import_vue321.createCommentVNode)("v-if", true),
            (0, import_vue321.createElementVNode)("input", (0, import_vue321.mergeProps)({
              id: (0, import_vue321.unref)(inputId),
              ref_key: "input",
              ref: input,
              class: (0, import_vue321.unref)(nsInput).e("inner")
            }, (0, import_vue321.unref)(attrs), {
              type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
              disabled: (0, import_vue321.unref)(inputDisabled),
              formatter: _ctx.formatter,
              parser: _ctx.parser,
              readonly: _ctx.readonly,
              autocomplete: _ctx.autocomplete,
              tabindex: _ctx.tabindex,
              "aria-label": _ctx.label,
              placeholder: _ctx.placeholder,
              style: _ctx.inputStyle,
              form: props.form,
              onCompositionstart: handleCompositionStart,
              onCompositionupdate: handleCompositionUpdate,
              onCompositionend: handleCompositionEnd,
              onInput: handleInput,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onChange: handleChange,
              onKeydown: handleKeydown
            }), null, 16, _hoisted_2),
            (0, import_vue321.createCommentVNode)(" suffix slot "),
            (0, import_vue321.unref)(suffixVisible) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("span", {
              key: 1,
              class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("suffix"))
            }, [
              (0, import_vue321.createElementVNode)("span", {
                class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("suffix-inner")),
                onClick: focus
              }, [
                !(0, import_vue321.unref)(showClear) || !(0, import_vue321.unref)(showPwdVisible) || !(0, import_vue321.unref)(isWordLimitVisible) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)(import_vue321.Fragment, { key: 0 }, [
                  (0, import_vue321.renderSlot)(_ctx.$slots, "suffix"),
                  _ctx.suffixIcon ? ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.unref)(ElIcon), {
                    key: 0,
                    class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("icon"))
                  }, {
                    default: (0, import_vue321.withCtx)(() => [
                      ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.resolveDynamicComponent)(_ctx.suffixIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : (0, import_vue321.createCommentVNode)("v-if", true)
                ], 64)) : (0, import_vue321.createCommentVNode)("v-if", true),
                (0, import_vue321.unref)(showClear) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.unref)(ElIcon), {
                  key: 1,
                  class: (0, import_vue321.normalizeClass)([(0, import_vue321.unref)(nsInput).e("icon"), (0, import_vue321.unref)(nsInput).e("clear")]),
                  onMousedown: (0, import_vue321.withModifiers)((0, import_vue321.unref)(import_shared16.NOOP), ["prevent"]),
                  onClick: clear
                }, {
                  default: (0, import_vue321.withCtx)(() => [
                    (0, import_vue321.createVNode)((0, import_vue321.unref)(circle_close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown"])) : (0, import_vue321.createCommentVNode)("v-if", true),
                (0, import_vue321.unref)(showPwdVisible) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.unref)(ElIcon), {
                  key: 2,
                  class: (0, import_vue321.normalizeClass)([(0, import_vue321.unref)(nsInput).e("icon"), (0, import_vue321.unref)(nsInput).e("password")]),
                  onClick: handlePasswordVisible
                }, {
                  default: (0, import_vue321.withCtx)(() => [
                    ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.resolveDynamicComponent)((0, import_vue321.unref)(passwordIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : (0, import_vue321.createCommentVNode)("v-if", true),
                (0, import_vue321.unref)(isWordLimitVisible) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("span", {
                  key: 3,
                  class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("count"))
                }, [
                  (0, import_vue321.createElementVNode)("span", {
                    class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("count-inner"))
                  }, (0, import_vue321.toDisplayString)((0, import_vue321.unref)(textLength)) + " / " + (0, import_vue321.toDisplayString)((0, import_vue321.unref)(attrs).maxlength), 3)
                ], 2)) : (0, import_vue321.createCommentVNode)("v-if", true),
                (0, import_vue321.unref)(validateState) && (0, import_vue321.unref)(validateIcon) && (0, import_vue321.unref)(needStatusIcon) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.unref)(ElIcon), {
                  key: 4,
                  class: (0, import_vue321.normalizeClass)([
                    (0, import_vue321.unref)(nsInput).e("icon"),
                    (0, import_vue321.unref)(nsInput).e("validateIcon"),
                    (0, import_vue321.unref)(nsInput).is("loading", (0, import_vue321.unref)(validateState) === "validating")
                  ])
                }, {
                  default: (0, import_vue321.withCtx)(() => [
                    ((0, import_vue321.openBlock)(), (0, import_vue321.createBlock)((0, import_vue321.resolveDynamicComponent)((0, import_vue321.unref)(validateIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : (0, import_vue321.createCommentVNode)("v-if", true)
              ], 2)
            ], 2)) : (0, import_vue321.createCommentVNode)("v-if", true)
          ], 2),
          (0, import_vue321.createCommentVNode)(" append slot "),
          _ctx.$slots.append ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("div", {
            key: 1,
            class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).be("group", "append"))
          }, [
            (0, import_vue321.renderSlot)(_ctx.$slots, "append")
          ], 2)) : (0, import_vue321.createCommentVNode)("v-if", true)
        ], 64)) : ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)(import_vue321.Fragment, { key: 1 }, [
          (0, import_vue321.createCommentVNode)(" textarea "),
          (0, import_vue321.createElementVNode)("textarea", (0, import_vue321.mergeProps)({
            id: (0, import_vue321.unref)(inputId),
            ref_key: "textarea",
            ref: textarea,
            class: (0, import_vue321.unref)(nsTextarea).e("inner")
          }, (0, import_vue321.unref)(attrs), {
            tabindex: _ctx.tabindex,
            disabled: (0, import_vue321.unref)(inputDisabled),
            readonly: _ctx.readonly,
            autocomplete: _ctx.autocomplete,
            style: (0, import_vue321.unref)(textareaStyle),
            "aria-label": _ctx.label,
            placeholder: _ctx.placeholder,
            form: props.form,
            onCompositionstart: handleCompositionStart,
            onCompositionupdate: handleCompositionUpdate,
            onCompositionend: handleCompositionEnd,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeydown: handleKeydown
          }), null, 16, _hoisted_3),
          (0, import_vue321.unref)(isWordLimitVisible) ? ((0, import_vue321.openBlock)(), (0, import_vue321.createElementBlock)("span", {
            key: 0,
            style: (0, import_vue321.normalizeStyle)(countStyle.value),
            class: (0, import_vue321.normalizeClass)((0, import_vue321.unref)(nsInput).e("count"))
          }, (0, import_vue321.toDisplayString)((0, import_vue321.unref)(textLength)) + " / " + (0, import_vue321.toDisplayString)((0, import_vue321.unref)(attrs).maxlength), 7)) : (0, import_vue321.createCommentVNode)("v-if", true)
        ], 64))
      ], 16, _hoisted_1)), [
        [import_vue321.vShow, _ctx.type !== "hidden"]
      ]);
    };
  }
});
var Input = /* @__PURE__ */ _export_sfc(_sfc_main4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input/index.mjs
var ElInput = withInstall(Input);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/scrollbar2.mjs
var import_vue324 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/util.mjs
var GAP = 4;
var BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
var renderThumbStyle = ({
  move,
  size: size2,
  bar
}) => ({
  [bar.size]: size2,
  transform: `translate${bar.axis}(${move}%)`
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/bar2.mjs
var import_vue323 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/thumb2.mjs
var import_vue322 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/thumb.mjs
var thumbProps = buildProps({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/thumb2.mjs
var COMPONENT_NAME2 = "Thumb";
var _sfc_main5 = /* @__PURE__ */ (0, import_vue322.defineComponent)({
  __name: "thumb",
  props: thumbProps,
  setup(__props) {
    const props = __props;
    const scrollbar = (0, import_vue322.inject)(scrollbarContextKey);
    const ns2 = useNamespace("scrollbar");
    if (!scrollbar)
      throwError(COMPONENT_NAME2, "can not inject scrollbar context");
    const instance = (0, import_vue322.ref)();
    const thumb = (0, import_vue322.ref)();
    const thumbState = (0, import_vue322.ref)({});
    const visible = (0, import_vue322.ref)(false);
    let cursorDown = false;
    let cursorLeave = false;
    let originalOnSelectStart = isClient ? document.onselectstart : null;
    const bar = (0, import_vue322.computed)(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
    const thumbStyle = (0, import_vue322.computed)(() => renderThumbStyle({
      size: props.size,
      move: props.move,
      bar: bar.value
    }));
    const offsetRatio = (0, import_vue322.computed)(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
    const clickThumbHandler = (e) => {
      var _a2;
      e.stopPropagation();
      if (e.ctrlKey || [1, 2].includes(e.button))
        return;
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
      startDrag(e);
      const el = e.currentTarget;
      if (!el)
        return;
      thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
    };
    const clickTrackHandler = (e) => {
      if (!thumb.value || !instance.value || !scrollbar.wrapElement)
        return;
      const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };
    const startDrag = (e) => {
      e.stopImmediatePropagation();
      cursorDown = true;
      document.addEventListener("mousemove", mouseMoveDocumentHandler);
      document.addEventListener("mouseup", mouseUpDocumentHandler);
      originalOnSelectStart = document.onselectstart;
      document.onselectstart = () => false;
    };
    const mouseMoveDocumentHandler = (e) => {
      if (!instance.value || !thumb.value)
        return;
      if (cursorDown === false)
        return;
      const prevPage = thumbState.value[bar.value.axis];
      if (!prevPage)
        return;
      const offset2 = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };
    const mouseUpDocumentHandler = () => {
      cursorDown = false;
      thumbState.value[bar.value.axis] = 0;
      document.removeEventListener("mousemove", mouseMoveDocumentHandler);
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
      restoreOnselectstart();
      if (cursorLeave)
        visible.value = false;
    };
    const mouseMoveScrollbarHandler = () => {
      cursorLeave = false;
      visible.value = !!props.size;
    };
    const mouseLeaveScrollbarHandler = () => {
      cursorLeave = true;
      visible.value = cursorDown;
    };
    (0, import_vue322.onBeforeUnmount)(() => {
      restoreOnselectstart();
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
    });
    const restoreOnselectstart = () => {
      if (document.onselectstart !== originalOnSelectStart)
        document.onselectstart = originalOnSelectStart;
    };
    useEventListener((0, import_vue322.toRef)(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
    useEventListener((0, import_vue322.toRef)(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
    return (_ctx, _cache) => {
      return (0, import_vue322.openBlock)(), (0, import_vue322.createBlock)(import_vue322.Transition, {
        name: (0, import_vue322.unref)(ns2).b("fade"),
        persisted: ""
      }, {
        default: (0, import_vue322.withCtx)(() => [
          (0, import_vue322.withDirectives)((0, import_vue322.createElementVNode)("div", {
            ref_key: "instance",
            ref: instance,
            class: (0, import_vue322.normalizeClass)([(0, import_vue322.unref)(ns2).e("bar"), (0, import_vue322.unref)(ns2).is((0, import_vue322.unref)(bar).key)]),
            onMousedown: clickTrackHandler
          }, [
            (0, import_vue322.createElementVNode)("div", {
              ref_key: "thumb",
              ref: thumb,
              class: (0, import_vue322.normalizeClass)((0, import_vue322.unref)(ns2).e("thumb")),
              style: (0, import_vue322.normalizeStyle)((0, import_vue322.unref)(thumbStyle)),
              onMousedown: clickThumbHandler
            }, null, 38)
          ], 34), [
            [import_vue322.vShow, _ctx.always || visible.value]
          ])
        ]),
        _: 1
      }, 8, ["name"]);
    };
  }
});
var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/bar.mjs
var barProps = buildProps({
  always: {
    type: Boolean,
    default: true
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/bar2.mjs
var _sfc_main6 = /* @__PURE__ */ (0, import_vue323.defineComponent)({
  __name: "bar",
  props: barProps,
  setup(__props, { expose }) {
    const props = __props;
    const moveX = (0, import_vue323.ref)(0);
    const moveY = (0, import_vue323.ref)(0);
    const handleScroll2 = (wrap) => {
      if (wrap) {
        const offsetHeight = wrap.offsetHeight - GAP;
        const offsetWidth = wrap.offsetWidth - GAP;
        moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
        moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
      }
    };
    expose({
      handleScroll: handleScroll2
    });
    return (_ctx, _cache) => {
      return (0, import_vue323.openBlock)(), (0, import_vue323.createElementBlock)(import_vue323.Fragment, null, [
        (0, import_vue323.createVNode)(Thumb, {
          move: moveX.value,
          ratio: _ctx.ratioX,
          size: _ctx.width,
          always: _ctx.always
        }, null, 8, ["move", "ratio", "size", "always"]),
        (0, import_vue323.createVNode)(Thumb, {
          move: moveY.value,
          ratio: _ctx.ratioY,
          size: _ctx.height,
          vertical: "",
          always: _ctx.always
        }, null, 8, ["move", "ratio", "size", "always"])
      ], 64);
    };
  }
});
var Bar = /* @__PURE__ */ _export_sfc(_sfc_main6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/scrollbar.mjs
var scrollbarProps = buildProps({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: false
  },
  wrapStyle: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  }
});
var scrollbarEmits = {
  scroll: ({
    scrollTop,
    scrollLeft
  }) => [scrollTop, scrollLeft].every(isNumber)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/src/scrollbar2.mjs
var import_shared17 = require("@vue/shared");
var COMPONENT_NAME3 = "ElScrollbar";
var __default__5 = (0, import_vue324.defineComponent)({
  name: COMPONENT_NAME3
});
var _sfc_main7 = /* @__PURE__ */ (0, import_vue324.defineComponent)({
  ...__default__5,
  props: scrollbarProps,
  emits: scrollbarEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("scrollbar");
    let stopResizeObserver = void 0;
    let stopResizeListener = void 0;
    const scrollbarRef = (0, import_vue324.ref)();
    const wrapRef = (0, import_vue324.ref)();
    const resizeRef = (0, import_vue324.ref)();
    const sizeWidth = (0, import_vue324.ref)("0");
    const sizeHeight = (0, import_vue324.ref)("0");
    const barRef = (0, import_vue324.ref)();
    const ratioY = (0, import_vue324.ref)(1);
    const ratioX = (0, import_vue324.ref)(1);
    const style = (0, import_vue324.computed)(() => {
      const style2 = {};
      if (props.height)
        style2.height = addUnit(props.height);
      if (props.maxHeight)
        style2.maxHeight = addUnit(props.maxHeight);
      return [props.wrapStyle, style2];
    });
    const wrapKls = (0, import_vue324.computed)(() => {
      return [
        props.wrapClass,
        ns2.e("wrap"),
        { [ns2.em("wrap", "hidden-default")]: !props.native }
      ];
    });
    const resizeKls = (0, import_vue324.computed)(() => {
      return [ns2.e("view"), props.viewClass];
    });
    const handleScroll2 = () => {
      var _a2;
      if (wrapRef.value) {
        (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
        emit("scroll", {
          scrollTop: wrapRef.value.scrollTop,
          scrollLeft: wrapRef.value.scrollLeft
        });
      }
    };
    function scrollTo(arg1, arg2) {
      if ((0, import_shared17.isObject)(arg1)) {
        wrapRef.value.scrollTo(arg1);
      } else if (isNumber(arg1) && isNumber(arg2)) {
        wrapRef.value.scrollTo(arg1, arg2);
      }
    }
    const setScrollTop = (value) => {
      if (!isNumber(value)) {
        debugWarn(COMPONENT_NAME3, "value must be a number");
        return;
      }
      wrapRef.value.scrollTop = value;
    };
    const setScrollLeft = (value) => {
      if (!isNumber(value)) {
        debugWarn(COMPONENT_NAME3, "value must be a number");
        return;
      }
      wrapRef.value.scrollLeft = value;
    };
    const update = () => {
      if (!wrapRef.value)
        return;
      const offsetHeight = wrapRef.value.offsetHeight - GAP;
      const offsetWidth = wrapRef.value.offsetWidth - GAP;
      const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
      const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
      const height = Math.max(originalHeight, props.minSize);
      const width = Math.max(originalWidth, props.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
      sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
      sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
    };
    (0, import_vue324.watch)(() => props.noresize, (noresize) => {
      if (noresize) {
        stopResizeObserver == null ? void 0 : stopResizeObserver();
        stopResizeListener == null ? void 0 : stopResizeListener();
      } else {
        ;
        ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
        stopResizeListener = useEventListener("resize", update);
      }
    }, { immediate: true });
    (0, import_vue324.watch)(() => [props.maxHeight, props.height], () => {
      if (!props.native)
        (0, import_vue324.nextTick)(() => {
          var _a2;
          update();
          if (wrapRef.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
          }
        });
    });
    (0, import_vue324.provide)(scrollbarContextKey, (0, import_vue324.reactive)({
      scrollbarElement: scrollbarRef,
      wrapElement: wrapRef
    }));
    (0, import_vue324.onMounted)(() => {
      if (!props.native)
        (0, import_vue324.nextTick)(() => {
          update();
        });
    });
    (0, import_vue324.onUpdated)(() => update());
    expose({
      wrapRef,
      update,
      scrollTo,
      setScrollTop,
      setScrollLeft,
      handleScroll: handleScroll2
    });
    return (_ctx, _cache) => {
      return (0, import_vue324.openBlock)(), (0, import_vue324.createElementBlock)("div", {
        ref_key: "scrollbarRef",
        ref: scrollbarRef,
        class: (0, import_vue324.normalizeClass)((0, import_vue324.unref)(ns2).b())
      }, [
        (0, import_vue324.createElementVNode)("div", {
          ref_key: "wrapRef",
          ref: wrapRef,
          class: (0, import_vue324.normalizeClass)((0, import_vue324.unref)(wrapKls)),
          style: (0, import_vue324.normalizeStyle)((0, import_vue324.unref)(style)),
          onScroll: handleScroll2
        }, [
          ((0, import_vue324.openBlock)(), (0, import_vue324.createBlock)((0, import_vue324.resolveDynamicComponent)(_ctx.tag), {
            ref_key: "resizeRef",
            ref: resizeRef,
            class: (0, import_vue324.normalizeClass)((0, import_vue324.unref)(resizeKls)),
            style: (0, import_vue324.normalizeStyle)(_ctx.viewStyle)
          }, {
            default: (0, import_vue324.withCtx)(() => [
              (0, import_vue324.renderSlot)(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]))
        ], 38),
        !_ctx.native ? ((0, import_vue324.openBlock)(), (0, import_vue324.createBlock)(Bar, {
          key: 0,
          ref_key: "barRef",
          ref: barRef,
          height: sizeHeight.value,
          width: sizeWidth.value,
          always: _ctx.always,
          "ratio-x": ratioX.value,
          "ratio-y": ratioY.value
        }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : (0, import_vue324.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/scrollbar/index.mjs
var ElScrollbar = withInstall(Scrollbar);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/tooltip2.mjs
var import_vue335 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/popper2.mjs
var import_vue325 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/popper.mjs
var roleTypes = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
];
var popperProps = buildProps({
  role: {
    type: String,
    values: roleTypes,
    default: "tooltip"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/popper2.mjs
var __default__6 = (0, import_vue325.defineComponent)({
  name: "ElPopperRoot",
  inheritAttrs: false
});
var _sfc_main8 = /* @__PURE__ */ (0, import_vue325.defineComponent)({
  ...__default__6,
  props: popperProps,
  setup(__props, { expose }) {
    const props = __props;
    const triggerRef2 = (0, import_vue325.ref)();
    const popperInstanceRef = (0, import_vue325.ref)();
    const contentRef = (0, import_vue325.ref)();
    const referenceRef = (0, import_vue325.ref)();
    const role = (0, import_vue325.computed)(() => props.role);
    const popperProvides = {
      triggerRef: triggerRef2,
      popperInstanceRef,
      contentRef,
      referenceRef,
      role
    };
    expose(popperProvides);
    (0, import_vue325.provide)(POPPER_INJECTION_KEY, popperProvides);
    return (_ctx, _cache) => {
      return (0, import_vue325.renderSlot)(_ctx.$slots, "default");
    };
  }
});
var Popper = /* @__PURE__ */ _export_sfc(_sfc_main8, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/arrow2.mjs
var import_vue326 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/arrow.mjs
var popperArrowProps = buildProps({
  arrowOffset: {
    type: Number,
    default: 5
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/arrow2.mjs
var __default__7 = (0, import_vue326.defineComponent)({
  name: "ElPopperArrow",
  inheritAttrs: false
});
var _sfc_main9 = /* @__PURE__ */ (0, import_vue326.defineComponent)({
  ...__default__7,
  props: popperArrowProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("popper");
    const { arrowOffset, arrowRef } = (0, import_vue326.inject)(POPPER_CONTENT_INJECTION_KEY, void 0);
    (0, import_vue326.watch)(() => props.arrowOffset, (val) => {
      arrowOffset.value = val;
    });
    (0, import_vue326.onBeforeUnmount)(() => {
      arrowRef.value = void 0;
    });
    expose({
      arrowRef
    });
    return (_ctx, _cache) => {
      return (0, import_vue326.openBlock)(), (0, import_vue326.createElementBlock)("span", {
        ref_key: "arrowRef",
        ref: arrowRef,
        class: (0, import_vue326.normalizeClass)((0, import_vue326.unref)(ns2).e("arrow")),
        "data-popper-arrow": ""
      }, null, 2);
    };
  }
});
var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/trigger2.mjs
var import_vue328 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slot/src/only-child.mjs
var import_vue327 = require("vue");
var import_shared18 = require("@vue/shared");
var NAME = "ElOnlyChild";
var OnlyChild = (0, import_vue327.defineComponent)({
  name: NAME,
  setup(_2, {
    slots,
    attrs
  }) {
    var _a2;
    const forwardRefInjection = (0, import_vue327.inject)(FORWARD_REF_INJECTION_KEY);
    const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : import_shared18.NOOP);
    return () => {
      var _a22;
      const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
      if (!defaultSlot)
        return null;
      if (defaultSlot.length > 1) {
        debugWarn(NAME, "requires exact only one valid child.");
        return null;
      }
      const firstLegitNode = findFirstLegitChild(defaultSlot);
      if (!firstLegitNode) {
        debugWarn(NAME, "no valid child node found");
        return null;
      }
      return (0, import_vue327.withDirectives)((0, import_vue327.cloneVNode)(firstLegitNode, attrs), [[forwardRefDirective]]);
    };
  }
});
function findFirstLegitChild(node) {
  if (!node)
    return null;
  const children = node;
  for (const child of children) {
    if ((0, import_shared18.isObject)(child)) {
      switch (child.type) {
        case import_vue327.Comment:
          continue;
        case import_vue327.Text:
        case "svg":
          return wrapTextContent(child);
        case import_vue327.Fragment:
          return findFirstLegitChild(child.children);
        default:
          return child;
      }
    }
    return wrapTextContent(child);
  }
  return null;
}
function wrapTextContent(s2) {
  const ns2 = useNamespace("only-child");
  return (0, import_vue327.createVNode)("span", {
    "class": ns2.e("content")
  }, [s2]);
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/trigger.mjs
var popperTriggerProps = buildProps({
  virtualRef: {
    type: definePropType(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: definePropType(Function)
  },
  onMouseleave: {
    type: definePropType(Function)
  },
  onClick: {
    type: definePropType(Function)
  },
  onKeydown: {
    type: definePropType(Function)
  },
  onFocus: {
    type: definePropType(Function)
  },
  onBlur: {
    type: definePropType(Function)
  },
  onContextmenu: {
    type: definePropType(Function)
  },
  id: String,
  open: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/trigger2.mjs
var __default__8 = (0, import_vue328.defineComponent)({
  name: "ElPopperTrigger",
  inheritAttrs: false
});
var _sfc_main10 = /* @__PURE__ */ (0, import_vue328.defineComponent)({
  ...__default__8,
  props: popperTriggerProps,
  setup(__props, { expose }) {
    const props = __props;
    const { role, triggerRef: triggerRef2 } = (0, import_vue328.inject)(POPPER_INJECTION_KEY, void 0);
    useForwardRef(triggerRef2);
    const ariaControls = (0, import_vue328.computed)(() => {
      return ariaHaspopup.value ? props.id : void 0;
    });
    const ariaDescribedby = (0, import_vue328.computed)(() => {
      if (role && role.value === "tooltip") {
        return props.open && props.id ? props.id : void 0;
      }
      return void 0;
    });
    const ariaHaspopup = (0, import_vue328.computed)(() => {
      if (role && role.value !== "tooltip") {
        return role.value;
      }
      return void 0;
    });
    const ariaExpanded = (0, import_vue328.computed)(() => {
      return ariaHaspopup.value ? `${props.open}` : void 0;
    });
    let virtualTriggerAriaStopWatch = void 0;
    (0, import_vue328.onMounted)(() => {
      (0, import_vue328.watch)(() => props.virtualRef, (virtualEl) => {
        if (virtualEl) {
          triggerRef2.value = unrefElement(virtualEl);
        }
      }, {
        immediate: true
      });
      (0, import_vue328.watch)(triggerRef2, (el, prevEl) => {
        virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
        virtualTriggerAriaStopWatch = void 0;
        if (isElement(el)) {
          ;
          [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ].forEach((eventName) => {
            var _a2;
            const handler = props[eventName];
            if (handler) {
              ;
              el.addEventListener(eventName.slice(2).toLowerCase(), handler);
              (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
            }
          });
          virtualTriggerAriaStopWatch = (0, import_vue328.watch)([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
            ;
            [
              "aria-controls",
              "aria-describedby",
              "aria-haspopup",
              "aria-expanded"
            ].forEach((key, idx) => {
              isNil_default(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
            });
          }, { immediate: true });
        }
        if (isElement(prevEl)) {
          ;
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((key) => prevEl.removeAttribute(key));
        }
      }, {
        immediate: true
      });
    });
    (0, import_vue328.onBeforeUnmount)(() => {
      virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
      virtualTriggerAriaStopWatch = void 0;
    });
    expose({
      triggerRef: triggerRef2
    });
    return (_ctx, _cache) => {
      return !_ctx.virtualTriggering ? ((0, import_vue328.openBlock)(), (0, import_vue328.createBlock)((0, import_vue328.unref)(OnlyChild), (0, import_vue328.mergeProps)({ key: 0 }, _ctx.$attrs, {
        "aria-controls": (0, import_vue328.unref)(ariaControls),
        "aria-describedby": (0, import_vue328.unref)(ariaDescribedby),
        "aria-expanded": (0, import_vue328.unref)(ariaExpanded),
        "aria-haspopup": (0, import_vue328.unref)(ariaHaspopup)
      }), {
        default: (0, import_vue328.withCtx)(() => [
          (0, import_vue328.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : (0, import_vue328.createCommentVNode)("v-if", true);
    };
  }
});
var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main10, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/content2.mjs
var import_vue331 = require("vue");
var import_shared20 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/focus-trap/src/focus-trap.mjs
var import_vue330 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/focus-trap/src/utils.mjs
var import_vue329 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/focus-trap/src/tokens.mjs
var FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
var FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
var FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
var FOCUS_AFTER_TRAPPED_OPTS = {
  cancelable: true,
  bubbles: false
};
var FOCUSOUT_PREVENTED_OPTS = {
  cancelable: true,
  bubbles: false
};
var ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
var ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
var FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/focus-trap/src/utils.mjs
var focusReason = (0, import_vue329.ref)();
var lastUserFocusTimestamp = (0, import_vue329.ref)(0);
var lastAutomatedFocusTimestamp = (0, import_vue329.ref)(0);
var focusReasonUserCount = 0;
var obtainAllFocusableElements2 = (element) => {
  const nodes = [];
  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
};
var getVisibleElement = (elements, container) => {
  for (const element of elements) {
    if (!isHidden(element, container))
      return element;
  }
};
var isHidden = (element, container) => {
  if (process.env.NODE_ENV === "test")
    return false;
  if (getComputedStyle(element).visibility === "hidden")
    return true;
  while (element) {
    if (container && element === container)
      return false;
    if (getComputedStyle(element).display === "none")
      return true;
    element = element.parentElement;
  }
  return false;
};
var getEdges = (container) => {
  const focusable = obtainAllFocusableElements2(container);
  const first = getVisibleElement(focusable, container);
  const last = getVisibleElement(focusable.reverse(), container);
  return [first, last];
};
var isSelectable = (element) => {
  return element instanceof HTMLInputElement && "select" in element;
};
var tryFocus = (element, shouldSelect) => {
  if (element && element.focus) {
    const prevFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    lastAutomatedFocusTimestamp.value = window.performance.now();
    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
      element.select();
    }
  }
};
function removeFromStack(list, item) {
  const copy = [...list];
  const idx = list.indexOf(item);
  if (idx !== -1) {
    copy.splice(idx, 1);
  }
  return copy;
}
var createFocusableStack = () => {
  let stack = [];
  const push = (layer) => {
    const currentLayer = stack[0];
    if (currentLayer && layer !== currentLayer) {
      currentLayer.pause();
    }
    stack = removeFromStack(stack, layer);
    stack.unshift(layer);
  };
  const remove = (layer) => {
    var _a2, _b;
    stack = removeFromStack(stack, layer);
    (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
  };
  return {
    push,
    remove
  };
};
var focusFirstDescendant = (elements, shouldSelect = false) => {
  const prevFocusedElement = document.activeElement;
  for (const element of elements) {
    tryFocus(element, shouldSelect);
    if (document.activeElement !== prevFocusedElement)
      return;
  }
};
var focusableStack = createFocusableStack();
var isFocusCausedByUserEvent = () => {
  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
};
var notifyFocusReasonPointer = () => {
  focusReason.value = "pointer";
  lastUserFocusTimestamp.value = window.performance.now();
};
var notifyFocusReasonKeydown = () => {
  focusReason.value = "keyboard";
  lastUserFocusTimestamp.value = window.performance.now();
};
var useFocusReason = () => {
  (0, import_vue329.onMounted)(() => {
    if (focusReasonUserCount === 0) {
      document.addEventListener("mousedown", notifyFocusReasonPointer);
      document.addEventListener("touchstart", notifyFocusReasonPointer);
      document.addEventListener("keydown", notifyFocusReasonKeydown);
    }
    focusReasonUserCount++;
  });
  (0, import_vue329.onBeforeUnmount)(() => {
    focusReasonUserCount--;
    if (focusReasonUserCount <= 0) {
      document.removeEventListener("mousedown", notifyFocusReasonPointer);
      document.removeEventListener("touchstart", notifyFocusReasonPointer);
      document.removeEventListener("keydown", notifyFocusReasonKeydown);
    }
  });
  return {
    focusReason,
    lastUserFocusTimestamp,
    lastAutomatedFocusTimestamp
  };
};
var createFocusOutPreventedEvent = (detail) => {
  return new CustomEvent(FOCUSOUT_PREVENTED, {
    ...FOCUSOUT_PREVENTED_OPTS,
    detail
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/focus-trap/src/focus-trap.mjs
var import_shared19 = require("@vue/shared");
var _sfc_main11 = (0, import_vue330.defineComponent)({
  name: "ElFocusTrap",
  inheritAttrs: false,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    ON_TRAP_FOCUS_EVT,
    ON_RELEASE_FOCUS_EVT,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(props, { emit }) {
    const forwardRef = (0, import_vue330.ref)();
    let lastFocusBeforeTrapped;
    let lastFocusAfterTrapped;
    const { focusReason: focusReason2 } = useFocusReason();
    useEscapeKeydown((event) => {
      if (props.trapped && !focusLayer.paused) {
        emit("release-requested", event);
      }
    });
    const focusLayer = {
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    };
    const onKeydown = (e) => {
      if (!props.loop && !props.trapped)
        return;
      if (focusLayer.paused)
        return;
      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
      const { loop } = props;
      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
      const currentFocusingEl = document.activeElement;
      if (isTabbing && currentFocusingEl) {
        const container = currentTarget;
        const [first, last] = getEdges(container);
        const isTabbable = first && last;
        if (!isTabbable) {
          if (currentFocusingEl === container) {
            const focusoutPreventedEvent = createFocusOutPreventedEvent({
              focusReason: focusReason2.value
            });
            emit("focusout-prevented", focusoutPreventedEvent);
            if (!focusoutPreventedEvent.defaultPrevented) {
              e.preventDefault();
            }
          }
        } else {
          if (!shiftKey && currentFocusingEl === last) {
            const focusoutPreventedEvent = createFocusOutPreventedEvent({
              focusReason: focusReason2.value
            });
            emit("focusout-prevented", focusoutPreventedEvent);
            if (!focusoutPreventedEvent.defaultPrevented) {
              e.preventDefault();
              if (loop)
                tryFocus(first, true);
            }
          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
            const focusoutPreventedEvent = createFocusOutPreventedEvent({
              focusReason: focusReason2.value
            });
            emit("focusout-prevented", focusoutPreventedEvent);
            if (!focusoutPreventedEvent.defaultPrevented) {
              e.preventDefault();
              if (loop)
                tryFocus(last, true);
            }
          }
        }
      }
    };
    (0, import_vue330.provide)(FOCUS_TRAP_INJECTION_KEY, {
      focusTrapRef: forwardRef,
      onKeydown
    });
    (0, import_vue330.watch)(() => props.focusTrapEl, (focusTrapEl) => {
      if (focusTrapEl) {
        forwardRef.value = focusTrapEl;
      }
    }, { immediate: true });
    (0, import_vue330.watch)([forwardRef], ([forwardRef2], [oldForwardRef]) => {
      if (forwardRef2) {
        forwardRef2.addEventListener("keydown", onKeydown);
        forwardRef2.addEventListener("focusin", onFocusIn);
        forwardRef2.addEventListener("focusout", onFocusOut);
      }
      if (oldForwardRef) {
        oldForwardRef.removeEventListener("keydown", onKeydown);
        oldForwardRef.removeEventListener("focusin", onFocusIn);
        oldForwardRef.removeEventListener("focusout", onFocusOut);
      }
    });
    const trapOnFocus = (e) => {
      emit(ON_TRAP_FOCUS_EVT, e);
    };
    const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
    const onFocusIn = (e) => {
      const trapContainer = (0, import_vue330.unref)(forwardRef);
      if (!trapContainer)
        return;
      const target = e.target;
      const relatedTarget = e.relatedTarget;
      const isFocusedInTrap = target && trapContainer.contains(target);
      if (!props.trapped) {
        const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
        if (!isPrevFocusedInTrap) {
          lastFocusBeforeTrapped = relatedTarget;
        }
      }
      if (isFocusedInTrap)
        emit("focusin", e);
      if (focusLayer.paused)
        return;
      if (props.trapped) {
        if (isFocusedInTrap) {
          lastFocusAfterTrapped = target;
        } else {
          tryFocus(lastFocusAfterTrapped, true);
        }
      }
    };
    const onFocusOut = (e) => {
      const trapContainer = (0, import_vue330.unref)(forwardRef);
      if (focusLayer.paused || !trapContainer)
        return;
      if (props.trapped) {
        const relatedTarget = e.relatedTarget;
        if (!isNil_default(relatedTarget) && !trapContainer.contains(relatedTarget)) {
          setTimeout(() => {
            if (!focusLayer.paused && props.trapped) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason2.value
              });
              emit("focusout-prevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          }, 0);
        }
      } else {
        const target = e.target;
        const isFocusedInTrap = target && trapContainer.contains(target);
        if (!isFocusedInTrap)
          emit("focusout", e);
      }
    };
    async function startTrap() {
      await (0, import_vue330.nextTick)();
      const trapContainer = (0, import_vue330.unref)(forwardRef);
      if (trapContainer) {
        focusableStack.push(focusLayer);
        const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
        lastFocusBeforeTrapped = prevFocusedElement;
        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
        if (!isPrevFocusContained) {
          const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
          trapContainer.dispatchEvent(focusEvent);
          if (!focusEvent.defaultPrevented) {
            (0, import_vue330.nextTick)(() => {
              let focusStartEl = props.focusStartEl;
              if (!(0, import_shared19.isString)(focusStartEl)) {
                tryFocus(focusStartEl);
                if (document.activeElement !== focusStartEl) {
                  focusStartEl = "first";
                }
              }
              if (focusStartEl === "first") {
                focusFirstDescendant(obtainAllFocusableElements2(trapContainer), true);
              }
              if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                tryFocus(trapContainer);
              }
            });
          }
        }
      }
    }
    function stopTrap() {
      const trapContainer = (0, import_vue330.unref)(forwardRef);
      if (trapContainer) {
        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
          ...FOCUS_AFTER_TRAPPED_OPTS,
          detail: {
            focusReason: focusReason2.value
          }
        });
        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
        trapContainer.dispatchEvent(releasedEvent);
        if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent())) {
          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
        }
        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
        focusableStack.remove(focusLayer);
      }
    }
    (0, import_vue330.onMounted)(() => {
      if (props.trapped) {
        startTrap();
      }
      (0, import_vue330.watch)(() => props.trapped, (trapped) => {
        if (trapped) {
          startTrap();
        } else {
          stopTrap();
        }
      });
    });
    (0, import_vue330.onBeforeUnmount)(() => {
      if (props.trapped) {
        stopTrap();
      }
    });
    return {
      onKeydown
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue330.renderSlot)(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
}
var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main11, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/content.mjs
var POSITIONING_STRATEGIES = ["fixed", "absolute"];
var popperCoreConfigProps = buildProps({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: definePropType(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Ee,
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: POSITIONING_STRATEGIES,
    default: "absolute"
  }
});
var popperContentProps = buildProps({
  ...popperCoreConfigProps,
  id: String,
  style: {
    type: definePropType([String, Array, Object])
  },
  className: {
    type: definePropType([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: true
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: false
  },
  trapping: {
    type: Boolean,
    default: false
  },
  popperClass: {
    type: definePropType([String, Array, Object])
  },
  popperStyle: {
    type: definePropType([String, Array, Object])
  },
  referenceEl: {
    type: definePropType(Object)
  },
  triggerTargetEl: {
    type: definePropType(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
});
var popperContentEmits = {
  mouseenter: (evt) => evt instanceof MouseEvent,
  mouseleave: (evt) => evt instanceof MouseEvent,
  focus: () => true,
  blur: () => true,
  close: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/utils.mjs
var buildPopperOptions = (props, arrowProps) => {
  const { placement, strategy, popperOptions } = props;
  const options = {
    placement,
    strategy,
    ...popperOptions,
    modifiers: genModifiers(props)
  };
  attachArrow(options, arrowProps);
  deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
  return options;
};
var unwrapMeasurableEl = ($el) => {
  if (!isClient)
    return;
  return unrefElement($el);
};
function genModifiers(options) {
  const { offset: offset2, gpuAcceleration, fallbackPlacements } = options;
  return [
    {
      name: "offset",
      options: {
        offset: [0, offset2 != null ? offset2 : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration
      }
    }
  ];
}
function attachArrow(options, { arrowEl, arrowOffset }) {
  options.modifiers.push({
    name: "arrow",
    options: {
      element: arrowEl,
      padding: arrowOffset != null ? arrowOffset : 5
    }
  });
}
function deriveExtraModifiers(options, modifiers) {
  if (modifiers) {
    options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
  }
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/src/content2.mjs
var __default__9 = (0, import_vue331.defineComponent)({
  name: "ElPopperContent"
});
var _sfc_main12 = /* @__PURE__ */ (0, import_vue331.defineComponent)({
  ...__default__9,
  props: popperContentProps,
  emits: popperContentEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = (0, import_vue331.inject)(POPPER_INJECTION_KEY, void 0);
    const formItemContext = (0, import_vue331.inject)(formItemContextKey, void 0);
    const { nextZIndex } = useZIndex();
    const ns2 = useNamespace("popper");
    const popperContentRef = (0, import_vue331.ref)();
    const focusStartRef = (0, import_vue331.ref)("first");
    const arrowRef = (0, import_vue331.ref)();
    const arrowOffset = (0, import_vue331.ref)();
    (0, import_vue331.provide)(POPPER_CONTENT_INJECTION_KEY, {
      arrowRef,
      arrowOffset
    });
    if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
      (0, import_vue331.provide)(formItemContextKey, {
        ...formItemContext,
        addInputId: import_shared20.NOOP,
        removeInputId: import_shared20.NOOP
      });
    }
    const contentZIndex = (0, import_vue331.ref)(props.zIndex || nextZIndex());
    const trapped = (0, import_vue331.ref)(false);
    let triggerTargetAriaStopWatch = void 0;
    const computedReference = (0, import_vue331.computed)(() => unwrapMeasurableEl(props.referenceEl) || (0, import_vue331.unref)(triggerRef2));
    const contentStyle = (0, import_vue331.computed)(() => [{ zIndex: (0, import_vue331.unref)(contentZIndex) }, props.popperStyle]);
    const contentClass = (0, import_vue331.computed)(() => [
      ns2.b(),
      ns2.is("pure", props.pure),
      ns2.is(props.effect),
      props.popperClass
    ]);
    const ariaModal = (0, import_vue331.computed)(() => {
      return role && role.value === "dialog" ? "false" : void 0;
    });
    const createPopperInstance = ({
      referenceEl,
      popperContentEl,
      arrowEl
    }) => {
      const options = buildPopperOptions(props, {
        arrowEl,
        arrowOffset: (0, import_vue331.unref)(arrowOffset)
      });
      return yn(referenceEl, popperContentEl, options);
    };
    const updatePopper = (shouldUpdateZIndex = true) => {
      var _a2;
      (_a2 = (0, import_vue331.unref)(popperInstanceRef)) == null ? void 0 : _a2.update();
      shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex());
    };
    const togglePopperAlive = () => {
      var _a2, _b;
      const monitorable = { name: "eventListeners", enabled: props.visible };
      (_b = (_a2 = (0, import_vue331.unref)(popperInstanceRef)) == null ? void 0 : _a2.setOptions) == null ? void 0 : _b.call(_a2, (options) => ({
        ...options,
        modifiers: [...options.modifiers || [], monitorable]
      }));
      updatePopper(false);
      if (props.visible && props.focusOnShow) {
        trapped.value = true;
      } else if (props.visible === false) {
        trapped.value = false;
      }
    };
    const onFocusAfterTrapped = () => {
      emit("focus");
    };
    const onFocusAfterReleased = (event) => {
      var _a2;
      if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
        focusStartRef.value = "first";
        emit("blur");
      }
    };
    const onFocusInTrap = (event) => {
      if (props.visible && !trapped.value) {
        if (event.target) {
          focusStartRef.value = event.target;
        }
        trapped.value = true;
      }
    };
    const onFocusoutPrevented = (event) => {
      if (!props.trapping) {
        if (event.detail.focusReason === "pointer") {
          event.preventDefault();
        }
        trapped.value = false;
      }
    };
    const onReleaseRequested = () => {
      trapped.value = false;
      emit("close");
    };
    (0, import_vue331.onMounted)(() => {
      let updateHandle;
      (0, import_vue331.watch)(computedReference, (referenceEl) => {
        var _a2;
        updateHandle == null ? void 0 : updateHandle();
        const popperInstance = (0, import_vue331.unref)(popperInstanceRef);
        (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);
        if (referenceEl) {
          const popperContentEl = (0, import_vue331.unref)(popperContentRef);
          contentRef.value = popperContentEl;
          popperInstanceRef.value = createPopperInstance({
            referenceEl,
            popperContentEl,
            arrowEl: (0, import_vue331.unref)(arrowRef)
          });
          updateHandle = (0, import_vue331.watch)(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {
            immediate: true
          });
        } else {
          popperInstanceRef.value = void 0;
        }
      }, {
        immediate: true
      });
      (0, import_vue331.watch)(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
        triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
        triggerTargetAriaStopWatch = void 0;
        const el = (0, import_vue331.unref)(triggerTargetEl || popperContentRef.value);
        const prevEl = (0, import_vue331.unref)(prevTriggerTargetEl || popperContentRef.value);
        if (isElement(el)) {
          triggerTargetAriaStopWatch = (0, import_vue331.watch)([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
            ;
            ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
              isNil_default(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
            });
          }, { immediate: true });
        }
        if (prevEl !== el && isElement(prevEl)) {
          ;
          ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
            prevEl.removeAttribute(key);
          });
        }
      }, { immediate: true });
      (0, import_vue331.watch)(() => props.visible, togglePopperAlive, { immediate: true });
      (0, import_vue331.watch)(() => buildPopperOptions(props, {
        arrowEl: (0, import_vue331.unref)(arrowRef),
        arrowOffset: (0, import_vue331.unref)(arrowOffset)
      }), (option2) => {
        var _a2;
        return (_a2 = popperInstanceRef.value) == null ? void 0 : _a2.setOptions(option2);
      });
    });
    (0, import_vue331.onBeforeUnmount)(() => {
      triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
      triggerTargetAriaStopWatch = void 0;
    });
    expose({
      popperContentRef,
      popperInstanceRef,
      updatePopper,
      contentStyle
    });
    return (_ctx, _cache) => {
      return (0, import_vue331.openBlock)(), (0, import_vue331.createElementBlock)("div", {
        ref_key: "popperContentRef",
        ref: popperContentRef,
        style: (0, import_vue331.normalizeStyle)((0, import_vue331.unref)(contentStyle)),
        class: (0, import_vue331.normalizeClass)((0, import_vue331.unref)(contentClass)),
        tabindex: "-1",
        onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
        onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
      }, [
        (0, import_vue331.createVNode)((0, import_vue331.unref)(ElFocusTrap), {
          trapped: trapped.value,
          "trap-on-focus-in": true,
          "focus-trap-el": popperContentRef.value,
          "focus-start-el": focusStartRef.value,
          onFocusAfterTrapped,
          onFocusAfterReleased,
          onFocusin: onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        }, {
          default: (0, import_vue331.withCtx)(() => [
            (0, import_vue331.renderSlot)(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el"])
      ], 38);
    };
  }
});
var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main12, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popper/index.mjs
var ElPopper = withInstall(Popper);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/content.mjs
var ns = useNamespace("tooltip");
var useTooltipContentProps = buildProps({
  ...useDelayedToggleProps,
  ...popperContentProps,
  appendTo: {
    type: definePropType([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: false
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: definePropType(Boolean),
    default: null
  },
  transition: {
    type: String,
    default: `${ns.namespace.value}-fade-in-linear`
  },
  teleported: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/trigger.mjs
var useTooltipTriggerProps = buildProps({
  ...popperTriggerProps,
  disabled: Boolean,
  trigger: {
    type: definePropType([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: definePropType(Array),
    default: () => [EVENT_CODE.enter, EVENT_CODE.space]
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/tooltip.mjs
var {
  useModelToggleProps: useTooltipModelToggleProps,
  useModelToggleEmits: useTooltipModelToggleEmits,
  useModelToggle: useTooltipModelToggle
} = createModelToggleComposable("visible");
var useTooltipProps = buildProps({
  ...popperProps,
  ...useTooltipModelToggleProps,
  ...useTooltipContentProps,
  ...useTooltipTriggerProps,
  ...popperArrowProps,
  showArrow: {
    type: Boolean,
    default: true
  }
});
var tooltipEmits = [
  ...useTooltipModelToggleEmits,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
];

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/trigger2.mjs
var import_vue333 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/utils.mjs
var import_vue332 = require("vue");
var import_shared21 = require("@vue/shared");
var isTriggerType = (trigger, type4) => {
  if ((0, import_shared21.isArray)(trigger)) {
    return trigger.includes(type4);
  }
  return trigger === type4;
};
var whenTrigger = (trigger, type4, handler) => {
  return (e) => {
    isTriggerType((0, import_vue332.unref)(trigger), type4) && handler(e);
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/trigger2.mjs
var __default__10 = (0, import_vue333.defineComponent)({
  name: "ElTooltipTrigger"
});
var _sfc_main13 = /* @__PURE__ */ (0, import_vue333.defineComponent)({
  ...__default__10,
  props: useTooltipTriggerProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("tooltip");
    const { controlled, id: id2, open, onOpen, onClose, onToggle } = (0, import_vue333.inject)(TOOLTIP_INJECTION_KEY, void 0);
    const triggerRef2 = (0, import_vue333.ref)(null);
    const stopWhenControlledOrDisabled = () => {
      if ((0, import_vue333.unref)(controlled) || props.disabled) {
        return true;
      }
    };
    const trigger = (0, import_vue333.toRef)(props, "trigger");
    const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
    const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
    const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
      if (e.button === 0) {
        onToggle(e);
      }
    }));
    const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
    const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
    const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
      e.preventDefault();
      onToggle(e);
    }));
    const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
      const { code } = e;
      if (props.triggerKeys.includes(code)) {
        e.preventDefault();
        onToggle(e);
      }
    });
    expose({
      triggerRef: triggerRef2
    });
    return (_ctx, _cache) => {
      return (0, import_vue333.openBlock)(), (0, import_vue333.createBlock)((0, import_vue333.unref)(ElPopperTrigger), {
        id: (0, import_vue333.unref)(id2),
        "virtual-ref": _ctx.virtualRef,
        open: (0, import_vue333.unref)(open),
        "virtual-triggering": _ctx.virtualTriggering,
        class: (0, import_vue333.normalizeClass)((0, import_vue333.unref)(ns2).e("trigger")),
        onBlur: (0, import_vue333.unref)(onBlur),
        onClick: (0, import_vue333.unref)(onClick),
        onContextmenu: (0, import_vue333.unref)(onContextMenu),
        onFocus: (0, import_vue333.unref)(onFocus),
        onMouseenter: (0, import_vue333.unref)(onMouseenter),
        onMouseleave: (0, import_vue333.unref)(onMouseleave),
        onKeydown: (0, import_vue333.unref)(onKeydown)
      }, {
        default: (0, import_vue333.withCtx)(() => [
          (0, import_vue333.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
    };
  }
});
var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main13, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/content2.mjs
var import_vue334 = require("vue");
var __default__11 = (0, import_vue334.defineComponent)({
  name: "ElTooltipContent",
  inheritAttrs: false
});
var _sfc_main14 = /* @__PURE__ */ (0, import_vue334.defineComponent)({
  ...__default__11,
  props: useTooltipContentProps,
  setup(__props, { expose }) {
    const props = __props;
    const { selector } = usePopperContainerId();
    const contentRef = (0, import_vue334.ref)(null);
    const destroyed = (0, import_vue334.ref)(false);
    const {
      controlled,
      id: id2,
      open,
      trigger,
      onClose,
      onOpen,
      onShow,
      onHide,
      onBeforeShow,
      onBeforeHide
    } = (0, import_vue334.inject)(TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = (0, import_vue334.computed)(() => {
      if (process.env.NODE_ENV === "test") {
        return true;
      }
      return props.persistent;
    });
    (0, import_vue334.onBeforeUnmount)(() => {
      destroyed.value = true;
    });
    const shouldRender = (0, import_vue334.computed)(() => {
      return (0, import_vue334.unref)(persistentRef) ? true : (0, import_vue334.unref)(open);
    });
    const shouldShow = (0, import_vue334.computed)(() => {
      return props.disabled ? false : (0, import_vue334.unref)(open);
    });
    const appendTo = (0, import_vue334.computed)(() => {
      return props.appendTo || selector.value;
    });
    const contentStyle = (0, import_vue334.computed)(() => {
      var _a2;
      return (_a2 = props.style) != null ? _a2 : {};
    });
    const ariaHidden = (0, import_vue334.computed)(() => !(0, import_vue334.unref)(open));
    const onTransitionLeave = () => {
      onHide();
    };
    const stopWhenControlled = () => {
      if ((0, import_vue334.unref)(controlled))
        return true;
    };
    const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable && (0, import_vue334.unref)(trigger) === "hover") {
        onOpen();
      }
    });
    const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
      if ((0, import_vue334.unref)(trigger) === "hover") {
        onClose();
      }
    });
    const onBeforeEnter = () => {
      var _a2, _b;
      (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      onBeforeShow == null ? void 0 : onBeforeShow();
    };
    const onBeforeLeave = () => {
      onBeforeHide == null ? void 0 : onBeforeHide();
    };
    const onAfterShow = () => {
      onShow();
      stopHandle = onClickOutside((0, import_vue334.computed)(() => {
        var _a2;
        return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
      }), () => {
        if ((0, import_vue334.unref)(controlled))
          return;
        const $trigger = (0, import_vue334.unref)(trigger);
        if ($trigger !== "hover") {
          onClose();
        }
      });
    };
    const onBlur = () => {
      if (!props.virtualTriggering) {
        onClose();
      }
    };
    let stopHandle;
    (0, import_vue334.watch)(() => (0, import_vue334.unref)(open), (val) => {
      if (!val) {
        stopHandle == null ? void 0 : stopHandle();
      }
    }, {
      flush: "post"
    });
    (0, import_vue334.watch)(() => props.content, () => {
      var _a2, _b;
      (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
    });
    expose({
      contentRef
    });
    return (_ctx, _cache) => {
      return (0, import_vue334.openBlock)(), (0, import_vue334.createBlock)(import_vue334.Teleport, {
        disabled: !_ctx.teleported,
        to: (0, import_vue334.unref)(appendTo)
      }, [
        (0, import_vue334.createVNode)(import_vue334.Transition, {
          name: _ctx.transition,
          onAfterLeave: onTransitionLeave,
          onBeforeEnter,
          onAfterEnter: onAfterShow,
          onBeforeLeave
        }, {
          default: (0, import_vue334.withCtx)(() => [
            (0, import_vue334.unref)(shouldRender) ? (0, import_vue334.withDirectives)(((0, import_vue334.openBlock)(), (0, import_vue334.createBlock)((0, import_vue334.unref)(ElPopperContent), (0, import_vue334.mergeProps)({
              key: 0,
              id: (0, import_vue334.unref)(id2),
              ref_key: "contentRef",
              ref: contentRef
            }, _ctx.$attrs, {
              "aria-label": _ctx.ariaLabel,
              "aria-hidden": (0, import_vue334.unref)(ariaHidden),
              "boundaries-padding": _ctx.boundariesPadding,
              "fallback-placements": _ctx.fallbackPlacements,
              "gpu-acceleration": _ctx.gpuAcceleration,
              offset: _ctx.offset,
              placement: _ctx.placement,
              "popper-options": _ctx.popperOptions,
              strategy: _ctx.strategy,
              effect: _ctx.effect,
              enterable: _ctx.enterable,
              pure: _ctx.pure,
              "popper-class": _ctx.popperClass,
              "popper-style": [_ctx.popperStyle, (0, import_vue334.unref)(contentStyle)],
              "reference-el": _ctx.referenceEl,
              "trigger-target-el": _ctx.triggerTargetEl,
              visible: (0, import_vue334.unref)(shouldShow),
              "z-index": _ctx.zIndex,
              onMouseenter: (0, import_vue334.unref)(onContentEnter),
              onMouseleave: (0, import_vue334.unref)(onContentLeave),
              onBlur,
              onClose: (0, import_vue334.unref)(onClose)
            }), {
              default: (0, import_vue334.withCtx)(() => [
                !destroyed.value ? (0, import_vue334.renderSlot)(_ctx.$slots, "default", { key: 0 }) : (0, import_vue334.createCommentVNode)("v-if", true)
              ]),
              _: 3
            }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
              [import_vue334.vShow, (0, import_vue334.unref)(shouldShow)]
            ]) : (0, import_vue334.createCommentVNode)("v-if", true)
          ]),
          _: 3
        }, 8, ["name"])
      ], 8, ["disabled", "to"]);
    };
  }
});
var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main14, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/src/tooltip2.mjs
var _hoisted_12 = ["innerHTML"];
var _hoisted_22 = { key: 1 };
var __default__12 = (0, import_vue335.defineComponent)({
  name: "ElTooltip"
});
var _sfc_main15 = /* @__PURE__ */ (0, import_vue335.defineComponent)({
  ...__default__12,
  props: useTooltipProps,
  emits: tooltipEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    usePopperContainer();
    const id2 = useId();
    const popperRef = (0, import_vue335.ref)();
    const contentRef = (0, import_vue335.ref)();
    const updatePopper = () => {
      var _a2;
      const popperComponent = (0, import_vue335.unref)(popperRef);
      if (popperComponent) {
        (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
      }
    };
    const open = (0, import_vue335.ref)(false);
    const toggleReason = (0, import_vue335.ref)();
    const { show, hide: hide2, hasUpdateHandler } = useTooltipModelToggle({
      indicator: open,
      toggleReason
    });
    const { onOpen, onClose } = useDelayedToggle({
      showAfter: (0, import_vue335.toRef)(props, "showAfter"),
      hideAfter: (0, import_vue335.toRef)(props, "hideAfter"),
      open: show,
      close: hide2
    });
    const controlled = (0, import_vue335.computed)(() => isBoolean(props.visible) && !hasUpdateHandler.value);
    (0, import_vue335.provide)(TOOLTIP_INJECTION_KEY, {
      controlled,
      id: id2,
      open: (0, import_vue335.readonly)(open),
      trigger: (0, import_vue335.toRef)(props, "trigger"),
      onOpen: (event) => {
        onOpen(event);
      },
      onClose: (event) => {
        onClose(event);
      },
      onToggle: (event) => {
        if ((0, import_vue335.unref)(open)) {
          onClose(event);
        } else {
          onOpen(event);
        }
      },
      onShow: () => {
        emit("show", toggleReason.value);
      },
      onHide: () => {
        emit("hide", toggleReason.value);
      },
      onBeforeShow: () => {
        emit("before-show", toggleReason.value);
      },
      onBeforeHide: () => {
        emit("before-hide", toggleReason.value);
      },
      updatePopper
    });
    (0, import_vue335.watch)(() => props.disabled, (disabled) => {
      if (disabled && open.value) {
        open.value = false;
      }
    });
    const isFocusInsideContent = () => {
      var _a2, _b;
      const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
      return popperContent && popperContent.contains(document.activeElement);
    };
    (0, import_vue335.onDeactivated)(() => open.value && hide2());
    expose({
      popperRef,
      contentRef,
      isFocusInsideContent,
      updatePopper,
      onOpen,
      onClose,
      hide: hide2
    });
    return (_ctx, _cache) => {
      return (0, import_vue335.openBlock)(), (0, import_vue335.createBlock)((0, import_vue335.unref)(ElPopper), {
        ref_key: "popperRef",
        ref: popperRef,
        role: _ctx.role
      }, {
        default: (0, import_vue335.withCtx)(() => [
          (0, import_vue335.createVNode)(ElTooltipTrigger, {
            disabled: _ctx.disabled,
            trigger: _ctx.trigger,
            "trigger-keys": _ctx.triggerKeys,
            "virtual-ref": _ctx.virtualRef,
            "virtual-triggering": _ctx.virtualTriggering
          }, {
            default: (0, import_vue335.withCtx)(() => [
              _ctx.$slots.default ? (0, import_vue335.renderSlot)(_ctx.$slots, "default", { key: 0 }) : (0, import_vue335.createCommentVNode)("v-if", true)
            ]),
            _: 3
          }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
          (0, import_vue335.createVNode)(ElTooltipContent, {
            ref_key: "contentRef",
            ref: contentRef,
            "aria-label": _ctx.ariaLabel,
            "boundaries-padding": _ctx.boundariesPadding,
            content: _ctx.content,
            disabled: _ctx.disabled,
            effect: _ctx.effect,
            enterable: _ctx.enterable,
            "fallback-placements": _ctx.fallbackPlacements,
            "hide-after": _ctx.hideAfter,
            "gpu-acceleration": _ctx.gpuAcceleration,
            offset: _ctx.offset,
            persistent: _ctx.persistent,
            "popper-class": _ctx.popperClass,
            "popper-style": _ctx.popperStyle,
            placement: _ctx.placement,
            "popper-options": _ctx.popperOptions,
            pure: _ctx.pure,
            "raw-content": _ctx.rawContent,
            "reference-el": _ctx.referenceEl,
            "trigger-target-el": _ctx.triggerTargetEl,
            "show-after": _ctx.showAfter,
            strategy: _ctx.strategy,
            teleported: _ctx.teleported,
            transition: _ctx.transition,
            "virtual-triggering": _ctx.virtualTriggering,
            "z-index": _ctx.zIndex,
            "append-to": _ctx.appendTo
          }, {
            default: (0, import_vue335.withCtx)(() => [
              (0, import_vue335.renderSlot)(_ctx.$slots, "content", {}, () => [
                _ctx.rawContent ? ((0, import_vue335.openBlock)(), (0, import_vue335.createElementBlock)("span", {
                  key: 0,
                  innerHTML: _ctx.content
                }, null, 8, _hoisted_12)) : ((0, import_vue335.openBlock)(), (0, import_vue335.createElementBlock)("span", _hoisted_22, (0, import_vue335.toDisplayString)(_ctx.content), 1))
              ]),
              _ctx.showArrow ? ((0, import_vue335.openBlock)(), (0, import_vue335.createBlock)((0, import_vue335.unref)(ElPopperArrow), {
                key: 0,
                "arrow-offset": _ctx.arrowOffset
              }, null, 8, ["arrow-offset"])) : (0, import_vue335.createCommentVNode)("v-if", true)
            ]),
            _: 3
          }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
        ]),
        _: 3
      }, 8, ["role"]);
    };
  }
});
var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main15, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip/index.mjs
var ElTooltip = withInstall(Tooltip);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/autocomplete/src/autocomplete.mjs
var import_shared22 = require("@vue/shared");
var autocompleteProps = buildProps({
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: definePropType(String),
    values: [
      "top",
      "top-start",
      "top-end",
      "bottom",
      "bottom-start",
      "bottom-end"
    ],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: definePropType([Function, Array]),
    default: import_shared22.NOOP
  },
  popperClass: {
    type: String,
    default: ""
  },
  triggerOnFocus: {
    type: Boolean,
    default: true
  },
  selectWhenUnmatched: {
    type: Boolean,
    default: false
  },
  hideLoading: {
    type: Boolean,
    default: false
  },
  label: {
    type: String
  },
  teleported: useTooltipContentProps.teleported,
  highlightFirstItem: {
    type: Boolean,
    default: false
  },
  fitInputWidth: {
    type: Boolean,
    default: false
  }
});
var autocompleteEmits = {
  [UPDATE_MODEL_EVENT]: (value) => (0, import_shared22.isString)(value),
  [INPUT_EVENT]: (value) => (0, import_shared22.isString)(value),
  [CHANGE_EVENT]: (value) => (0, import_shared22.isString)(value),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  clear: () => true,
  select: (item) => (0, import_shared22.isObject)(item)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/autocomplete/src/autocomplete2.mjs
var import_shared23 = require("@vue/shared");
var _hoisted_13 = ["aria-expanded", "aria-owns"];
var _hoisted_23 = { key: 0 };
var _hoisted_32 = ["id", "aria-selected", "onClick"];
var COMPONENT_NAME4 = "ElAutocomplete";
var __default__13 = (0, import_vue336.defineComponent)({
  name: COMPONENT_NAME4,
  inheritAttrs: false
});
var _sfc_main16 = /* @__PURE__ */ (0, import_vue336.defineComponent)({
  ...__default__13,
  props: autocompleteProps,
  emits: autocompleteEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const attrs = useAttrs();
    const rawAttrs = (0, import_vue336.useAttrs)();
    const disabled = useDisabled();
    const ns2 = useNamespace("autocomplete");
    const inputRef = (0, import_vue336.ref)();
    const regionRef = (0, import_vue336.ref)();
    const popperRef = (0, import_vue336.ref)();
    const listboxRef = (0, import_vue336.ref)();
    let readonly5 = false;
    let ignoreFocusEvent = false;
    const suggestions = (0, import_vue336.ref)([]);
    const highlightedIndex = (0, import_vue336.ref)(-1);
    const dropdownWidth = (0, import_vue336.ref)("");
    const activated = (0, import_vue336.ref)(false);
    const suggestionDisabled = (0, import_vue336.ref)(false);
    const loading = (0, import_vue336.ref)(false);
    const listboxId = (0, import_vue336.computed)(() => ns2.b(String(generateId())));
    const styles = (0, import_vue336.computed)(() => rawAttrs.style);
    const suggestionVisible = (0, import_vue336.computed)(() => {
      const isValidData = suggestions.value.length > 0;
      return (isValidData || loading.value) && activated.value;
    });
    const suggestionLoading = (0, import_vue336.computed)(() => !props.hideLoading && loading.value);
    const refInput = (0, import_vue336.computed)(() => {
      if (inputRef.value) {
        return Array.from(inputRef.value.$el.querySelectorAll("input"));
      }
      return [];
    });
    const onSuggestionShow = async () => {
      await (0, import_vue336.nextTick)();
      if (suggestionVisible.value) {
        dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
      }
    };
    const onShow = () => {
      ignoreFocusEvent = true;
    };
    const onHide = () => {
      ignoreFocusEvent = false;
      highlightedIndex.value = -1;
    };
    const getData = async (queryString) => {
      if (suggestionDisabled.value)
        return;
      const cb = (suggestionList) => {
        loading.value = false;
        if (suggestionDisabled.value)
          return;
        if ((0, import_shared23.isArray)(suggestionList)) {
          suggestions.value = suggestionList;
          highlightedIndex.value = props.highlightFirstItem ? 0 : -1;
        } else {
          throwError(COMPONENT_NAME4, "autocomplete suggestions must be an array");
        }
      };
      loading.value = true;
      if ((0, import_shared23.isArray)(props.fetchSuggestions)) {
        cb(props.fetchSuggestions);
      } else {
        const result = await props.fetchSuggestions(queryString, cb);
        if ((0, import_shared23.isArray)(result))
          cb(result);
      }
    };
    const debouncedGetData = debounce_default(getData, props.debounce);
    const handleInput = (value) => {
      const valuePresented = !!value;
      emit(INPUT_EVENT, value);
      emit(UPDATE_MODEL_EVENT, value);
      suggestionDisabled.value = false;
      activated.value || (activated.value = valuePresented);
      if (!props.triggerOnFocus && !value) {
        suggestionDisabled.value = true;
        suggestions.value = [];
        return;
      }
      debouncedGetData(value);
    };
    const handleMouseDown = (event) => {
      var _a2;
      if (disabled.value)
        return;
      if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
        activated.value = true;
      }
    };
    const handleChange = (value) => {
      emit(CHANGE_EVENT, value);
    };
    const handleFocus = (evt) => {
      if (ignoreFocusEvent)
        return;
      activated.value = true;
      emit("focus", evt);
      if (props.triggerOnFocus && !readonly5) {
        debouncedGetData(String(props.modelValue));
      }
    };
    const handleBlur = (evt) => {
      if (ignoreFocusEvent)
        return;
      emit("blur", evt);
    };
    const handleClear = () => {
      activated.value = false;
      emit(UPDATE_MODEL_EVENT, "");
      emit("clear");
    };
    const handleKeyEnter = async () => {
      if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) {
        handleSelect(suggestions.value[highlightedIndex.value]);
      } else if (props.selectWhenUnmatched) {
        emit("select", { value: props.modelValue });
        suggestions.value = [];
        highlightedIndex.value = -1;
      }
    };
    const handleKeyEscape = (evt) => {
      if (suggestionVisible.value) {
        evt.preventDefault();
        evt.stopPropagation();
        close2();
      }
    };
    const close2 = () => {
      activated.value = false;
    };
    const focus = () => {
      var _a2;
      (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
    };
    const handleSelect = async (item) => {
      emit(INPUT_EVENT, item[props.valueKey]);
      emit(UPDATE_MODEL_EVENT, item[props.valueKey]);
      emit("select", item);
      suggestions.value = [];
      highlightedIndex.value = -1;
    };
    const highlight = (index2) => {
      if (!suggestionVisible.value || loading.value)
        return;
      if (index2 < 0) {
        highlightedIndex.value = -1;
        return;
      }
      if (index2 >= suggestions.value.length) {
        index2 = suggestions.value.length - 1;
      }
      const suggestion = regionRef.value.querySelector(`.${ns2.be("suggestion", "wrap")}`);
      const suggestionList = suggestion.querySelectorAll(`.${ns2.be("suggestion", "list")} li`);
      const highlightItem = suggestionList[index2];
      const scrollTop = suggestion.scrollTop;
      const { offsetTop, scrollHeight } = highlightItem;
      if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) {
        suggestion.scrollTop += scrollHeight;
      }
      if (offsetTop < scrollTop) {
        suggestion.scrollTop -= scrollHeight;
      }
      highlightedIndex.value = index2;
      inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
    };
    onClickOutside(listboxRef, () => {
      suggestionVisible.value && close2();
    });
    (0, import_vue336.onMounted)(() => {
      ;
      inputRef.value.ref.setAttribute("role", "textbox");
      inputRef.value.ref.setAttribute("aria-autocomplete", "list");
      inputRef.value.ref.setAttribute("aria-controls", "id");
      inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
      readonly5 = inputRef.value.ref.hasAttribute("readonly");
    });
    expose({
      highlightedIndex,
      activated,
      loading,
      inputRef,
      popperRef,
      suggestions,
      handleSelect,
      handleKeyEnter,
      focus,
      blur,
      close: close2,
      highlight
    });
    return (_ctx, _cache) => {
      return (0, import_vue336.openBlock)(), (0, import_vue336.createBlock)((0, import_vue336.unref)(ElTooltip), {
        ref_key: "popperRef",
        ref: popperRef,
        visible: (0, import_vue336.unref)(suggestionVisible),
        placement: _ctx.placement,
        "fallback-placements": ["bottom-start", "top-start"],
        "popper-class": [(0, import_vue336.unref)(ns2).e("popper"), _ctx.popperClass],
        teleported: _ctx.teleported,
        "gpu-acceleration": false,
        pure: "",
        "manual-mode": "",
        effect: "light",
        trigger: "click",
        transition: `${(0, import_vue336.unref)(ns2).namespace.value}-zoom-in-top`,
        persistent: "",
        onBeforeShow: onSuggestionShow,
        onShow,
        onHide
      }, {
        content: (0, import_vue336.withCtx)(() => [
          (0, import_vue336.createElementVNode)("div", {
            ref_key: "regionRef",
            ref: regionRef,
            class: (0, import_vue336.normalizeClass)([(0, import_vue336.unref)(ns2).b("suggestion"), (0, import_vue336.unref)(ns2).is("loading", (0, import_vue336.unref)(suggestionLoading))]),
            style: (0, import_vue336.normalizeStyle)({
              [_ctx.fitInputWidth ? "width" : "minWidth"]: dropdownWidth.value,
              outline: "none"
            }),
            role: "region"
          }, [
            (0, import_vue336.createVNode)((0, import_vue336.unref)(ElScrollbar), {
              id: (0, import_vue336.unref)(listboxId),
              tag: "ul",
              "wrap-class": (0, import_vue336.unref)(ns2).be("suggestion", "wrap"),
              "view-class": (0, import_vue336.unref)(ns2).be("suggestion", "list"),
              role: "listbox"
            }, {
              default: (0, import_vue336.withCtx)(() => [
                (0, import_vue336.unref)(suggestionLoading) ? ((0, import_vue336.openBlock)(), (0, import_vue336.createElementBlock)("li", _hoisted_23, [
                  (0, import_vue336.createVNode)((0, import_vue336.unref)(ElIcon), {
                    class: (0, import_vue336.normalizeClass)((0, import_vue336.unref)(ns2).is("loading"))
                  }, {
                    default: (0, import_vue336.withCtx)(() => [
                      (0, import_vue336.createVNode)((0, import_vue336.unref)(loading_default))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])) : ((0, import_vue336.openBlock)(true), (0, import_vue336.createElementBlock)(import_vue336.Fragment, { key: 1 }, (0, import_vue336.renderList)(suggestions.value, (item, index2) => {
                  return (0, import_vue336.openBlock)(), (0, import_vue336.createElementBlock)("li", {
                    id: `${(0, import_vue336.unref)(listboxId)}-item-${index2}`,
                    key: index2,
                    class: (0, import_vue336.normalizeClass)({ highlighted: highlightedIndex.value === index2 }),
                    role: "option",
                    "aria-selected": highlightedIndex.value === index2,
                    onClick: ($event) => handleSelect(item)
                  }, [
                    (0, import_vue336.renderSlot)(_ctx.$slots, "default", { item }, () => [
                      (0, import_vue336.createTextVNode)((0, import_vue336.toDisplayString)(item[_ctx.valueKey]), 1)
                    ])
                  ], 10, _hoisted_32);
                }), 128))
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class"])
          ], 6)
        ]),
        default: (0, import_vue336.withCtx)(() => [
          (0, import_vue336.createElementVNode)("div", {
            ref_key: "listboxRef",
            ref: listboxRef,
            class: (0, import_vue336.normalizeClass)([(0, import_vue336.unref)(ns2).b(), _ctx.$attrs.class]),
            style: (0, import_vue336.normalizeStyle)((0, import_vue336.unref)(styles)),
            role: "combobox",
            "aria-haspopup": "listbox",
            "aria-expanded": (0, import_vue336.unref)(suggestionVisible),
            "aria-owns": (0, import_vue336.unref)(listboxId)
          }, [
            (0, import_vue336.createVNode)((0, import_vue336.unref)(ElInput), (0, import_vue336.mergeProps)({
              ref_key: "inputRef",
              ref: inputRef
            }, (0, import_vue336.unref)(attrs), {
              "model-value": _ctx.modelValue,
              onInput: handleInput,
              onChange: handleChange,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onClear: handleClear,
              onKeydown: [
                _cache[0] || (_cache[0] = (0, import_vue336.withKeys)((0, import_vue336.withModifiers)(($event) => highlight(highlightedIndex.value - 1), ["prevent"]), ["up"])),
                _cache[1] || (_cache[1] = (0, import_vue336.withKeys)((0, import_vue336.withModifiers)(($event) => highlight(highlightedIndex.value + 1), ["prevent"]), ["down"])),
                (0, import_vue336.withKeys)(handleKeyEnter, ["enter"]),
                (0, import_vue336.withKeys)(close2, ["tab"]),
                (0, import_vue336.withKeys)(handleKeyEscape, ["esc"])
              ],
              onMousedown: handleMouseDown
            }), (0, import_vue336.createSlots)({ _: 2 }, [
              _ctx.$slots.prepend ? {
                name: "prepend",
                fn: (0, import_vue336.withCtx)(() => [
                  (0, import_vue336.renderSlot)(_ctx.$slots, "prepend")
                ])
              } : void 0,
              _ctx.$slots.append ? {
                name: "append",
                fn: (0, import_vue336.withCtx)(() => [
                  (0, import_vue336.renderSlot)(_ctx.$slots, "append")
                ])
              } : void 0,
              _ctx.$slots.prefix ? {
                name: "prefix",
                fn: (0, import_vue336.withCtx)(() => [
                  (0, import_vue336.renderSlot)(_ctx.$slots, "prefix")
                ])
              } : void 0,
              _ctx.$slots.suffix ? {
                name: "suffix",
                fn: (0, import_vue336.withCtx)(() => [
                  (0, import_vue336.renderSlot)(_ctx.$slots, "suffix")
                ])
              } : void 0
            ]), 1040, ["model-value", "onKeydown"])
          ], 14, _hoisted_13)
        ]),
        _: 3
      }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]);
    };
  }
});
var Autocomplete = /* @__PURE__ */ _export_sfc(_sfc_main16, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/autocomplete/index.mjs
var ElAutocomplete = withInstall(Autocomplete);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/avatar/src/avatar2.mjs
var import_vue337 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/avatar/src/avatar.mjs
var avatarProps = buildProps({
  size: {
    type: [Number, String],
    values: componentSizes,
    default: "",
    validator: (val) => isNumber(val)
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: iconPropType
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: definePropType(String),
    default: "cover"
  }
});
var avatarEmits = {
  error: (evt) => evt instanceof Event
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/avatar/src/avatar2.mjs
var import_shared24 = require("@vue/shared");
var _hoisted_14 = ["src", "alt", "srcset"];
var __default__14 = (0, import_vue337.defineComponent)({
  name: "ElAvatar"
});
var _sfc_main17 = /* @__PURE__ */ (0, import_vue337.defineComponent)({
  ...__default__14,
  props: avatarProps,
  emits: avatarEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("avatar");
    const hasLoadError = (0, import_vue337.ref)(false);
    const avatarClass = (0, import_vue337.computed)(() => {
      const { size: size2, icon, shape } = props;
      const classList = [ns2.b()];
      if ((0, import_shared24.isString)(size2))
        classList.push(ns2.m(size2));
      if (icon)
        classList.push(ns2.m("icon"));
      if (shape)
        classList.push(ns2.m(shape));
      return classList;
    });
    const sizeStyle = (0, import_vue337.computed)(() => {
      const { size: size2 } = props;
      return isNumber(size2) ? ns2.cssVarBlock({
        size: addUnit(size2) || ""
      }) : void 0;
    });
    const fitStyle = (0, import_vue337.computed)(() => ({
      objectFit: props.fit
    }));
    (0, import_vue337.watch)(() => props.src, () => hasLoadError.value = false);
    function handleError(e) {
      hasLoadError.value = true;
      emit("error", e);
    }
    return (_ctx, _cache) => {
      return (0, import_vue337.openBlock)(), (0, import_vue337.createElementBlock)("span", {
        class: (0, import_vue337.normalizeClass)((0, import_vue337.unref)(avatarClass)),
        style: (0, import_vue337.normalizeStyle)((0, import_vue337.unref)(sizeStyle))
      }, [
        (_ctx.src || _ctx.srcSet) && !hasLoadError.value ? ((0, import_vue337.openBlock)(), (0, import_vue337.createElementBlock)("img", {
          key: 0,
          src: _ctx.src,
          alt: _ctx.alt,
          srcset: _ctx.srcSet,
          style: (0, import_vue337.normalizeStyle)((0, import_vue337.unref)(fitStyle)),
          onError: handleError
        }, null, 44, _hoisted_14)) : _ctx.icon ? ((0, import_vue337.openBlock)(), (0, import_vue337.createBlock)((0, import_vue337.unref)(ElIcon), { key: 1 }, {
          default: (0, import_vue337.withCtx)(() => [
            ((0, import_vue337.openBlock)(), (0, import_vue337.createBlock)((0, import_vue337.resolveDynamicComponent)(_ctx.icon)))
          ]),
          _: 1
        })) : (0, import_vue337.renderSlot)(_ctx.$slots, "default", { key: 2 })
      ], 6);
    };
  }
});
var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main17, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/avatar/index.mjs
var ElAvatar = withInstall(Avatar);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/backtop/src/backtop2.mjs
var import_vue339 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/backtop/src/backtop.mjs
var backtopProps = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
};
var backtopEmits = {
  click: (evt) => evt instanceof MouseEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/backtop/src/use-backtop.mjs
var import_vue338 = require("vue");
var useBackTop = (props, emit, componentName2) => {
  const el = (0, import_vue338.shallowRef)();
  const container = (0, import_vue338.shallowRef)();
  const visible = (0, import_vue338.ref)(false);
  const scrollToTop = () => {
    if (!el.value)
      return;
    const beginTime = Date.now();
    const beginValue = el.value.scrollTop;
    const frameFunc = () => {
      if (!el.value)
        return;
      const progress = (Date.now() - beginTime) / 500;
      if (progress < 1) {
        el.value.scrollTop = beginValue * (1 - easeInOutCubic(progress));
        requestAnimationFrame(frameFunc);
      } else {
        el.value.scrollTop = 0;
      }
    };
    requestAnimationFrame(frameFunc);
  };
  const handleScroll2 = () => {
    if (el.value)
      visible.value = el.value.scrollTop >= props.visibilityHeight;
  };
  const handleClick = (event) => {
    scrollToTop();
    emit("click", event);
  };
  const handleScrollThrottled = useThrottleFn(handleScroll2, 300, true);
  useEventListener(container, "scroll", handleScrollThrottled);
  (0, import_vue338.onMounted)(() => {
    var _a2;
    container.value = document;
    el.value = document.documentElement;
    if (props.target) {
      el.value = (_a2 = document.querySelector(props.target)) != null ? _a2 : void 0;
      if (!el.value) {
        throwError(componentName2, `target does not exist: ${props.target}`);
      }
      container.value = el.value;
    }
  });
  return {
    visible,
    handleClick
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/backtop/src/backtop2.mjs
var COMPONENT_NAME5 = "ElBacktop";
var __default__15 = (0, import_vue339.defineComponent)({
  name: COMPONENT_NAME5
});
var _sfc_main18 = /* @__PURE__ */ (0, import_vue339.defineComponent)({
  ...__default__15,
  props: backtopProps,
  emits: backtopEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("backtop");
    const { handleClick, visible } = useBackTop(props, emit, COMPONENT_NAME5);
    const backTopStyle = (0, import_vue339.computed)(() => ({
      right: `${props.right}px`,
      bottom: `${props.bottom}px`
    }));
    return (_ctx, _cache) => {
      return (0, import_vue339.openBlock)(), (0, import_vue339.createBlock)(import_vue339.Transition, {
        name: `${(0, import_vue339.unref)(ns2).namespace.value}-fade-in`
      }, {
        default: (0, import_vue339.withCtx)(() => [
          (0, import_vue339.unref)(visible) ? ((0, import_vue339.openBlock)(), (0, import_vue339.createElementBlock)("div", {
            key: 0,
            style: (0, import_vue339.normalizeStyle)((0, import_vue339.unref)(backTopStyle)),
            class: (0, import_vue339.normalizeClass)((0, import_vue339.unref)(ns2).b()),
            onClick: _cache[0] || (_cache[0] = (0, import_vue339.withModifiers)((...args) => (0, import_vue339.unref)(handleClick) && (0, import_vue339.unref)(handleClick)(...args), ["stop"]))
          }, [
            (0, import_vue339.renderSlot)(_ctx.$slots, "default", {}, () => [
              (0, import_vue339.createVNode)((0, import_vue339.unref)(ElIcon), {
                class: (0, import_vue339.normalizeClass)((0, import_vue339.unref)(ns2).e("icon"))
              }, {
                default: (0, import_vue339.withCtx)(() => [
                  (0, import_vue339.createVNode)((0, import_vue339.unref)(caret_top_default))
                ]),
                _: 1
              }, 8, ["class"])
            ])
          ], 6)) : (0, import_vue339.createCommentVNode)("v-if", true)
        ]),
        _: 3
      }, 8, ["name"]);
    };
  }
});
var Backtop = /* @__PURE__ */ _export_sfc(_sfc_main18, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/backtop/index.mjs
var ElBacktop = withInstall(Backtop);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/badge/src/badge2.mjs
var import_vue340 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/badge/src/badge.mjs
var badgeProps = buildProps({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/badge/src/badge2.mjs
var _hoisted_15 = ["textContent"];
var __default__16 = (0, import_vue340.defineComponent)({
  name: "ElBadge"
});
var _sfc_main19 = /* @__PURE__ */ (0, import_vue340.defineComponent)({
  ...__default__16,
  props: badgeProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("badge");
    const content = (0, import_vue340.computed)(() => {
      if (props.isDot)
        return "";
      if (isNumber(props.value) && isNumber(props.max)) {
        return props.max < props.value ? `${props.max}+` : `${props.value}`;
      }
      return `${props.value}`;
    });
    expose({
      content
    });
    return (_ctx, _cache) => {
      return (0, import_vue340.openBlock)(), (0, import_vue340.createElementBlock)("div", {
        class: (0, import_vue340.normalizeClass)((0, import_vue340.unref)(ns2).b())
      }, [
        (0, import_vue340.renderSlot)(_ctx.$slots, "default"),
        (0, import_vue340.createVNode)(import_vue340.Transition, {
          name: `${(0, import_vue340.unref)(ns2).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: (0, import_vue340.withCtx)(() => [
            (0, import_vue340.withDirectives)((0, import_vue340.createElementVNode)("sup", {
              class: (0, import_vue340.normalizeClass)([
                (0, import_vue340.unref)(ns2).e("content"),
                (0, import_vue340.unref)(ns2).em("content", _ctx.type),
                (0, import_vue340.unref)(ns2).is("fixed", !!_ctx.$slots.default),
                (0, import_vue340.unref)(ns2).is("dot", _ctx.isDot)
              ]),
              textContent: (0, import_vue340.toDisplayString)((0, import_vue340.unref)(content))
            }, null, 10, _hoisted_15), [
              [import_vue340.vShow, !_ctx.hidden && ((0, import_vue340.unref)(content) || _ctx.isDot)]
            ])
          ]),
          _: 1
        }, 8, ["name"])
      ], 2);
    };
  }
});
var Badge = /* @__PURE__ */ _export_sfc(_sfc_main19, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/badge/index.mjs
var ElBadge = withInstall(Badge);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/src/breadcrumb2.mjs
var import_vue341 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/src/breadcrumb.mjs
var breadcrumbProps = buildProps({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: iconPropType
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/src/breadcrumb2.mjs
var __default__17 = (0, import_vue341.defineComponent)({
  name: "ElBreadcrumb"
});
var _sfc_main20 = /* @__PURE__ */ (0, import_vue341.defineComponent)({
  ...__default__17,
  props: breadcrumbProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("breadcrumb");
    const breadcrumb = (0, import_vue341.ref)();
    (0, import_vue341.provide)(breadcrumbKey, props);
    (0, import_vue341.onMounted)(() => {
      const items = breadcrumb.value.querySelectorAll(`.${ns2.e("item")}`);
      if (items.length) {
        items[items.length - 1].setAttribute("aria-current", "page");
      }
    });
    return (_ctx, _cache) => {
      return (0, import_vue341.openBlock)(), (0, import_vue341.createElementBlock)("div", {
        ref_key: "breadcrumb",
        ref: breadcrumb,
        class: (0, import_vue341.normalizeClass)((0, import_vue341.unref)(ns2).b()),
        "aria-label": "Breadcrumb",
        role: "navigation"
      }, [
        (0, import_vue341.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Breadcrumb = /* @__PURE__ */ _export_sfc(_sfc_main20, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/src/breadcrumb-item2.mjs
var import_vue342 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/src/breadcrumb-item.mjs
var breadcrumbItemProps = buildProps({
  to: {
    type: definePropType([String, Object]),
    default: ""
  },
  replace: {
    type: Boolean,
    default: false
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/src/breadcrumb-item2.mjs
var __default__18 = (0, import_vue342.defineComponent)({
  name: "ElBreadcrumbItem"
});
var _sfc_main21 = /* @__PURE__ */ (0, import_vue342.defineComponent)({
  ...__default__18,
  props: breadcrumbItemProps,
  setup(__props) {
    const props = __props;
    const instance = (0, import_vue342.getCurrentInstance)();
    const breadcrumbContext = (0, import_vue342.inject)(breadcrumbKey, void 0);
    const ns2 = useNamespace("breadcrumb");
    const { separator, separatorIcon } = (0, import_vue342.toRefs)(breadcrumbContext);
    const router = instance.appContext.config.globalProperties.$router;
    const link = (0, import_vue342.ref)();
    const onClick = () => {
      if (!props.to || !router)
        return;
      props.replace ? router.replace(props.to) : router.push(props.to);
    };
    return (_ctx, _cache) => {
      return (0, import_vue342.openBlock)(), (0, import_vue342.createElementBlock)("span", {
        class: (0, import_vue342.normalizeClass)((0, import_vue342.unref)(ns2).e("item"))
      }, [
        (0, import_vue342.createElementVNode)("span", {
          ref_key: "link",
          ref: link,
          class: (0, import_vue342.normalizeClass)([(0, import_vue342.unref)(ns2).e("inner"), (0, import_vue342.unref)(ns2).is("link", !!_ctx.to)]),
          role: "link",
          onClick
        }, [
          (0, import_vue342.renderSlot)(_ctx.$slots, "default")
        ], 2),
        (0, import_vue342.unref)(separatorIcon) ? ((0, import_vue342.openBlock)(), (0, import_vue342.createBlock)((0, import_vue342.unref)(ElIcon), {
          key: 0,
          class: (0, import_vue342.normalizeClass)((0, import_vue342.unref)(ns2).e("separator"))
        }, {
          default: (0, import_vue342.withCtx)(() => [
            ((0, import_vue342.openBlock)(), (0, import_vue342.createBlock)((0, import_vue342.resolveDynamicComponent)((0, import_vue342.unref)(separatorIcon))))
          ]),
          _: 1
        }, 8, ["class"])) : ((0, import_vue342.openBlock)(), (0, import_vue342.createElementBlock)("span", {
          key: 1,
          class: (0, import_vue342.normalizeClass)((0, import_vue342.unref)(ns2).e("separator")),
          role: "presentation"
        }, (0, import_vue342.toDisplayString)((0, import_vue342.unref)(separator)), 3))
      ], 2);
    };
  }
});
var BreadcrumbItem = /* @__PURE__ */ _export_sfc(_sfc_main21, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/breadcrumb/index.mjs
var ElBreadcrumb = withInstall(Breadcrumb, {
  BreadcrumbItem
});
var ElBreadcrumbItem = withNoopInstall(BreadcrumbItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button2.mjs
var import_vue345 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/use-button.mjs
var import_vue343 = require("vue");
var useButton = (props, emit) => {
  useDeprecated({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, (0, import_vue343.computed)(() => props.type === "text"));
  const buttonGroupContext = (0, import_vue343.inject)(buttonGroupContextKey, void 0);
  const globalConfig2 = useGlobalConfig("button");
  const { form } = useFormItem();
  const _size = useSize((0, import_vue343.computed)(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
  const _disabled = useDisabled();
  const _ref = (0, import_vue343.ref)();
  const slots = (0, import_vue343.useSlots)();
  const _type = (0, import_vue343.computed)(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
  const autoInsertSpace = (0, import_vue343.computed)(() => {
    var _a2, _b, _c;
    return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
  });
  const shouldAddSpace = (0, import_vue343.computed)(() => {
    var _a2;
    const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
    if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
      const slot = defaultSlot[0];
      if ((slot == null ? void 0 : slot.type) === import_vue343.Text) {
        const text = slot.children;
        return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
      }
    }
    return false;
  });
  const handleClick = (evt) => {
    if (props.nativeType === "reset") {
      form == null ? void 0 : form.resetFields();
    }
    emit("click", evt);
  };
  return {
    _disabled,
    _size,
    _type,
    _ref,
    shouldAddSpace,
    handleClick
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button.mjs
var buttonTypes = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
];
var buttonNativeTypes = ["button", "submit", "reset"];
var buttonProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  type: {
    type: String,
    values: buttonTypes,
    default: ""
  },
  icon: {
    type: iconPropType
  },
  nativeType: {
    type: String,
    values: buttonNativeTypes,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: iconPropType,
    default: () => loading_default
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  }
});
var buttonEmits = {
  click: (evt) => evt instanceof MouseEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button-custom.mjs
var import_vue344 = require("vue");

// ../../node_modules/.pnpm/@ctrl+tinycolor@3.4.1/node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n, max4) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max4 === 360 ? n : Math.min(max4, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max4), 10) / 100;
  }
  if (Math.abs(n - max4) < 1e-6) {
    return 1;
  }
  if (max4 === 360) {
    n = (n < 0 ? n % max4 + max4 : n % max4) / parseFloat(String(max4));
  } else {
    n = n % max4 / parseFloat(String(max4));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}

// ../../node_modules/.pnpm/@ctrl+tinycolor@3.4.1/node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r, g, b3) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b3, 255) * 255
  };
}
function rgbToHsl(r, g, b3) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b3 = bound01(b3, 255);
  var max4 = Math.max(r, g, b3);
  var min4 = Math.min(r, g, b3);
  var h29 = 0;
  var s2 = 0;
  var l2 = (max4 + min4) / 2;
  if (max4 === min4) {
    s2 = 0;
    h29 = 0;
  } else {
    var d2 = max4 - min4;
    s2 = l2 > 0.5 ? d2 / (2 - max4 - min4) : d2 / (max4 + min4);
    switch (max4) {
      case r:
        h29 = (g - b3) / d2 + (g < b3 ? 6 : 0);
        break;
      case g:
        h29 = (b3 - r) / d2 + 2;
        break;
      case b3:
        h29 = (r - g) / d2 + 4;
        break;
      default:
        break;
    }
    h29 /= 6;
  }
  return { h: h29, s: s2, l: l2 };
}
function hue2rgb(p2, q2, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t);
  }
  if (t < 1 / 2) {
    return q2;
  }
  if (t < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t) * 6;
  }
  return p2;
}
function hslToRgb(h29, s2, l2) {
  var r;
  var g;
  var b3;
  h29 = bound01(h29, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g = l2;
    b3 = l2;
    r = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r = hue2rgb(p2, q2, h29 + 1 / 3);
    g = hue2rgb(p2, q2, h29);
    b3 = hue2rgb(p2, q2, h29 - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b3 * 255 };
}
function rgbToHsv(r, g, b3) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b3 = bound01(b3, 255);
  var max4 = Math.max(r, g, b3);
  var min4 = Math.min(r, g, b3);
  var h29 = 0;
  var v3 = max4;
  var d2 = max4 - min4;
  var s2 = max4 === 0 ? 0 : d2 / max4;
  if (max4 === min4) {
    h29 = 0;
  } else {
    switch (max4) {
      case r:
        h29 = (g - b3) / d2 + (g < b3 ? 6 : 0);
        break;
      case g:
        h29 = (b3 - r) / d2 + 2;
        break;
      case b3:
        h29 = (r - g) / d2 + 4;
        break;
      default:
        break;
    }
    h29 /= 6;
  }
  return { h: h29, s: s2, v: v3 };
}
function hsvToRgb(h29, s2, v3) {
  h29 = bound01(h29, 360) * 6;
  s2 = bound01(s2, 100);
  v3 = bound01(v3, 100);
  var i = Math.floor(h29);
  var f2 = h29 - i;
  var p2 = v3 * (1 - s2);
  var q2 = v3 * (1 - f2 * s2);
  var t = v3 * (1 - (1 - f2) * s2);
  var mod = i % 6;
  var r = [v3, q2, p2, p2, t, v3][mod];
  var g = [t, v3, v3, q2, p2, p2][mod];
  var b3 = [p2, p2, t, v3, v3, q2][mod];
  return { r: r * 255, g: g * 255, b: b3 * 255 };
}
function rgbToHex(r, g, b3, allow3Char) {
  var hex2 = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b3).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r, g, b3, a3, allow4Char) {
  var hex2 = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b3).toString(16)),
    pad2(convertDecimalToHex(a3))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h29) {
  return parseIntFromHex(h29) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}

// ../../node_modules/.pnpm/@ctrl+tinycolor@3.4.1/node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

// ../../node_modules/.pnpm/@ctrl+tinycolor@3.4.1/node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a3 = 1;
  var s2 = null;
  var v3 = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v3 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v3);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a3 = color.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a3
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}

// ../../node_modules/.pnpm/@ctrl+tinycolor@3.4.1/node_modules/@ctrl/tinycolor/dist/module/index.js
var TinyColor = (
  /** @class */
  function() {
    function TinyColor2(color, opts) {
      if (color === void 0) {
        color = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a2;
      if (color instanceof TinyColor2) {
        return color;
      }
      if (typeof color === "number") {
        color = numberInputToObject(color);
      }
      this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R2;
      var G2;
      var B3;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R2 = RsRGB / 12.92;
      } else {
        R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G2 = GsRGB / 12.92;
      } else {
        G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B3 = BsRGB / 12.92;
      } else {
        B3 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B3;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h29 = Math.round(hsv.h * 360);
      var s2 = Math.round(hsv.s * 100);
      var v3 = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h29, ", ").concat(s2, "%, ").concat(v3, "%)") : "hsva(".concat(h29, ", ").concat(s2, "%, ").concat(v3, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h29 = Math.round(hsl.h * 360);
      var s2 = Math.round(hsl.s * 100);
      var l2 = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h29, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h29, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r = Math.round(this.r);
      var g = Math.round(this.g);
      var b3 = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b3, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b3, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x3) {
        return "".concat(Math.round(bound01(x3, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x3) {
        return Math.round(bound01(x3, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
        var _b = _a2[_i], key = _b[0], value = _b[1];
        if (hex2 === value) {
          return key;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format2) {
      var formatSet = Boolean(format2);
      format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
      if (needsAlphaFormat) {
        if (format2 === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format2 === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format2 === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format2 === "hex" || format2 === "hex6") {
        formattedString = this.toHexString();
      }
      if (format2 === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format2 === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format2 === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format2 === "name") {
        formattedString = this.toName();
      }
      if (format2 === "hsl") {
        formattedString = this.toHslString();
      }
      if (format2 === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h29 = hsv.h;
      var s2 = hsv.s;
      var v3 = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h: h29, s: s2, v: v3 }));
        v3 = (v3 + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h29 = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h29 + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h29 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      return new TinyColor2({
        r: bg.r + (fg.r - bg.r) * fg.a,
        g: bg.g + (fg.g - bg.g) * fg.a,
        b: bg.b + (fg.b - bg.b) * fg.a
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n) {
      var hsl = this.toHsl();
      var h29 = hsl.h;
      var result = [this];
      var increment = 360 / n;
      for (var i = 1; i < n; i++) {
        result.push(new TinyColor2({ h: (h29 + i * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color) {
      return this.toRgbString() === new TinyColor2(color).toRgbString();
    };
    return TinyColor2;
  }()
);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button-custom.mjs
function darken(color, amount = 20) {
  return color.mix("#141414", amount).toString();
}
function useButtonCustomStyle(props) {
  const _disabled = useDisabled();
  const ns2 = useNamespace("button");
  return (0, import_vue344.computed)(() => {
    let styles = {};
    const buttonColor = props.color;
    if (buttonColor) {
      const color = new TinyColor(buttonColor);
      const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
      if (props.plain) {
        styles = ns2.cssVarBlock({
          "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
          "text-color": buttonColor,
          "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
          "hover-text-color": `var(${ns2.cssVarName("color-white")})`,
          "hover-bg-color": buttonColor,
          "hover-border-color": buttonColor,
          "active-bg-color": activeBgColor,
          "active-text-color": `var(${ns2.cssVarName("color-white")})`,
          "active-border-color": activeBgColor
        });
        if (_disabled.value) {
          styles[ns2.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
          styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns2.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
        }
      } else {
        const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
        const textColor = color.isDark() ? `var(${ns2.cssVarName("color-white")})` : `var(${ns2.cssVarName("color-black")})`;
        styles = ns2.cssVarBlock({
          "bg-color": buttonColor,
          "text-color": textColor,
          "border-color": buttonColor,
          "hover-bg-color": hoverBgColor,
          "hover-text-color": textColor,
          "hover-border-color": hoverBgColor,
          "active-bg-color": activeBgColor,
          "active-border-color": activeBgColor
        });
        if (_disabled.value) {
          const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns2.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
          styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns2.cssVarName("color-white")})`;
          styles[ns2.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
        }
      }
    }
    return styles;
  });
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button2.mjs
var _hoisted_17 = ["aria-disabled", "disabled", "autofocus", "type"];
var __default__19 = (0, import_vue345.defineComponent)({
  name: "ElButton"
});
var _sfc_main22 = /* @__PURE__ */ (0, import_vue345.defineComponent)({
  ...__default__19,
  props: buttonProps,
  emits: buttonEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const buttonStyle = useButtonCustomStyle(props);
    const ns2 = useNamespace("button");
    const { _ref, _size, _type, _disabled, shouldAddSpace, handleClick } = useButton(props, emit);
    expose({
      ref: _ref,
      size: _size,
      type: _type,
      disabled: _disabled,
      shouldAddSpace
    });
    return (_ctx, _cache) => {
      return (0, import_vue345.openBlock)(), (0, import_vue345.createElementBlock)("button", {
        ref_key: "_ref",
        ref: _ref,
        class: (0, import_vue345.normalizeClass)([
          (0, import_vue345.unref)(ns2).b(),
          (0, import_vue345.unref)(ns2).m((0, import_vue345.unref)(_type)),
          (0, import_vue345.unref)(ns2).m((0, import_vue345.unref)(_size)),
          (0, import_vue345.unref)(ns2).is("disabled", (0, import_vue345.unref)(_disabled)),
          (0, import_vue345.unref)(ns2).is("loading", _ctx.loading),
          (0, import_vue345.unref)(ns2).is("plain", _ctx.plain),
          (0, import_vue345.unref)(ns2).is("round", _ctx.round),
          (0, import_vue345.unref)(ns2).is("circle", _ctx.circle),
          (0, import_vue345.unref)(ns2).is("text", _ctx.text),
          (0, import_vue345.unref)(ns2).is("link", _ctx.link),
          (0, import_vue345.unref)(ns2).is("has-bg", _ctx.bg)
        ]),
        "aria-disabled": (0, import_vue345.unref)(_disabled) || _ctx.loading,
        disabled: (0, import_vue345.unref)(_disabled) || _ctx.loading,
        autofocus: _ctx.autofocus,
        type: _ctx.nativeType,
        style: (0, import_vue345.normalizeStyle)((0, import_vue345.unref)(buttonStyle)),
        onClick: _cache[0] || (_cache[0] = (...args) => (0, import_vue345.unref)(handleClick) && (0, import_vue345.unref)(handleClick)(...args))
      }, [
        _ctx.loading ? ((0, import_vue345.openBlock)(), (0, import_vue345.createElementBlock)(import_vue345.Fragment, { key: 0 }, [
          _ctx.$slots.loading ? (0, import_vue345.renderSlot)(_ctx.$slots, "loading", { key: 0 }) : ((0, import_vue345.openBlock)(), (0, import_vue345.createBlock)((0, import_vue345.unref)(ElIcon), {
            key: 1,
            class: (0, import_vue345.normalizeClass)((0, import_vue345.unref)(ns2).is("loading"))
          }, {
            default: (0, import_vue345.withCtx)(() => [
              ((0, import_vue345.openBlock)(), (0, import_vue345.createBlock)((0, import_vue345.resolveDynamicComponent)(_ctx.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : _ctx.icon || _ctx.$slots.icon ? ((0, import_vue345.openBlock)(), (0, import_vue345.createBlock)((0, import_vue345.unref)(ElIcon), { key: 1 }, {
          default: (0, import_vue345.withCtx)(() => [
            _ctx.icon ? ((0, import_vue345.openBlock)(), (0, import_vue345.createBlock)((0, import_vue345.resolveDynamicComponent)(_ctx.icon), { key: 0 })) : (0, import_vue345.renderSlot)(_ctx.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : (0, import_vue345.createCommentVNode)("v-if", true),
        _ctx.$slots.default ? ((0, import_vue345.openBlock)(), (0, import_vue345.createElementBlock)("span", {
          key: 2,
          class: (0, import_vue345.normalizeClass)({ [(0, import_vue345.unref)(ns2).em("text", "expand")]: (0, import_vue345.unref)(shouldAddSpace) })
        }, [
          (0, import_vue345.renderSlot)(_ctx.$slots, "default")
        ], 2)) : (0, import_vue345.createCommentVNode)("v-if", true)
      ], 14, _hoisted_17);
    };
  }
});
var Button = /* @__PURE__ */ _export_sfc(_sfc_main22, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button-group2.mjs
var import_vue346 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button-group.mjs
var buttonGroupProps = {
  size: buttonProps.size,
  type: buttonProps.type
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/src/button-group2.mjs
var __default__20 = (0, import_vue346.defineComponent)({
  name: "ElButtonGroup"
});
var _sfc_main23 = /* @__PURE__ */ (0, import_vue346.defineComponent)({
  ...__default__20,
  props: buttonGroupProps,
  setup(__props) {
    const props = __props;
    (0, import_vue346.provide)(buttonGroupContextKey, (0, import_vue346.reactive)({
      size: (0, import_vue346.toRef)(props, "size"),
      type: (0, import_vue346.toRef)(props, "type")
    }));
    const ns2 = useNamespace("button");
    return (_ctx, _cache) => {
      return (0, import_vue346.openBlock)(), (0, import_vue346.createElementBlock)("div", {
        class: (0, import_vue346.normalizeClass)(`${(0, import_vue346.unref)(ns2).b("group")}`)
      }, [
        (0, import_vue346.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main23, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/button/index.mjs
var ElButton = withInstall(Button, {
  ButtonGroup
});
var ElButtonGroup = withNoopInstall(ButtonGroup);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/calendar2.mjs
var import_vue357 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/date-table2.mjs
var import_vue355 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker.mjs
var import_vue353 = require("vue");
var import_dayjs4 = __toESM(require_dayjs_min(), 1);
var import_customParseFormat = __toESM(require_customParseFormat(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/constants.mjs
var timeUnits = ["hours", "minutes", "seconds"];
var DEFAULT_FORMATS_TIME = "HH:mm:ss";
var DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
var DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  dates: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/common/picker.mjs
var import_vue347 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/utils.mjs
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_shared25 = require("@vue/shared");
var buildTimeList = (value, bound) => {
  return [
    value > 0 ? value - 1 : void 0,
    value,
    value < bound ? value + 1 : void 0
  ];
};
var rangeArr = (n) => Array.from(Array.from({ length: n }).keys());
var extractDateFormat = (format2) => {
  return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
var extractTimeFormat = (format2) => {
  return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};
var dateEquals = function(a3, b3) {
  const aIsDate = (0, import_shared25.isDate)(a3);
  const bIsDate = (0, import_shared25.isDate)(b3);
  if (aIsDate && bIsDate) {
    return a3.getTime() === b3.getTime();
  }
  if (!aIsDate && !bIsDate) {
    return a3 === b3;
  }
  return false;
};
var valueEquals = function(a3, b3) {
  const aIsArray = (0, import_shared25.isArray)(a3);
  const bIsArray = (0, import_shared25.isArray)(b3);
  if (aIsArray && bIsArray) {
    if (a3.length !== b3.length) {
      return false;
    }
    return a3.every((item, index2) => dateEquals(item, b3[index2]));
  }
  if (!aIsArray && !bIsArray) {
    return dateEquals(a3, b3);
  }
  return false;
};
var parseDate = function(date5, format2, lang) {
  const day = isEmpty(format2) || format2 === "x" ? (0, import_dayjs.default)(date5).locale(lang) : (0, import_dayjs.default)(date5, format2).locale(lang);
  return day.isValid() ? day : void 0;
};
var formatter = function(date5, format2, lang) {
  if (isEmpty(format2))
    return date5;
  if (format2 === "x")
    return +date5;
  return (0, import_dayjs.default)(date5).locale(lang).format(format2);
};
var makeList = (total2, method4) => {
  var _a2;
  const arr = [];
  const disabledArr = method4 == null ? void 0 : method4();
  for (let i = 0; i < total2; i++) {
    arr.push((_a2 = disabledArr == null ? void 0 : disabledArr.includes(i)) != null ? _a2 : false);
  }
  return arr;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/props/shared.mjs
var disabledTimeListsProps = buildProps({
  disabledHours: {
    type: definePropType(Function)
  },
  disabledMinutes: {
    type: definePropType(Function)
  },
  disabledSeconds: {
    type: definePropType(Function)
  }
});
var timePanelSharedProps = buildProps({
  visible: Boolean,
  actualVisible: {
    type: Boolean,
    default: void 0
  },
  format: {
    type: String,
    default: ""
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/common/props.mjs
var timePickerDefaultProps = buildProps({
  id: {
    type: definePropType([Array, String])
  },
  name: {
    type: definePropType([Array, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: String,
  valueFormat: String,
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: definePropType([String, Object]),
    default: circle_close_default
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: definePropType([String, Object]),
    default: ""
  },
  size: useSizeProp,
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  modelValue: {
    type: definePropType([Date, Array, String, Number]),
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: definePropType([Date, Array])
  },
  defaultTime: {
    type: definePropType([Date, Array])
  },
  isRange: {
    type: Boolean,
    default: false
  },
  ...disabledTimeListsProps,
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: definePropType([String, Number]),
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/common/picker.mjs
var import_shared27 = require("@vue/shared");
var _hoisted_19 = ["id", "name", "placeholder", "value", "disabled", "readonly"];
var _hoisted_24 = ["id", "name", "placeholder", "value", "disabled", "readonly"];
var __default__21 = (0, import_vue347.defineComponent)({
  name: "Picker"
});
var _sfc_main24 = /* @__PURE__ */ (0, import_vue347.defineComponent)({
  ...__default__21,
  props: timePickerDefaultProps,
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur",
    "calendar-change",
    "panel-change",
    "visible-change",
    "keydown"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const { lang } = useLocale();
    const nsDate = useNamespace("date");
    const nsInput = useNamespace("input");
    const nsRange = useNamespace("range");
    const { form, formItem } = useFormItem();
    const elPopperOptions = (0, import_vue347.inject)("ElPopperOptions", {});
    const refPopper = (0, import_vue347.ref)();
    const inputRef = (0, import_vue347.ref)();
    const pickerVisible = (0, import_vue347.ref)(false);
    const pickerActualVisible = (0, import_vue347.ref)(false);
    const valueOnOpen = (0, import_vue347.ref)(null);
    let hasJustTabExitedInput = false;
    let ignoreFocusEvent = false;
    (0, import_vue347.watch)(pickerVisible, (val) => {
      if (!val) {
        userInput.value = null;
        (0, import_vue347.nextTick)(() => {
          emitChange(props.modelValue);
        });
      } else {
        (0, import_vue347.nextTick)(() => {
          if (val) {
            valueOnOpen.value = props.modelValue;
          }
        });
      }
    });
    const emitChange = (val, isClear) => {
      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        emit("change", val);
        props.validateEvent && (formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err)));
      }
    };
    const emitInput = (input) => {
      if (!valueEquals(props.modelValue, input)) {
        let formatted;
        if ((0, import_shared27.isArray)(input)) {
          formatted = input.map((item) => formatter(item, props.valueFormat, lang.value));
        } else if (input) {
          formatted = formatter(input, props.valueFormat, lang.value);
        }
        emit("update:modelValue", input ? formatted : input, lang.value);
      }
    };
    const emitKeydown = (e) => {
      emit("keydown", e);
    };
    const refInput = (0, import_vue347.computed)(() => {
      if (inputRef.value) {
        const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
        return Array.from(_r.querySelectorAll("input"));
      }
      return [];
    });
    const setSelectionRange = (start, end2, pos) => {
      const _inputs = refInput.value;
      if (!_inputs.length)
        return;
      if (!pos || pos === "min") {
        _inputs[0].setSelectionRange(start, end2);
        _inputs[0].focus();
      } else if (pos === "max") {
        _inputs[1].setSelectionRange(start, end2);
        _inputs[1].focus();
      }
    };
    const focusOnInputBox = () => {
      focus(true, true);
      (0, import_vue347.nextTick)(() => {
        ignoreFocusEvent = false;
      });
    };
    const onPick = (date5 = "", visible = false) => {
      if (!visible) {
        ignoreFocusEvent = true;
      }
      pickerVisible.value = visible;
      let result;
      if ((0, import_shared27.isArray)(date5)) {
        result = date5.map((_2) => _2.toDate());
      } else {
        result = date5 ? date5.toDate() : date5;
      }
      userInput.value = null;
      emitInput(result);
    };
    const onBeforeShow = () => {
      pickerActualVisible.value = true;
    };
    const onShow = () => {
      emit("visible-change", true);
    };
    const onKeydownPopperContent = (event) => {
      if ((event == null ? void 0 : event.key) === EVENT_CODE.esc) {
        focus(true, true);
      }
    };
    const onHide = () => {
      pickerActualVisible.value = false;
      pickerVisible.value = false;
      ignoreFocusEvent = false;
      emit("visible-change", false);
    };
    const handleOpen = () => {
      pickerVisible.value = true;
    };
    const handleClose = () => {
      pickerVisible.value = false;
    };
    const focus = (focusStartInput = true, isIgnoreFocusEvent = false) => {
      ignoreFocusEvent = isIgnoreFocusEvent;
      const [leftInput, rightInput] = (0, import_vue347.unref)(refInput);
      let input = leftInput;
      if (!focusStartInput && isRangeInput.value) {
        input = rightInput;
      }
      if (input) {
        input.focus();
      }
    };
    const handleFocusInput = (e) => {
      if (props.readonly || pickerDisabled.value || pickerVisible.value || ignoreFocusEvent) {
        return;
      }
      pickerVisible.value = true;
      emit("focus", e);
    };
    let currentHandleBlurDeferCallback = void 0;
    const handleBlurInput = (e) => {
      const handleBlurDefer = async () => {
        setTimeout(() => {
          var _a2;
          if (currentHandleBlurDeferCallback === handleBlurDefer) {
            if (!(((_a2 = refPopper.value) == null ? void 0 : _a2.isFocusInsideContent()) && !hasJustTabExitedInput) && refInput.value.filter((input) => {
              return input.contains(document.activeElement);
            }).length === 0) {
              handleChange();
              pickerVisible.value = false;
              emit("blur", e);
              props.validateEvent && (formItem == null ? void 0 : formItem.validate("blur").catch((err) => debugWarn(err)));
            }
            hasJustTabExitedInput = false;
          }
        }, 0);
      };
      currentHandleBlurDeferCallback = handleBlurDefer;
      handleBlurDefer();
    };
    const pickerDisabled = (0, import_vue347.computed)(() => {
      return props.disabled || (form == null ? void 0 : form.disabled);
    });
    const parsedValue2 = (0, import_vue347.computed)(() => {
      let dayOrDays;
      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          dayOrDays = pickerOptions.value.getDefaultValue();
        }
      } else {
        if ((0, import_shared27.isArray)(props.modelValue)) {
          dayOrDays = props.modelValue.map((d2) => parseDate(d2, props.valueFormat, lang.value));
        } else {
          dayOrDays = parseDate(props.modelValue, props.valueFormat, lang.value);
        }
      }
      if (pickerOptions.value.getRangeAvailableTime) {
        const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
        if (!isEqual_default(availableResult, dayOrDays)) {
          dayOrDays = availableResult;
          emitInput((0, import_shared27.isArray)(dayOrDays) ? dayOrDays.map((_2) => _2.toDate()) : dayOrDays.toDate());
        }
      }
      if ((0, import_shared27.isArray)(dayOrDays) && dayOrDays.some((day) => !day)) {
        dayOrDays = [];
      }
      return dayOrDays;
    });
    const displayValue = (0, import_vue347.computed)(() => {
      if (!pickerOptions.value.panelReady)
        return "";
      const formattedValue = formatDayjsToString(parsedValue2.value);
      if ((0, import_shared27.isArray)(userInput.value)) {
        return [
          userInput.value[0] || formattedValue && formattedValue[0] || "",
          userInput.value[1] || formattedValue && formattedValue[1] || ""
        ];
      } else if (userInput.value !== null) {
        return userInput.value;
      }
      if (!isTimePicker.value && valueIsEmpty.value)
        return "";
      if (!pickerVisible.value && valueIsEmpty.value)
        return "";
      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
      }
      return "";
    });
    const isTimeLikePicker = (0, import_vue347.computed)(() => props.type.includes("time"));
    const isTimePicker = (0, import_vue347.computed)(() => props.type.startsWith("time"));
    const isDatesPicker = (0, import_vue347.computed)(() => props.type === "dates");
    const triggerIcon = (0, import_vue347.computed)(() => props.prefixIcon || (isTimeLikePicker.value ? clock_default : calendar_default));
    const showClose = (0, import_vue347.ref)(false);
    const onClearIconClick = (event) => {
      if (props.readonly || pickerDisabled.value)
        return;
      if (showClose.value) {
        event.stopPropagation();
        focusOnInputBox();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };
    const valueIsEmpty = (0, import_vue347.computed)(() => {
      const { modelValue } = props;
      return !modelValue || (0, import_shared27.isArray)(modelValue) && !modelValue.filter(Boolean).length;
    });
    const onMouseDownInput = async (event) => {
      var _a2;
      if (props.readonly || pickerDisabled.value)
        return;
      if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
        pickerVisible.value = true;
      }
    };
    const onMouseEnter = () => {
      if (props.readonly || pickerDisabled.value)
        return;
      if (!valueIsEmpty.value && props.clearable) {
        showClose.value = true;
      }
    };
    const onMouseLeave = () => {
      showClose.value = false;
    };
    const onTouchStartInput = (event) => {
      var _a2;
      if (props.readonly || pickerDisabled.value)
        return;
      if (((_a2 = event.touches[0].target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
        pickerVisible.value = true;
      }
    };
    const isRangeInput = (0, import_vue347.computed)(() => {
      return props.type.includes("range");
    });
    const pickerSize = useSize();
    const popperEl = (0, import_vue347.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = (0, import_vue347.unref)(refPopper)) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
    });
    const actualInputRef = (0, import_vue347.computed)(() => {
      var _a2;
      if ((0, import_vue347.unref)(isRangeInput)) {
        return (0, import_vue347.unref)(inputRef);
      }
      return (_a2 = (0, import_vue347.unref)(inputRef)) == null ? void 0 : _a2.$el;
    });
    onClickOutside(actualInputRef, (e) => {
      const unrefedPopperEl = (0, import_vue347.unref)(popperEl);
      const inputEl = (0, import_vue347.unref)(actualInputRef);
      if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl))
        return;
      pickerVisible.value = false;
    });
    const userInput = (0, import_vue347.ref)(null);
    const handleChange = () => {
      if (userInput.value) {
        const value = parseUserInputToDayjs(displayValue.value);
        if (value) {
          if (isValidValue3(value)) {
            emitInput((0, import_shared27.isArray)(value) ? value.map((_2) => _2.toDate()) : value.toDate());
            userInput.value = null;
          }
        }
      }
      if (userInput.value === "") {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };
    const parseUserInputToDayjs = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.parseUserInput(value);
    };
    const formatDayjsToString = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.formatToString(value);
    };
    const isValidValue3 = (value) => {
      return pickerOptions.value.isValidValue(value);
    };
    const handleKeydownInput = async (event) => {
      if (props.readonly || pickerDisabled.value)
        return;
      const { code } = event;
      emitKeydown(event);
      if (code === EVENT_CODE.esc) {
        if (pickerVisible.value === true) {
          pickerVisible.value = false;
          event.preventDefault();
          event.stopPropagation();
        }
        return;
      }
      if (code === EVENT_CODE.down) {
        if (pickerOptions.value.handleFocusPicker) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (pickerVisible.value === false) {
          pickerVisible.value = true;
          await (0, import_vue347.nextTick)();
        }
        if (pickerOptions.value.handleFocusPicker) {
          pickerOptions.value.handleFocusPicker();
          return;
        }
      }
      if (code === EVENT_CODE.tab) {
        hasJustTabExitedInput = true;
        return;
      }
      if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
        if (userInput.value === null || userInput.value === "" || isValidValue3(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }
        event.stopPropagation();
        return;
      }
      if (userInput.value) {
        event.stopPropagation();
        return;
      }
      if (pickerOptions.value.handleKeydownInput) {
        pickerOptions.value.handleKeydownInput(event);
      }
    };
    const onUserInput = (e) => {
      userInput.value = e;
      if (!pickerVisible.value) {
        pickerVisible.value = true;
      }
    };
    const handleStartInput = (event) => {
      const target = event.target;
      if (userInput.value) {
        userInput.value = [target.value, userInput.value[1]];
      } else {
        userInput.value = [target.value, null];
      }
    };
    const handleEndInput = (event) => {
      const target = event.target;
      if (userInput.value) {
        userInput.value = [userInput.value[0], target.value];
      } else {
        userInput.value = [null, target.value];
      }
    };
    const handleStartChange = () => {
      var _a2;
      const values = userInput.value;
      const value = parseUserInputToDayjs(values && values[0]);
      const parsedVal = (0, import_vue347.unref)(parsedValue2);
      if (value && value.isValid()) {
        userInput.value = [
          formatDayjsToString(value),
          ((_a2 = displayValue.value) == null ? void 0 : _a2[1]) || null
        ];
        const newValue = [value, parsedVal && (parsedVal[1] || null)];
        if (isValidValue3(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const handleEndChange = () => {
      var _a2;
      const values = (0, import_vue347.unref)(userInput);
      const value = parseUserInputToDayjs(values && values[1]);
      const parsedVal = (0, import_vue347.unref)(parsedValue2);
      if (value && value.isValid()) {
        userInput.value = [
          ((_a2 = (0, import_vue347.unref)(displayValue)) == null ? void 0 : _a2[0]) || null,
          formatDayjsToString(value)
        ];
        const newValue = [parsedVal && parsedVal[0], value];
        if (isValidValue3(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const pickerOptions = (0, import_vue347.ref)({});
    const onSetPickerOption = (e) => {
      pickerOptions.value[e[0]] = e[1];
      pickerOptions.value.panelReady = true;
    };
    const onCalendarChange = (e) => {
      emit("calendar-change", e);
    };
    const onPanelChange = (value, mode, view) => {
      emit("panel-change", value, mode, view);
    };
    (0, import_vue347.provide)("EP_PICKER_BASE", {
      props
    });
    expose({
      focus,
      handleFocusInput,
      handleBlurInput,
      handleOpen,
      handleClose,
      onPick
    });
    return (_ctx, _cache) => {
      return (0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.unref)(ElTooltip), (0, import_vue347.mergeProps)({
        ref_key: "refPopper",
        ref: refPopper,
        visible: pickerVisible.value,
        effect: "light",
        pure: "",
        trigger: "click"
      }, _ctx.$attrs, {
        role: "dialog",
        teleported: "",
        transition: `${(0, import_vue347.unref)(nsDate).namespace.value}-zoom-in-top`,
        "popper-class": [`${(0, import_vue347.unref)(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
        "popper-options": (0, import_vue347.unref)(elPopperOptions),
        "fallback-placements": ["bottom", "top", "right", "left"],
        "gpu-acceleration": false,
        "stop-popper-mouse-event": false,
        "hide-after": 0,
        persistent: "",
        onBeforeShow,
        onShow,
        onHide
      }), {
        default: (0, import_vue347.withCtx)(() => [
          !(0, import_vue347.unref)(isRangeInput) ? ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.unref)(ElInput), {
            key: 0,
            id: _ctx.id,
            ref_key: "inputRef",
            ref: inputRef,
            "container-role": "combobox",
            "model-value": (0, import_vue347.unref)(displayValue),
            name: _ctx.name,
            size: (0, import_vue347.unref)(pickerSize),
            disabled: (0, import_vue347.unref)(pickerDisabled),
            placeholder: _ctx.placeholder,
            class: (0, import_vue347.normalizeClass)([(0, import_vue347.unref)(nsDate).b("editor"), (0, import_vue347.unref)(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
            style: (0, import_vue347.normalizeStyle)(_ctx.$attrs.style),
            readonly: !_ctx.editable || _ctx.readonly || (0, import_vue347.unref)(isDatesPicker) || _ctx.type === "week",
            label: _ctx.label,
            tabindex: _ctx.tabindex,
            "validate-event": false,
            onInput: onUserInput,
            onFocus: handleFocusInput,
            onBlur: handleBlurInput,
            onKeydown: handleKeydownInput,
            onChange: handleChange,
            onMousedown: onMouseDownInput,
            onMouseenter: onMouseEnter,
            onMouseleave: onMouseLeave,
            onTouchstart: onTouchStartInput,
            onClick: _cache[0] || (_cache[0] = (0, import_vue347.withModifiers)(() => {
            }, ["stop"]))
          }, {
            prefix: (0, import_vue347.withCtx)(() => [
              (0, import_vue347.unref)(triggerIcon) ? ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.unref)(ElIcon), {
                key: 0,
                class: (0, import_vue347.normalizeClass)((0, import_vue347.unref)(nsInput).e("icon")),
                onMousedown: (0, import_vue347.withModifiers)(onMouseDownInput, ["prevent"]),
                onTouchstart: onTouchStartInput
              }, {
                default: (0, import_vue347.withCtx)(() => [
                  ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.resolveDynamicComponent)((0, import_vue347.unref)(triggerIcon))))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : (0, import_vue347.createCommentVNode)("v-if", true)
            ]),
            suffix: (0, import_vue347.withCtx)(() => [
              showClose.value && _ctx.clearIcon ? ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.unref)(ElIcon), {
                key: 0,
                class: (0, import_vue347.normalizeClass)(`${(0, import_vue347.unref)(nsInput).e("icon")} clear-icon`),
                onClick: (0, import_vue347.withModifiers)(onClearIconClick, ["stop"])
              }, {
                default: (0, import_vue347.withCtx)(() => [
                  ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.resolveDynamicComponent)(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (0, import_vue347.createCommentVNode)("v-if", true)
            ]),
            _: 1
          }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"])) : ((0, import_vue347.openBlock)(), (0, import_vue347.createElementBlock)("div", {
            key: 1,
            ref_key: "inputRef",
            ref: inputRef,
            class: (0, import_vue347.normalizeClass)([
              (0, import_vue347.unref)(nsDate).b("editor"),
              (0, import_vue347.unref)(nsDate).bm("editor", _ctx.type),
              (0, import_vue347.unref)(nsInput).e("wrapper"),
              (0, import_vue347.unref)(nsDate).is("disabled", (0, import_vue347.unref)(pickerDisabled)),
              (0, import_vue347.unref)(nsDate).is("active", pickerVisible.value),
              (0, import_vue347.unref)(nsRange).b("editor"),
              (0, import_vue347.unref)(pickerSize) ? (0, import_vue347.unref)(nsRange).bm("editor", (0, import_vue347.unref)(pickerSize)) : "",
              _ctx.$attrs.class
            ]),
            style: (0, import_vue347.normalizeStyle)(_ctx.$attrs.style),
            onClick: handleFocusInput,
            onMouseenter: onMouseEnter,
            onMouseleave: onMouseLeave,
            onTouchstart: onTouchStartInput,
            onKeydown: handleKeydownInput
          }, [
            (0, import_vue347.unref)(triggerIcon) ? ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.unref)(ElIcon), {
              key: 0,
              class: (0, import_vue347.normalizeClass)([(0, import_vue347.unref)(nsInput).e("icon"), (0, import_vue347.unref)(nsRange).e("icon")]),
              onMousedown: (0, import_vue347.withModifiers)(onMouseDownInput, ["prevent"]),
              onTouchstart: onTouchStartInput
            }, {
              default: (0, import_vue347.withCtx)(() => [
                ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.resolveDynamicComponent)((0, import_vue347.unref)(triggerIcon))))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : (0, import_vue347.createCommentVNode)("v-if", true),
            (0, import_vue347.createElementVNode)("input", {
              id: _ctx.id && _ctx.id[0],
              autocomplete: "off",
              name: _ctx.name && _ctx.name[0],
              placeholder: _ctx.startPlaceholder,
              value: (0, import_vue347.unref)(displayValue) && (0, import_vue347.unref)(displayValue)[0],
              disabled: (0, import_vue347.unref)(pickerDisabled),
              readonly: !_ctx.editable || _ctx.readonly,
              class: (0, import_vue347.normalizeClass)((0, import_vue347.unref)(nsRange).b("input")),
              onMousedown: onMouseDownInput,
              onInput: handleStartInput,
              onChange: handleStartChange,
              onFocus: handleFocusInput,
              onBlur: handleBlurInput
            }, null, 42, _hoisted_19),
            (0, import_vue347.renderSlot)(_ctx.$slots, "range-separator", {}, () => [
              (0, import_vue347.createElementVNode)("span", {
                class: (0, import_vue347.normalizeClass)((0, import_vue347.unref)(nsRange).b("separator"))
              }, (0, import_vue347.toDisplayString)(_ctx.rangeSeparator), 3)
            ]),
            (0, import_vue347.createElementVNode)("input", {
              id: _ctx.id && _ctx.id[1],
              autocomplete: "off",
              name: _ctx.name && _ctx.name[1],
              placeholder: _ctx.endPlaceholder,
              value: (0, import_vue347.unref)(displayValue) && (0, import_vue347.unref)(displayValue)[1],
              disabled: (0, import_vue347.unref)(pickerDisabled),
              readonly: !_ctx.editable || _ctx.readonly,
              class: (0, import_vue347.normalizeClass)((0, import_vue347.unref)(nsRange).b("input")),
              onMousedown: onMouseDownInput,
              onFocus: handleFocusInput,
              onBlur: handleBlurInput,
              onInput: handleEndInput,
              onChange: handleEndChange
            }, null, 42, _hoisted_24),
            _ctx.clearIcon ? ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.unref)(ElIcon), {
              key: 1,
              class: (0, import_vue347.normalizeClass)([
                (0, import_vue347.unref)(nsInput).e("icon"),
                (0, import_vue347.unref)(nsRange).e("close-icon"),
                {
                  [(0, import_vue347.unref)(nsRange).e("close-icon--hidden")]: !showClose.value
                }
              ]),
              onClick: onClearIconClick
            }, {
              default: (0, import_vue347.withCtx)(() => [
                ((0, import_vue347.openBlock)(), (0, import_vue347.createBlock)((0, import_vue347.resolveDynamicComponent)(_ctx.clearIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : (0, import_vue347.createCommentVNode)("v-if", true)
          ], 38))
        ]),
        content: (0, import_vue347.withCtx)(() => [
          (0, import_vue347.renderSlot)(_ctx.$slots, "default", {
            visible: pickerVisible.value,
            actualVisible: pickerActualVisible.value,
            parsedValue: (0, import_vue347.unref)(parsedValue2),
            format: _ctx.format,
            unlinkPanels: _ctx.unlinkPanels,
            type: _ctx.type,
            defaultValue: _ctx.defaultValue,
            onPick,
            onSelectRange: setSelectionRange,
            onSetPickerOption,
            onCalendarChange,
            onPanelChange,
            onKeydown: onKeydownPopperContent,
            onMousedown: _cache[1] || (_cache[1] = (0, import_vue347.withModifiers)(() => {
            }, ["stop"]))
          })
        ]),
        _: 3
      }, 16, ["visible", "transition", "popper-class", "popper-options"]);
    };
  }
});
var CommonPicker = /* @__PURE__ */ _export_sfc(_sfc_main24, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker-com/panel-time-pick.mjs
var import_vue351 = require("vue");
var import_dayjs2 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/props/panel-time-picker.mjs
var panelTimePickerProps = buildProps({
  ...timePanelSharedProps,
  datetimeRole: String,
  parsedValue: {
    type: definePropType(Object)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/composables/use-time-panel.mjs
var useTimePanel = ({
  getAvailableHours,
  getAvailableMinutes,
  getAvailableSeconds
}) => {
  const getAvailableTime = (date5, role, first, compareDate) => {
    const availableTimeGetters = {
      hour: getAvailableHours,
      minute: getAvailableMinutes,
      second: getAvailableSeconds
    };
    let result = date5;
    ["hour", "minute", "second"].forEach((type4) => {
      if (availableTimeGetters[type4]) {
        let availableTimeSlots;
        const method4 = availableTimeGetters[type4];
        switch (type4) {
          case "minute": {
            availableTimeSlots = method4(result.hour(), role, compareDate);
            break;
          }
          case "second": {
            availableTimeSlots = method4(result.hour(), result.minute(), role, compareDate);
            break;
          }
          default: {
            availableTimeSlots = method4(role, compareDate);
            break;
          }
        }
        if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result[type4]())) {
          const pos = first ? 0 : availableTimeSlots.length - 1;
          result = result[type4](availableTimeSlots[pos]);
        }
      }
    });
    return result;
  };
  const timePickerOptions = {};
  const onSetOption = ([key, val]) => {
    timePickerOptions[key] = val;
  };
  return {
    timePickerOptions,
    getAvailableTime,
    onSetOption
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/composables/use-time-picker.mjs
var import_vue348 = require("vue");
var makeAvailableArr = (disabledList) => {
  const trueOrNumber = (isDisabled, index2) => isDisabled || index2;
  const getNumber = (predicate) => predicate !== true;
  return disabledList.map(trueOrNumber).filter(getNumber);
};
var getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare) => {
    return makeList(24, disabledHours && (() => disabledHours == null ? void 0 : disabledHours(role, compare)));
  };
  const getMinutesList = (hour, role, compare) => {
    return makeList(60, disabledMinutes && (() => disabledMinutes == null ? void 0 : disabledMinutes(hour, role, compare)));
  };
  const getSecondsList = (hour, minute, role, compare) => {
    return makeList(60, disabledSeconds && (() => disabledSeconds == null ? void 0 : disabledSeconds(hour, minute, role, compare)));
  };
  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};
var buildAvailableTimeSlotGetter = (disabledHours, disabledMinutes, disabledSeconds) => {
  const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
  const getAvailableHours = (role, compare) => {
    return makeAvailableArr(getHoursList(role, compare));
  };
  const getAvailableMinutes = (hour, role, compare) => {
    return makeAvailableArr(getMinutesList(hour, role, compare));
  };
  const getAvailableSeconds = (hour, minute, role, compare) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare));
  };
  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};
var useOldValue = (props) => {
  const oldValue = (0, import_vue348.ref)(props.parsedValue);
  (0, import_vue348.watch)(() => props.visible, (val) => {
    if (!val) {
      oldValue.value = props.parsedValue;
    }
  });
  return oldValue;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker-com/basic-time-spinner.mjs
var import_vue350 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/directives/click-outside/index.mjs
var nodeList = /* @__PURE__ */ new Map();
var startClick;
if (isClient) {
  document.addEventListener("mousedown", (e) => startClick = e);
  document.addEventListener("mouseup", (e) => {
    for (const handlers2 of nodeList.values()) {
      for (const { documentHandler } of handlers2) {
        documentHandler(e, startClick);
      }
    }
  });
}
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (isElement(binding.arg)) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
var ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    const handlers2 = nodeList.get(el);
    const oldHandlerIndex = handlers2.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers2.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers2.push(newHandler);
    }
  },
  unmounted(el) {
    nodeList.delete(el);
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/directives/repeat-click/index.mjs
var import_shared29 = require("@vue/shared");
var REPEAT_INTERVAL = 100;
var REPEAT_DELAY = 600;
var vRepeatClick = {
  beforeMount(el, binding) {
    const value = binding.value;
    const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = (0, import_shared29.isFunction)(value) ? {} : value;
    let intervalId;
    let delayId;
    const handler = () => (0, import_shared29.isFunction)(value) ? value() : value.handler();
    const clear = () => {
      if (delayId) {
        clearTimeout(delayId);
        delayId = void 0;
      }
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = void 0;
      }
    };
    el.addEventListener("mousedown", (evt) => {
      if (evt.button !== 0)
        return;
      clear();
      handler();
      document.addEventListener("mouseup", () => clear(), {
        once: true
      });
      delayId = setTimeout(() => {
        intervalId = setInterval(() => {
          handler();
        }, interval);
      }, delay);
    });
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/directives/trap-focus/index.mjs
var import_vue349 = require("vue");
var FOCUSABLE_CHILDREN = "_trap-focus-children";
var FOCUS_STACK = [];
var FOCUS_HANDLER = (e) => {
  var _a2;
  if (FOCUS_STACK.length === 0)
    return;
  const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
  if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
    if (focusableElement.length === 1) {
      e.preventDefault();
      if (document.activeElement !== focusableElement[0]) {
        focusableElement[0].focus();
      }
      return;
    }
    const goingBackward = e.shiftKey;
    const isFirst = e.target === focusableElement[0];
    const isLast = e.target === focusableElement[focusableElement.length - 1];
    if (isFirst && goingBackward) {
      e.preventDefault();
      focusableElement[focusableElement.length - 1].focus();
    }
    if (isLast && !goingBackward) {
      e.preventDefault();
      focusableElement[0].focus();
    }
    if (process.env.NODE_ENV === "test") {
      const index2 = focusableElement.indexOf(e.target);
      if (index2 !== -1) {
        (_a2 = focusableElement[goingBackward ? index2 - 1 : index2 + 1]) == null ? void 0 : _a2.focus();
      }
    }
  }
};
var TrapFocus = {
  beforeMount(el) {
    el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
    FOCUS_STACK.push(el);
    if (FOCUS_STACK.length <= 1) {
      document.addEventListener("keydown", FOCUS_HANDLER);
    }
  },
  updated(el) {
    (0, import_vue349.nextTick)(() => {
      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
    });
  },
  unmounted() {
    FOCUS_STACK.shift();
    if (FOCUS_STACK.length === 0) {
      document.removeEventListener("keydown", FOCUS_HANDLER);
    }
  }
};

// ../../node_modules/.pnpm/normalize-wheel-es@1.2.0/node_modules/normalize-wheel-es/dist/index.mjs
var v = false;
var o;
var f;
var s;
var u;
var d;
var N2;
var l;
var p;
var m2;
var w2;
var D;
var x;
var E2;
var M;
var F;
function a2() {
  if (!v) {
    v = true;
    var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (x = /\b(iPhone|iP[ao]d)/.exec(e), E2 = /\b(iP[ao]d)/.exec(e), w2 = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
      o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(e);
      N2 = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
    } else
      o = f = s = d = u = NaN;
    if (i) {
      if (i[1]) {
        var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        l = t ? parseFloat(t[1].replace("_", ".")) : true;
      } else
        l = false;
      p = !!i[2], m2 = !!i[3];
    } else
      l = p = m2 = false;
  }
}
var _ = { ie: function() {
  return a2() || o;
}, ieCompatibilityMode: function() {
  return a2() || N2 > o;
}, ie64: function() {
  return _.ie() && D;
}, firefox: function() {
  return a2() || f;
}, opera: function() {
  return a2() || s;
}, webkit: function() {
  return a2() || u;
}, safari: function() {
  return _.webkit();
}, chrome: function() {
  return a2() || d;
}, windows: function() {
  return a2() || p;
}, osx: function() {
  return a2() || l;
}, linux: function() {
  return a2() || m2;
}, iphone: function() {
  return a2() || x;
}, mobile: function() {
  return a2() || x || E2 || w2 || F;
}, nativeApp: function() {
  return a2() || M;
}, android: function() {
  return a2() || w2;
}, ipad: function() {
  return a2() || E2;
} };
var A = _;
var c = !!(typeof window < "u" && window.document && window.document.createElement);
var U2 = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c };
var h = U2;
var X2;
h.canUseDOM && (X2 = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
function S(e, n) {
  if (!h.canUseDOM || n && !("addEventListener" in document))
    return false;
  var i = "on" + e, r = i in document;
  if (!r) {
    var t = document.createElement("div");
    t.setAttribute(i, "return;"), r = typeof t[i] == "function";
  }
  return !r && X2 && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var b = S;
var O = 10;
var I3 = 40;
var P2 = 800;
function T(e) {
  var n = 0, i = 0, r = 0, t = 0;
  return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I3, t *= I3) : (r *= P2, t *= P2)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
}
T.getEventType = function() {
  return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
};
var Y = T;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/directives/mousewheel/index.mjs
var mousewheel = function(element, callback) {
  if (element && element.addEventListener) {
    const fn2 = function(event) {
      const normalized = Y(event);
      callback && Reflect.apply(callback, this, [event, normalized]);
    };
    element.addEventListener("wheel", fn2, { passive: true });
  }
};
var Mousewheel = {
  beforeMount(el, binding) {
    mousewheel(el, binding.value);
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/props/basic-time-spinner.mjs
var basicTimeSpinnerProps = buildProps({
  role: {
    type: String,
    required: true
  },
  spinnerDate: {
    type: definePropType(Object),
    required: true
  },
  showSeconds: {
    type: Boolean,
    default: true
  },
  arrowControl: Boolean,
  amPmMode: {
    type: definePropType(String),
    default: ""
  },
  ...disabledTimeListsProps
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker-com/basic-time-spinner.mjs
var _hoisted_111 = ["onClick"];
var _hoisted_25 = ["onMouseenter"];
var _sfc_main25 = /* @__PURE__ */ (0, import_vue350.defineComponent)({
  __name: "basic-time-spinner",
  props: basicTimeSpinnerProps,
  emits: ["change", "select-range", "set-option"],
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("time");
    const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
    let isScrolling = false;
    const currentScrollbar = (0, import_vue350.ref)();
    const listHoursRef = (0, import_vue350.ref)();
    const listMinutesRef = (0, import_vue350.ref)();
    const listSecondsRef = (0, import_vue350.ref)();
    const listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    };
    const spinnerItems = (0, import_vue350.computed)(() => {
      return props.showSeconds ? timeUnits : timeUnits.slice(0, 2);
    });
    const timePartials = (0, import_vue350.computed)(() => {
      const { spinnerDate } = props;
      const hours = spinnerDate.hour();
      const minutes = spinnerDate.minute();
      const seconds = spinnerDate.second();
      return { hours, minutes, seconds };
    });
    const timeList = (0, import_vue350.computed)(() => {
      const { hours, minutes } = (0, import_vue350.unref)(timePartials);
      return {
        hours: getHoursList(props.role),
        minutes: getMinutesList(hours, props.role),
        seconds: getSecondsList(hours, minutes, props.role)
      };
    });
    const arrowControlTimeList = (0, import_vue350.computed)(() => {
      const { hours, minutes, seconds } = (0, import_vue350.unref)(timePartials);
      return {
        hours: buildTimeList(hours, 23),
        minutes: buildTimeList(minutes, 59),
        seconds: buildTimeList(seconds, 59)
      };
    });
    const debouncedResetScroll = debounce_default((type4) => {
      isScrolling = false;
      adjustCurrentSpinner(type4);
    }, 200);
    const getAmPmFlag = (hour) => {
      const shouldShowAmPm = !!props.amPmMode;
      if (!shouldShowAmPm)
        return "";
      const isCapital = props.amPmMode === "A";
      let content = hour < 12 ? " am" : " pm";
      if (isCapital)
        content = content.toUpperCase();
      return content;
    };
    const emitSelectRange = (type4) => {
      let range3;
      switch (type4) {
        case "hours":
          range3 = [0, 2];
          break;
        case "minutes":
          range3 = [3, 5];
          break;
        case "seconds":
          range3 = [6, 8];
          break;
      }
      const [left2, right2] = range3;
      emit("select-range", left2, right2);
      currentScrollbar.value = type4;
    };
    const adjustCurrentSpinner = (type4) => {
      adjustSpinner(type4, (0, import_vue350.unref)(timePartials)[type4]);
    };
    const adjustSpinners = () => {
      adjustCurrentSpinner("hours");
      adjustCurrentSpinner("minutes");
      adjustCurrentSpinner("seconds");
    };
    const getScrollbarElement = (el) => el.querySelector(`.${ns2.namespace.value}-scrollbar__wrap`);
    const adjustSpinner = (type4, value) => {
      if (props.arrowControl)
        return;
      const scrollbar = (0, import_vue350.unref)(listRefsMap[type4]);
      if (scrollbar && scrollbar.$el) {
        getScrollbarElement(scrollbar.$el).scrollTop = Math.max(0, value * typeItemHeight(type4));
      }
    };
    const typeItemHeight = (type4) => {
      const scrollbar = (0, import_vue350.unref)(listRefsMap[type4]);
      return (scrollbar == null ? void 0 : scrollbar.$el.querySelector("li").offsetHeight) || 0;
    };
    const onIncrement = () => {
      scrollDown(1);
    };
    const onDecrement = () => {
      scrollDown(-1);
    };
    const scrollDown = (step) => {
      if (!currentScrollbar.value) {
        emitSelectRange("hours");
      }
      const label = currentScrollbar.value;
      const now2 = (0, import_vue350.unref)(timePartials)[label];
      const total2 = currentScrollbar.value === "hours" ? 24 : 60;
      const next = findNextUnDisabled(label, now2, step, total2);
      modifyDateField(label, next);
      adjustSpinner(label, next);
      (0, import_vue350.nextTick)(() => emitSelectRange(label));
    };
    const findNextUnDisabled = (type4, now2, step, total2) => {
      let next = (now2 + step + total2) % total2;
      const list = (0, import_vue350.unref)(timeList)[type4];
      while (list[next] && next !== now2) {
        next = (next + step + total2) % total2;
      }
      return next;
    };
    const modifyDateField = (type4, value) => {
      const list = (0, import_vue350.unref)(timeList)[type4];
      const isDisabled = list[value];
      if (isDisabled)
        return;
      const { hours, minutes, seconds } = (0, import_vue350.unref)(timePartials);
      let changeTo;
      switch (type4) {
        case "hours":
          changeTo = props.spinnerDate.hour(value).minute(minutes).second(seconds);
          break;
        case "minutes":
          changeTo = props.spinnerDate.hour(hours).minute(value).second(seconds);
          break;
        case "seconds":
          changeTo = props.spinnerDate.hour(hours).minute(minutes).second(value);
          break;
      }
      emit("change", changeTo);
    };
    const handleClick = (type4, { value, disabled }) => {
      if (!disabled) {
        modifyDateField(type4, value);
        emitSelectRange(type4);
        adjustSpinner(type4, value);
      }
    };
    const handleScroll2 = (type4) => {
      isScrolling = true;
      debouncedResetScroll(type4);
      const value = Math.min(Math.round((getScrollbarElement((0, import_vue350.unref)(listRefsMap[type4]).$el).scrollTop - (scrollBarHeight(type4) * 0.5 - 10) / typeItemHeight(type4) + 3) / typeItemHeight(type4)), type4 === "hours" ? 23 : 59);
      modifyDateField(type4, value);
    };
    const scrollBarHeight = (type4) => {
      return (0, import_vue350.unref)(listRefsMap[type4]).$el.offsetHeight;
    };
    const bindScrollEvent = () => {
      const bindFunction = (type4) => {
        const scrollbar = (0, import_vue350.unref)(listRefsMap[type4]);
        if (scrollbar && scrollbar.$el) {
          getScrollbarElement(scrollbar.$el).onscroll = () => {
            handleScroll2(type4);
          };
        }
      };
      bindFunction("hours");
      bindFunction("minutes");
      bindFunction("seconds");
    };
    (0, import_vue350.onMounted)(() => {
      (0, import_vue350.nextTick)(() => {
        !props.arrowControl && bindScrollEvent();
        adjustSpinners();
        if (props.role === "start")
          emitSelectRange("hours");
      });
    });
    const setRef = (scrollbar, type4) => {
      listRefsMap[type4].value = scrollbar;
    };
    emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
    emit("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
    (0, import_vue350.watch)(() => props.spinnerDate, () => {
      if (isScrolling)
        return;
      adjustSpinners();
    });
    return (_ctx, _cache) => {
      return (0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)("div", {
        class: (0, import_vue350.normalizeClass)([(0, import_vue350.unref)(ns2).b("spinner"), { "has-seconds": _ctx.showSeconds }])
      }, [
        !_ctx.arrowControl ? ((0, import_vue350.openBlock)(true), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 0 }, (0, import_vue350.renderList)((0, import_vue350.unref)(spinnerItems), (item) => {
          return (0, import_vue350.openBlock)(), (0, import_vue350.createBlock)((0, import_vue350.unref)(ElScrollbar), {
            key: item,
            ref_for: true,
            ref: (scrollbar) => setRef(scrollbar, item),
            class: (0, import_vue350.normalizeClass)((0, import_vue350.unref)(ns2).be("spinner", "wrapper")),
            "wrap-style": "max-height: inherit;",
            "view-class": (0, import_vue350.unref)(ns2).be("spinner", "list"),
            noresize: "",
            tag: "ul",
            onMouseenter: ($event) => emitSelectRange(item),
            onMousemove: ($event) => adjustCurrentSpinner(item)
          }, {
            default: (0, import_vue350.withCtx)(() => [
              ((0, import_vue350.openBlock)(true), (0, import_vue350.createElementBlock)(import_vue350.Fragment, null, (0, import_vue350.renderList)((0, import_vue350.unref)(timeList)[item], (disabled, key) => {
                return (0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)("li", {
                  key,
                  class: (0, import_vue350.normalizeClass)([
                    (0, import_vue350.unref)(ns2).be("spinner", "item"),
                    (0, import_vue350.unref)(ns2).is("active", key === (0, import_vue350.unref)(timePartials)[item]),
                    (0, import_vue350.unref)(ns2).is("disabled", disabled)
                  ]),
                  onClick: ($event) => handleClick(item, { value: key, disabled })
                }, [
                  item === "hours" ? ((0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 0 }, [
                    (0, import_vue350.createTextVNode)((0, import_vue350.toDisplayString)(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + (0, import_vue350.toDisplayString)(getAmPmFlag(key)), 1)
                  ], 64)) : ((0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 1 }, [
                    (0, import_vue350.createTextVNode)((0, import_vue350.toDisplayString)(("0" + key).slice(-2)), 1)
                  ], 64))
                ], 10, _hoisted_111);
              }), 128))
            ]),
            _: 2
          }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
        }), 128)) : (0, import_vue350.createCommentVNode)("v-if", true),
        _ctx.arrowControl ? ((0, import_vue350.openBlock)(true), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 1 }, (0, import_vue350.renderList)((0, import_vue350.unref)(spinnerItems), (item) => {
          return (0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)("div", {
            key: item,
            class: (0, import_vue350.normalizeClass)([(0, import_vue350.unref)(ns2).be("spinner", "wrapper"), (0, import_vue350.unref)(ns2).is("arrow")]),
            onMouseenter: ($event) => emitSelectRange(item)
          }, [
            (0, import_vue350.withDirectives)(((0, import_vue350.openBlock)(), (0, import_vue350.createBlock)((0, import_vue350.unref)(ElIcon), {
              class: (0, import_vue350.normalizeClass)(["arrow-up", (0, import_vue350.unref)(ns2).be("spinner", "arrow")])
            }, {
              default: (0, import_vue350.withCtx)(() => [
                (0, import_vue350.createVNode)((0, import_vue350.unref)(arrow_up_default))
              ]),
              _: 1
            }, 8, ["class"])), [
              [(0, import_vue350.unref)(vRepeatClick), onDecrement]
            ]),
            (0, import_vue350.withDirectives)(((0, import_vue350.openBlock)(), (0, import_vue350.createBlock)((0, import_vue350.unref)(ElIcon), {
              class: (0, import_vue350.normalizeClass)(["arrow-down", (0, import_vue350.unref)(ns2).be("spinner", "arrow")])
            }, {
              default: (0, import_vue350.withCtx)(() => [
                (0, import_vue350.createVNode)((0, import_vue350.unref)(arrow_down_default))
              ]),
              _: 1
            }, 8, ["class"])), [
              [(0, import_vue350.unref)(vRepeatClick), onIncrement]
            ]),
            (0, import_vue350.createElementVNode)("ul", {
              class: (0, import_vue350.normalizeClass)((0, import_vue350.unref)(ns2).be("spinner", "list"))
            }, [
              ((0, import_vue350.openBlock)(true), (0, import_vue350.createElementBlock)(import_vue350.Fragment, null, (0, import_vue350.renderList)((0, import_vue350.unref)(arrowControlTimeList)[item], (time, key) => {
                return (0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)("li", {
                  key,
                  class: (0, import_vue350.normalizeClass)([
                    (0, import_vue350.unref)(ns2).be("spinner", "item"),
                    (0, import_vue350.unref)(ns2).is("active", time === (0, import_vue350.unref)(timePartials)[item]),
                    (0, import_vue350.unref)(ns2).is("disabled", (0, import_vue350.unref)(timeList)[item][time])
                  ])
                }, [
                  typeof time === "number" ? ((0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 0 }, [
                    item === "hours" ? ((0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 0 }, [
                      (0, import_vue350.createTextVNode)((0, import_vue350.toDisplayString)(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + (0, import_vue350.toDisplayString)(getAmPmFlag(time)), 1)
                    ], 64)) : ((0, import_vue350.openBlock)(), (0, import_vue350.createElementBlock)(import_vue350.Fragment, { key: 1 }, [
                      (0, import_vue350.createTextVNode)((0, import_vue350.toDisplayString)(("0" + time).slice(-2)), 1)
                    ], 64))
                  ], 64)) : (0, import_vue350.createCommentVNode)("v-if", true)
                ], 2);
              }), 128))
            ], 2)
          ], 42, _hoisted_25);
        }), 128)) : (0, import_vue350.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var TimeSpinner = /* @__PURE__ */ _export_sfc(_sfc_main25, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker-com/panel-time-pick.mjs
var _sfc_main26 = /* @__PURE__ */ (0, import_vue351.defineComponent)({
  __name: "panel-time-pick",
  props: panelTimePickerProps,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(__props, { emit }) {
    const props = __props;
    const pickerBase = (0, import_vue351.inject)("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue
    } = pickerBase.props;
    const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours, disabledMinutes, disabledSeconds);
    const ns2 = useNamespace("time");
    const { t, lang } = useLocale();
    const selectionRange = (0, import_vue351.ref)([0, 2]);
    const oldValue = useOldValue(props);
    const transitionName = (0, import_vue351.computed)(() => {
      return isUndefined(props.actualVisible) ? `${ns2.namespace.value}-zoom-in-top` : "";
    });
    const showSeconds = (0, import_vue351.computed)(() => {
      return props.format.includes("ss");
    });
    const amPmMode = (0, import_vue351.computed)(() => {
      if (props.format.includes("A"))
        return "A";
      if (props.format.includes("a"))
        return "a";
      return "";
    });
    const isValidValue3 = (_date) => {
      const parsedDate = (0, import_dayjs2.default)(_date).locale(lang.value);
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate.isSame(result);
    };
    const handleCancel = () => {
      emit("pick", oldValue.value, false);
    };
    const handleConfirm = (visible = false, first = false) => {
      if (first)
        return;
      emit("pick", props.parsedValue, visible);
    };
    const handleChange = (_date) => {
      if (!props.visible) {
        return;
      }
      const result = getRangeAvailableTime(_date).millisecond(0);
      emit("pick", result, true);
    };
    const setSelectionRange = (start, end2) => {
      emit("select-range", start, end2);
      selectionRange.value = [start, end2];
    };
    const changeSelectionRange = (step) => {
      const list = [0, 3].concat(showSeconds.value ? [6] : []);
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      timePickerOptions["start_emitSelectRange"](mapping[next]);
    };
    const handleKeydown = (event) => {
      const code = event.code;
      const { left: left2, right: right2, up: up2, down: down2 } = EVENT_CODE;
      if ([left2, right2].includes(code)) {
        const step = code === left2 ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }
      if ([up2, down2].includes(code)) {
        const step = code === up2 ? -1 : 1;
        timePickerOptions["start_scrollDown"](step);
        event.preventDefault();
        return;
      }
    };
    const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    });
    const getRangeAvailableTime = (date5) => {
      return getAvailableTime(date5, props.datetimeRole || "", true);
    };
    const parseUserInput = (value) => {
      if (!value)
        return null;
      return (0, import_dayjs2.default)(value, props.format).locale(lang.value);
    };
    const formatToString = (value) => {
      if (!value)
        return null;
      return value.format(props.format);
    };
    const getDefaultValue2 = () => {
      return (0, import_dayjs2.default)(defaultValue).locale(lang.value);
    };
    emit("set-picker-option", ["isValidValue", isValidValue3]);
    emit("set-picker-option", ["formatToString", formatToString]);
    emit("set-picker-option", ["parseUserInput", parseUserInput]);
    emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
    emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
    emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
    return (_ctx, _cache) => {
      return (0, import_vue351.openBlock)(), (0, import_vue351.createBlock)(import_vue351.Transition, { name: (0, import_vue351.unref)(transitionName) }, {
        default: (0, import_vue351.withCtx)(() => [
          _ctx.actualVisible || _ctx.visible ? ((0, import_vue351.openBlock)(), (0, import_vue351.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue351.normalizeClass)((0, import_vue351.unref)(ns2).b("panel"))
          }, [
            (0, import_vue351.createElementVNode)("div", {
              class: (0, import_vue351.normalizeClass)([(0, import_vue351.unref)(ns2).be("panel", "content"), { "has-seconds": (0, import_vue351.unref)(showSeconds) }])
            }, [
              (0, import_vue351.createVNode)(TimeSpinner, {
                ref: "spinner",
                role: _ctx.datetimeRole || "start",
                "arrow-control": (0, import_vue351.unref)(arrowControl),
                "show-seconds": (0, import_vue351.unref)(showSeconds),
                "am-pm-mode": (0, import_vue351.unref)(amPmMode),
                "spinner-date": _ctx.parsedValue,
                "disabled-hours": (0, import_vue351.unref)(disabledHours),
                "disabled-minutes": (0, import_vue351.unref)(disabledMinutes),
                "disabled-seconds": (0, import_vue351.unref)(disabledSeconds),
                onChange: handleChange,
                onSetOption: (0, import_vue351.unref)(onSetOption),
                onSelectRange: setSelectionRange
              }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
            ], 2),
            (0, import_vue351.createElementVNode)("div", {
              class: (0, import_vue351.normalizeClass)((0, import_vue351.unref)(ns2).be("panel", "footer"))
            }, [
              (0, import_vue351.createElementVNode)("button", {
                type: "button",
                class: (0, import_vue351.normalizeClass)([(0, import_vue351.unref)(ns2).be("panel", "btn"), "cancel"]),
                onClick: handleCancel
              }, (0, import_vue351.toDisplayString)((0, import_vue351.unref)(t)("el.datepicker.cancel")), 3),
              (0, import_vue351.createElementVNode)("button", {
                type: "button",
                class: (0, import_vue351.normalizeClass)([(0, import_vue351.unref)(ns2).be("panel", "btn"), "confirm"]),
                onClick: _cache[0] || (_cache[0] = ($event) => handleConfirm())
              }, (0, import_vue351.toDisplayString)((0, import_vue351.unref)(t)("el.datepicker.confirm")), 3)
            ], 2)
          ], 2)) : (0, import_vue351.createCommentVNode)("v-if", true)
        ]),
        _: 1
      }, 8, ["name"]);
    };
  }
});
var TimePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main26, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker-com/panel-time-range.mjs
var import_vue352 = require("vue");
var import_dayjs3 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/props/panel-time-range.mjs
var panelTimeRangeProps = buildProps({
  ...timePanelSharedProps,
  parsedValue: {
    type: definePropType(Array)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker-com/panel-time-range.mjs
var import_shared32 = require("@vue/shared");
var _hoisted_113 = ["disabled"];
var _sfc_main27 = /* @__PURE__ */ (0, import_vue352.defineComponent)({
  __name: "panel-time-range",
  props: panelTimeRangeProps,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(__props, { emit }) {
    const props = __props;
    const makeSelectRange = (start, end2) => {
      const result = [];
      for (let i = start; i <= end2; i++) {
        result.push(i);
      }
      return result;
    };
    const { t, lang } = useLocale();
    const nsTime = useNamespace("time");
    const nsPicker = useNamespace("picker");
    const pickerBase = (0, import_vue352.inject)("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue
    } = pickerBase.props;
    const startTime = (0, import_vue352.computed)(() => props.parsedValue[0]);
    const endTime = (0, import_vue352.computed)(() => props.parsedValue[1]);
    const oldValue = useOldValue(props);
    const handleCancel = () => {
      emit("pick", oldValue.value, false);
    };
    const showSeconds = (0, import_vue352.computed)(() => {
      return props.format.includes("ss");
    });
    const amPmMode = (0, import_vue352.computed)(() => {
      if (props.format.includes("A"))
        return "A";
      if (props.format.includes("a"))
        return "a";
      return "";
    });
    const handleConfirm = (visible = false) => {
      emit("pick", [startTime.value, endTime.value], visible);
    };
    const handleMinChange = (date5) => {
      handleChange(date5.millisecond(0), endTime.value);
    };
    const handleMaxChange = (date5) => {
      handleChange(startTime.value, date5.millisecond(0));
    };
    const isValidValue3 = (_date) => {
      const parsedDate = _date.map((_2) => (0, import_dayjs3.default)(_2).locale(lang.value));
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
    };
    const handleChange = (start, end2) => {
      emit("pick", [start, end2], true);
    };
    const btnConfirmDisabled = (0, import_vue352.computed)(() => {
      return startTime.value > endTime.value;
    });
    const selectionRange = (0, import_vue352.ref)([0, 2]);
    const setMinSelectionRange = (start, end2) => {
      emit("select-range", start, end2, "min");
      selectionRange.value = [start, end2];
    };
    const offset2 = (0, import_vue352.computed)(() => showSeconds.value ? 11 : 8);
    const setMaxSelectionRange = (start, end2) => {
      emit("select-range", start, end2, "max");
      const _offset = (0, import_vue352.unref)(offset2);
      selectionRange.value = [start + _offset, end2 + _offset];
    };
    const changeSelectionRange = (step) => {
      const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      const half = list.length / 2;
      if (next < half) {
        timePickerOptions["start_emitSelectRange"](mapping[next]);
      } else {
        timePickerOptions["end_emitSelectRange"](mapping[next - half]);
      }
    };
    const handleKeydown = (event) => {
      const code = event.code;
      const { left: left2, right: right2, up: up2, down: down2 } = EVENT_CODE;
      if ([left2, right2].includes(code)) {
        const step = code === left2 ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }
      if ([up2, down2].includes(code)) {
        const step = code === up2 ? -1 : 1;
        const role = selectionRange.value[0] < offset2.value ? "start" : "end";
        timePickerOptions[`${role}_scrollDown`](step);
        event.preventDefault();
        return;
      }
    };
    const disabledHours_ = (role, compare) => {
      const defaultDisable = disabledHours ? disabledHours(role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? endTime.value : startTime.value);
      const compareHour = compareDate.hour();
      const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
      return union_default(defaultDisable, nextDisable);
    };
    const disabledMinutes_ = (hour, role, compare) => {
      const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? endTime.value : startTime.value);
      const compareHour = compareDate.hour();
      if (hour !== compareHour) {
        return defaultDisable;
      }
      const compareMinute = compareDate.minute();
      const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
      return union_default(defaultDisable, nextDisable);
    };
    const disabledSeconds_ = (hour, minute, role, compare) => {
      const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? endTime.value : startTime.value);
      const compareHour = compareDate.hour();
      const compareMinute = compareDate.minute();
      if (hour !== compareHour || minute !== compareMinute) {
        return defaultDisable;
      }
      const compareSecond = compareDate.second();
      const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
      return union_default(defaultDisable, nextDisable);
    };
    const getRangeAvailableTime = ([start, end2]) => {
      return [
        getAvailableTime(start, "start", true, end2),
        getAvailableTime(end2, "end", false, start)
      ];
    };
    const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours_, disabledMinutes_, disabledSeconds_);
    const {
      timePickerOptions,
      getAvailableTime,
      onSetOption
    } = useTimePanel({
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    });
    const parseUserInput = (days) => {
      if (!days)
        return null;
      if ((0, import_shared32.isArray)(days)) {
        return days.map((d2) => (0, import_dayjs3.default)(d2, props.format).locale(lang.value));
      }
      return (0, import_dayjs3.default)(days, props.format).locale(lang.value);
    };
    const formatToString = (days) => {
      if (!days)
        return null;
      if ((0, import_shared32.isArray)(days)) {
        return days.map((d2) => d2.format(props.format));
      }
      return days.format(props.format);
    };
    const getDefaultValue2 = () => {
      if ((0, import_shared32.isArray)(defaultValue)) {
        return defaultValue.map((d2) => (0, import_dayjs3.default)(d2).locale(lang.value));
      }
      const defaultDay = (0, import_dayjs3.default)(defaultValue).locale(lang.value);
      return [defaultDay, defaultDay.add(60, "m")];
    };
    emit("set-picker-option", ["formatToString", formatToString]);
    emit("set-picker-option", ["parseUserInput", parseUserInput]);
    emit("set-picker-option", ["isValidValue", isValidValue3]);
    emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
    emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
    emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
    return (_ctx, _cache) => {
      return _ctx.actualVisible ? ((0, import_vue352.openBlock)(), (0, import_vue352.createElementBlock)("div", {
        key: 0,
        class: (0, import_vue352.normalizeClass)([(0, import_vue352.unref)(nsTime).b("range-picker"), (0, import_vue352.unref)(nsPicker).b("panel")])
      }, [
        (0, import_vue352.createElementVNode)("div", {
          class: (0, import_vue352.normalizeClass)((0, import_vue352.unref)(nsTime).be("range-picker", "content"))
        }, [
          (0, import_vue352.createElementVNode)("div", {
            class: (0, import_vue352.normalizeClass)((0, import_vue352.unref)(nsTime).be("range-picker", "cell"))
          }, [
            (0, import_vue352.createElementVNode)("div", {
              class: (0, import_vue352.normalizeClass)((0, import_vue352.unref)(nsTime).be("range-picker", "header"))
            }, (0, import_vue352.toDisplayString)((0, import_vue352.unref)(t)("el.datepicker.startTime")), 3),
            (0, import_vue352.createElementVNode)("div", {
              class: (0, import_vue352.normalizeClass)([
                (0, import_vue352.unref)(nsTime).be("range-picker", "body"),
                (0, import_vue352.unref)(nsTime).be("panel", "content"),
                (0, import_vue352.unref)(nsTime).is("arrow", (0, import_vue352.unref)(arrowControl)),
                { "has-seconds": (0, import_vue352.unref)(showSeconds) }
              ])
            }, [
              (0, import_vue352.createVNode)(TimeSpinner, {
                ref: "minSpinner",
                role: "start",
                "show-seconds": (0, import_vue352.unref)(showSeconds),
                "am-pm-mode": (0, import_vue352.unref)(amPmMode),
                "arrow-control": (0, import_vue352.unref)(arrowControl),
                "spinner-date": (0, import_vue352.unref)(startTime),
                "disabled-hours": disabledHours_,
                "disabled-minutes": disabledMinutes_,
                "disabled-seconds": disabledSeconds_,
                onChange: handleMinChange,
                onSetOption: (0, import_vue352.unref)(onSetOption),
                onSelectRange: setMinSelectionRange
              }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
            ], 2)
          ], 2),
          (0, import_vue352.createElementVNode)("div", {
            class: (0, import_vue352.normalizeClass)((0, import_vue352.unref)(nsTime).be("range-picker", "cell"))
          }, [
            (0, import_vue352.createElementVNode)("div", {
              class: (0, import_vue352.normalizeClass)((0, import_vue352.unref)(nsTime).be("range-picker", "header"))
            }, (0, import_vue352.toDisplayString)((0, import_vue352.unref)(t)("el.datepicker.endTime")), 3),
            (0, import_vue352.createElementVNode)("div", {
              class: (0, import_vue352.normalizeClass)([
                (0, import_vue352.unref)(nsTime).be("range-picker", "body"),
                (0, import_vue352.unref)(nsTime).be("panel", "content"),
                (0, import_vue352.unref)(nsTime).is("arrow", (0, import_vue352.unref)(arrowControl)),
                { "has-seconds": (0, import_vue352.unref)(showSeconds) }
              ])
            }, [
              (0, import_vue352.createVNode)(TimeSpinner, {
                ref: "maxSpinner",
                role: "end",
                "show-seconds": (0, import_vue352.unref)(showSeconds),
                "am-pm-mode": (0, import_vue352.unref)(amPmMode),
                "arrow-control": (0, import_vue352.unref)(arrowControl),
                "spinner-date": (0, import_vue352.unref)(endTime),
                "disabled-hours": disabledHours_,
                "disabled-minutes": disabledMinutes_,
                "disabled-seconds": disabledSeconds_,
                onChange: handleMaxChange,
                onSetOption: (0, import_vue352.unref)(onSetOption),
                onSelectRange: setMaxSelectionRange
              }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
            ], 2)
          ], 2)
        ], 2),
        (0, import_vue352.createElementVNode)("div", {
          class: (0, import_vue352.normalizeClass)((0, import_vue352.unref)(nsTime).be("panel", "footer"))
        }, [
          (0, import_vue352.createElementVNode)("button", {
            type: "button",
            class: (0, import_vue352.normalizeClass)([(0, import_vue352.unref)(nsTime).be("panel", "btn"), "cancel"]),
            onClick: _cache[0] || (_cache[0] = ($event) => handleCancel())
          }, (0, import_vue352.toDisplayString)((0, import_vue352.unref)(t)("el.datepicker.cancel")), 3),
          (0, import_vue352.createElementVNode)("button", {
            type: "button",
            class: (0, import_vue352.normalizeClass)([(0, import_vue352.unref)(nsTime).be("panel", "btn"), "confirm"]),
            disabled: (0, import_vue352.unref)(btnConfirmDisabled),
            onClick: _cache[1] || (_cache[1] = ($event) => handleConfirm())
          }, (0, import_vue352.toDisplayString)((0, import_vue352.unref)(t)("el.datepicker.confirm")), 11, _hoisted_113)
        ], 2)
      ], 2)) : (0, import_vue352.createCommentVNode)("v-if", true);
    };
  }
});
var TimeRangePanel = /* @__PURE__ */ _export_sfc(_sfc_main27, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/src/time-picker.mjs
import_dayjs4.default.extend(import_customParseFormat.default);
var TimePicker = (0, import_vue353.defineComponent)({
  name: "ElTimePicker",
  install: null,
  props: {
    ...timePickerDefaultProps,
    isRange: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue"],
  setup(props, ctx) {
    const commonPicker = (0, import_vue353.ref)();
    const [type4, Panel] = props.isRange ? ["timerange", TimeRangePanel] : ["time", TimePickPanel];
    const modelUpdater = (value) => ctx.emit("update:modelValue", value);
    (0, import_vue353.provide)("ElPopperOptions", props.popperOptions);
    ctx.expose({
      focus: (e) => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.handleFocusInput(e);
      },
      blur: (e) => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.handleBlurInput(e);
      },
      handleOpen: () => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.handleOpen();
      },
      handleClose: () => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.handleClose();
      }
    });
    return () => {
      var _a2;
      const format2 = (_a2 = props.format) != null ? _a2 : DEFAULT_FORMATS_TIME;
      return (0, import_vue353.createVNode)(CommonPicker, (0, import_vue353.mergeProps)(props, {
        "ref": commonPicker,
        "type": type4,
        "format": format2,
        "onUpdate:modelValue": modelUpdater
      }), {
        default: (props2) => (0, import_vue353.createVNode)(Panel, props2, null)
      });
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-picker/index.mjs
var _TimePicker = TimePicker;
_TimePicker.install = (app) => {
  app.component(_TimePicker.name, _TimePicker);
};
var ElTimePicker = _TimePicker;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/date-table.mjs
var import_shared33 = require("@vue/shared");
var getPrevMonthLastDays = (date5, count) => {
  const lastDay = date5.subtract(1, "month").endOf("month").date();
  return rangeArr(count).map((_2, index2) => lastDay - (count - index2 - 1));
};
var getMonthDays = (date5) => {
  const days = date5.daysInMonth();
  return rangeArr(days).map((_2, index2) => index2 + 1);
};
var toNestedArr = (days) => rangeArr(days.length / 7).map((index2) => {
  const start = index2 * 7;
  return days.slice(start, start + 7);
});
var dateTableProps = buildProps({
  selectedDay: {
    type: definePropType(Object)
  },
  range: {
    type: definePropType(Array)
  },
  date: {
    type: definePropType(Object),
    required: true
  },
  hideHeader: {
    type: Boolean
  }
});
var dateTableEmits = {
  pick: (value) => (0, import_shared33.isObject)(value)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/use-date-table.mjs
var import_vue354 = require("vue");
var import_dayjs5 = __toESM(require_dayjs_min(), 1);
var import_localeData = __toESM(require_localeData(), 1);
var useDateTable = (props, emit) => {
  import_dayjs5.default.extend(import_localeData.default);
  const firstDayOfWeek = import_dayjs5.default.localeData().firstDayOfWeek();
  const { t, lang } = useLocale();
  const now2 = (0, import_dayjs5.default)().locale(lang.value);
  const isInRange = (0, import_vue354.computed)(() => !!props.range && !!props.range.length);
  const rows = (0, import_vue354.computed)(() => {
    let days = [];
    if (isInRange.value) {
      const [start, end2] = props.range;
      const currentMonthRange = rangeArr(end2.date() - start.date() + 1).map((index2) => ({
        text: start.date() + index2,
        type: "current"
      }));
      let remaining = currentMonthRange.length % 7;
      remaining = remaining === 0 ? 0 : 7 - remaining;
      const nextMonthRange = rangeArr(remaining).map((_2, index2) => ({
        text: index2 + 1,
        type: "next"
      }));
      days = currentMonthRange.concat(nextMonthRange);
    } else {
      const firstDay = props.date.startOf("month").day();
      const prevMonthDays = getPrevMonthLastDays(props.date, (firstDay - firstDayOfWeek + 7) % 7).map((day) => ({
        text: day,
        type: "prev"
      }));
      const currentMonthDays = getMonthDays(props.date).map((day) => ({
        text: day,
        type: "current"
      }));
      days = [...prevMonthDays, ...currentMonthDays];
      const remaining = 7 - (days.length % 7 || 7);
      const nextMonthDays = rangeArr(remaining).map((_2, index2) => ({
        text: index2 + 1,
        type: "next"
      }));
      days = days.concat(nextMonthDays);
    }
    return toNestedArr(days);
  });
  const weekDays = (0, import_vue354.computed)(() => {
    const start = firstDayOfWeek;
    if (start === 0) {
      return WEEK_DAYS.map((_2) => t(`el.datepicker.weeks.${_2}`));
    } else {
      return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start)).map((_2) => t(`el.datepicker.weeks.${_2}`));
    }
  });
  const getFormattedDate = (day, type4) => {
    switch (type4) {
      case "prev":
        return props.date.startOf("month").subtract(1, "month").date(day);
      case "next":
        return props.date.startOf("month").add(1, "month").date(day);
      case "current":
        return props.date.date(day);
    }
  };
  const handlePickDay = ({ text, type: type4 }) => {
    const date5 = getFormattedDate(text, type4);
    emit("pick", date5);
  };
  const getSlotData = ({ text, type: type4 }) => {
    const day = getFormattedDate(text, type4);
    return {
      isSelected: day.isSame(props.selectedDay),
      type: `${type4}-month`,
      day: day.format("YYYY-MM-DD"),
      date: day.toDate()
    };
  };
  return {
    now: now2,
    isInRange,
    rows,
    weekDays,
    getFormattedDate,
    handlePickDay,
    getSlotData
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/date-table2.mjs
var _hoisted_115 = { key: 0 };
var _hoisted_27 = ["onClick"];
var __default__22 = (0, import_vue355.defineComponent)({
  name: "DateTable"
});
var _sfc_main28 = /* @__PURE__ */ (0, import_vue355.defineComponent)({
  ...__default__22,
  props: dateTableProps,
  emits: dateTableEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const {
      isInRange,
      now: now2,
      rows,
      weekDays,
      getFormattedDate,
      handlePickDay,
      getSlotData
    } = useDateTable(props, emit);
    const nsTable = useNamespace("calendar-table");
    const nsDay = useNamespace("calendar-day");
    const getCellClass = ({ text, type: type4 }) => {
      const classes = [type4];
      if (type4 === "current") {
        const date5 = getFormattedDate(text, type4);
        if (date5.isSame(props.selectedDay, "day")) {
          classes.push(nsDay.is("selected"));
        }
        if (date5.isSame(now2, "day")) {
          classes.push(nsDay.is("today"));
        }
      }
      return classes;
    };
    expose({
      getFormattedDate
    });
    return (_ctx, _cache) => {
      return (0, import_vue355.openBlock)(), (0, import_vue355.createElementBlock)("table", {
        class: (0, import_vue355.normalizeClass)([(0, import_vue355.unref)(nsTable).b(), (0, import_vue355.unref)(nsTable).is("range", (0, import_vue355.unref)(isInRange))]),
        cellspacing: "0",
        cellpadding: "0"
      }, [
        !_ctx.hideHeader ? ((0, import_vue355.openBlock)(), (0, import_vue355.createElementBlock)("thead", _hoisted_115, [
          ((0, import_vue355.openBlock)(true), (0, import_vue355.createElementBlock)(import_vue355.Fragment, null, (0, import_vue355.renderList)((0, import_vue355.unref)(weekDays), (day) => {
            return (0, import_vue355.openBlock)(), (0, import_vue355.createElementBlock)("th", { key: day }, (0, import_vue355.toDisplayString)(day), 1);
          }), 128))
        ])) : (0, import_vue355.createCommentVNode)("v-if", true),
        (0, import_vue355.createElementVNode)("tbody", null, [
          ((0, import_vue355.openBlock)(true), (0, import_vue355.createElementBlock)(import_vue355.Fragment, null, (0, import_vue355.renderList)((0, import_vue355.unref)(rows), (row, index2) => {
            return (0, import_vue355.openBlock)(), (0, import_vue355.createElementBlock)("tr", {
              key: index2,
              class: (0, import_vue355.normalizeClass)({
                [(0, import_vue355.unref)(nsTable).e("row")]: true,
                [(0, import_vue355.unref)(nsTable).em("row", "hide-border")]: index2 === 0 && _ctx.hideHeader
              })
            }, [
              ((0, import_vue355.openBlock)(true), (0, import_vue355.createElementBlock)(import_vue355.Fragment, null, (0, import_vue355.renderList)(row, (cell, key) => {
                return (0, import_vue355.openBlock)(), (0, import_vue355.createElementBlock)("td", {
                  key,
                  class: (0, import_vue355.normalizeClass)(getCellClass(cell)),
                  onClick: ($event) => (0, import_vue355.unref)(handlePickDay)(cell)
                }, [
                  (0, import_vue355.createElementVNode)("div", {
                    class: (0, import_vue355.normalizeClass)((0, import_vue355.unref)(nsDay).b())
                  }, [
                    (0, import_vue355.renderSlot)(_ctx.$slots, "date-cell", {
                      data: (0, import_vue355.unref)(getSlotData)(cell)
                    }, () => [
                      (0, import_vue355.createElementVNode)("span", null, (0, import_vue355.toDisplayString)(cell.text), 1)
                    ])
                  ], 2)
                ], 10, _hoisted_27);
              }), 128))
            ], 2);
          }), 128))
        ])
      ], 2);
    };
  }
});
var DateTable = /* @__PURE__ */ _export_sfc(_sfc_main28, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/use-calendar.mjs
var import_vue356 = require("vue");
var import_dayjs6 = __toESM(require_dayjs_min(), 1);
var adjacentMonth = (start, end2) => {
  const firstMonthLastDay = start.endOf("month");
  const lastMonthFirstDay = end2.startOf("month");
  const isSameWeek = firstMonthLastDay.isSame(lastMonthFirstDay, "week");
  const lastMonthStartDay = isSameWeek ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
  return [
    [start, firstMonthLastDay],
    [lastMonthStartDay.startOf("week"), end2]
  ];
};
var threeConsecutiveMonth = (start, end2) => {
  const firstMonthLastDay = start.endOf("month");
  const secondMonthFirstDay = start.add(1, "month").startOf("month");
  const secondMonthStartDay = firstMonthLastDay.isSame(secondMonthFirstDay, "week") ? secondMonthFirstDay.add(1, "week") : secondMonthFirstDay;
  const secondMonthLastDay = secondMonthStartDay.endOf("month");
  const lastMonthFirstDay = end2.startOf("month");
  const lastMonthStartDay = secondMonthLastDay.isSame(lastMonthFirstDay, "week") ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
  return [
    [start, firstMonthLastDay],
    [secondMonthStartDay.startOf("week"), secondMonthLastDay],
    [lastMonthStartDay.startOf("week"), end2]
  ];
};
var useCalendar = (props, emit, componentName2) => {
  const slots = (0, import_vue356.useSlots)();
  const { lang } = useLocale();
  const selectedDay = (0, import_vue356.ref)();
  const now2 = (0, import_dayjs6.default)().locale(lang.value);
  const realSelectedDay = (0, import_vue356.computed)({
    get() {
      if (!props.modelValue)
        return selectedDay.value;
      return date5.value;
    },
    set(val) {
      if (!val)
        return;
      selectedDay.value = val;
      const result = val.toDate();
      emit(INPUT_EVENT, result);
      emit(UPDATE_MODEL_EVENT, result);
    }
  });
  const validatedRange = (0, import_vue356.computed)(() => {
    if (!props.range)
      return [];
    const rangeArrDayjs = props.range.map((_2) => (0, import_dayjs6.default)(_2).locale(lang.value));
    const [startDayjs, endDayjs] = rangeArrDayjs;
    if (startDayjs.isAfter(endDayjs)) {
      debugWarn(componentName2, "end time should be greater than start time");
      return [];
    }
    if (startDayjs.isSame(endDayjs, "month")) {
      return calculateValidatedDateRange(startDayjs, endDayjs);
    } else {
      if (startDayjs.add(1, "month").month() !== endDayjs.month()) {
        debugWarn(componentName2, "start time and end time interval must not exceed two months");
        return [];
      }
      return calculateValidatedDateRange(startDayjs, endDayjs);
    }
  });
  const date5 = (0, import_vue356.computed)(() => {
    if (!props.modelValue) {
      return realSelectedDay.value || (validatedRange.value.length ? validatedRange.value[0][0] : now2);
    } else {
      return (0, import_dayjs6.default)(props.modelValue).locale(lang.value);
    }
  });
  const prevMonthDayjs = (0, import_vue356.computed)(() => date5.value.subtract(1, "month").date(1));
  const nextMonthDayjs = (0, import_vue356.computed)(() => date5.value.add(1, "month").date(1));
  const prevYearDayjs = (0, import_vue356.computed)(() => date5.value.subtract(1, "year").date(1));
  const nextYearDayjs = (0, import_vue356.computed)(() => date5.value.add(1, "year").date(1));
  const calculateValidatedDateRange = (startDayjs, endDayjs) => {
    const firstDay = startDayjs.startOf("week");
    const lastDay = endDayjs.endOf("week");
    const firstMonth = firstDay.get("month");
    const lastMonth = lastDay.get("month");
    if (firstMonth === lastMonth) {
      return [[firstDay, lastDay]];
    } else if ((firstMonth + 1) % 12 === lastMonth) {
      return adjacentMonth(firstDay, lastDay);
    } else if (firstMonth + 2 === lastMonth || (firstMonth + 1) % 11 === lastMonth) {
      return threeConsecutiveMonth(firstDay, lastDay);
    } else {
      debugWarn(componentName2, "start time and end time interval must not exceed two months");
      return [];
    }
  };
  const pickDay = (day) => {
    realSelectedDay.value = day;
  };
  const selectDate = (type4) => {
    const dateMap = {
      "prev-month": prevMonthDayjs.value,
      "next-month": nextMonthDayjs.value,
      "prev-year": prevYearDayjs.value,
      "next-year": nextYearDayjs.value,
      today: now2
    };
    const day = dateMap[type4];
    if (!day.isSame(date5.value, "day")) {
      pickDay(day);
    }
  };
  useDeprecated({
    from: '"dateCell"',
    replacement: '"date-cell"',
    scope: "ElCalendar",
    version: "2.3.0",
    ref: "https://element-plus.org/en-US/component/calendar.html#slots",
    type: "Slot"
  }, (0, import_vue356.computed)(() => !!slots.dateCell));
  return {
    calculateValidatedDateRange,
    date: date5,
    realSelectedDay,
    pickDay,
    selectDate,
    validatedRange
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/calendar.mjs
var import_shared34 = require("@vue/shared");
var isValidRange = (range3) => (0, import_shared34.isArray)(range3) && range3.length === 2 && range3.every((item) => (0, import_shared34.isDate)(item));
var calendarProps = buildProps({
  modelValue: {
    type: Date
  },
  range: {
    type: definePropType(Array),
    validator: isValidRange
  }
});
var calendarEmits = {
  [UPDATE_MODEL_EVENT]: (value) => (0, import_shared34.isDate)(value),
  [INPUT_EVENT]: (value) => (0, import_shared34.isDate)(value)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/src/calendar2.mjs
var COMPONENT_NAME6 = "ElCalendar";
var __default__23 = (0, import_vue357.defineComponent)({
  name: COMPONENT_NAME6
});
var _sfc_main29 = /* @__PURE__ */ (0, import_vue357.defineComponent)({
  ...__default__23,
  props: calendarProps,
  emits: calendarEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("calendar");
    const {
      calculateValidatedDateRange,
      date: date5,
      pickDay,
      realSelectedDay,
      selectDate,
      validatedRange
    } = useCalendar(props, emit, COMPONENT_NAME6);
    const { t } = useLocale();
    const i18nDate = (0, import_vue357.computed)(() => {
      const pickedMonth = `el.datepicker.month${date5.value.format("M")}`;
      return `${date5.value.year()} ${t("el.datepicker.year")} ${t(pickedMonth)}`;
    });
    expose({
      selectedDay: realSelectedDay,
      pickDay,
      selectDate,
      calculateValidatedDateRange
    });
    return (_ctx, _cache) => {
      return (0, import_vue357.openBlock)(), (0, import_vue357.createElementBlock)("div", {
        class: (0, import_vue357.normalizeClass)((0, import_vue357.unref)(ns2).b())
      }, [
        (0, import_vue357.createElementVNode)("div", {
          class: (0, import_vue357.normalizeClass)((0, import_vue357.unref)(ns2).e("header"))
        }, [
          (0, import_vue357.renderSlot)(_ctx.$slots, "header", { date: (0, import_vue357.unref)(i18nDate) }, () => [
            (0, import_vue357.createElementVNode)("div", {
              class: (0, import_vue357.normalizeClass)((0, import_vue357.unref)(ns2).e("title"))
            }, (0, import_vue357.toDisplayString)((0, import_vue357.unref)(i18nDate)), 3),
            (0, import_vue357.unref)(validatedRange).length === 0 ? ((0, import_vue357.openBlock)(), (0, import_vue357.createElementBlock)("div", {
              key: 0,
              class: (0, import_vue357.normalizeClass)((0, import_vue357.unref)(ns2).e("button-group"))
            }, [
              (0, import_vue357.createVNode)((0, import_vue357.unref)(ElButtonGroup), null, {
                default: (0, import_vue357.withCtx)(() => [
                  (0, import_vue357.createVNode)((0, import_vue357.unref)(ElButton), {
                    size: "small",
                    onClick: _cache[0] || (_cache[0] = ($event) => (0, import_vue357.unref)(selectDate)("prev-month"))
                  }, {
                    default: (0, import_vue357.withCtx)(() => [
                      (0, import_vue357.createTextVNode)((0, import_vue357.toDisplayString)((0, import_vue357.unref)(t)("el.datepicker.prevMonth")), 1)
                    ]),
                    _: 1
                  }),
                  (0, import_vue357.createVNode)((0, import_vue357.unref)(ElButton), {
                    size: "small",
                    onClick: _cache[1] || (_cache[1] = ($event) => (0, import_vue357.unref)(selectDate)("today"))
                  }, {
                    default: (0, import_vue357.withCtx)(() => [
                      (0, import_vue357.createTextVNode)((0, import_vue357.toDisplayString)((0, import_vue357.unref)(t)("el.datepicker.today")), 1)
                    ]),
                    _: 1
                  }),
                  (0, import_vue357.createVNode)((0, import_vue357.unref)(ElButton), {
                    size: "small",
                    onClick: _cache[2] || (_cache[2] = ($event) => (0, import_vue357.unref)(selectDate)("next-month"))
                  }, {
                    default: (0, import_vue357.withCtx)(() => [
                      (0, import_vue357.createTextVNode)((0, import_vue357.toDisplayString)((0, import_vue357.unref)(t)("el.datepicker.nextMonth")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ], 2)) : (0, import_vue357.createCommentVNode)("v-if", true)
          ])
        ], 2),
        (0, import_vue357.unref)(validatedRange).length === 0 ? ((0, import_vue357.openBlock)(), (0, import_vue357.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue357.normalizeClass)((0, import_vue357.unref)(ns2).e("body"))
        }, [
          (0, import_vue357.createVNode)(DateTable, {
            date: (0, import_vue357.unref)(date5),
            "selected-day": (0, import_vue357.unref)(realSelectedDay),
            onPick: (0, import_vue357.unref)(pickDay)
          }, (0, import_vue357.createSlots)({ _: 2 }, [
            _ctx.$slots["date-cell"] || _ctx.$slots.dateCell ? {
              name: "date-cell",
              fn: (0, import_vue357.withCtx)((data) => [
                _ctx.$slots["date-cell"] ? (0, import_vue357.renderSlot)(_ctx.$slots, "date-cell", (0, import_vue357.normalizeProps)((0, import_vue357.mergeProps)({ key: 0 }, data))) : (0, import_vue357.renderSlot)(_ctx.$slots, "dateCell", (0, import_vue357.normalizeProps)((0, import_vue357.mergeProps)({ key: 1 }, data)))
              ])
            } : void 0
          ]), 1032, ["date", "selected-day", "onPick"])
        ], 2)) : ((0, import_vue357.openBlock)(), (0, import_vue357.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue357.normalizeClass)((0, import_vue357.unref)(ns2).e("body"))
        }, [
          ((0, import_vue357.openBlock)(true), (0, import_vue357.createElementBlock)(import_vue357.Fragment, null, (0, import_vue357.renderList)((0, import_vue357.unref)(validatedRange), (range_, index2) => {
            return (0, import_vue357.openBlock)(), (0, import_vue357.createBlock)(DateTable, {
              key: index2,
              date: range_[0],
              "selected-day": (0, import_vue357.unref)(realSelectedDay),
              range: range_,
              "hide-header": index2 !== 0,
              onPick: (0, import_vue357.unref)(pickDay)
            }, (0, import_vue357.createSlots)({ _: 2 }, [
              _ctx.$slots["date-cell"] || _ctx.$slots.dateCell ? {
                name: "date-cell",
                fn: (0, import_vue357.withCtx)((data) => [
                  _ctx.$slots["date-cell"] ? (0, import_vue357.renderSlot)(_ctx.$slots, "date-cell", (0, import_vue357.normalizeProps)((0, import_vue357.mergeProps)({ key: 0 }, data))) : (0, import_vue357.renderSlot)(_ctx.$slots, "dateCell", (0, import_vue357.normalizeProps)((0, import_vue357.mergeProps)({ key: 1 }, data)))
                ])
              } : void 0
            ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]);
          }), 128))
        ], 2))
      ], 2);
    };
  }
});
var Calendar = /* @__PURE__ */ _export_sfc(_sfc_main29, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/calendar/index.mjs
var ElCalendar = withInstall(Calendar);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/card/src/card2.mjs
var import_vue358 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/card/src/card.mjs
var cardProps = buildProps({
  header: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/card/src/card2.mjs
var __default__24 = (0, import_vue358.defineComponent)({
  name: "ElCard"
});
var _sfc_main30 = /* @__PURE__ */ (0, import_vue358.defineComponent)({
  ...__default__24,
  props: cardProps,
  setup(__props) {
    const ns2 = useNamespace("card");
    return (_ctx, _cache) => {
      return (0, import_vue358.openBlock)(), (0, import_vue358.createElementBlock)("div", {
        class: (0, import_vue358.normalizeClass)([(0, import_vue358.unref)(ns2).b(), (0, import_vue358.unref)(ns2).is(`${_ctx.shadow}-shadow`)])
      }, [
        _ctx.$slots.header || _ctx.header ? ((0, import_vue358.openBlock)(), (0, import_vue358.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue358.normalizeClass)((0, import_vue358.unref)(ns2).e("header"))
        }, [
          (0, import_vue358.renderSlot)(_ctx.$slots, "header", {}, () => [
            (0, import_vue358.createTextVNode)((0, import_vue358.toDisplayString)(_ctx.header), 1)
          ])
        ], 2)) : (0, import_vue358.createCommentVNode)("v-if", true),
        (0, import_vue358.createElementVNode)("div", {
          class: (0, import_vue358.normalizeClass)((0, import_vue358.unref)(ns2).e("body")),
          style: (0, import_vue358.normalizeStyle)(_ctx.bodyStyle)
        }, [
          (0, import_vue358.renderSlot)(_ctx.$slots, "default")
        ], 6)
      ], 2);
    };
  }
});
var Card = /* @__PURE__ */ _export_sfc(_sfc_main30, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/card/index.mjs
var ElCard = withInstall(Card);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/carousel2.mjs
var import_vue360 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/carousel.mjs
var carouselProps = buildProps({
  initialIndex: {
    type: Number,
    default: 0
  },
  height: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: true
  },
  interval: {
    type: Number,
    default: 3e3
  },
  indicatorPosition: {
    type: String,
    values: ["", "none", "outside"],
    default: ""
  },
  indicator: {
    type: Boolean,
    default: true
  },
  arrow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "hover"
  },
  type: {
    type: String,
    values: ["", "card"],
    default: ""
  },
  loop: {
    type: Boolean,
    default: true
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  pauseOnHover: {
    type: Boolean,
    default: true
  }
});
var carouselEmits = {
  change: (current, prev) => [current, prev].every(isNumber)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/use-carousel.mjs
var import_vue359 = require("vue");
var import_shared35 = require("@vue/shared");
var THROTTLE_TIME = 300;
var useCarousel = (props, emit, componentName2) => {
  const {
    children: items,
    addChild: addItem,
    removeChild: removeItem
  } = useOrderedChildren((0, import_vue359.getCurrentInstance)(), "ElCarouselItem");
  const activeIndex = (0, import_vue359.ref)(-1);
  const timer = (0, import_vue359.ref)(null);
  const hover = (0, import_vue359.ref)(false);
  const root2 = (0, import_vue359.ref)();
  const arrowDisplay = (0, import_vue359.computed)(() => props.arrow !== "never" && !(0, import_vue359.unref)(isVertical));
  const hasLabel = (0, import_vue359.computed)(() => {
    return items.value.some((item) => item.props.label.toString().length > 0);
  });
  const isCardType = (0, import_vue359.computed)(() => props.type === "card");
  const isVertical = (0, import_vue359.computed)(() => props.direction === "vertical");
  const throttledArrowClick = throttle_default((index2) => {
    setActiveItem(index2);
  }, THROTTLE_TIME, { trailing: true });
  const throttledIndicatorHover = throttle_default((index2) => {
    handleIndicatorHover(index2);
  }, THROTTLE_TIME);
  function pauseTimer() {
    if (timer.value) {
      clearInterval(timer.value);
      timer.value = null;
    }
  }
  function startTimer() {
    if (props.interval <= 0 || !props.autoplay || timer.value)
      return;
    timer.value = setInterval(() => playSlides(), props.interval);
  }
  const playSlides = () => {
    if (activeIndex.value < items.value.length - 1) {
      activeIndex.value = activeIndex.value + 1;
    } else if (props.loop) {
      activeIndex.value = 0;
    }
  };
  function setActiveItem(index2) {
    if ((0, import_shared35.isString)(index2)) {
      const filteredItems = items.value.filter((item) => item.props.name === index2);
      if (filteredItems.length > 0) {
        index2 = items.value.indexOf(filteredItems[0]);
      }
    }
    index2 = Number(index2);
    if (Number.isNaN(index2) || index2 !== Math.floor(index2)) {
      debugWarn(componentName2, "index must be integer.");
      return;
    }
    const itemCount = items.value.length;
    const oldIndex2 = activeIndex.value;
    if (index2 < 0) {
      activeIndex.value = props.loop ? itemCount - 1 : 0;
    } else if (index2 >= itemCount) {
      activeIndex.value = props.loop ? 0 : itemCount - 1;
    } else {
      activeIndex.value = index2;
    }
    if (oldIndex2 === activeIndex.value) {
      resetItemPosition(oldIndex2);
    }
    resetTimer();
  }
  function resetItemPosition(oldIndex2) {
    items.value.forEach((item, index2) => {
      item.translateItem(index2, activeIndex.value, oldIndex2);
    });
  }
  function itemInStage(item, index2) {
    var _a2, _b, _c, _d;
    const _items = (0, import_vue359.unref)(items);
    const itemCount = _items.length;
    if (itemCount === 0 || !item.states.inStage)
      return false;
    const nextItemIndex = index2 + 1;
    const prevItemIndex = index2 - 1;
    const lastItemIndex = itemCount - 1;
    const isLastItemActive = _items[lastItemIndex].states.active;
    const isFirstItemActive = _items[0].states.active;
    const isNextItemActive = (_b = (_a2 = _items[nextItemIndex]) == null ? void 0 : _a2.states) == null ? void 0 : _b.active;
    const isPrevItemActive = (_d = (_c = _items[prevItemIndex]) == null ? void 0 : _c.states) == null ? void 0 : _d.active;
    if (index2 === lastItemIndex && isFirstItemActive || isNextItemActive) {
      return "left";
    } else if (index2 === 0 && isLastItemActive || isPrevItemActive) {
      return "right";
    }
    return false;
  }
  function handleMouseEnter() {
    hover.value = true;
    if (props.pauseOnHover) {
      pauseTimer();
    }
  }
  function handleMouseLeave() {
    hover.value = false;
    startTimer();
  }
  function handleButtonEnter(arrow2) {
    if ((0, import_vue359.unref)(isVertical))
      return;
    items.value.forEach((item, index2) => {
      if (arrow2 === itemInStage(item, index2)) {
        item.states.hover = true;
      }
    });
  }
  function handleButtonLeave() {
    if ((0, import_vue359.unref)(isVertical))
      return;
    items.value.forEach((item) => {
      item.states.hover = false;
    });
  }
  function handleIndicatorClick(index2) {
    activeIndex.value = index2;
  }
  function handleIndicatorHover(index2) {
    if (props.trigger === "hover" && index2 !== activeIndex.value) {
      activeIndex.value = index2;
    }
  }
  function prev() {
    setActiveItem(activeIndex.value - 1);
  }
  function next() {
    setActiveItem(activeIndex.value + 1);
  }
  function resetTimer() {
    pauseTimer();
    startTimer();
  }
  (0, import_vue359.watch)(() => activeIndex.value, (current, prev2) => {
    resetItemPosition(prev2);
    if (prev2 > -1) {
      emit("change", current, prev2);
    }
  });
  (0, import_vue359.watch)(() => props.autoplay, (autoplay) => {
    autoplay ? startTimer() : pauseTimer();
  });
  (0, import_vue359.watch)(() => props.loop, () => {
    setActiveItem(activeIndex.value);
  });
  (0, import_vue359.watch)(() => props.interval, () => {
    resetTimer();
  });
  (0, import_vue359.watch)(() => items.value, () => {
    if (items.value.length > 0)
      setActiveItem(props.initialIndex);
  });
  const resizeObserver = (0, import_vue359.shallowRef)();
  (0, import_vue359.onMounted)(() => {
    resizeObserver.value = useResizeObserver(root2.value, () => {
      resetItemPosition();
    });
    startTimer();
  });
  (0, import_vue359.onBeforeUnmount)(() => {
    pauseTimer();
    if (root2.value && resizeObserver.value)
      resizeObserver.value.stop();
  });
  (0, import_vue359.provide)(carouselContextKey, {
    root: root2,
    isCardType,
    isVertical,
    items,
    loop: props.loop,
    addItem,
    removeItem,
    setActiveItem
  });
  return {
    root: root2,
    activeIndex,
    arrowDisplay,
    hasLabel,
    hover,
    isCardType,
    items,
    handleButtonEnter,
    handleButtonLeave,
    handleIndicatorClick,
    handleMouseEnter,
    handleMouseLeave,
    setActiveItem,
    prev,
    next,
    throttledArrowClick,
    throttledIndicatorHover
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/carousel2.mjs
var _hoisted_116 = ["onMouseenter", "onClick"];
var _hoisted_29 = { key: 0 };
var COMPONENT_NAME7 = "ElCarousel";
var __default__25 = (0, import_vue360.defineComponent)({
  name: COMPONENT_NAME7
});
var _sfc_main31 = /* @__PURE__ */ (0, import_vue360.defineComponent)({
  ...__default__25,
  props: carouselProps,
  emits: carouselEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const {
      root: root2,
      activeIndex,
      arrowDisplay,
      hasLabel,
      hover,
      isCardType,
      items,
      handleButtonEnter,
      handleButtonLeave,
      handleIndicatorClick,
      handleMouseEnter,
      handleMouseLeave,
      setActiveItem,
      prev,
      next,
      throttledArrowClick,
      throttledIndicatorHover
    } = useCarousel(props, emit, COMPONENT_NAME7);
    const ns2 = useNamespace("carousel");
    const carouselClasses = (0, import_vue360.computed)(() => {
      const classes = [ns2.b(), ns2.m(props.direction)];
      if ((0, import_vue360.unref)(isCardType)) {
        classes.push(ns2.m("card"));
      }
      return classes;
    });
    const indicatorsClasses = (0, import_vue360.computed)(() => {
      const classes = [ns2.e("indicators"), ns2.em("indicators", props.direction)];
      if ((0, import_vue360.unref)(hasLabel)) {
        classes.push(ns2.em("indicators", "labels"));
      }
      if (props.indicatorPosition === "outside" || (0, import_vue360.unref)(isCardType)) {
        classes.push(ns2.em("indicators", "outside"));
      }
      return classes;
    });
    expose({
      setActiveItem,
      prev,
      next
    });
    return (_ctx, _cache) => {
      return (0, import_vue360.openBlock)(), (0, import_vue360.createElementBlock)("div", {
        ref_key: "root",
        ref: root2,
        class: (0, import_vue360.normalizeClass)((0, import_vue360.unref)(carouselClasses)),
        onMouseenter: _cache[6] || (_cache[6] = (0, import_vue360.withModifiers)((...args) => (0, import_vue360.unref)(handleMouseEnter) && (0, import_vue360.unref)(handleMouseEnter)(...args), ["stop"])),
        onMouseleave: _cache[7] || (_cache[7] = (0, import_vue360.withModifiers)((...args) => (0, import_vue360.unref)(handleMouseLeave) && (0, import_vue360.unref)(handleMouseLeave)(...args), ["stop"]))
      }, [
        (0, import_vue360.createElementVNode)("div", {
          class: (0, import_vue360.normalizeClass)((0, import_vue360.unref)(ns2).e("container")),
          style: (0, import_vue360.normalizeStyle)({ height: _ctx.height })
        }, [
          (0, import_vue360.unref)(arrowDisplay) ? ((0, import_vue360.openBlock)(), (0, import_vue360.createBlock)(import_vue360.Transition, {
            key: 0,
            name: "carousel-arrow-left",
            persisted: ""
          }, {
            default: (0, import_vue360.withCtx)(() => [
              (0, import_vue360.withDirectives)((0, import_vue360.createElementVNode)("button", {
                type: "button",
                class: (0, import_vue360.normalizeClass)([(0, import_vue360.unref)(ns2).e("arrow"), (0, import_vue360.unref)(ns2).em("arrow", "left")]),
                onMouseenter: _cache[0] || (_cache[0] = ($event) => (0, import_vue360.unref)(handleButtonEnter)("left")),
                onMouseleave: _cache[1] || (_cache[1] = (...args) => (0, import_vue360.unref)(handleButtonLeave) && (0, import_vue360.unref)(handleButtonLeave)(...args)),
                onClick: _cache[2] || (_cache[2] = (0, import_vue360.withModifiers)(($event) => (0, import_vue360.unref)(throttledArrowClick)((0, import_vue360.unref)(activeIndex) - 1), ["stop"]))
              }, [
                (0, import_vue360.createVNode)((0, import_vue360.unref)(ElIcon), null, {
                  default: (0, import_vue360.withCtx)(() => [
                    (0, import_vue360.createVNode)((0, import_vue360.unref)(arrow_left_default))
                  ]),
                  _: 1
                })
              ], 34), [
                [
                  import_vue360.vShow,
                  (_ctx.arrow === "always" || (0, import_vue360.unref)(hover)) && (props.loop || (0, import_vue360.unref)(activeIndex) > 0)
                ]
              ])
            ]),
            _: 1
          })) : (0, import_vue360.createCommentVNode)("v-if", true),
          (0, import_vue360.unref)(arrowDisplay) ? ((0, import_vue360.openBlock)(), (0, import_vue360.createBlock)(import_vue360.Transition, {
            key: 1,
            name: "carousel-arrow-right",
            persisted: ""
          }, {
            default: (0, import_vue360.withCtx)(() => [
              (0, import_vue360.withDirectives)((0, import_vue360.createElementVNode)("button", {
                type: "button",
                class: (0, import_vue360.normalizeClass)([(0, import_vue360.unref)(ns2).e("arrow"), (0, import_vue360.unref)(ns2).em("arrow", "right")]),
                onMouseenter: _cache[3] || (_cache[3] = ($event) => (0, import_vue360.unref)(handleButtonEnter)("right")),
                onMouseleave: _cache[4] || (_cache[4] = (...args) => (0, import_vue360.unref)(handleButtonLeave) && (0, import_vue360.unref)(handleButtonLeave)(...args)),
                onClick: _cache[5] || (_cache[5] = (0, import_vue360.withModifiers)(($event) => (0, import_vue360.unref)(throttledArrowClick)((0, import_vue360.unref)(activeIndex) + 1), ["stop"]))
              }, [
                (0, import_vue360.createVNode)((0, import_vue360.unref)(ElIcon), null, {
                  default: (0, import_vue360.withCtx)(() => [
                    (0, import_vue360.createVNode)((0, import_vue360.unref)(arrow_right_default))
                  ]),
                  _: 1
                })
              ], 34), [
                [
                  import_vue360.vShow,
                  (_ctx.arrow === "always" || (0, import_vue360.unref)(hover)) && (props.loop || (0, import_vue360.unref)(activeIndex) < (0, import_vue360.unref)(items).length - 1)
                ]
              ])
            ]),
            _: 1
          })) : (0, import_vue360.createCommentVNode)("v-if", true),
          (0, import_vue360.renderSlot)(_ctx.$slots, "default")
        ], 6),
        _ctx.indicatorPosition !== "none" ? ((0, import_vue360.openBlock)(), (0, import_vue360.createElementBlock)("ul", {
          key: 0,
          class: (0, import_vue360.normalizeClass)((0, import_vue360.unref)(indicatorsClasses))
        }, [
          ((0, import_vue360.openBlock)(true), (0, import_vue360.createElementBlock)(import_vue360.Fragment, null, (0, import_vue360.renderList)((0, import_vue360.unref)(items), (item, index2) => {
            return (0, import_vue360.openBlock)(), (0, import_vue360.createElementBlock)("li", {
              key: index2,
              class: (0, import_vue360.normalizeClass)([
                (0, import_vue360.unref)(ns2).e("indicator"),
                (0, import_vue360.unref)(ns2).em("indicator", _ctx.direction),
                (0, import_vue360.unref)(ns2).is("active", index2 === (0, import_vue360.unref)(activeIndex))
              ]),
              onMouseenter: ($event) => (0, import_vue360.unref)(throttledIndicatorHover)(index2),
              onClick: (0, import_vue360.withModifiers)(($event) => (0, import_vue360.unref)(handleIndicatorClick)(index2), ["stop"])
            }, [
              (0, import_vue360.createElementVNode)("button", {
                class: (0, import_vue360.normalizeClass)((0, import_vue360.unref)(ns2).e("button"))
              }, [
                (0, import_vue360.unref)(hasLabel) ? ((0, import_vue360.openBlock)(), (0, import_vue360.createElementBlock)("span", _hoisted_29, (0, import_vue360.toDisplayString)(item.props.label), 1)) : (0, import_vue360.createCommentVNode)("v-if", true)
              ], 2)
            ], 42, _hoisted_116);
          }), 128))
        ], 2)) : (0, import_vue360.createCommentVNode)("v-if", true)
      ], 34);
    };
  }
});
var Carousel = /* @__PURE__ */ _export_sfc(_sfc_main31, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/carousel-item2.mjs
var import_vue362 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/carousel-item.mjs
var carouselItemProps = buildProps({
  name: { type: String, default: "" },
  label: {
    type: [String, Number],
    default: ""
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/use-carousel-item.mjs
var import_vue361 = require("vue");
var useCarouselItem = (props, componentName2) => {
  const carouselContext = (0, import_vue361.inject)(carouselContextKey);
  const instance = (0, import_vue361.getCurrentInstance)();
  if (!carouselContext) {
    debugWarn(componentName2, "usage: <el-carousel></el-carousel-item></el-carousel>");
  }
  if (!instance) {
    debugWarn(componentName2, "compositional hook can only be invoked inside setups");
  }
  const CARD_SCALE = 0.83;
  const hover = (0, import_vue361.ref)(false);
  const translate2 = (0, import_vue361.ref)(0);
  const scale = (0, import_vue361.ref)(1);
  const active = (0, import_vue361.ref)(false);
  const ready = (0, import_vue361.ref)(false);
  const inStage = (0, import_vue361.ref)(false);
  const animating = (0, import_vue361.ref)(false);
  const { isCardType, isVertical } = carouselContext;
  function processIndex(index2, activeIndex, length) {
    const lastItemIndex = length - 1;
    const prevItemIndex = activeIndex - 1;
    const nextItemIndex = activeIndex + 1;
    const halfItemIndex = length / 2;
    if (activeIndex === 0 && index2 === lastItemIndex) {
      return -1;
    } else if (activeIndex === lastItemIndex && index2 === 0) {
      return length;
    } else if (index2 < prevItemIndex && activeIndex - index2 >= halfItemIndex) {
      return length + 1;
    } else if (index2 > nextItemIndex && index2 - activeIndex >= halfItemIndex) {
      return -2;
    }
    return index2;
  }
  function calcCardTranslate(index2, activeIndex) {
    var _a2;
    const parentWidth = ((_a2 = carouselContext.root.value) == null ? void 0 : _a2.offsetWidth) || 0;
    if (inStage.value) {
      return parentWidth * ((2 - CARD_SCALE) * (index2 - activeIndex) + 1) / 4;
    } else if (index2 < activeIndex) {
      return -(1 + CARD_SCALE) * parentWidth / 4;
    } else {
      return (3 + CARD_SCALE) * parentWidth / 4;
    }
  }
  function calcTranslate(index2, activeIndex, isVertical2) {
    const rootEl2 = carouselContext.root.value;
    if (!rootEl2)
      return 0;
    const distance = (isVertical2 ? rootEl2.offsetHeight : rootEl2.offsetWidth) || 0;
    return distance * (index2 - activeIndex);
  }
  const translateItem = (index2, activeIndex, oldIndex2) => {
    var _a2;
    const _isCardType = (0, import_vue361.unref)(isCardType);
    const carouselItemLength = (_a2 = carouselContext.items.value.length) != null ? _a2 : Number.NaN;
    const isActive = index2 === activeIndex;
    if (!_isCardType && !isUndefined(oldIndex2)) {
      animating.value = isActive || index2 === oldIndex2;
    }
    if (!isActive && carouselItemLength > 2 && carouselContext.loop) {
      index2 = processIndex(index2, activeIndex, carouselItemLength);
    }
    const _isVertical = (0, import_vue361.unref)(isVertical);
    active.value = isActive;
    if (_isCardType) {
      if (_isVertical) {
        debugWarn("Carousel", "vertical direction is not supported for card mode");
      }
      inStage.value = Math.round(Math.abs(index2 - activeIndex)) <= 1;
      translate2.value = calcCardTranslate(index2, activeIndex);
      scale.value = (0, import_vue361.unref)(active) ? 1 : CARD_SCALE;
    } else {
      translate2.value = calcTranslate(index2, activeIndex, _isVertical);
    }
    ready.value = true;
  };
  function handleItemClick() {
    if (carouselContext && (0, import_vue361.unref)(isCardType)) {
      const index2 = carouselContext.items.value.findIndex(({ uid: uid2 }) => uid2 === instance.uid);
      carouselContext.setActiveItem(index2);
    }
  }
  (0, import_vue361.onMounted)(() => {
    carouselContext.addItem({
      props,
      states: (0, import_vue361.reactive)({
        hover,
        translate: translate2,
        scale,
        active,
        ready,
        inStage,
        animating
      }),
      uid: instance.uid,
      translateItem
    });
  });
  (0, import_vue361.onUnmounted)(() => {
    carouselContext.removeItem(instance.uid);
  });
  return {
    active,
    animating,
    hover,
    inStage,
    isVertical,
    translate: translate2,
    isCardType,
    scale,
    ready,
    handleItemClick
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/src/carousel-item2.mjs
var COMPONENT_NAME8 = "ElCarouselItem";
var __default__26 = (0, import_vue362.defineComponent)({
  name: "ElCarouselItem"
});
var _sfc_main32 = /* @__PURE__ */ (0, import_vue362.defineComponent)({
  ...__default__26,
  props: carouselItemProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("carousel");
    const {
      active,
      animating,
      hover,
      inStage,
      isVertical,
      translate: translate2,
      isCardType,
      scale,
      ready,
      handleItemClick
    } = useCarouselItem(props, COMPONENT_NAME8);
    const itemStyle = (0, import_vue362.computed)(() => {
      const translateType = `translate${(0, import_vue362.unref)(isVertical) ? "Y" : "X"}`;
      const _translate = `${translateType}(${(0, import_vue362.unref)(translate2)}px)`;
      const _scale = `scale(${(0, import_vue362.unref)(scale)})`;
      const transform = [_translate, _scale].join(" ");
      return {
        transform
      };
    });
    return (_ctx, _cache) => {
      return (0, import_vue362.withDirectives)(((0, import_vue362.openBlock)(), (0, import_vue362.createElementBlock)("div", {
        class: (0, import_vue362.normalizeClass)([
          (0, import_vue362.unref)(ns2).e("item"),
          (0, import_vue362.unref)(ns2).is("active", (0, import_vue362.unref)(active)),
          (0, import_vue362.unref)(ns2).is("in-stage", (0, import_vue362.unref)(inStage)),
          (0, import_vue362.unref)(ns2).is("hover", (0, import_vue362.unref)(hover)),
          (0, import_vue362.unref)(ns2).is("animating", (0, import_vue362.unref)(animating)),
          { [(0, import_vue362.unref)(ns2).em("item", "card")]: (0, import_vue362.unref)(isCardType) }
        ]),
        style: (0, import_vue362.normalizeStyle)((0, import_vue362.unref)(itemStyle)),
        onClick: _cache[0] || (_cache[0] = (...args) => (0, import_vue362.unref)(handleItemClick) && (0, import_vue362.unref)(handleItemClick)(...args))
      }, [
        (0, import_vue362.unref)(isCardType) ? (0, import_vue362.withDirectives)(((0, import_vue362.openBlock)(), (0, import_vue362.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue362.normalizeClass)((0, import_vue362.unref)(ns2).e("mask"))
        }, null, 2)), [
          [import_vue362.vShow, !(0, import_vue362.unref)(active)]
        ]) : (0, import_vue362.createCommentVNode)("v-if", true),
        (0, import_vue362.renderSlot)(_ctx.$slots, "default")
      ], 6)), [
        [import_vue362.vShow, (0, import_vue362.unref)(ready)]
      ]);
    };
  }
});
var CarouselItem = /* @__PURE__ */ _export_sfc(_sfc_main32, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/carousel/index.mjs
var ElCarousel = withInstall(Carousel, {
  CarouselItem
});
var ElCarouselItem = withNoopInstall(CarouselItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader/src/cascader2.mjs
var import_vue380 = require("vue");
var import_shared44 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/index.mjs
var import_vue378 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/menu.mjs
var import_vue376 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/node2.mjs
var import_vue375 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox2.mjs
var import_vue367 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox.mjs
var import_shared36 = require("@vue/shared");
var checkboxProps = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: useSizeProp,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: true
  }
};
var checkboxEmits = {
  [UPDATE_MODEL_EVENT]: (val) => (0, import_shared36.isString)(val) || isNumber(val) || isBoolean(val),
  change: (val) => (0, import_shared36.isString)(val) || isNumber(val) || isBoolean(val)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/composables/use-checkbox-disabled.mjs
var import_vue363 = require("vue");
var useCheckboxDisabled = ({
  model,
  isChecked
}) => {
  const checkboxGroup = (0, import_vue363.inject)(checkboxGroupContextKey, void 0);
  const isLimitDisabled = (0, import_vue363.computed)(() => {
    var _a2, _b;
    const max4 = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
    const min4 = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
    return !isUndefined(max4) && model.value.length >= max4 && !isChecked.value || !isUndefined(min4) && model.value.length <= min4 && isChecked.value;
  });
  const isDisabled = useDisabled((0, import_vue363.computed)(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
  return {
    isDisabled,
    isLimitDisabled
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/composables/use-checkbox-event.mjs
var import_vue364 = require("vue");
var useCheckboxEvent = (props, {
  model,
  isLimitExceeded,
  hasOwnLabel,
  isDisabled,
  isLabeledByFormItem
}) => {
  const checkboxGroup = (0, import_vue364.inject)(checkboxGroupContextKey, void 0);
  const { formItem } = useFormItem();
  const { emit } = (0, import_vue364.getCurrentInstance)();
  function getLabeledValue(value) {
    var _a2, _b;
    return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
  }
  function emitChangeEvent(checked, e) {
    emit("change", getLabeledValue(checked), e);
  }
  function handleChange(e) {
    if (isLimitExceeded.value)
      return;
    const target = e.target;
    emit("change", getLabeledValue(target.checked), e);
  }
  async function onClickRoot(e) {
    if (isLimitExceeded.value)
      return;
    if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
      const eventTargets = e.composedPath();
      const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
      if (!hasLabel) {
        model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
        await (0, import_vue364.nextTick)();
        emitChangeEvent(model.value, e);
      }
    }
  }
  const validateEvent = (0, import_vue364.computed)(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
  (0, import_vue364.watch)(() => props.modelValue, () => {
    if (validateEvent.value) {
      formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
    }
  });
  return {
    handleChange,
    onClickRoot
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/composables/use-checkbox-model.mjs
var import_vue365 = require("vue");
var import_shared37 = require("@vue/shared");
var useCheckboxModel = (props) => {
  const selfModel = (0, import_vue365.ref)(false);
  const { emit } = (0, import_vue365.getCurrentInstance)();
  const checkboxGroup = (0, import_vue365.inject)(checkboxGroupContextKey, void 0);
  const isGroup = (0, import_vue365.computed)(() => isUndefined(checkboxGroup) === false);
  const isLimitExceeded = (0, import_vue365.ref)(false);
  const model = (0, import_vue365.computed)({
    get() {
      var _a2, _b;
      return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
    },
    set(val) {
      var _a2, _b;
      if (isGroup.value && (0, import_shared37.isArray)(val)) {
        isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
        isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
      } else {
        emit(UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }
  });
  return {
    model,
    isGroup,
    isLimitExceeded
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/composables/use-checkbox-status.mjs
var import_vue366 = require("vue");
var import_shared38 = require("@vue/shared");
var useCheckboxStatus = (props, slots, { model }) => {
  const checkboxGroup = (0, import_vue366.inject)(checkboxGroupContextKey, void 0);
  const isFocused = (0, import_vue366.ref)(false);
  const isChecked = (0, import_vue366.computed)(() => {
    const value = model.value;
    if (isBoolean(value)) {
      return value;
    } else if ((0, import_shared38.isArray)(value)) {
      if ((0, import_shared38.isObject)(props.label)) {
        return value.map(import_vue366.toRaw).some((o2) => isEqual_default(o2, props.label));
      } else {
        return value.map(import_vue366.toRaw).includes(props.label);
      }
    } else if (value !== null && value !== void 0) {
      return value === props.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxButtonSize = useSize((0, import_vue366.computed)(() => {
    var _a2;
    return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
  }), {
    prop: true
  });
  const checkboxSize = useSize((0, import_vue366.computed)(() => {
    var _a2;
    return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
  }));
  const hasOwnLabel = (0, import_vue366.computed)(() => {
    return !!(slots.default || props.label);
  });
  return {
    checkboxButtonSize,
    isChecked,
    isFocused,
    checkboxSize,
    hasOwnLabel
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/composables/use-checkbox.mjs
var import_shared39 = require("@vue/shared");
var setStoreValue = (props, { model }) => {
  function addToStore() {
    if ((0, import_shared39.isArray)(model.value) && !model.value.includes(props.label)) {
      model.value.push(props.label);
    } else {
      model.value = props.trueLabel || true;
    }
  }
  props.checked && addToStore();
};
var useCheckbox = (props, slots) => {
  const { formItem: elFormItem } = useFormItem();
  const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
  const {
    isFocused,
    isChecked,
    checkboxButtonSize,
    checkboxSize,
    hasOwnLabel
  } = useCheckboxStatus(props, slots, { model });
  const { isDisabled } = useCheckboxDisabled({ model, isChecked });
  const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
    formItemContext: elFormItem,
    disableIdGeneration: hasOwnLabel,
    disableIdManagement: isGroup
  });
  const { handleChange, onClickRoot } = useCheckboxEvent(props, {
    model,
    isLimitExceeded,
    hasOwnLabel,
    isDisabled,
    isLabeledByFormItem
  });
  setStoreValue(props, { model });
  return {
    inputId,
    isLabeledByFormItem,
    isChecked,
    isDisabled,
    isFocused,
    checkboxButtonSize,
    checkboxSize,
    hasOwnLabel,
    model,
    handleChange,
    onClickRoot
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox2.mjs
var _hoisted_117 = ["tabindex", "role", "aria-checked"];
var _hoisted_211 = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
var _hoisted_33 = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
var __default__27 = (0, import_vue367.defineComponent)({
  name: "ElCheckbox"
});
var _sfc_main33 = /* @__PURE__ */ (0, import_vue367.defineComponent)({
  ...__default__27,
  props: checkboxProps,
  emits: checkboxEmits,
  setup(__props) {
    const props = __props;
    const slots = (0, import_vue367.useSlots)();
    const {
      inputId,
      isLabeledByFormItem,
      isChecked,
      isDisabled,
      isFocused,
      checkboxSize,
      hasOwnLabel,
      model,
      handleChange,
      onClickRoot
    } = useCheckbox(props, slots);
    const ns2 = useNamespace("checkbox");
    const compKls = (0, import_vue367.computed)(() => {
      return [
        ns2.b(),
        ns2.m(checkboxSize.value),
        ns2.is("disabled", isDisabled.value),
        ns2.is("bordered", props.border),
        ns2.is("checked", isChecked.value)
      ];
    });
    const spanKls = (0, import_vue367.computed)(() => {
      return [
        ns2.e("input"),
        ns2.is("disabled", isDisabled.value),
        ns2.is("checked", isChecked.value),
        ns2.is("indeterminate", props.indeterminate),
        ns2.is("focus", isFocused.value)
      ];
    });
    return (_ctx, _cache) => {
      return (0, import_vue367.openBlock)(), (0, import_vue367.createBlock)((0, import_vue367.resolveDynamicComponent)(!(0, import_vue367.unref)(hasOwnLabel) && (0, import_vue367.unref)(isLabeledByFormItem) ? "span" : "label"), {
        class: (0, import_vue367.normalizeClass)((0, import_vue367.unref)(compKls)),
        "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
        onClick: (0, import_vue367.unref)(onClickRoot)
      }, {
        default: (0, import_vue367.withCtx)(() => [
          (0, import_vue367.createElementVNode)("span", {
            class: (0, import_vue367.normalizeClass)((0, import_vue367.unref)(spanKls)),
            tabindex: _ctx.indeterminate ? 0 : void 0,
            role: _ctx.indeterminate ? "checkbox" : void 0,
            "aria-checked": _ctx.indeterminate ? "mixed" : void 0
          }, [
            _ctx.trueLabel || _ctx.falseLabel ? (0, import_vue367.withDirectives)(((0, import_vue367.openBlock)(), (0, import_vue367.createElementBlock)("input", {
              key: 0,
              id: (0, import_vue367.unref)(inputId),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, import_vue367.isRef)(model) ? model.value = $event : null),
              class: (0, import_vue367.normalizeClass)((0, import_vue367.unref)(ns2).e("original")),
              type: "checkbox",
              "aria-hidden": _ctx.indeterminate ? "true" : "false",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: (0, import_vue367.unref)(isDisabled),
              "true-value": _ctx.trueLabel,
              "false-value": _ctx.falseLabel,
              onChange: _cache[1] || (_cache[1] = (...args) => (0, import_vue367.unref)(handleChange) && (0, import_vue367.unref)(handleChange)(...args)),
              onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
              onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
            }, null, 42, _hoisted_211)), [
              [import_vue367.vModelCheckbox, (0, import_vue367.unref)(model)]
            ]) : (0, import_vue367.withDirectives)(((0, import_vue367.openBlock)(), (0, import_vue367.createElementBlock)("input", {
              key: 1,
              id: (0, import_vue367.unref)(inputId),
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => (0, import_vue367.isRef)(model) ? model.value = $event : null),
              class: (0, import_vue367.normalizeClass)((0, import_vue367.unref)(ns2).e("original")),
              type: "checkbox",
              "aria-hidden": _ctx.indeterminate ? "true" : "false",
              disabled: (0, import_vue367.unref)(isDisabled),
              value: _ctx.label,
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              onChange: _cache[5] || (_cache[5] = (...args) => (0, import_vue367.unref)(handleChange) && (0, import_vue367.unref)(handleChange)(...args)),
              onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
              onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
            }, null, 42, _hoisted_33)), [
              [import_vue367.vModelCheckbox, (0, import_vue367.unref)(model)]
            ]),
            (0, import_vue367.createElementVNode)("span", {
              class: (0, import_vue367.normalizeClass)((0, import_vue367.unref)(ns2).e("inner"))
            }, null, 2)
          ], 10, _hoisted_117),
          (0, import_vue367.unref)(hasOwnLabel) ? ((0, import_vue367.openBlock)(), (0, import_vue367.createElementBlock)("span", {
            key: 0,
            class: (0, import_vue367.normalizeClass)((0, import_vue367.unref)(ns2).e("label"))
          }, [
            (0, import_vue367.renderSlot)(_ctx.$slots, "default"),
            !_ctx.$slots.default ? ((0, import_vue367.openBlock)(), (0, import_vue367.createElementBlock)(import_vue367.Fragment, { key: 0 }, [
              (0, import_vue367.createTextVNode)((0, import_vue367.toDisplayString)(_ctx.label), 1)
            ], 64)) : (0, import_vue367.createCommentVNode)("v-if", true)
          ], 2)) : (0, import_vue367.createCommentVNode)("v-if", true)
        ]),
        _: 3
      }, 8, ["class", "aria-controls", "onClick"]);
    };
  }
});
var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main33, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox-button.mjs
var import_vue368 = require("vue");
var _hoisted_118 = ["name", "tabindex", "disabled", "true-value", "false-value"];
var _hoisted_213 = ["name", "tabindex", "disabled", "value"];
var __default__28 = (0, import_vue368.defineComponent)({
  name: "ElCheckboxButton"
});
var _sfc_main34 = /* @__PURE__ */ (0, import_vue368.defineComponent)({
  ...__default__28,
  props: checkboxProps,
  emits: checkboxEmits,
  setup(__props) {
    const props = __props;
    const slots = (0, import_vue368.useSlots)();
    const {
      isFocused,
      isChecked,
      isDisabled,
      checkboxButtonSize,
      model,
      handleChange
    } = useCheckbox(props, slots);
    const checkboxGroup = (0, import_vue368.inject)(checkboxGroupContextKey, void 0);
    const ns2 = useNamespace("checkbox");
    const activeStyle = (0, import_vue368.computed)(() => {
      var _a2, _b, _c, _d;
      const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
      };
    });
    const lableKls = (0, import_vue368.computed)(() => {
      return [
        ns2.b("button"),
        ns2.bm("button", checkboxButtonSize.value),
        ns2.is("disabled", isDisabled.value),
        ns2.is("checked", isChecked.value),
        ns2.is("focus", isFocused.value)
      ];
    });
    return (_ctx, _cache) => {
      return (0, import_vue368.openBlock)(), (0, import_vue368.createElementBlock)("label", {
        class: (0, import_vue368.normalizeClass)((0, import_vue368.unref)(lableKls))
      }, [
        _ctx.trueLabel || _ctx.falseLabel ? (0, import_vue368.withDirectives)(((0, import_vue368.openBlock)(), (0, import_vue368.createElementBlock)("input", {
          key: 0,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, import_vue368.isRef)(model) ? model.value = $event : null),
          class: (0, import_vue368.normalizeClass)((0, import_vue368.unref)(ns2).be("button", "original")),
          type: "checkbox",
          name: _ctx.name,
          tabindex: _ctx.tabindex,
          disabled: (0, import_vue368.unref)(isDisabled),
          "true-value": _ctx.trueLabel,
          "false-value": _ctx.falseLabel,
          onChange: _cache[1] || (_cache[1] = (...args) => (0, import_vue368.unref)(handleChange) && (0, import_vue368.unref)(handleChange)(...args)),
          onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
          onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
        }, null, 42, _hoisted_118)), [
          [import_vue368.vModelCheckbox, (0, import_vue368.unref)(model)]
        ]) : (0, import_vue368.withDirectives)(((0, import_vue368.openBlock)(), (0, import_vue368.createElementBlock)("input", {
          key: 1,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => (0, import_vue368.isRef)(model) ? model.value = $event : null),
          class: (0, import_vue368.normalizeClass)((0, import_vue368.unref)(ns2).be("button", "original")),
          type: "checkbox",
          name: _ctx.name,
          tabindex: _ctx.tabindex,
          disabled: (0, import_vue368.unref)(isDisabled),
          value: _ctx.label,
          onChange: _cache[5] || (_cache[5] = (...args) => (0, import_vue368.unref)(handleChange) && (0, import_vue368.unref)(handleChange)(...args)),
          onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
          onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
        }, null, 42, _hoisted_213)), [
          [import_vue368.vModelCheckbox, (0, import_vue368.unref)(model)]
        ]),
        _ctx.$slots.default || _ctx.label ? ((0, import_vue368.openBlock)(), (0, import_vue368.createElementBlock)("span", {
          key: 2,
          class: (0, import_vue368.normalizeClass)((0, import_vue368.unref)(ns2).be("button", "inner")),
          style: (0, import_vue368.normalizeStyle)((0, import_vue368.unref)(isChecked) ? (0, import_vue368.unref)(activeStyle) : void 0)
        }, [
          (0, import_vue368.renderSlot)(_ctx.$slots, "default", {}, () => [
            (0, import_vue368.createTextVNode)((0, import_vue368.toDisplayString)(_ctx.label), 1)
          ])
        ], 6)) : (0, import_vue368.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main34, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox-group2.mjs
var import_vue369 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox-group.mjs
var import_shared40 = require("@vue/shared");
var checkboxGroupProps = buildProps({
  modelValue: {
    type: definePropType(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: useSizeProp,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var checkboxGroupEmits = {
  [UPDATE_MODEL_EVENT]: (val) => (0, import_shared40.isArray)(val),
  change: (val) => (0, import_shared40.isArray)(val)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/src/checkbox-group2.mjs
var __default__29 = (0, import_vue369.defineComponent)({
  name: "ElCheckboxGroup"
});
var _sfc_main35 = /* @__PURE__ */ (0, import_vue369.defineComponent)({
  ...__default__29,
  props: checkboxGroupProps,
  emits: checkboxGroupEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("checkbox");
    const { formItem } = useFormItem();
    const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const changeEvent = async (value) => {
      emit(UPDATE_MODEL_EVENT, value);
      await (0, import_vue369.nextTick)();
      emit("change", value);
    };
    const modelValue = (0, import_vue369.computed)({
      get() {
        return props.modelValue;
      },
      set(val) {
        changeEvent(val);
      }
    });
    (0, import_vue369.provide)(checkboxGroupContextKey, {
      ...pick_default((0, import_vue369.toRefs)(props), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue,
      changeEvent
    });
    (0, import_vue369.watch)(() => props.modelValue, () => {
      if (props.validateEvent) {
        formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
      }
    });
    return (_ctx, _cache) => {
      var _a2;
      return (0, import_vue369.openBlock)(), (0, import_vue369.createBlock)((0, import_vue369.resolveDynamicComponent)(_ctx.tag), {
        id: (0, import_vue369.unref)(groupId),
        class: (0, import_vue369.normalizeClass)((0, import_vue369.unref)(ns2).b("group")),
        role: "group",
        "aria-label": !(0, import_vue369.unref)(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
        "aria-labelledby": (0, import_vue369.unref)(isLabeledByFormItem) ? (_a2 = (0, import_vue369.unref)(formItem)) == null ? void 0 : _a2.labelId : void 0
      }, {
        default: (0, import_vue369.withCtx)(() => [
          (0, import_vue369.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main35, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/checkbox/index.mjs
var ElCheckbox = withInstall(Checkbox, {
  CheckboxButton,
  CheckboxGroup
});
var ElCheckboxButton = withNoopInstall(CheckboxButton);
var ElCheckboxGroup = withNoopInstall(CheckboxGroup);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio2.mjs
var import_vue371 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio.mjs
var import_shared41 = require("@vue/shared");
var radioPropsBase = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
});
var radioProps = buildProps({
  ...radioPropsBase,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
});
var radioEmits = {
  [UPDATE_MODEL_EVENT]: (val) => (0, import_shared41.isString)(val) || isNumber(val) || isBoolean(val),
  [CHANGE_EVENT]: (val) => (0, import_shared41.isString)(val) || isNumber(val) || isBoolean(val)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/use-radio.mjs
var import_vue370 = require("vue");
var useRadio = (props, emit) => {
  const radioRef = (0, import_vue370.ref)();
  const radioGroup = (0, import_vue370.inject)(radioGroupKey, void 0);
  const isGroup = (0, import_vue370.computed)(() => !!radioGroup);
  const modelValue = (0, import_vue370.computed)({
    get() {
      return isGroup.value ? radioGroup.modelValue : props.modelValue;
    },
    set(val) {
      if (isGroup.value) {
        radioGroup.changeEvent(val);
      } else {
        emit && emit(UPDATE_MODEL_EVENT, val);
      }
      radioRef.value.checked = props.modelValue === props.label;
    }
  });
  const size2 = useSize((0, import_vue370.computed)(() => radioGroup == null ? void 0 : radioGroup.size));
  const disabled = useDisabled((0, import_vue370.computed)(() => radioGroup == null ? void 0 : radioGroup.disabled));
  const focus = (0, import_vue370.ref)(false);
  const tabIndex = (0, import_vue370.computed)(() => {
    return disabled.value || isGroup.value && modelValue.value !== props.label ? -1 : 0;
  });
  return {
    radioRef,
    isGroup,
    radioGroup,
    focus,
    size: size2,
    disabled,
    tabIndex,
    modelValue
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio2.mjs
var _hoisted_119 = ["value", "name", "disabled"];
var __default__30 = (0, import_vue371.defineComponent)({
  name: "ElRadio"
});
var _sfc_main36 = /* @__PURE__ */ (0, import_vue371.defineComponent)({
  ...__default__30,
  props: radioProps,
  emits: radioEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("radio");
    const { radioRef, radioGroup, focus, size: size2, disabled, modelValue } = useRadio(props, emit);
    function handleChange() {
      (0, import_vue371.nextTick)(() => emit("change", modelValue.value));
    }
    return (_ctx, _cache) => {
      var _a2;
      return (0, import_vue371.openBlock)(), (0, import_vue371.createElementBlock)("label", {
        class: (0, import_vue371.normalizeClass)([
          (0, import_vue371.unref)(ns2).b(),
          (0, import_vue371.unref)(ns2).is("disabled", (0, import_vue371.unref)(disabled)),
          (0, import_vue371.unref)(ns2).is("focus", (0, import_vue371.unref)(focus)),
          (0, import_vue371.unref)(ns2).is("bordered", _ctx.border),
          (0, import_vue371.unref)(ns2).is("checked", (0, import_vue371.unref)(modelValue) === _ctx.label),
          (0, import_vue371.unref)(ns2).m((0, import_vue371.unref)(size2))
        ])
      }, [
        (0, import_vue371.createElementVNode)("span", {
          class: (0, import_vue371.normalizeClass)([
            (0, import_vue371.unref)(ns2).e("input"),
            (0, import_vue371.unref)(ns2).is("disabled", (0, import_vue371.unref)(disabled)),
            (0, import_vue371.unref)(ns2).is("checked", (0, import_vue371.unref)(modelValue) === _ctx.label)
          ])
        }, [
          (0, import_vue371.withDirectives)((0, import_vue371.createElementVNode)("input", {
            ref_key: "radioRef",
            ref: radioRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, import_vue371.isRef)(modelValue) ? modelValue.value = $event : null),
            class: (0, import_vue371.normalizeClass)((0, import_vue371.unref)(ns2).e("original")),
            value: _ctx.label,
            name: _ctx.name || ((_a2 = (0, import_vue371.unref)(radioGroup)) == null ? void 0 : _a2.name),
            disabled: (0, import_vue371.unref)(disabled),
            type: "radio",
            onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
            onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false),
            onChange: handleChange
          }, null, 42, _hoisted_119), [
            [import_vue371.vModelRadio, (0, import_vue371.unref)(modelValue)]
          ]),
          (0, import_vue371.createElementVNode)("span", {
            class: (0, import_vue371.normalizeClass)((0, import_vue371.unref)(ns2).e("inner"))
          }, null, 2)
        ], 2),
        (0, import_vue371.createElementVNode)("span", {
          class: (0, import_vue371.normalizeClass)((0, import_vue371.unref)(ns2).e("label")),
          onKeydown: _cache[3] || (_cache[3] = (0, import_vue371.withModifiers)(() => {
          }, ["stop"]))
        }, [
          (0, import_vue371.renderSlot)(_ctx.$slots, "default", {}, () => [
            (0, import_vue371.createTextVNode)((0, import_vue371.toDisplayString)(_ctx.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var Radio = /* @__PURE__ */ _export_sfc(_sfc_main36, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio-button2.mjs
var import_vue372 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio-button.mjs
var radioButtonProps = buildProps({
  ...radioPropsBase,
  name: {
    type: String,
    default: ""
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio-button2.mjs
var _hoisted_120 = ["value", "name", "disabled"];
var __default__31 = (0, import_vue372.defineComponent)({
  name: "ElRadioButton"
});
var _sfc_main37 = /* @__PURE__ */ (0, import_vue372.defineComponent)({
  ...__default__31,
  props: radioButtonProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("radio");
    const { radioRef, focus, size: size2, disabled, modelValue, radioGroup } = useRadio(props);
    const activeStyle = (0, import_vue372.computed)(() => {
      return {
        backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
        borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
        boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
        color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
      };
    });
    return (_ctx, _cache) => {
      var _a2;
      return (0, import_vue372.openBlock)(), (0, import_vue372.createElementBlock)("label", {
        class: (0, import_vue372.normalizeClass)([
          (0, import_vue372.unref)(ns2).b("button"),
          (0, import_vue372.unref)(ns2).is("active", (0, import_vue372.unref)(modelValue) === _ctx.label),
          (0, import_vue372.unref)(ns2).is("disabled", (0, import_vue372.unref)(disabled)),
          (0, import_vue372.unref)(ns2).is("focus", (0, import_vue372.unref)(focus)),
          (0, import_vue372.unref)(ns2).bm("button", (0, import_vue372.unref)(size2))
        ])
      }, [
        (0, import_vue372.withDirectives)((0, import_vue372.createElementVNode)("input", {
          ref_key: "radioRef",
          ref: radioRef,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, import_vue372.isRef)(modelValue) ? modelValue.value = $event : null),
          class: (0, import_vue372.normalizeClass)((0, import_vue372.unref)(ns2).be("button", "original-radio")),
          value: _ctx.label,
          type: "radio",
          name: _ctx.name || ((_a2 = (0, import_vue372.unref)(radioGroup)) == null ? void 0 : _a2.name),
          disabled: (0, import_vue372.unref)(disabled),
          onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false)
        }, null, 42, _hoisted_120), [
          [import_vue372.vModelRadio, (0, import_vue372.unref)(modelValue)]
        ]),
        (0, import_vue372.createElementVNode)("span", {
          class: (0, import_vue372.normalizeClass)((0, import_vue372.unref)(ns2).be("button", "inner")),
          style: (0, import_vue372.normalizeStyle)((0, import_vue372.unref)(modelValue) === _ctx.label ? (0, import_vue372.unref)(activeStyle) : {}),
          onKeydown: _cache[3] || (_cache[3] = (0, import_vue372.withModifiers)(() => {
          }, ["stop"]))
        }, [
          (0, import_vue372.renderSlot)(_ctx.$slots, "default", {}, () => [
            (0, import_vue372.createTextVNode)((0, import_vue372.toDisplayString)(_ctx.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main37, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio-group2.mjs
var import_vue373 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio-group.mjs
var radioGroupProps = buildProps({
  id: {
    type: String,
    default: void 0
  },
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var radioGroupEmits = radioEmits;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/src/radio-group2.mjs
var _hoisted_121 = ["id", "aria-label", "aria-labelledby"];
var __default__32 = (0, import_vue373.defineComponent)({
  name: "ElRadioGroup"
});
var _sfc_main38 = /* @__PURE__ */ (0, import_vue373.defineComponent)({
  ...__default__32,
  props: radioGroupProps,
  emits: radioGroupEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("radio");
    const radioId = useId();
    const radioGroupRef = (0, import_vue373.ref)();
    const { formItem } = useFormItem();
    const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const changeEvent = (value) => {
      emit(UPDATE_MODEL_EVENT, value);
      (0, import_vue373.nextTick)(() => emit("change", value));
    };
    (0, import_vue373.onMounted)(() => {
      const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
      const firstLabel = radios[0];
      if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
        firstLabel.tabIndex = 0;
      }
    });
    const name = (0, import_vue373.computed)(() => {
      return props.name || radioId.value;
    });
    (0, import_vue373.provide)(radioGroupKey, (0, import_vue373.reactive)({
      ...(0, import_vue373.toRefs)(props),
      changeEvent,
      name
    }));
    (0, import_vue373.watch)(() => props.modelValue, () => {
      if (props.validateEvent) {
        formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
      }
    });
    return (_ctx, _cache) => {
      return (0, import_vue373.openBlock)(), (0, import_vue373.createElementBlock)("div", {
        id: (0, import_vue373.unref)(groupId),
        ref_key: "radioGroupRef",
        ref: radioGroupRef,
        class: (0, import_vue373.normalizeClass)((0, import_vue373.unref)(ns2).b("group")),
        role: "radiogroup",
        "aria-label": !(0, import_vue373.unref)(isLabeledByFormItem) ? _ctx.label || "radio-group" : void 0,
        "aria-labelledby": (0, import_vue373.unref)(isLabeledByFormItem) ? (0, import_vue373.unref)(formItem).labelId : void 0
      }, [
        (0, import_vue373.renderSlot)(_ctx.$slots, "default")
      ], 10, _hoisted_121);
    };
  }
});
var RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main38, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/radio/index.mjs
var ElRadio = withInstall(Radio, {
  RadioButton,
  RadioGroup
});
var ElRadioGroup = withNoopInstall(RadioGroup);
var ElRadioButton = withNoopInstall(RadioButton);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/node-content.mjs
var import_vue374 = require("vue");
var NodeContent = (0, import_vue374.defineComponent)({
  name: "NodeContent",
  setup() {
    const ns2 = useNamespace("cascader-node");
    return {
      ns: ns2
    };
  },
  render() {
    const { ns: ns2 } = this;
    const { node, panel } = this.$parent;
    const { data, label } = node;
    const { renderLabelFn } = panel;
    return (0, import_vue374.h)("span", { class: ns2.e("label") }, renderLabelFn ? renderLabelFn({ node, data }) : label);
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/types.mjs
var CASCADER_PANEL_INJECTION_KEY = Symbol();

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/node2.mjs
var _sfc_main39 = (0, import_vue375.defineComponent)({
  name: "ElCascaderNode",
  components: {
    ElCheckbox,
    ElRadio,
    NodeContent,
    ElIcon,
    Check: check_default,
    Loading: loading_default,
    ArrowRight: arrow_right_default
  },
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ["expand"],
  setup(props, { emit }) {
    const panel = (0, import_vue375.inject)(CASCADER_PANEL_INJECTION_KEY);
    const ns2 = useNamespace("cascader-node");
    const isHoverMenu = (0, import_vue375.computed)(() => panel.isHoverMenu);
    const multiple = (0, import_vue375.computed)(() => panel.config.multiple);
    const checkStrictly = (0, import_vue375.computed)(() => panel.config.checkStrictly);
    const checkedNodeId = (0, import_vue375.computed)(() => {
      var _a2;
      return (_a2 = panel.checkedNodes[0]) == null ? void 0 : _a2.uid;
    });
    const isDisabled = (0, import_vue375.computed)(() => props.node.isDisabled);
    const isLeaf2 = (0, import_vue375.computed)(() => props.node.isLeaf);
    const expandable = (0, import_vue375.computed)(() => checkStrictly.value && !isLeaf2.value || !isDisabled.value);
    const inExpandingPath = (0, import_vue375.computed)(() => isInPath(panel.expandingNode));
    const inCheckedPath = (0, import_vue375.computed)(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
    const isInPath = (node) => {
      var _a2;
      const { level, uid: uid2 } = props.node;
      return ((_a2 = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a2.uid) === uid2;
    };
    const doExpand = () => {
      if (inExpandingPath.value)
        return;
      panel.expandNode(props.node);
    };
    const doCheck = (checked) => {
      const { node } = props;
      if (checked === node.checked)
        return;
      panel.handleCheckChange(node, checked);
    };
    const doLoad = () => {
      panel.lazyLoad(props.node, () => {
        if (!isLeaf2.value)
          doExpand();
      });
    };
    const handleHoverExpand = (e) => {
      if (!isHoverMenu.value)
        return;
      handleExpand();
      !isLeaf2.value && emit("expand", e);
    };
    const handleExpand = () => {
      const { node } = props;
      if (!expandable.value || node.loading)
        return;
      node.loaded ? doExpand() : doLoad();
    };
    const handleClick = () => {
      if (isHoverMenu.value && !isLeaf2.value)
        return;
      if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
        handleCheck(true);
      } else {
        handleExpand();
      }
    };
    const handleSelectCheck = (checked) => {
      if (checkStrictly.value) {
        doCheck(checked);
        if (props.node.loaded) {
          doExpand();
        }
      } else {
        handleCheck(checked);
      }
    };
    const handleCheck = (checked) => {
      if (!props.node.loaded) {
        doLoad();
      } else {
        doCheck(checked);
        !checkStrictly.value && doExpand();
      }
    };
    return {
      panel,
      isHoverMenu,
      multiple,
      checkStrictly,
      checkedNodeId,
      isDisabled,
      isLeaf: isLeaf2,
      expandable,
      inExpandingPath,
      inCheckedPath,
      ns: ns2,
      handleHoverExpand,
      handleExpand,
      handleClick,
      handleCheck,
      handleSelectCheck
    };
  }
});
var _hoisted_122 = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
var _hoisted_215 = /* @__PURE__ */ (0, import_vue375.createElementVNode)("span", null, null, -1);
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = (0, import_vue375.resolveComponent)("el-checkbox");
  const _component_el_radio = (0, import_vue375.resolveComponent)("el-radio");
  const _component_check = (0, import_vue375.resolveComponent)("check");
  const _component_el_icon = (0, import_vue375.resolveComponent)("el-icon");
  const _component_node_content = (0, import_vue375.resolveComponent)("node-content");
  const _component_loading = (0, import_vue375.resolveComponent)("loading");
  const _component_arrow_right = (0, import_vue375.resolveComponent)("arrow-right");
  return (0, import_vue375.openBlock)(), (0, import_vue375.createElementBlock)("li", {
    id: `${_ctx.menuId}-${_ctx.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !_ctx.isLeaf,
    "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
    "aria-expanded": _ctx.inExpandingPath,
    tabindex: _ctx.expandable ? -1 : void 0,
    class: (0, import_vue375.normalizeClass)([
      _ctx.ns.b(),
      _ctx.ns.is("selectable", _ctx.checkStrictly),
      _ctx.ns.is("active", _ctx.node.checked),
      _ctx.ns.is("disabled", !_ctx.expandable),
      _ctx.inExpandingPath && "in-active-path",
      _ctx.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    (0, import_vue375.createCommentVNode)(" prefix "),
    _ctx.multiple ? ((0, import_vue375.openBlock)(), (0, import_vue375.createBlock)(_component_el_checkbox, {
      key: 0,
      "model-value": _ctx.node.checked,
      indeterminate: _ctx.node.indeterminate,
      disabled: _ctx.isDisabled,
      onClick: _cache[0] || (_cache[0] = (0, import_vue375.withModifiers)(() => {
      }, ["stop"])),
      "onUpdate:modelValue": _ctx.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : _ctx.checkStrictly ? ((0, import_vue375.openBlock)(), (0, import_vue375.createBlock)(_component_el_radio, {
      key: 1,
      "model-value": _ctx.checkedNodeId,
      label: _ctx.node.uid,
      disabled: _ctx.isDisabled,
      "onUpdate:modelValue": _ctx.handleSelectCheck,
      onClick: _cache[1] || (_cache[1] = (0, import_vue375.withModifiers)(() => {
      }, ["stop"]))
    }, {
      default: (0, import_vue375.withCtx)(() => [
        (0, import_vue375.createCommentVNode)("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
        _hoisted_215
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : _ctx.isLeaf && _ctx.node.checked ? ((0, import_vue375.openBlock)(), (0, import_vue375.createBlock)(_component_el_icon, {
      key: 2,
      class: (0, import_vue375.normalizeClass)(_ctx.ns.e("prefix"))
    }, {
      default: (0, import_vue375.withCtx)(() => [
        (0, import_vue375.createVNode)(_component_check)
      ]),
      _: 1
    }, 8, ["class"])) : (0, import_vue375.createCommentVNode)("v-if", true),
    (0, import_vue375.createCommentVNode)(" content "),
    (0, import_vue375.createVNode)(_component_node_content),
    (0, import_vue375.createCommentVNode)(" postfix "),
    !_ctx.isLeaf ? ((0, import_vue375.openBlock)(), (0, import_vue375.createElementBlock)(import_vue375.Fragment, { key: 3 }, [
      _ctx.node.loading ? ((0, import_vue375.openBlock)(), (0, import_vue375.createBlock)(_component_el_icon, {
        key: 0,
        class: (0, import_vue375.normalizeClass)([_ctx.ns.is("loading"), _ctx.ns.e("postfix")])
      }, {
        default: (0, import_vue375.withCtx)(() => [
          (0, import_vue375.createVNode)(_component_loading)
        ]),
        _: 1
      }, 8, ["class"])) : ((0, import_vue375.openBlock)(), (0, import_vue375.createBlock)(_component_el_icon, {
        key: 1,
        class: (0, import_vue375.normalizeClass)(["arrow-right", _ctx.ns.e("postfix")])
      }, {
        default: (0, import_vue375.withCtx)(() => [
          (0, import_vue375.createVNode)(_component_arrow_right)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64)) : (0, import_vue375.createCommentVNode)("v-if", true)
  ], 42, _hoisted_122);
}
var ElCascaderNode = /* @__PURE__ */ _export_sfc(_sfc_main39, [["render", _sfc_render2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/menu.mjs
var _sfc_main40 = (0, import_vue376.defineComponent)({
  name: "ElCascaderMenu",
  components: {
    Loading: loading_default,
    ElIcon,
    ElScrollbar,
    ElCascaderNode
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup(props) {
    const instance = (0, import_vue376.getCurrentInstance)();
    const ns2 = useNamespace("cascader-menu");
    const { t } = useLocale();
    const id2 = generateId();
    let activeNode = null;
    let hoverTimer = null;
    const panel = (0, import_vue376.inject)(CASCADER_PANEL_INJECTION_KEY);
    const hoverZone = (0, import_vue376.ref)(null);
    const isEmpty2 = (0, import_vue376.computed)(() => !props.nodes.length);
    const isLoading = (0, import_vue376.computed)(() => !panel.initialLoaded);
    const menuId = (0, import_vue376.computed)(() => `cascader-menu-${id2}-${props.index}`);
    const handleExpand = (e) => {
      activeNode = e.target;
    };
    const handleMouseMove = (e) => {
      if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
        return;
      if (activeNode.contains(e.target)) {
        clearHoverTimer();
        const el = instance.vnode.el;
        const { left: left2 } = el.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = el;
        const startX = e.clientX - left2;
        const top = activeNode.offsetTop;
        const bottom = top + activeNode.offsetHeight;
        hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />
        `;
      } else if (!hoverTimer) {
        hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };
    const clearHoverTimer = () => {
      if (!hoverTimer)
        return;
      clearTimeout(hoverTimer);
      hoverTimer = null;
    };
    const clearHoverZone = () => {
      if (!hoverZone.value)
        return;
      hoverZone.value.innerHTML = "";
      clearHoverTimer();
    };
    return {
      ns: ns2,
      panel,
      hoverZone,
      isEmpty: isEmpty2,
      isLoading,
      menuId,
      t,
      handleExpand,
      handleMouseMove,
      clearHoverZone
    };
  }
});
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_node = (0, import_vue376.resolveComponent)("el-cascader-node");
  const _component_loading = (0, import_vue376.resolveComponent)("loading");
  const _component_el_icon = (0, import_vue376.resolveComponent)("el-icon");
  const _component_el_scrollbar = (0, import_vue376.resolveComponent)("el-scrollbar");
  return (0, import_vue376.openBlock)(), (0, import_vue376.createBlock)(_component_el_scrollbar, {
    key: _ctx.menuId,
    tag: "ul",
    role: "menu",
    class: (0, import_vue376.normalizeClass)(_ctx.ns.b()),
    "wrap-class": _ctx.ns.e("wrap"),
    "view-class": [_ctx.ns.e("list"), _ctx.ns.is("empty", _ctx.isEmpty)],
    onMousemove: _ctx.handleMouseMove,
    onMouseleave: _ctx.clearHoverZone
  }, {
    default: (0, import_vue376.withCtx)(() => {
      var _a2;
      return [
        ((0, import_vue376.openBlock)(true), (0, import_vue376.createElementBlock)(import_vue376.Fragment, null, (0, import_vue376.renderList)(_ctx.nodes, (node) => {
          return (0, import_vue376.openBlock)(), (0, import_vue376.createBlock)(_component_el_cascader_node, {
            key: node.uid,
            node,
            "menu-id": _ctx.menuId,
            onExpand: _ctx.handleExpand
          }, null, 8, ["node", "menu-id", "onExpand"]);
        }), 128)),
        _ctx.isLoading ? ((0, import_vue376.openBlock)(), (0, import_vue376.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue376.normalizeClass)(_ctx.ns.e("empty-text"))
        }, [
          (0, import_vue376.createVNode)(_component_el_icon, {
            size: "14",
            class: (0, import_vue376.normalizeClass)(_ctx.ns.is("loading"))
          }, {
            default: (0, import_vue376.withCtx)(() => [
              (0, import_vue376.createVNode)(_component_loading)
            ]),
            _: 1
          }, 8, ["class"]),
          (0, import_vue376.createTextVNode)(" " + (0, import_vue376.toDisplayString)(_ctx.t("el.cascader.loading")), 1)
        ], 2)) : _ctx.isEmpty ? ((0, import_vue376.openBlock)(), (0, import_vue376.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue376.normalizeClass)(_ctx.ns.e("empty-text"))
        }, (0, import_vue376.toDisplayString)(_ctx.t("el.cascader.noData")), 3)) : ((_a2 = _ctx.panel) == null ? void 0 : _a2.isHoverMenu) ? ((0, import_vue376.openBlock)(), (0, import_vue376.createElementBlock)("svg", {
          key: 2,
          ref: "hoverZone",
          class: (0, import_vue376.normalizeClass)(_ctx.ns.e("hover-zone"))
        }, null, 2)) : (0, import_vue376.createCommentVNode)("v-if", true)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var ElCascaderMenu = /* @__PURE__ */ _export_sfc(_sfc_main40, [["render", _sfc_render3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/node.mjs
var import_shared42 = require("@vue/shared");
var uid = 0;
var calculatePathNodes = (node) => {
  const nodes = [node];
  let { parent } = node;
  while (parent) {
    nodes.unshift(parent);
    parent = parent.parent;
  }
  return nodes;
};
var Node = class {
  constructor(data, config, parent, root2 = false) {
    this.data = data;
    this.config = config;
    this.parent = parent;
    this.root = root2;
    this.uid = uid++;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    const { value: valueKey, label: labelKey, children: childrenKey } = config;
    const childrenData = data[childrenKey];
    const pathNodes = calculatePathNodes(this);
    this.level = root2 ? 0 : parent ? parent.level + 1 : 1;
    this.value = data[valueKey];
    this.label = data[labelKey];
    this.pathNodes = pathNodes;
    this.pathValues = pathNodes.map((node) => node.value);
    this.pathLabels = pathNodes.map((node) => node.label);
    this.childrenData = childrenData;
    this.children = (childrenData || []).map((child) => new Node(child, config, this));
    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
  }
  get isDisabled() {
    const { data, parent, config } = this;
    const { disabled, checkStrictly } = config;
    const isDisabled = (0, import_shared42.isFunction)(disabled) ? disabled(data, this) : !!data[disabled];
    return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);
  }
  get isLeaf() {
    const { data, config, childrenData, loaded } = this;
    const { lazy, leaf } = config;
    const isLeaf2 = (0, import_shared42.isFunction)(leaf) ? leaf(data, this) : data[leaf];
    return isUndefined(isLeaf2) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf2;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(childData) {
    const { childrenData, children } = this;
    const node = new Node(childData, this.config, this);
    if (Array.isArray(childrenData)) {
      childrenData.push(childData);
    } else {
      this.childrenData = [childData];
    }
    children.push(node);
    return node;
  }
  calcText(allLevels, separator) {
    const text = allLevels ? this.pathLabels.join(separator) : this.label;
    this.text = text;
    return text;
  }
  broadcast(event, ...args) {
    const handlerName = `onParent${capitalize(event)}`;
    this.children.forEach((child) => {
      if (child) {
        child.broadcast(event, ...args);
        child[handlerName] && child[handlerName](...args);
      }
    });
  }
  emit(event, ...args) {
    const { parent } = this;
    const handlerName = `onChild${capitalize(event)}`;
    if (parent) {
      parent[handlerName] && parent[handlerName](...args);
      parent.emit(event, ...args);
    }
  }
  onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  }
  onChildCheck() {
    const { children } = this;
    const validChildren = children.filter((child) => !child.isDisabled);
    const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
    this.setCheckState(checked);
  }
  setCheckState(checked) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c2, p2) => {
      const num = p2.checked ? 1 : p2.indeterminate ? 0.5 : 0;
      return c2 + num;
    }, 0);
    this.checked = this.loaded && this.children.filter((child) => !child.isDisabled).every((child) => child.loaded && child.checked) && checked;
    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
  }
  doCheck(checked) {
    if (this.checked === checked)
      return;
    const { checkStrictly, multiple } = this.config;
    if (checkStrictly || !multiple) {
      this.checked = checked;
    } else {
      this.broadcast("check", checked);
      this.setCheckState(checked);
      this.emit("check");
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/store.mjs
var flatNodes = (nodes, leafOnly) => {
  return nodes.reduce((res, node) => {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }
    return res;
  }, []);
};
var Store = class {
  constructor(data, config) {
    this.config = config;
    const nodes = (data || []).map((nodeData) => new Node(nodeData, this.config));
    this.nodes = nodes;
    this.allNodes = flatNodes(nodes, false);
    this.leafNodes = flatNodes(nodes, true);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(leafOnly) {
    return leafOnly ? this.leafNodes : this.allNodes;
  }
  appendNode(nodeData, parentNode) {
    const node = parentNode ? parentNode.appendChild(nodeData) : new Node(nodeData, this.config);
    if (!parentNode)
      this.nodes.push(node);
    this.allNodes.push(node);
    node.isLeaf && this.leafNodes.push(node);
  }
  appendNodes(nodeDataList, parentNode) {
    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
  }
  getNodeByValue(value, leafOnly = false) {
    if (!value && value !== 0)
      return null;
    const node = this.getFlattedNodes(leafOnly).find((node2) => isEqual_default(node2.value, value) || isEqual_default(node2.pathValues, value));
    return node || null;
  }
  getSameNode(node) {
    if (!node)
      return null;
    const node_ = this.getFlattedNodes(false).find(({ value, level }) => isEqual_default(node.value, value) && node.level === level);
    return node_ || null;
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/config.mjs
var import_vue377 = require("vue");
var import_shared43 = require("@vue/shared");
var CommonProps = buildProps({
  modelValue: {
    type: definePropType([Number, String, Array])
  },
  options: {
    type: definePropType(Array),
    default: () => []
  },
  props: {
    type: definePropType(Object),
    default: () => ({})
  }
});
var DefaultProps = {
  expandTrigger: "click",
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: import_shared43.NOOP,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
};
var useCascaderConfig = (props) => {
  return (0, import_vue377.computed)(() => ({
    ...DefaultProps,
    ...props.props
  }));
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/utils.mjs
var getMenuIndex = (el) => {
  if (!el)
    return 0;
  const pieces = el.id.split("-");
  return Number(pieces[pieces.length - 2]);
};
var checkNode = (el) => {
  if (!el)
    return;
  const input = el.querySelector("input");
  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};
var sortByOriginalOrder = (oldNodes, newNodes) => {
  const newNodesCopy = newNodes.slice(0);
  const newIds = newNodesCopy.map((node) => node.uid);
  const res = oldNodes.reduce((acc, item) => {
    const index2 = newIds.indexOf(item.uid);
    if (index2 > -1) {
      acc.push(item);
      newNodesCopy.splice(index2, 1);
      newIds.splice(index2, 1);
    }
    return acc;
  }, []);
  res.push(...newNodesCopy);
  return res;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/src/index.mjs
var _sfc_main41 = (0, import_vue378.defineComponent)({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu
  },
  props: {
    ...CommonProps,
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "close", "expand-change"],
  setup(props, { emit, slots }) {
    let manualChecked = false;
    const ns2 = useNamespace("cascader");
    const config = useCascaderConfig(props);
    let store = null;
    const initialLoaded = (0, import_vue378.ref)(true);
    const menuList = (0, import_vue378.ref)([]);
    const checkedValue = (0, import_vue378.ref)(null);
    const menus = (0, import_vue378.ref)([]);
    const expandingNode = (0, import_vue378.ref)(null);
    const checkedNodes = (0, import_vue378.ref)([]);
    const isHoverMenu = (0, import_vue378.computed)(() => config.value.expandTrigger === "hover");
    const renderLabelFn = (0, import_vue378.computed)(() => props.renderLabel || slots.default);
    const initStore = () => {
      const { options } = props;
      const cfg = config.value;
      manualChecked = false;
      store = new Store(options, cfg);
      menus.value = [store.getNodes()];
      if (cfg.lazy && isEmpty(props.options)) {
        initialLoaded.value = false;
        lazyLoad(void 0, (list) => {
          if (list) {
            store = new Store(list, cfg);
            menus.value = [store.getNodes()];
          }
          initialLoaded.value = true;
          syncCheckedValue(false, true);
        });
      } else {
        syncCheckedValue(false, true);
      }
    };
    const lazyLoad = (node, cb) => {
      const cfg = config.value;
      node = node || new Node({}, cfg, void 0, true);
      node.loading = true;
      const resolve = (dataList) => {
        const _node = node;
        const parent = _node.root ? null : _node;
        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));
        _node.loading = false;
        _node.loaded = true;
        _node.childrenData = _node.childrenData || [];
        cb && cb(dataList);
      };
      cfg.lazyLoad(node, resolve);
    };
    const expandNode = (node, silent) => {
      var _a2;
      const { level } = node;
      const newMenus = menus.value.slice(0, level);
      let newExpandingNode;
      if (node.isLeaf) {
        newExpandingNode = node.pathNodes[level - 2];
      } else {
        newExpandingNode = node;
        newMenus.push(node.children);
      }
      if (((_a2 = expandingNode.value) == null ? void 0 : _a2.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
        expandingNode.value = node;
        menus.value = newMenus;
        !silent && emit("expand-change", (node == null ? void 0 : node.pathValues) || []);
      }
    };
    const handleCheckChange = (node, checked, emitClose = true) => {
      const { checkStrictly, multiple } = config.value;
      const oldNode = checkedNodes.value[0];
      manualChecked = true;
      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
      node.doCheck(checked);
      calculateCheckedValue();
      emitClose && !multiple && !checkStrictly && emit("close");
      !emitClose && !multiple && !checkStrictly && expandParentNode(node);
    };
    const expandParentNode = (node) => {
      if (!node)
        return;
      node = node.parent;
      expandParentNode(node);
      node && expandNode(node);
    };
    const getFlattedNodes = (leafOnly) => {
      return store == null ? void 0 : store.getFlattedNodes(leafOnly);
    };
    const getCheckedNodes = (leafOnly) => {
      var _a2;
      return (_a2 = getFlattedNodes(leafOnly)) == null ? void 0 : _a2.filter((node) => node.checked !== false);
    };
    const clearCheckedNodes = () => {
      checkedNodes.value.forEach((node) => node.doCheck(false));
      calculateCheckedValue();
    };
    const calculateCheckedValue = () => {
      var _a2;
      const { checkStrictly, multiple } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = getCheckedNodes(!checkStrictly);
      const nodes = sortByOriginalOrder(oldNodes, newNodes);
      const values = nodes.map((node) => node.valueByOption);
      checkedNodes.value = nodes;
      checkedValue.value = multiple ? values : (_a2 = values[0]) != null ? _a2 : null;
    };
    const syncCheckedValue = (loaded = false, forced = false) => {
      const { modelValue } = props;
      const { lazy, multiple, checkStrictly } = config.value;
      const leafOnly = !checkStrictly;
      if (!initialLoaded.value || manualChecked || !forced && isEqual_default(modelValue, checkedValue.value))
        return;
      if (lazy && !loaded) {
        const values = unique(flattenDeep_default(castArray2(modelValue)));
        const nodes = values.map((val) => store == null ? void 0 : store.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
        if (nodes.length) {
          nodes.forEach((node) => {
            lazyLoad(node, () => syncCheckedValue(false, forced));
          });
        } else {
          syncCheckedValue(true, forced);
        }
      } else {
        const values = multiple ? castArray2(modelValue) : [modelValue];
        const nodes = unique(values.map((val) => store == null ? void 0 : store.getNodeByValue(val, leafOnly)));
        syncMenuState(nodes, forced);
        checkedValue.value = cloneDeep_default(modelValue);
      }
    };
    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
      const { checkStrictly } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = newCheckedNodes.filter((node) => !!node && (checkStrictly || node.isLeaf));
      const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);
      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
      if (newExpandingNode) {
        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
      } else {
        expandingNode.value = null;
      }
      oldNodes.forEach((node) => node.doCheck(false));
      newNodes.forEach((node) => node.doCheck(true));
      checkedNodes.value = newNodes;
      (0, import_vue378.nextTick)(scrollToExpandingNode);
    };
    const scrollToExpandingNode = () => {
      if (!isClient)
        return;
      menuList.value.forEach((menu) => {
        const menuElement = menu == null ? void 0 : menu.$el;
        if (menuElement) {
          const container = menuElement.querySelector(`.${ns2.namespace.value}-scrollbar__wrap`);
          const activeNode = menuElement.querySelector(`.${ns2.b("node")}.${ns2.is("active")}`) || menuElement.querySelector(`.${ns2.b("node")}.in-active-path`);
          scrollIntoView(container, activeNode);
        }
      });
    };
    const handleKeyDown = (e) => {
      const target = e.target;
      const { code } = e;
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down: {
          e.preventDefault();
          const distance = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance, `.${ns2.b("node")}[tabindex="-1"]`));
          break;
        }
        case EVENT_CODE.left: {
          e.preventDefault();
          const preMenu = menuList.value[getMenuIndex(target) - 1];
          const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns2.b("node")}[aria-expanded="true"]`);
          focusNode(expandedNode);
          break;
        }
        case EVENT_CODE.right: {
          e.preventDefault();
          const nextMenu = menuList.value[getMenuIndex(target) + 1];
          const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns2.b("node")}[tabindex="-1"]`);
          focusNode(firstNode);
          break;
        }
        case EVENT_CODE.enter:
          checkNode(target);
          break;
      }
    };
    (0, import_vue378.provide)(CASCADER_PANEL_INJECTION_KEY, (0, import_vue378.reactive)({
      config,
      expandingNode,
      checkedNodes,
      isHoverMenu,
      initialLoaded,
      renderLabelFn,
      lazyLoad,
      expandNode,
      handleCheckChange
    }));
    (0, import_vue378.watch)([config, () => props.options], initStore, {
      deep: true,
      immediate: true
    });
    (0, import_vue378.watch)(() => props.modelValue, () => {
      manualChecked = false;
      syncCheckedValue();
    }, {
      deep: true
    });
    (0, import_vue378.watch)(() => checkedValue.value, (val) => {
      if (!isEqual_default(val, props.modelValue)) {
        emit(UPDATE_MODEL_EVENT, val);
        emit(CHANGE_EVENT, val);
      }
    });
    (0, import_vue378.onBeforeUpdate)(() => menuList.value = []);
    (0, import_vue378.onMounted)(() => !isEmpty(props.modelValue) && syncCheckedValue());
    return {
      ns: ns2,
      menuList,
      menus,
      checkedNodes,
      handleKeyDown,
      handleCheckChange,
      getFlattedNodes,
      getCheckedNodes,
      clearCheckedNodes,
      calculateCheckedValue,
      scrollToExpandingNode
    };
  }
});
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_menu = (0, import_vue378.resolveComponent)("el-cascader-menu");
  return (0, import_vue378.openBlock)(), (0, import_vue378.createElementBlock)("div", {
    class: (0, import_vue378.normalizeClass)([_ctx.ns.b("panel"), _ctx.ns.is("bordered", _ctx.border)]),
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
  }, [
    ((0, import_vue378.openBlock)(true), (0, import_vue378.createElementBlock)(import_vue378.Fragment, null, (0, import_vue378.renderList)(_ctx.menus, (menu, index2) => {
      return (0, import_vue378.openBlock)(), (0, import_vue378.createBlock)(_component_el_cascader_menu, {
        key: index2,
        ref_for: true,
        ref: (item) => _ctx.menuList[index2] = item,
        index: index2,
        nodes: [...menu]
      }, null, 8, ["index", "nodes"]);
    }), 128))
  ], 34);
}
var CascaderPanel = /* @__PURE__ */ _export_sfc(_sfc_main41, [["render", _sfc_render4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader-panel/index.mjs
CascaderPanel.install = (app) => {
  app.component(CascaderPanel.name, CascaderPanel);
};
var _CascaderPanel = CascaderPanel;
var ElCascaderPanel = _CascaderPanel;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tag/src/tag2.mjs
var import_vue379 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tag/src/tag.mjs
var tagProps = buildProps({
  closable: Boolean,
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  hit: Boolean,
  disableTransitions: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: componentSizes,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
});
var tagEmits = {
  close: (evt) => evt instanceof MouseEvent,
  click: (evt) => evt instanceof MouseEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tag/src/tag2.mjs
var __default__33 = (0, import_vue379.defineComponent)({
  name: "ElTag"
});
var _sfc_main42 = /* @__PURE__ */ (0, import_vue379.defineComponent)({
  ...__default__33,
  props: tagProps,
  emits: tagEmits,
  setup(__props, { emit }) {
    const props = __props;
    const tagSize = useSize();
    const ns2 = useNamespace("tag");
    const classes = (0, import_vue379.computed)(() => {
      const { type: type4, hit, effect, closable, round: round2 } = props;
      return [
        ns2.b(),
        ns2.is("closable", closable),
        ns2.m(type4),
        ns2.m(tagSize.value),
        ns2.m(effect),
        ns2.is("hit", hit),
        ns2.is("round", round2)
      ];
    });
    const handleClose = (event) => {
      emit("close", event);
    };
    const handleClick = (event) => {
      emit("click", event);
    };
    return (_ctx, _cache) => {
      return _ctx.disableTransitions ? ((0, import_vue379.openBlock)(), (0, import_vue379.createElementBlock)("span", {
        key: 0,
        class: (0, import_vue379.normalizeClass)((0, import_vue379.unref)(classes)),
        style: (0, import_vue379.normalizeStyle)({ backgroundColor: _ctx.color }),
        onClick: handleClick
      }, [
        (0, import_vue379.createElementVNode)("span", {
          class: (0, import_vue379.normalizeClass)((0, import_vue379.unref)(ns2).e("content"))
        }, [
          (0, import_vue379.renderSlot)(_ctx.$slots, "default")
        ], 2),
        _ctx.closable ? ((0, import_vue379.openBlock)(), (0, import_vue379.createBlock)((0, import_vue379.unref)(ElIcon), {
          key: 0,
          class: (0, import_vue379.normalizeClass)((0, import_vue379.unref)(ns2).e("close")),
          onClick: (0, import_vue379.withModifiers)(handleClose, ["stop"])
        }, {
          default: (0, import_vue379.withCtx)(() => [
            (0, import_vue379.createVNode)((0, import_vue379.unref)(close_default))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : (0, import_vue379.createCommentVNode)("v-if", true)
      ], 6)) : ((0, import_vue379.openBlock)(), (0, import_vue379.createBlock)(import_vue379.Transition, {
        key: 1,
        name: `${(0, import_vue379.unref)(ns2).namespace.value}-zoom-in-center`,
        appear: ""
      }, {
        default: (0, import_vue379.withCtx)(() => [
          (0, import_vue379.createElementVNode)("span", {
            class: (0, import_vue379.normalizeClass)((0, import_vue379.unref)(classes)),
            style: (0, import_vue379.normalizeStyle)({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            (0, import_vue379.createElementVNode)("span", {
              class: (0, import_vue379.normalizeClass)((0, import_vue379.unref)(ns2).e("content"))
            }, [
              (0, import_vue379.renderSlot)(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? ((0, import_vue379.openBlock)(), (0, import_vue379.createBlock)((0, import_vue379.unref)(ElIcon), {
              key: 0,
              class: (0, import_vue379.normalizeClass)((0, import_vue379.unref)(ns2).e("close")),
              onClick: (0, import_vue379.withModifiers)(handleClose, ["stop"])
            }, {
              default: (0, import_vue379.withCtx)(() => [
                (0, import_vue379.createVNode)((0, import_vue379.unref)(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : (0, import_vue379.createCommentVNode)("v-if", true)
          ], 6)
        ]),
        _: 3
      }, 8, ["name"]));
    };
  }
});
var Tag = /* @__PURE__ */ _export_sfc(_sfc_main42, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tag/index.mjs
var ElTag = withInstall(Tag);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader/src/cascader.mjs
var cascaderProps = buildProps({
  ...CommonProps,
  size: useSizeProp,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: definePropType(Function),
    default: (node, keyword) => node.text.includes(keyword)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: true
  },
  collapseTags: Boolean,
  collapseTagsTooltip: {
    type: Boolean,
    default: false
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: definePropType(Function),
    default: () => true
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: useTooltipContentProps.teleported,
  tagType: { ...tagProps.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var cascaderEmits = {
  [UPDATE_MODEL_EVENT]: (val) => !!val,
  [CHANGE_EVENT]: (val) => !!val,
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  visibleChange: (val) => isBoolean(val),
  expandChange: (val) => !!val,
  removeTag: (val) => !!val
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader/src/cascader2.mjs
var _hoisted_123 = { key: 0 };
var _hoisted_216 = ["placeholder", "onKeydown"];
var _hoisted_34 = ["onClick"];
var COMPONENT_NAME9 = "ElCascader";
var __default__34 = (0, import_vue380.defineComponent)({
  name: COMPONENT_NAME9
});
var _sfc_main43 = /* @__PURE__ */ (0, import_vue380.defineComponent)({
  ...__default__34,
  props: cascaderProps,
  emits: cascaderEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const popperOptions = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: true,
          phase: "main",
          fn: ({ state }) => {
            const { modifiersData, placement } = state;
            if (["right", "left", "bottom", "top"].includes(placement))
              return;
            modifiersData.arrow.x = 35;
          },
          requires: ["arrow"]
        }
      ]
    };
    const attrs = (0, import_vue380.useAttrs)();
    let inputInitialHeight = 0;
    let pressDeleteCount = 0;
    const nsCascader = useNamespace("cascader");
    const nsInput = useNamespace("input");
    const { t } = useLocale();
    const { form, formItem } = useFormItem();
    const tooltipRef = (0, import_vue380.ref)(null);
    const input = (0, import_vue380.ref)(null);
    const tagWrapper = (0, import_vue380.ref)(null);
    const panel = (0, import_vue380.ref)(null);
    const suggestionPanel = (0, import_vue380.ref)(null);
    const popperVisible = (0, import_vue380.ref)(false);
    const inputHover = (0, import_vue380.ref)(false);
    const filtering = (0, import_vue380.ref)(false);
    const inputValue = (0, import_vue380.ref)("");
    const searchInputValue = (0, import_vue380.ref)("");
    const presentTags = (0, import_vue380.ref)([]);
    const allPresentTags = (0, import_vue380.ref)([]);
    const suggestions = (0, import_vue380.ref)([]);
    const isOnComposition = (0, import_vue380.ref)(false);
    const cascaderStyle = (0, import_vue380.computed)(() => {
      return attrs.style;
    });
    const isDisabled = (0, import_vue380.computed)(() => props.disabled || (form == null ? void 0 : form.disabled));
    const inputPlaceholder = (0, import_vue380.computed)(() => props.placeholder || t("el.cascader.placeholder"));
    const currentPlaceholder = (0, import_vue380.computed)(() => searchInputValue.value || presentTags.value.length > 0 || isOnComposition.value ? "" : inputPlaceholder.value);
    const realSize = useSize();
    const tagSize = (0, import_vue380.computed)(() => ["small"].includes(realSize.value) ? "small" : "default");
    const multiple = (0, import_vue380.computed)(() => !!props.props.multiple);
    const readonly5 = (0, import_vue380.computed)(() => !props.filterable || multiple.value);
    const searchKeyword = (0, import_vue380.computed)(() => multiple.value ? searchInputValue.value : inputValue.value);
    const checkedNodes = (0, import_vue380.computed)(() => {
      var _a2;
      return ((_a2 = panel.value) == null ? void 0 : _a2.checkedNodes) || [];
    });
    const clearBtnVisible = (0, import_vue380.computed)(() => {
      if (!props.clearable || isDisabled.value || filtering.value || !inputHover.value)
        return false;
      return !!checkedNodes.value.length;
    });
    const presentText = (0, import_vue380.computed)(() => {
      const { showAllLevels, separator } = props;
      const nodes = checkedNodes.value;
      return nodes.length ? multiple.value ? "" : nodes[0].calcText(showAllLevels, separator) : "";
    });
    const checkedValue = (0, import_vue380.computed)({
      get() {
        return cloneDeep_default(props.modelValue);
      },
      set(val) {
        emit(UPDATE_MODEL_EVENT, val);
        emit(CHANGE_EVENT, val);
        if (props.validateEvent) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
        }
      }
    });
    const cascaderPanelRef = (0, import_vue380.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
    });
    const cascaderKls = (0, import_vue380.computed)(() => {
      return [
        nsCascader.b(),
        nsCascader.m(realSize.value),
        nsCascader.is("disabled", isDisabled.value),
        attrs.class
      ];
    });
    const cascaderIconKls = (0, import_vue380.computed)(() => {
      return [
        nsInput.e("icon"),
        "icon-arrow-down",
        nsCascader.is("reverse", popperVisible.value)
      ];
    });
    const togglePopperVisible = (visible) => {
      var _a2, _b, _c;
      if (isDisabled.value)
        return;
      visible = visible != null ? visible : !popperVisible.value;
      if (visible !== popperVisible.value) {
        popperVisible.value = visible;
        (_b = (_a2 = input.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.setAttribute("aria-expanded", `${visible}`);
        if (visible) {
          updatePopperPosition();
          (0, import_vue380.nextTick)((_c = panel.value) == null ? void 0 : _c.scrollToExpandingNode);
        } else if (props.filterable) {
          syncPresentTextValue();
        }
        emit("visibleChange", visible);
      }
    };
    const updatePopperPosition = () => {
      (0, import_vue380.nextTick)(() => {
        var _a2;
        (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper();
      });
    };
    const hideSuggestionPanel = () => {
      filtering.value = false;
    };
    const genTag3 = (node) => {
      const { showAllLevels, separator } = props;
      return {
        node,
        key: node.uid,
        text: node.calcText(showAllLevels, separator),
        hitState: false,
        closable: !isDisabled.value && !node.isDisabled,
        isCollapseTag: false
      };
    };
    const deleteTag = (tag) => {
      var _a2;
      const node = tag.node;
      node.doCheck(false);
      (_a2 = panel.value) == null ? void 0 : _a2.calculateCheckedValue();
      emit("removeTag", node.valueByOption);
    };
    const calculatePresentTags = () => {
      if (!multiple.value)
        return;
      const nodes = checkedNodes.value;
      const tags = [];
      const allTags = [];
      nodes.forEach((node) => allTags.push(genTag3(node)));
      allPresentTags.value = allTags;
      if (nodes.length) {
        const [first, ...rest] = nodes;
        const restCount = rest.length;
        tags.push(genTag3(first));
        if (restCount) {
          if (props.collapseTags) {
            tags.push({
              key: -1,
              text: `+ ${restCount}`,
              closable: false,
              isCollapseTag: true
            });
          } else {
            rest.forEach((node) => tags.push(genTag3(node)));
          }
        }
      }
      presentTags.value = tags;
    };
    const calculateSuggestions = () => {
      var _a2, _b;
      const { filterMethod, showAllLevels, separator } = props;
      const res = (_b = (_a2 = panel.value) == null ? void 0 : _a2.getFlattedNodes(!props.props.checkStrictly)) == null ? void 0 : _b.filter((node) => {
        if (node.isDisabled)
          return false;
        node.calcText(showAllLevels, separator);
        return filterMethod(node, searchKeyword.value);
      });
      if (multiple.value) {
        presentTags.value.forEach((tag) => {
          tag.hitState = false;
        });
        allPresentTags.value.forEach((tag) => {
          tag.hitState = false;
        });
      }
      filtering.value = true;
      suggestions.value = res;
      updatePopperPosition();
    };
    const focusFirstNode = () => {
      var _a2;
      let firstNode;
      if (filtering.value && suggestionPanel.value) {
        firstNode = suggestionPanel.value.$el.querySelector(`.${nsCascader.e("suggestion-item")}`);
      } else {
        firstNode = (_a2 = panel.value) == null ? void 0 : _a2.$el.querySelector(`.${nsCascader.b("node")}[tabindex="-1"]`);
      }
      if (firstNode) {
        firstNode.focus();
        !filtering.value && firstNode.click();
      }
    };
    const updateStyle = () => {
      var _a2, _b;
      const inputInner = (_a2 = input.value) == null ? void 0 : _a2.input;
      const tagWrapperEl = tagWrapper.value;
      const suggestionPanelEl = (_b = suggestionPanel.value) == null ? void 0 : _b.$el;
      if (!isClient || !inputInner)
        return;
      if (suggestionPanelEl) {
        const suggestionList = suggestionPanelEl.querySelector(`.${nsCascader.e("suggestion-list")}`);
        suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
      }
      if (tagWrapperEl) {
        const { offsetHeight } = tagWrapperEl;
        const height = presentTags.value.length > 0 ? `${Math.max(offsetHeight + 6, inputInitialHeight)}px` : `${inputInitialHeight}px`;
        inputInner.style.height = height;
        updatePopperPosition();
      }
    };
    const getCheckedNodes = (leafOnly) => {
      var _a2;
      return (_a2 = panel.value) == null ? void 0 : _a2.getCheckedNodes(leafOnly);
    };
    const handleExpandChange = (value) => {
      updatePopperPosition();
      emit("expandChange", value);
    };
    const handleComposition = (event) => {
      var _a2;
      const text = (_a2 = event.target) == null ? void 0 : _a2.value;
      if (event.type === "compositionend") {
        isOnComposition.value = false;
        (0, import_vue380.nextTick)(() => handleInput(text));
      } else {
        const lastCharacter = text[text.length - 1] || "";
        isOnComposition.value = !isKorean(lastCharacter);
      }
    };
    const handleKeyDown = (e) => {
      if (isOnComposition.value)
        return;
      switch (e.code) {
        case EVENT_CODE.enter:
          togglePopperVisible();
          break;
        case EVENT_CODE.down:
          togglePopperVisible(true);
          (0, import_vue380.nextTick)(focusFirstNode);
          e.preventDefault();
          break;
        case EVENT_CODE.esc:
          if (popperVisible.value === true) {
            e.preventDefault();
            e.stopPropagation();
            togglePopperVisible(false);
          }
          break;
        case EVENT_CODE.tab:
          togglePopperVisible(false);
          break;
      }
    };
    const handleClear = () => {
      var _a2;
      (_a2 = panel.value) == null ? void 0 : _a2.clearCheckedNodes();
      if (!popperVisible.value && props.filterable) {
        syncPresentTextValue();
      }
      togglePopperVisible(false);
    };
    const syncPresentTextValue = () => {
      const { value } = presentText;
      inputValue.value = value;
      searchInputValue.value = value;
    };
    const handleSuggestionClick = (node) => {
      var _a2, _b;
      const { checked } = node;
      if (multiple.value) {
        (_a2 = panel.value) == null ? void 0 : _a2.handleCheckChange(node, !checked, false);
      } else {
        !checked && ((_b = panel.value) == null ? void 0 : _b.handleCheckChange(node, true, false));
        togglePopperVisible(false);
      }
    };
    const handleSuggestionKeyDown = (e) => {
      const target = e.target;
      const { code } = e;
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down: {
          const distance = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance, `.${nsCascader.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case EVENT_CODE.enter:
          target.click();
          break;
      }
    };
    const handleDelete = () => {
      const tags = presentTags.value;
      const lastTag = tags[tags.length - 1];
      pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
      if (!lastTag || !pressDeleteCount || props.collapseTags && tags.length > 1)
        return;
      if (lastTag.hitState) {
        deleteTag(lastTag);
      } else {
        lastTag.hitState = true;
      }
    };
    const handleFocus = (e) => {
      emit("focus", e);
    };
    const handleBlur = (e) => {
      emit("blur", e);
    };
    const handleFilter = debounce_default(() => {
      const { value } = searchKeyword;
      if (!value)
        return;
      const passed = props.beforeFilter(value);
      if ((0, import_shared44.isPromise)(passed)) {
        passed.then(calculateSuggestions).catch(() => {
        });
      } else if (passed !== false) {
        calculateSuggestions();
      } else {
        hideSuggestionPanel();
      }
    }, props.debounce);
    const handleInput = (val, e) => {
      !popperVisible.value && togglePopperVisible(true);
      if (e == null ? void 0 : e.isComposing)
        return;
      val ? handleFilter() : hideSuggestionPanel();
    };
    (0, import_vue380.watch)(filtering, updatePopperPosition);
    (0, import_vue380.watch)([checkedNodes, isDisabled], calculatePresentTags);
    (0, import_vue380.watch)(presentTags, () => {
      (0, import_vue380.nextTick)(() => updateStyle());
    });
    (0, import_vue380.watch)(presentText, syncPresentTextValue, { immediate: true });
    (0, import_vue380.onMounted)(() => {
      const inputInner = input.value.input;
      const inputInnerHeight = Number.parseFloat(useCssVar(nsInput.cssVarName("input-height"), inputInner).value) - 2;
      inputInitialHeight = inputInner.offsetHeight || inputInnerHeight;
      useResizeObserver(inputInner, updateStyle);
    });
    expose({
      getCheckedNodes,
      cascaderPanelRef
    });
    return (_ctx, _cache) => {
      return (0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElTooltip), {
        ref_key: "tooltipRef",
        ref: tooltipRef,
        visible: popperVisible.value,
        teleported: _ctx.teleported,
        "popper-class": [(0, import_vue380.unref)(nsCascader).e("dropdown"), _ctx.popperClass],
        "popper-options": popperOptions,
        "fallback-placements": [
          "bottom-start",
          "bottom",
          "top-start",
          "top",
          "right",
          "left"
        ],
        "stop-popper-mouse-event": false,
        "gpu-acceleration": false,
        placement: "bottom-start",
        transition: `${(0, import_vue380.unref)(nsCascader).namespace.value}-zoom-in-top`,
        effect: "light",
        pure: "",
        persistent: "",
        onHide: hideSuggestionPanel
      }, {
        default: (0, import_vue380.withCtx)(() => [
          (0, import_vue380.withDirectives)(((0, import_vue380.openBlock)(), (0, import_vue380.createElementBlock)("div", {
            class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(cascaderKls)),
            style: (0, import_vue380.normalizeStyle)((0, import_vue380.unref)(cascaderStyle)),
            onClick: _cache[5] || (_cache[5] = () => togglePopperVisible((0, import_vue380.unref)(readonly5) ? void 0 : true)),
            onKeydown: handleKeyDown,
            onMouseenter: _cache[6] || (_cache[6] = ($event) => inputHover.value = true),
            onMouseleave: _cache[7] || (_cache[7] = ($event) => inputHover.value = false)
          }, [
            (0, import_vue380.createVNode)((0, import_vue380.unref)(ElInput), {
              ref_key: "input",
              ref: input,
              modelValue: inputValue.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event),
              placeholder: (0, import_vue380.unref)(currentPlaceholder),
              readonly: (0, import_vue380.unref)(readonly5),
              disabled: (0, import_vue380.unref)(isDisabled),
              "validate-event": false,
              size: (0, import_vue380.unref)(realSize),
              class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).is("focus", popperVisible.value)),
              onCompositionstart: handleComposition,
              onCompositionupdate: handleComposition,
              onCompositionend: handleComposition,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onInput: handleInput
            }, {
              suffix: (0, import_vue380.withCtx)(() => [
                (0, import_vue380.unref)(clearBtnVisible) ? ((0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElIcon), {
                  key: "clear",
                  class: (0, import_vue380.normalizeClass)([(0, import_vue380.unref)(nsInput).e("icon"), "icon-circle-close"]),
                  onClick: (0, import_vue380.withModifiers)(handleClear, ["stop"])
                }, {
                  default: (0, import_vue380.withCtx)(() => [
                    (0, import_vue380.createVNode)((0, import_vue380.unref)(circle_close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : ((0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElIcon), {
                  key: "arrow-down",
                  class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(cascaderIconKls)),
                  onClick: _cache[0] || (_cache[0] = (0, import_vue380.withModifiers)(($event) => togglePopperVisible(), ["stop"]))
                }, {
                  default: (0, import_vue380.withCtx)(() => [
                    (0, import_vue380.createVNode)((0, import_vue380.unref)(arrow_down_default))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ]),
              _: 1
            }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class"]),
            (0, import_vue380.unref)(multiple) ? ((0, import_vue380.openBlock)(), (0, import_vue380.createElementBlock)("div", {
              key: 0,
              ref_key: "tagWrapper",
              ref: tagWrapper,
              class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).e("tags"))
            }, [
              ((0, import_vue380.openBlock)(true), (0, import_vue380.createElementBlock)(import_vue380.Fragment, null, (0, import_vue380.renderList)(presentTags.value, (tag) => {
                return (0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElTag), {
                  key: tag.key,
                  type: _ctx.tagType,
                  size: (0, import_vue380.unref)(tagSize),
                  hit: tag.hitState,
                  closable: tag.closable,
                  "disable-transitions": "",
                  onClose: ($event) => deleteTag(tag)
                }, {
                  default: (0, import_vue380.withCtx)(() => [
                    tag.isCollapseTag === false ? ((0, import_vue380.openBlock)(), (0, import_vue380.createElementBlock)("span", _hoisted_123, (0, import_vue380.toDisplayString)(tag.text), 1)) : ((0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElTooltip), {
                      key: 1,
                      disabled: popperVisible.value || !_ctx.collapseTagsTooltip,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      placement: "bottom",
                      effect: "light"
                    }, {
                      default: (0, import_vue380.withCtx)(() => [
                        (0, import_vue380.createElementVNode)("span", null, (0, import_vue380.toDisplayString)(tag.text), 1)
                      ]),
                      content: (0, import_vue380.withCtx)(() => [
                        (0, import_vue380.createElementVNode)("div", {
                          class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).e("collapse-tags"))
                        }, [
                          ((0, import_vue380.openBlock)(true), (0, import_vue380.createElementBlock)(import_vue380.Fragment, null, (0, import_vue380.renderList)(allPresentTags.value.slice(1), (tag2, idx) => {
                            return (0, import_vue380.openBlock)(), (0, import_vue380.createElementBlock)("div", {
                              key: idx,
                              class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).e("collapse-tag"))
                            }, [
                              ((0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElTag), {
                                key: tag2.key,
                                class: "in-tooltip",
                                type: _ctx.tagType,
                                size: (0, import_vue380.unref)(tagSize),
                                hit: tag2.hitState,
                                closable: tag2.closable,
                                "disable-transitions": "",
                                onClose: ($event) => deleteTag(tag2)
                              }, {
                                default: (0, import_vue380.withCtx)(() => [
                                  (0, import_vue380.createElementVNode)("span", null, (0, import_vue380.toDisplayString)(tag2.text), 1)
                                ]),
                                _: 2
                              }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["disabled"]))
                  ]),
                  _: 2
                }, 1032, ["type", "size", "hit", "closable", "onClose"]);
              }), 128)),
              _ctx.filterable && !(0, import_vue380.unref)(isDisabled) ? (0, import_vue380.withDirectives)(((0, import_vue380.openBlock)(), (0, import_vue380.createElementBlock)("input", {
                key: 0,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => searchInputValue.value = $event),
                type: "text",
                class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).e("search-input")),
                placeholder: (0, import_vue380.unref)(presentText) ? "" : (0, import_vue380.unref)(inputPlaceholder),
                onInput: _cache[3] || (_cache[3] = (e) => handleInput(searchInputValue.value, e)),
                onClick: _cache[4] || (_cache[4] = (0, import_vue380.withModifiers)(($event) => togglePopperVisible(true), ["stop"])),
                onKeydown: (0, import_vue380.withKeys)(handleDelete, ["delete"]),
                onCompositionstart: handleComposition,
                onCompositionupdate: handleComposition,
                onCompositionend: handleComposition
              }, null, 42, _hoisted_216)), [
                [import_vue380.vModelText, searchInputValue.value]
              ]) : (0, import_vue380.createCommentVNode)("v-if", true)
            ], 2)) : (0, import_vue380.createCommentVNode)("v-if", true)
          ], 38)), [
            [(0, import_vue380.unref)(ClickOutside), () => togglePopperVisible(false), (0, import_vue380.unref)(cascaderPanelRef)]
          ])
        ]),
        content: (0, import_vue380.withCtx)(() => [
          (0, import_vue380.withDirectives)((0, import_vue380.createVNode)((0, import_vue380.unref)(_CascaderPanel), {
            ref_key: "panel",
            ref: panel,
            modelValue: (0, import_vue380.unref)(checkedValue),
            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => (0, import_vue380.isRef)(checkedValue) ? checkedValue.value = $event : null),
            options: _ctx.options,
            props: props.props,
            border: false,
            "render-label": _ctx.$slots.default,
            onExpandChange: handleExpandChange,
            onClose: _cache[9] || (_cache[9] = ($event) => _ctx.$nextTick(() => togglePopperVisible(false)))
          }, null, 8, ["modelValue", "options", "props", "render-label"]), [
            [import_vue380.vShow, !filtering.value]
          ]),
          _ctx.filterable ? (0, import_vue380.withDirectives)(((0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElScrollbar), {
            key: 0,
            ref_key: "suggestionPanel",
            ref: suggestionPanel,
            tag: "ul",
            class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).e("suggestion-panel")),
            "view-class": (0, import_vue380.unref)(nsCascader).e("suggestion-list"),
            onKeydown: handleSuggestionKeyDown
          }, {
            default: (0, import_vue380.withCtx)(() => [
              suggestions.value.length ? ((0, import_vue380.openBlock)(true), (0, import_vue380.createElementBlock)(import_vue380.Fragment, { key: 0 }, (0, import_vue380.renderList)(suggestions.value, (item) => {
                return (0, import_vue380.openBlock)(), (0, import_vue380.createElementBlock)("li", {
                  key: item.uid,
                  class: (0, import_vue380.normalizeClass)([
                    (0, import_vue380.unref)(nsCascader).e("suggestion-item"),
                    (0, import_vue380.unref)(nsCascader).is("checked", item.checked)
                  ]),
                  tabindex: -1,
                  onClick: ($event) => handleSuggestionClick(item)
                }, [
                  (0, import_vue380.createElementVNode)("span", null, (0, import_vue380.toDisplayString)(item.text), 1),
                  item.checked ? ((0, import_vue380.openBlock)(), (0, import_vue380.createBlock)((0, import_vue380.unref)(ElIcon), { key: 0 }, {
                    default: (0, import_vue380.withCtx)(() => [
                      (0, import_vue380.createVNode)((0, import_vue380.unref)(check_default))
                    ]),
                    _: 1
                  })) : (0, import_vue380.createCommentVNode)("v-if", true)
                ], 10, _hoisted_34);
              }), 128)) : (0, import_vue380.renderSlot)(_ctx.$slots, "empty", { key: 1 }, () => [
                (0, import_vue380.createElementVNode)("li", {
                  class: (0, import_vue380.normalizeClass)((0, import_vue380.unref)(nsCascader).e("empty-text"))
                }, (0, import_vue380.toDisplayString)((0, import_vue380.unref)(t)("el.cascader.noMatch")), 3)
              ])
            ]),
            _: 3
          }, 8, ["class", "view-class"])), [
            [import_vue380.vShow, filtering.value]
          ]) : (0, import_vue380.createCommentVNode)("v-if", true)
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "transition"]);
    };
  }
});
var Cascader = /* @__PURE__ */ _export_sfc(_sfc_main43, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/cascader/index.mjs
Cascader.install = (app) => {
  app.component(Cascader.name, Cascader);
};
var _Cascader = Cascader;
var ElCascader = _Cascader;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/check-tag/src/check-tag2.mjs
var import_vue381 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/check-tag/src/check-tag.mjs
var checkTagProps = buildProps({
  checked: {
    type: Boolean,
    default: false
  }
});
var checkTagEmits = {
  "update:checked": (value) => isBoolean(value),
  [CHANGE_EVENT]: (value) => isBoolean(value)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/check-tag/src/check-tag2.mjs
var __default__35 = (0, import_vue381.defineComponent)({
  name: "ElCheckTag"
});
var _sfc_main44 = /* @__PURE__ */ (0, import_vue381.defineComponent)({
  ...__default__35,
  props: checkTagProps,
  emits: checkTagEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("check-tag");
    const handleChange = () => {
      const checked = !props.checked;
      emit(CHANGE_EVENT, checked);
      emit("update:checked", checked);
    };
    return (_ctx, _cache) => {
      return (0, import_vue381.openBlock)(), (0, import_vue381.createElementBlock)("span", {
        class: (0, import_vue381.normalizeClass)([(0, import_vue381.unref)(ns2).b(), (0, import_vue381.unref)(ns2).is("checked", _ctx.checked)]),
        onClick: handleChange
      }, [
        (0, import_vue381.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var CheckTag = /* @__PURE__ */ _export_sfc(_sfc_main44, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/check-tag/index.mjs
var ElCheckTag = withInstall(CheckTag);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/col/src/col2.mjs
var import_vue382 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/col/src/col.mjs
var colProps = buildProps({
  tag: {
    type: String,
    default: "div"
  },
  span: {
    type: Number,
    default: 24
  },
  offset: {
    type: Number,
    default: 0
  },
  pull: {
    type: Number,
    default: 0
  },
  push: {
    type: Number,
    default: 0
  },
  xs: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  sm: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  md: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  lg: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  xl: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/col/src/col2.mjs
var import_shared45 = require("@vue/shared");
var __default__36 = (0, import_vue382.defineComponent)({
  name: "ElCol"
});
var _sfc_main45 = /* @__PURE__ */ (0, import_vue382.defineComponent)({
  ...__default__36,
  props: colProps,
  setup(__props) {
    const props = __props;
    const { gutter } = (0, import_vue382.inject)(rowContextKey, { gutter: (0, import_vue382.computed)(() => 0) });
    const ns2 = useNamespace("col");
    const style = (0, import_vue382.computed)(() => {
      const styles = {};
      if (gutter.value) {
        styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
      }
      return styles;
    });
    const colKls = (0, import_vue382.computed)(() => {
      const classes = [];
      const pos = ["span", "offset", "pull", "push"];
      pos.forEach((prop) => {
        const size2 = props[prop];
        if (isNumber(size2)) {
          if (prop === "span")
            classes.push(ns2.b(`${props[prop]}`));
          else if (size2 > 0)
            classes.push(ns2.b(`${prop}-${props[prop]}`));
        }
      });
      const sizes = ["xs", "sm", "md", "lg", "xl"];
      sizes.forEach((size2) => {
        if (isNumber(props[size2])) {
          classes.push(ns2.b(`${size2}-${props[size2]}`));
        } else if ((0, import_shared45.isObject)(props[size2])) {
          Object.entries(props[size2]).forEach(([prop, sizeProp]) => {
            classes.push(prop !== "span" ? ns2.b(`${size2}-${prop}-${sizeProp}`) : ns2.b(`${size2}-${sizeProp}`));
          });
        }
      });
      if (gutter.value) {
        classes.push(ns2.is("guttered"));
      }
      return [ns2.b(), classes];
    });
    return (_ctx, _cache) => {
      return (0, import_vue382.openBlock)(), (0, import_vue382.createBlock)((0, import_vue382.resolveDynamicComponent)(_ctx.tag), {
        class: (0, import_vue382.normalizeClass)((0, import_vue382.unref)(colKls)),
        style: (0, import_vue382.normalizeStyle)((0, import_vue382.unref)(style))
      }, {
        default: (0, import_vue382.withCtx)(() => [
          (0, import_vue382.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]);
    };
  }
});
var Col = /* @__PURE__ */ _export_sfc(_sfc_main45, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/col/index.mjs
var ElCol = withInstall(Col);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/collapse2.mjs
var import_vue384 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/collapse.mjs
var emitChangeFn = (value) => typeof isNumber(value);
var collapseProps = buildProps({
  accordion: Boolean,
  modelValue: {
    type: definePropType([Array, String, Number]),
    default: () => mutable([])
  }
});
var collapseEmits = {
  [UPDATE_MODEL_EVENT]: emitChangeFn,
  [CHANGE_EVENT]: emitChangeFn
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/use-collapse.mjs
var import_vue383 = require("vue");
var useCollapse = (props, emit) => {
  const activeNames = (0, import_vue383.ref)(castArray_default(props.modelValue));
  const setActiveNames = (_activeNames) => {
    activeNames.value = _activeNames;
    const value = props.accordion ? activeNames.value[0] : activeNames.value;
    emit(UPDATE_MODEL_EVENT, value);
    emit(CHANGE_EVENT, value);
  };
  const handleItemClick = (name) => {
    if (props.accordion) {
      setActiveNames([activeNames.value[0] === name ? "" : name]);
    } else {
      const _activeNames = [...activeNames.value];
      const index2 = _activeNames.indexOf(name);
      if (index2 > -1) {
        _activeNames.splice(index2, 1);
      } else {
        _activeNames.push(name);
      }
      setActiveNames(_activeNames);
    }
  };
  (0, import_vue383.watch)(() => props.modelValue, () => activeNames.value = castArray_default(props.modelValue), { deep: true });
  (0, import_vue383.provide)(collapseContextKey, {
    activeNames,
    handleItemClick
  });
  return {
    activeNames,
    setActiveNames
  };
};
var useCollapseDOM = () => {
  const ns2 = useNamespace("collapse");
  const rootKls = (0, import_vue383.computed)(() => ns2.b());
  return {
    rootKls
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/collapse2.mjs
var __default__37 = (0, import_vue384.defineComponent)({
  name: "ElCollapse"
});
var _sfc_main46 = /* @__PURE__ */ (0, import_vue384.defineComponent)({
  ...__default__37,
  props: collapseProps,
  emits: collapseEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { activeNames, setActiveNames } = useCollapse(props, emit);
    const { rootKls } = useCollapseDOM();
    expose({
      activeNames,
      setActiveNames
    });
    return (_ctx, _cache) => {
      return (0, import_vue384.openBlock)(), (0, import_vue384.createElementBlock)("div", {
        class: (0, import_vue384.normalizeClass)((0, import_vue384.unref)(rootKls)),
        role: "tablist",
        "aria-multiselectable": "true"
      }, [
        (0, import_vue384.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main46, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/collapse-item2.mjs
var import_vue387 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse-transition/src/collapse-transition.mjs
var import_vue385 = require("vue");
var __default__38 = (0, import_vue385.defineComponent)({
  name: "ElCollapseTransition"
});
var _sfc_main47 = /* @__PURE__ */ (0, import_vue385.defineComponent)({
  ...__default__38,
  setup(__props) {
    const ns2 = useNamespace("collapse-transition");
    const on3 = {
      beforeEnter(el) {
        if (!el.dataset)
          el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.style.maxHeight = 0;
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
      },
      enter(el) {
        el.dataset.oldOverflow = el.style.overflow;
        if (el.scrollHeight !== 0) {
          el.style.maxHeight = `${el.scrollHeight}px`;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        } else {
          el.style.maxHeight = 0;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
        el.style.overflow = "hidden";
      },
      afterEnter(el) {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
      },
      beforeLeave(el) {
        if (!el.dataset)
          el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.dataset.oldOverflow = el.style.overflow;
        el.style.maxHeight = `${el.scrollHeight}px`;
        el.style.overflow = "hidden";
      },
      leave(el) {
        if (el.scrollHeight !== 0) {
          el.style.maxHeight = 0;
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        }
      },
      afterLeave(el) {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      }
    };
    return (_ctx, _cache) => {
      return (0, import_vue385.openBlock)(), (0, import_vue385.createBlock)(import_vue385.Transition, (0, import_vue385.mergeProps)({
        name: (0, import_vue385.unref)(ns2).b()
      }, (0, import_vue385.toHandlers)(on3)), {
        default: (0, import_vue385.withCtx)(() => [
          (0, import_vue385.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["name"]);
    };
  }
});
var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main47, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse-transition/index.mjs
CollapseTransition.install = (app) => {
  app.component(CollapseTransition.name, CollapseTransition);
};
var _CollapseTransition = CollapseTransition;
var ElCollapseTransition = _CollapseTransition;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/collapse-item.mjs
var collapseItemProps = buildProps({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: definePropType([String, Number]),
    default: () => generateId()
  },
  disabled: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/use-collapse-item.mjs
var import_vue386 = require("vue");
var useCollapseItem = (props) => {
  const collapse = (0, import_vue386.inject)(collapseContextKey);
  const focusing = (0, import_vue386.ref)(false);
  const isClick = (0, import_vue386.ref)(false);
  const id2 = (0, import_vue386.ref)(generateId());
  const isActive = (0, import_vue386.computed)(() => collapse == null ? void 0 : collapse.activeNames.value.includes(props.name));
  const handleFocus = () => {
    setTimeout(() => {
      if (!isClick.value) {
        focusing.value = true;
      } else {
        isClick.value = false;
      }
    }, 50);
  };
  const handleHeaderClick = () => {
    if (props.disabled)
      return;
    collapse == null ? void 0 : collapse.handleItemClick(props.name);
    focusing.value = false;
    isClick.value = true;
  };
  const handleEnterClick = () => {
    collapse == null ? void 0 : collapse.handleItemClick(props.name);
  };
  return {
    focusing,
    id: id2,
    isActive,
    handleFocus,
    handleHeaderClick,
    handleEnterClick
  };
};
var useCollapseItemDOM = (props, { focusing, isActive, id: id2 }) => {
  const ns2 = useNamespace("collapse");
  const rootKls = (0, import_vue386.computed)(() => [
    ns2.b("item"),
    ns2.is("active", (0, import_vue386.unref)(isActive)),
    ns2.is("disabled", props.disabled)
  ]);
  const headKls = (0, import_vue386.computed)(() => [
    ns2.be("item", "header"),
    ns2.is("active", (0, import_vue386.unref)(isActive)),
    { focusing: (0, import_vue386.unref)(focusing) && !props.disabled }
  ]);
  const arrowKls = (0, import_vue386.computed)(() => [
    ns2.be("item", "arrow"),
    ns2.is("active", (0, import_vue386.unref)(isActive))
  ]);
  const itemWrapperKls = (0, import_vue386.computed)(() => ns2.be("item", "wrap"));
  const itemContentKls = (0, import_vue386.computed)(() => ns2.be("item", "content"));
  const scopedContentId = (0, import_vue386.computed)(() => ns2.b(`content-${(0, import_vue386.unref)(id2)}`));
  const scopedHeadId = (0, import_vue386.computed)(() => ns2.b(`head-${(0, import_vue386.unref)(id2)}`));
  return {
    arrowKls,
    headKls,
    rootKls,
    itemWrapperKls,
    itemContentKls,
    scopedContentId,
    scopedHeadId
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/src/collapse-item2.mjs
var _hoisted_124 = ["aria-expanded", "aria-controls", "aria-describedby"];
var _hoisted_217 = ["id", "tabindex"];
var _hoisted_35 = ["id", "aria-hidden", "aria-labelledby"];
var __default__39 = (0, import_vue387.defineComponent)({
  name: "ElCollapseItem"
});
var _sfc_main48 = /* @__PURE__ */ (0, import_vue387.defineComponent)({
  ...__default__39,
  props: collapseItemProps,
  setup(__props, { expose }) {
    const props = __props;
    const {
      focusing,
      id: id2,
      isActive,
      handleFocus,
      handleHeaderClick,
      handleEnterClick
    } = useCollapseItem(props);
    const {
      arrowKls,
      headKls,
      rootKls,
      itemWrapperKls,
      itemContentKls,
      scopedContentId,
      scopedHeadId
    } = useCollapseItemDOM(props, { focusing, isActive, id: id2 });
    expose({
      isActive
    });
    return (_ctx, _cache) => {
      return (0, import_vue387.openBlock)(), (0, import_vue387.createElementBlock)("div", {
        class: (0, import_vue387.normalizeClass)((0, import_vue387.unref)(rootKls))
      }, [
        (0, import_vue387.createElementVNode)("div", {
          role: "tab",
          "aria-expanded": (0, import_vue387.unref)(isActive),
          "aria-controls": (0, import_vue387.unref)(scopedContentId),
          "aria-describedby": (0, import_vue387.unref)(scopedContentId)
        }, [
          (0, import_vue387.createElementVNode)("div", {
            id: (0, import_vue387.unref)(scopedHeadId),
            class: (0, import_vue387.normalizeClass)((0, import_vue387.unref)(headKls)),
            role: "button",
            tabindex: _ctx.disabled ? -1 : 0,
            onClick: _cache[0] || (_cache[0] = (...args) => (0, import_vue387.unref)(handleHeaderClick) && (0, import_vue387.unref)(handleHeaderClick)(...args)),
            onKeypress: _cache[1] || (_cache[1] = (0, import_vue387.withKeys)((0, import_vue387.withModifiers)((...args) => (0, import_vue387.unref)(handleEnterClick) && (0, import_vue387.unref)(handleEnterClick)(...args), ["stop", "prevent"]), ["space", "enter"])),
            onFocus: _cache[2] || (_cache[2] = (...args) => (0, import_vue387.unref)(handleFocus) && (0, import_vue387.unref)(handleFocus)(...args)),
            onBlur: _cache[3] || (_cache[3] = ($event) => focusing.value = false)
          }, [
            (0, import_vue387.renderSlot)(_ctx.$slots, "title", {}, () => [
              (0, import_vue387.createTextVNode)((0, import_vue387.toDisplayString)(_ctx.title), 1)
            ]),
            (0, import_vue387.createVNode)((0, import_vue387.unref)(ElIcon), {
              class: (0, import_vue387.normalizeClass)((0, import_vue387.unref)(arrowKls))
            }, {
              default: (0, import_vue387.withCtx)(() => [
                (0, import_vue387.createVNode)((0, import_vue387.unref)(arrow_right_default))
              ]),
              _: 1
            }, 8, ["class"])
          ], 42, _hoisted_217)
        ], 8, _hoisted_124),
        (0, import_vue387.createVNode)((0, import_vue387.unref)(_CollapseTransition), null, {
          default: (0, import_vue387.withCtx)(() => [
            (0, import_vue387.withDirectives)((0, import_vue387.createElementVNode)("div", {
              id: (0, import_vue387.unref)(scopedContentId),
              class: (0, import_vue387.normalizeClass)((0, import_vue387.unref)(itemWrapperKls)),
              role: "tabpanel",
              "aria-hidden": !(0, import_vue387.unref)(isActive),
              "aria-labelledby": (0, import_vue387.unref)(scopedHeadId)
            }, [
              (0, import_vue387.createElementVNode)("div", {
                class: (0, import_vue387.normalizeClass)((0, import_vue387.unref)(itemContentKls))
              }, [
                (0, import_vue387.renderSlot)(_ctx.$slots, "default")
              ], 2)
            ], 10, _hoisted_35), [
              [import_vue387.vShow, (0, import_vue387.unref)(isActive)]
            ])
          ]),
          _: 3
        })
      ], 2);
    };
  }
});
var CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main48, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collapse/index.mjs
var ElCollapse = withInstall(Collapse, {
  CollapseItem
});
var ElCollapseItem = withNoopInstall(CollapseItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/color-picker2.mjs
var import_vue392 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/components/alpha-slider.mjs
var import_vue388 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/utils/draggable.mjs
var isDragging = false;
function draggable(element, options) {
  if (!isClient)
    return;
  const moveFn = function(event) {
    var _a2;
    (_a2 = options.drag) == null ? void 0 : _a2.call(options, event);
  };
  const upFn = function(event) {
    var _a2;
    document.removeEventListener("mousemove", moveFn);
    document.removeEventListener("mouseup", upFn);
    document.removeEventListener("touchmove", moveFn);
    document.removeEventListener("touchend", upFn);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    (_a2 = options.end) == null ? void 0 : _a2.call(options, event);
  };
  const downFn = function(event) {
    var _a2;
    if (isDragging)
      return;
    event.preventDefault();
    document.onselectstart = () => false;
    document.ondragstart = () => false;
    document.addEventListener("mousemove", moveFn);
    document.addEventListener("mouseup", upFn);
    document.addEventListener("touchmove", moveFn);
    document.addEventListener("touchend", upFn);
    isDragging = true;
    (_a2 = options.start) == null ? void 0 : _a2.call(options, event);
  };
  element.addEventListener("mousedown", downFn);
  element.addEventListener("touchstart", downFn);
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/components/alpha-slider.mjs
var _sfc_main49 = (0, import_vue388.defineComponent)({
  name: "ElColorAlphaSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const ns2 = useNamespace("color-alpha-slider");
    const instance = (0, import_vue388.getCurrentInstance)();
    const thumb = (0, import_vue388.shallowRef)();
    const bar = (0, import_vue388.shallowRef)();
    const thumbLeft = (0, import_vue388.ref)(0);
    const thumbTop = (0, import_vue388.ref)(0);
    const background = (0, import_vue388.ref)();
    (0, import_vue388.watch)(() => props.color.get("alpha"), () => {
      update();
    });
    (0, import_vue388.watch)(() => props.color.value, () => {
      update();
    });
    function getThumbLeft() {
      if (!thumb.value)
        return 0;
      if (props.vertical)
        return 0;
      const el = instance.vnode.el;
      const alpha = props.color.get("alpha");
      if (!el)
        return 0;
      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
    }
    function getThumbTop() {
      if (!thumb.value)
        return 0;
      const el = instance.vnode.el;
      if (!props.vertical)
        return 0;
      const alpha = props.color.get("alpha");
      if (!el)
        return 0;
      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
    }
    function getBackground() {
      if (props.color && props.color.value) {
        const { r, g, b: b3 } = props.color.toRgb();
        return `linear-gradient(to right, rgba(${r}, ${g}, ${b3}, 0) 0%, rgba(${r}, ${g}, ${b3}, 1) 100%)`;
      }
      return "";
    }
    function handleClick(event) {
      const target = event.target;
      if (target !== thumb.value) {
        handleDrag(event);
      }
    }
    function handleDrag(event) {
      if (!bar.value || !thumb.value)
        return;
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      const { clientX, clientY } = getClientXY(event);
      if (!props.vertical) {
        let left2 = clientX - rect.left;
        left2 = Math.max(thumb.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
        props.color.set("alpha", Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
      } else {
        let top = clientY - rect.top;
        top = Math.max(thumb.value.offsetHeight / 2, top);
        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
        props.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
      }
    }
    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
      background.value = getBackground();
    }
    (0, import_vue388.onMounted)(() => {
      if (!bar.value || !thumb.value)
        return;
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      thumb,
      bar,
      thumbLeft,
      thumbTop,
      background,
      handleClick,
      update,
      ns: ns2
    };
  }
});
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue388.openBlock)(), (0, import_vue388.createElementBlock)("div", {
    class: (0, import_vue388.normalizeClass)([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
  }, [
    (0, import_vue388.createElementVNode)("div", {
      ref: "bar",
      class: (0, import_vue388.normalizeClass)(_ctx.ns.e("bar")),
      style: (0, import_vue388.normalizeStyle)({
        background: _ctx.background
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 6),
    (0, import_vue388.createElementVNode)("div", {
      ref: "thumb",
      class: (0, import_vue388.normalizeClass)(_ctx.ns.e("thumb")),
      style: (0, import_vue388.normalizeStyle)({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var AlphaSlider = /* @__PURE__ */ _export_sfc(_sfc_main49, [["render", _sfc_render5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/components/hue-slider.mjs
var import_vue389 = require("vue");
var _sfc_main50 = (0, import_vue389.defineComponent)({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: Boolean
  },
  setup(props) {
    const ns2 = useNamespace("color-hue-slider");
    const instance = (0, import_vue389.getCurrentInstance)();
    const thumb = (0, import_vue389.ref)();
    const bar = (0, import_vue389.ref)();
    const thumbLeft = (0, import_vue389.ref)(0);
    const thumbTop = (0, import_vue389.ref)(0);
    const hueValue = (0, import_vue389.computed)(() => {
      return props.color.get("hue");
    });
    (0, import_vue389.watch)(() => hueValue.value, () => {
      update();
    });
    function handleClick(event) {
      const target = event.target;
      if (target !== thumb.value) {
        handleDrag(event);
      }
    }
    function handleDrag(event) {
      if (!bar.value || !thumb.value)
        return;
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      const { clientX, clientY } = getClientXY(event);
      let hue;
      if (!props.vertical) {
        let left2 = clientX - rect.left;
        left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
        left2 = Math.max(thumb.value.offsetWidth / 2, left2);
        hue = Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
      } else {
        let top = clientY - rect.top;
        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
        top = Math.max(thumb.value.offsetHeight / 2, top);
        hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
      }
      props.color.set("hue", hue);
    }
    function getThumbLeft() {
      if (!thumb.value)
        return 0;
      const el = instance.vnode.el;
      if (props.vertical)
        return 0;
      const hue = props.color.get("hue");
      if (!el)
        return 0;
      return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
    }
    function getThumbTop() {
      if (!thumb.value)
        return 0;
      const el = instance.vnode.el;
      if (!props.vertical)
        return 0;
      const hue = props.color.get("hue");
      if (!el)
        return 0;
      return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
    }
    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
    }
    (0, import_vue389.onMounted)(() => {
      if (!bar.value || !thumb.value)
        return;
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      bar,
      thumb,
      thumbLeft,
      thumbTop,
      hueValue,
      handleClick,
      update,
      ns: ns2
    };
  }
});
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue389.openBlock)(), (0, import_vue389.createElementBlock)("div", {
    class: (0, import_vue389.normalizeClass)([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
  }, [
    (0, import_vue389.createElementVNode)("div", {
      ref: "bar",
      class: (0, import_vue389.normalizeClass)(_ctx.ns.e("bar")),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 2),
    (0, import_vue389.createElementVNode)("div", {
      ref: "thumb",
      class: (0, import_vue389.normalizeClass)(_ctx.ns.e("thumb")),
      style: (0, import_vue389.normalizeStyle)({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main50, [["render", _sfc_render7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/components/predefine.mjs
var import_vue390 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/color-picker.mjs
var import_shared46 = require("@vue/shared");
var colorPickerProps = buildProps({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: useSizeProp,
  popperClass: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  predefine: {
    type: definePropType(Array)
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var colorPickerEmits = {
  [UPDATE_MODEL_EVENT]: (val) => (0, import_shared46.isString)(val) || isNil_default(val),
  [CHANGE_EVENT]: (val) => (0, import_shared46.isString)(val) || isNil_default(val),
  activeChange: (val) => (0, import_shared46.isString)(val) || isNil_default(val)
};
var colorPickerContextKey = Symbol("colorPickerContextKey");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/utils/color.mjs
var import_shared47 = require("@vue/shared");
var hsv2hsl = function(hue, sat, val) {
  return [
    hue,
    sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
    hue / 2
  ];
};
var isOnePointZero2 = function(n) {
  return typeof n === "string" && n.includes(".") && Number.parseFloat(n) === 1;
};
var isPercentage2 = function(n) {
  return typeof n === "string" && n.includes("%");
};
var bound012 = function(value, max4) {
  if (isOnePointZero2(value))
    value = "100%";
  const processPercent = isPercentage2(value);
  value = Math.min(max4, Math.max(0, Number.parseFloat(`${value}`)));
  if (processPercent) {
    value = Number.parseInt(`${value * max4}`, 10) / 100;
  }
  if (Math.abs(value - max4) < 1e-6) {
    return 1;
  }
  return value % max4 / Number.parseFloat(max4);
};
var INT_HEX_MAP = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F"
};
var hexOne = (value) => {
  value = Math.min(Math.round(value), 255);
  const high = Math.floor(value / 16);
  const low = value % 16;
  return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
};
var toHex = function({ r, g, b: b3 }) {
  if (Number.isNaN(+r) || Number.isNaN(+g) || Number.isNaN(+b3))
    return "";
  return `#${hexOne(r)}${hexOne(g)}${hexOne(b3)}`;
};
var HEX_INT_MAP = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
var parseHexChannel = function(hex2) {
  if (hex2.length === 2) {
    return (HEX_INT_MAP[hex2[0].toUpperCase()] || +hex2[0]) * 16 + (HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1]);
  }
  return HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1];
};
var hsl2hsv = function(hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  let smin = sat;
  const lmin = Math.max(light, 0.01);
  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v3 = (light + sat) / 2;
  const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
  return {
    h: hue,
    s: sv * 100,
    v: v3 * 100
  };
};
var rgb2hsv = (r, g, b3) => {
  r = bound012(r, 255);
  g = bound012(g, 255);
  b3 = bound012(b3, 255);
  const max4 = Math.max(r, g, b3);
  const min4 = Math.min(r, g, b3);
  let h29;
  const v3 = max4;
  const d2 = max4 - min4;
  const s2 = max4 === 0 ? 0 : d2 / max4;
  if (max4 === min4) {
    h29 = 0;
  } else {
    switch (max4) {
      case r: {
        h29 = (g - b3) / d2 + (g < b3 ? 6 : 0);
        break;
      }
      case g: {
        h29 = (b3 - r) / d2 + 2;
        break;
      }
      case b3: {
        h29 = (r - g) / d2 + 4;
        break;
      }
    }
    h29 /= 6;
  }
  return { h: h29 * 360, s: s2 * 100, v: v3 * 100 };
};
var hsv2rgb = function(h29, s2, v3) {
  h29 = bound012(h29, 360) * 6;
  s2 = bound012(s2, 100);
  v3 = bound012(v3, 100);
  const i = Math.floor(h29);
  const f2 = h29 - i;
  const p2 = v3 * (1 - s2);
  const q2 = v3 * (1 - f2 * s2);
  const t = v3 * (1 - (1 - f2) * s2);
  const mod = i % 6;
  const r = [v3, q2, p2, p2, t, v3][mod];
  const g = [t, v3, v3, q2, p2, p2][mod];
  const b3 = [p2, p2, t, v3, v3, q2][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b3 * 255)
  };
};
var Color = class {
  constructor(options = {}) {
    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;
    this.enableAlpha = false;
    this.format = "hex";
    this.value = "";
    for (const option2 in options) {
      if ((0, import_shared47.hasOwn)(options, option2)) {
        this[option2] = options[option2];
      }
    }
    if (options.value) {
      this.fromString(options.value);
    } else {
      this.doOnChange();
    }
  }
  set(prop, value) {
    if (arguments.length === 1 && typeof prop === "object") {
      for (const p2 in prop) {
        if ((0, import_shared47.hasOwn)(prop, p2)) {
          this.set(p2, prop[p2]);
        }
      }
      return;
    }
    ;
    this[`_${prop}`] = value;
    this.doOnChange();
  }
  get(prop) {
    if (prop === "alpha") {
      return Math.floor(this[`_${prop}`]);
    }
    return this[`_${prop}`];
  }
  toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  }
  fromString(value) {
    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }
    const fromHSV = (h29, s2, v3) => {
      this._hue = Math.max(0, Math.min(360, h29));
      this._saturation = Math.max(0, Math.min(100, s2));
      this._value = Math.max(0, Math.min(100, v3));
      this.doOnChange();
    };
    if (value.includes("hsl")) {
      const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Number.parseFloat(parts[3]) * 100;
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        const { h: h29, s: s2, v: v3 } = hsl2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h29, s2, v3);
      }
    } else if (value.includes("hsv")) {
      const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Number.parseFloat(parts[3]) * 100;
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value.includes("rgb")) {
      const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Number.parseFloat(parts[3]) * 100;
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        const { h: h29, s: s2, v: v3 } = rgb2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h29, s2, v3);
      }
    } else if (value.includes("#")) {
      const hex2 = value.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex2))
        return;
      let r, g, b3;
      if (hex2.length === 3) {
        r = parseHexChannel(hex2[0] + hex2[0]);
        g = parseHexChannel(hex2[1] + hex2[1]);
        b3 = parseHexChannel(hex2[2] + hex2[2]);
      } else if (hex2.length === 6 || hex2.length === 8) {
        r = parseHexChannel(hex2.slice(0, 2));
        g = parseHexChannel(hex2.slice(2, 4));
        b3 = parseHexChannel(hex2.slice(4, 6));
      }
      if (hex2.length === 8) {
        this._alpha = parseHexChannel(hex2.slice(6)) / 255 * 100;
      } else if (hex2.length === 3 || hex2.length === 6) {
        this._alpha = 100;
      }
      const { h: h29, s: s2, v: v3 } = rgb2hsv(r, g, b3);
      fromHSV(h29, s2, v3);
    }
  }
  compare(color) {
    return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue, _saturation, _value, _alpha, format: format2 } = this;
    if (this.enableAlpha) {
      switch (format2) {
        case "hsl": {
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hex": {
          this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
          break;
        }
        default: {
          const { r, g, b: b3 } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgba(${r}, ${g}, ${b3}, ${this.get("alpha") / 100})`;
        }
      }
    } else {
      switch (format2) {
        case "hsl": {
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
          break;
        }
        case "rgb": {
          const { r, g, b: b3 } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgb(${r}, ${g}, ${b3})`;
          break;
        }
        default: {
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
        }
      }
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/components/predefine.mjs
var _sfc_main51 = (0, import_vue390.defineComponent)({
  props: {
    colors: {
      type: Array,
      required: true
    },
    color: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const ns2 = useNamespace("color-predefine");
    const { currentColor } = (0, import_vue390.inject)(colorPickerContextKey);
    const rgbaColors = (0, import_vue390.ref)(parseColors(props.colors, props.color));
    (0, import_vue390.watch)(() => currentColor.value, (val) => {
      const color = new Color();
      color.fromString(val);
      rgbaColors.value.forEach((item) => {
        item.selected = color.compare(item);
      });
    });
    (0, import_vue390.watchEffect)(() => {
      rgbaColors.value = parseColors(props.colors, props.color);
    });
    function handleSelect(index2) {
      props.color.fromString(props.colors[index2]);
    }
    function parseColors(colors, color) {
      return colors.map((value) => {
        const c2 = new Color();
        c2.enableAlpha = true;
        c2.format = "rgba";
        c2.fromString(value);
        c2.selected = c2.value === color.value;
        return c2;
      });
    }
    return {
      rgbaColors,
      handleSelect,
      ns: ns2
    };
  }
});
var _hoisted_125 = ["onClick"];
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue390.openBlock)(), (0, import_vue390.createElementBlock)("div", {
    class: (0, import_vue390.normalizeClass)(_ctx.ns.b())
  }, [
    (0, import_vue390.createElementVNode)("div", {
      class: (0, import_vue390.normalizeClass)(_ctx.ns.e("colors"))
    }, [
      ((0, import_vue390.openBlock)(true), (0, import_vue390.createElementBlock)(import_vue390.Fragment, null, (0, import_vue390.renderList)(_ctx.rgbaColors, (item, index2) => {
        return (0, import_vue390.openBlock)(), (0, import_vue390.createElementBlock)("div", {
          key: _ctx.colors[index2],
          class: (0, import_vue390.normalizeClass)([
            _ctx.ns.e("color-selector"),
            _ctx.ns.is("alpha", item._alpha < 100),
            { selected: item.selected }
          ]),
          onClick: ($event) => _ctx.handleSelect(index2)
        }, [
          (0, import_vue390.createElementVNode)("div", {
            style: (0, import_vue390.normalizeStyle)({ backgroundColor: item.value })
          }, null, 4)
        ], 10, _hoisted_125);
      }), 128))
    ], 2)
  ], 2);
}
var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main51, [["render", _sfc_render9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/components/sv-panel.mjs
var import_vue391 = require("vue");
var _sfc_main52 = (0, import_vue391.defineComponent)({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const ns2 = useNamespace("color-svpanel");
    const instance = (0, import_vue391.getCurrentInstance)();
    const cursorTop = (0, import_vue391.ref)(0);
    const cursorLeft = (0, import_vue391.ref)(0);
    const background = (0, import_vue391.ref)("hsl(0, 100%, 50%)");
    const colorValue = (0, import_vue391.computed)(() => {
      const hue = props.color.get("hue");
      const value = props.color.get("value");
      return { hue, value };
    });
    function update() {
      const saturation = props.color.get("saturation");
      const value = props.color.get("value");
      const el = instance.vnode.el;
      const { clientWidth: width, clientHeight: height } = el;
      cursorLeft.value = saturation * width / 100;
      cursorTop.value = (100 - value) * height / 100;
      background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
    }
    function handleDrag(event) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      const { clientX, clientY } = getClientXY(event);
      let left2 = clientX - rect.left;
      let top = clientY - rect.top;
      left2 = Math.max(0, left2);
      left2 = Math.min(left2, rect.width);
      top = Math.max(0, top);
      top = Math.min(top, rect.height);
      cursorLeft.value = left2;
      cursorTop.value = top;
      props.color.set({
        saturation: left2 / rect.width * 100,
        value: 100 - top / rect.height * 100
      });
    }
    (0, import_vue391.watch)(() => colorValue.value, () => {
      update();
    });
    (0, import_vue391.onMounted)(() => {
      draggable(instance.vnode.el, {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      });
      update();
    });
    return {
      cursorTop,
      cursorLeft,
      background,
      colorValue,
      handleDrag,
      update,
      ns: ns2
    };
  }
});
var _hoisted_126 = /* @__PURE__ */ (0, import_vue391.createElementVNode)("div", null, null, -1);
var _hoisted_218 = [
  _hoisted_126
];
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue391.openBlock)(), (0, import_vue391.createElementBlock)("div", {
    class: (0, import_vue391.normalizeClass)(_ctx.ns.b()),
    style: (0, import_vue391.normalizeStyle)({
      backgroundColor: _ctx.background
    })
  }, [
    (0, import_vue391.createElementVNode)("div", {
      class: (0, import_vue391.normalizeClass)(_ctx.ns.e("white"))
    }, null, 2),
    (0, import_vue391.createElementVNode)("div", {
      class: (0, import_vue391.normalizeClass)(_ctx.ns.e("black"))
    }, null, 2),
    (0, import_vue391.createElementVNode)("div", {
      class: (0, import_vue391.normalizeClass)(_ctx.ns.e("cursor")),
      style: (0, import_vue391.normalizeStyle)({
        top: _ctx.cursorTop + "px",
        left: _ctx.cursorLeft + "px"
      })
    }, _hoisted_218, 6)
  ], 6);
}
var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main52, [["render", _sfc_render11], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/src/color-picker2.mjs
var _hoisted_127 = ["id", "aria-label", "aria-labelledby", "aria-description", "tabindex", "onKeydown"];
var __default__40 = (0, import_vue392.defineComponent)({
  name: "ElColorPicker"
});
var _sfc_main53 = /* @__PURE__ */ (0, import_vue392.defineComponent)({
  ...__default__40,
  props: colorPickerProps,
  emits: colorPickerEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { t } = useLocale();
    const ns2 = useNamespace("color");
    const { formItem } = useFormItem();
    const colorSize = useSize();
    const colorDisabled = useDisabled();
    const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const hue = (0, import_vue392.ref)();
    const sv = (0, import_vue392.ref)();
    const alpha = (0, import_vue392.ref)();
    const popper = (0, import_vue392.ref)();
    let shouldActiveChange = true;
    const color = (0, import_vue392.reactive)(new Color({
      enableAlpha: props.showAlpha,
      format: props.colorFormat || "",
      value: props.modelValue
    }));
    const showPicker = (0, import_vue392.ref)(false);
    const showPanelColor = (0, import_vue392.ref)(false);
    const customInput = (0, import_vue392.ref)("");
    const displayedColor = (0, import_vue392.computed)(() => {
      if (!props.modelValue && !showPanelColor.value) {
        return "transparent";
      }
      return displayedRgb(color, props.showAlpha);
    });
    const currentColor = (0, import_vue392.computed)(() => {
      return !props.modelValue && !showPanelColor.value ? "" : color.value;
    });
    const buttonAriaLabel = (0, import_vue392.computed)(() => {
      return !isLabeledByFormItem.value ? props.label || t("el.colorpicker.defaultLabel") : void 0;
    });
    const buttonAriaLabelledby = (0, import_vue392.computed)(() => {
      return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
    });
    const btnKls = (0, import_vue392.computed)(() => {
      return [
        ns2.b("picker"),
        ns2.is("disabled", colorDisabled.value),
        ns2.bm("picker", colorSize.value)
      ];
    });
    function displayedRgb(color2, showAlpha) {
      if (!(color2 instanceof Color)) {
        throw new TypeError("color should be instance of _color Class");
      }
      const { r, g, b: b3 } = color2.toRgb();
      return showAlpha ? `rgba(${r}, ${g}, ${b3}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b3})`;
    }
    function setShowPicker(value) {
      showPicker.value = value;
    }
    const debounceSetShowPicker = debounce_default(setShowPicker, 100);
    function hide2() {
      debounceSetShowPicker(false);
      resetColor();
    }
    function resetColor() {
      (0, import_vue392.nextTick)(() => {
        if (props.modelValue) {
          color.fromString(props.modelValue);
        } else {
          color.value = "";
          (0, import_vue392.nextTick)(() => {
            showPanelColor.value = false;
          });
        }
      });
    }
    function handleTrigger() {
      if (colorDisabled.value)
        return;
      debounceSetShowPicker(!showPicker.value);
    }
    function handleConfirm() {
      color.fromString(customInput.value);
    }
    function confirmValue() {
      const value = color.value;
      emit(UPDATE_MODEL_EVENT, value);
      emit("change", value);
      if (props.validateEvent) {
        formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
      }
      debounceSetShowPicker(false);
      (0, import_vue392.nextTick)(() => {
        const newColor = new Color({
          enableAlpha: props.showAlpha,
          format: props.colorFormat || "",
          value: props.modelValue
        });
        if (!color.compare(newColor)) {
          resetColor();
        }
      });
    }
    function clear() {
      debounceSetShowPicker(false);
      emit(UPDATE_MODEL_EVENT, null);
      emit("change", null);
      if (props.modelValue !== null && props.validateEvent) {
        formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
      }
      resetColor();
    }
    (0, import_vue392.onMounted)(() => {
      if (props.modelValue) {
        customInput.value = currentColor.value;
      }
    });
    (0, import_vue392.watch)(() => props.modelValue, (newVal) => {
      if (!newVal) {
        showPanelColor.value = false;
      } else if (newVal && newVal !== color.value) {
        shouldActiveChange = false;
        color.fromString(newVal);
      }
    });
    (0, import_vue392.watch)(() => currentColor.value, (val) => {
      customInput.value = val;
      shouldActiveChange && emit("activeChange", val);
      shouldActiveChange = true;
    });
    (0, import_vue392.watch)(() => color.value, () => {
      if (!props.modelValue && !showPanelColor.value) {
        showPanelColor.value = true;
      }
    });
    (0, import_vue392.watch)(() => showPicker.value, () => {
      (0, import_vue392.nextTick)(() => {
        var _a2, _b, _c;
        (_a2 = hue.value) == null ? void 0 : _a2.update();
        (_b = sv.value) == null ? void 0 : _b.update();
        (_c = alpha.value) == null ? void 0 : _c.update();
      });
    });
    (0, import_vue392.provide)(colorPickerContextKey, {
      currentColor
    });
    expose({
      color
    });
    return (_ctx, _cache) => {
      return (0, import_vue392.openBlock)(), (0, import_vue392.createBlock)((0, import_vue392.unref)(ElTooltip), {
        ref_key: "popper",
        ref: popper,
        visible: showPicker.value,
        "show-arrow": false,
        "fallback-placements": ["bottom", "top", "right", "left"],
        offset: 0,
        "gpu-acceleration": false,
        "popper-class": [(0, import_vue392.unref)(ns2).be("picker", "panel"), (0, import_vue392.unref)(ns2).b("dropdown"), _ctx.popperClass],
        "stop-popper-mouse-event": false,
        effect: "light",
        trigger: "click",
        transition: `${(0, import_vue392.unref)(ns2).namespace.value}-zoom-in-top`,
        persistent: ""
      }, {
        content: (0, import_vue392.withCtx)(() => [
          (0, import_vue392.withDirectives)(((0, import_vue392.openBlock)(), (0, import_vue392.createElementBlock)("div", null, [
            (0, import_vue392.createElementVNode)("div", {
              class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("dropdown", "main-wrapper"))
            }, [
              (0, import_vue392.createVNode)(HueSlider, {
                ref_key: "hue",
                ref: hue,
                class: "hue-slider",
                color: (0, import_vue392.unref)(color),
                vertical: ""
              }, null, 8, ["color"]),
              (0, import_vue392.createVNode)(SvPanel, {
                ref: "svPanel",
                color: (0, import_vue392.unref)(color)
              }, null, 8, ["color"])
            ], 2),
            _ctx.showAlpha ? ((0, import_vue392.openBlock)(), (0, import_vue392.createBlock)(AlphaSlider, {
              key: 0,
              ref_key: "alpha",
              ref: alpha,
              color: (0, import_vue392.unref)(color)
            }, null, 8, ["color"])) : (0, import_vue392.createCommentVNode)("v-if", true),
            _ctx.predefine ? ((0, import_vue392.openBlock)(), (0, import_vue392.createBlock)(Predefine, {
              key: 1,
              ref: "predefine",
              color: (0, import_vue392.unref)(color),
              colors: _ctx.predefine
            }, null, 8, ["color", "colors"])) : (0, import_vue392.createCommentVNode)("v-if", true),
            (0, import_vue392.createElementVNode)("div", {
              class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("dropdown", "btns"))
            }, [
              (0, import_vue392.createElementVNode)("span", {
                class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("dropdown", "value"))
              }, [
                (0, import_vue392.createVNode)((0, import_vue392.unref)(ElInput), {
                  modelValue: customInput.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => customInput.value = $event),
                  "validate-event": false,
                  size: "small",
                  onKeyup: (0, import_vue392.withKeys)(handleConfirm, ["enter"]),
                  onBlur: handleConfirm
                }, null, 8, ["modelValue", "onKeyup"])
              ], 2),
              (0, import_vue392.createVNode)((0, import_vue392.unref)(ElButton), {
                class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("dropdown", "link-btn")),
                text: "",
                size: "small",
                onClick: clear
              }, {
                default: (0, import_vue392.withCtx)(() => [
                  (0, import_vue392.createTextVNode)((0, import_vue392.toDisplayString)((0, import_vue392.unref)(t)("el.colorpicker.clear")), 1)
                ]),
                _: 1
              }, 8, ["class"]),
              (0, import_vue392.createVNode)((0, import_vue392.unref)(ElButton), {
                plain: "",
                size: "small",
                class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("dropdown", "btn")),
                onClick: confirmValue
              }, {
                default: (0, import_vue392.withCtx)(() => [
                  (0, import_vue392.createTextVNode)((0, import_vue392.toDisplayString)((0, import_vue392.unref)(t)("el.colorpicker.confirm")), 1)
                ]),
                _: 1
              }, 8, ["class"])
            ], 2)
          ])), [
            [(0, import_vue392.unref)(ClickOutside), hide2]
          ])
        ]),
        default: (0, import_vue392.withCtx)(() => [
          (0, import_vue392.createElementVNode)("div", {
            id: (0, import_vue392.unref)(buttonId),
            class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(btnKls)),
            role: "button",
            "aria-label": (0, import_vue392.unref)(buttonAriaLabel),
            "aria-labelledby": (0, import_vue392.unref)(buttonAriaLabelledby),
            "aria-description": (0, import_vue392.unref)(t)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
            tabindex: _ctx.tabindex,
            onKeydown: (0, import_vue392.withKeys)(handleTrigger, ["enter"])
          }, [
            (0, import_vue392.unref)(colorDisabled) ? ((0, import_vue392.openBlock)(), (0, import_vue392.createElementBlock)("div", {
              key: 0,
              class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("picker", "mask"))
            }, null, 2)) : (0, import_vue392.createCommentVNode)("v-if", true),
            (0, import_vue392.createElementVNode)("div", {
              class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("picker", "trigger")),
              onClick: handleTrigger
            }, [
              (0, import_vue392.createElementVNode)("span", {
                class: (0, import_vue392.normalizeClass)([(0, import_vue392.unref)(ns2).be("picker", "color"), (0, import_vue392.unref)(ns2).is("alpha", _ctx.showAlpha)])
              }, [
                (0, import_vue392.createElementVNode)("span", {
                  class: (0, import_vue392.normalizeClass)((0, import_vue392.unref)(ns2).be("picker", "color-inner")),
                  style: (0, import_vue392.normalizeStyle)({
                    backgroundColor: (0, import_vue392.unref)(displayedColor)
                  })
                }, [
                  (0, import_vue392.withDirectives)((0, import_vue392.createVNode)((0, import_vue392.unref)(ElIcon), {
                    class: (0, import_vue392.normalizeClass)([(0, import_vue392.unref)(ns2).be("picker", "icon"), (0, import_vue392.unref)(ns2).is("icon-arrow-down")])
                  }, {
                    default: (0, import_vue392.withCtx)(() => [
                      (0, import_vue392.createVNode)((0, import_vue392.unref)(arrow_down_default))
                    ]),
                    _: 1
                  }, 8, ["class"]), [
                    [import_vue392.vShow, _ctx.modelValue || showPanelColor.value]
                  ]),
                  !_ctx.modelValue && !showPanelColor.value ? ((0, import_vue392.openBlock)(), (0, import_vue392.createBlock)((0, import_vue392.unref)(ElIcon), {
                    key: 0,
                    class: (0, import_vue392.normalizeClass)([(0, import_vue392.unref)(ns2).be("picker", "empty"), (0, import_vue392.unref)(ns2).is("icon-close")])
                  }, {
                    default: (0, import_vue392.withCtx)(() => [
                      (0, import_vue392.createVNode)((0, import_vue392.unref)(close_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : (0, import_vue392.createCommentVNode)("v-if", true)
                ], 6)
              ], 2)
            ], 2)
          ], 42, _hoisted_127)
        ]),
        _: 1
      }, 8, ["visible", "popper-class", "transition"]);
    };
  }
});
var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main53, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/color-picker/index.mjs
var ElColorPicker = withInstall(ColorPicker);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/config-provider/src/config-provider.mjs
var import_vue393 = require("vue");
var messageConfig = {};
var configProviderProps = buildProps({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: definePropType(Object)
  },
  size: useSizeProp,
  button: {
    type: definePropType(Object)
  },
  experimentalFeatures: {
    type: definePropType(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: definePropType(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
});
var ConfigProvider = (0, import_vue393.defineComponent)({
  name: "ElConfigProvider",
  props: configProviderProps,
  setup(props, { slots }) {
    (0, import_vue393.watch)(() => props.message, (val) => {
      Object.assign(messageConfig, val != null ? val : {});
    }, { immediate: true, deep: true });
    const config = provideGlobalConfig(props);
    return () => (0, import_vue393.renderSlot)(slots, "default", { config: config == null ? void 0 : config.value });
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/config-provider/index.mjs
var ElConfigProvider = withInstall(ConfigProvider);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/container/src/container.mjs
var import_vue394 = require("vue");
var __default__41 = (0, import_vue394.defineComponent)({
  name: "ElContainer"
});
var _sfc_main54 = /* @__PURE__ */ (0, import_vue394.defineComponent)({
  ...__default__41,
  props: {
    direction: {
      type: String
    }
  },
  setup(__props) {
    const props = __props;
    const slots = (0, import_vue394.useSlots)();
    const ns2 = useNamespace("container");
    const isVertical = (0, import_vue394.computed)(() => {
      if (props.direction === "vertical") {
        return true;
      } else if (props.direction === "horizontal") {
        return false;
      }
      if (slots && slots.default) {
        const vNodes = slots.default();
        return vNodes.some((vNode) => {
          const tag = vNode.type.name;
          return tag === "ElHeader" || tag === "ElFooter";
        });
      } else {
        return false;
      }
    });
    return (_ctx, _cache) => {
      return (0, import_vue394.openBlock)(), (0, import_vue394.createElementBlock)("section", {
        class: (0, import_vue394.normalizeClass)([(0, import_vue394.unref)(ns2).b(), (0, import_vue394.unref)(ns2).is("vertical", (0, import_vue394.unref)(isVertical))])
      }, [
        (0, import_vue394.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Container = /* @__PURE__ */ _export_sfc(_sfc_main54, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/container/src/aside.mjs
var import_vue395 = require("vue");
var __default__42 = (0, import_vue395.defineComponent)({
  name: "ElAside"
});
var _sfc_main55 = /* @__PURE__ */ (0, import_vue395.defineComponent)({
  ...__default__42,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("aside");
    const style = (0, import_vue395.computed)(() => props.width ? ns2.cssVarBlock({ width: props.width }) : {});
    return (_ctx, _cache) => {
      return (0, import_vue395.openBlock)(), (0, import_vue395.createElementBlock)("aside", {
        class: (0, import_vue395.normalizeClass)((0, import_vue395.unref)(ns2).b()),
        style: (0, import_vue395.normalizeStyle)((0, import_vue395.unref)(style))
      }, [
        (0, import_vue395.renderSlot)(_ctx.$slots, "default")
      ], 6);
    };
  }
});
var Aside = /* @__PURE__ */ _export_sfc(_sfc_main55, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/container/src/footer.mjs
var import_vue396 = require("vue");
var __default__43 = (0, import_vue396.defineComponent)({
  name: "ElFooter"
});
var _sfc_main56 = /* @__PURE__ */ (0, import_vue396.defineComponent)({
  ...__default__43,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("footer");
    const style = (0, import_vue396.computed)(() => props.height ? ns2.cssVarBlock({ height: props.height }) : {});
    return (_ctx, _cache) => {
      return (0, import_vue396.openBlock)(), (0, import_vue396.createElementBlock)("footer", {
        class: (0, import_vue396.normalizeClass)((0, import_vue396.unref)(ns2).b()),
        style: (0, import_vue396.normalizeStyle)((0, import_vue396.unref)(style))
      }, [
        (0, import_vue396.renderSlot)(_ctx.$slots, "default")
      ], 6);
    };
  }
});
var Footer = /* @__PURE__ */ _export_sfc(_sfc_main56, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/container/src/header.mjs
var import_vue397 = require("vue");
var __default__44 = (0, import_vue397.defineComponent)({
  name: "ElHeader"
});
var _sfc_main57 = /* @__PURE__ */ (0, import_vue397.defineComponent)({
  ...__default__44,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("header");
    const style = (0, import_vue397.computed)(() => {
      return props.height ? ns2.cssVarBlock({
        height: props.height
      }) : {};
    });
    return (_ctx, _cache) => {
      return (0, import_vue397.openBlock)(), (0, import_vue397.createElementBlock)("header", {
        class: (0, import_vue397.normalizeClass)((0, import_vue397.unref)(ns2).b()),
        style: (0, import_vue397.normalizeStyle)((0, import_vue397.unref)(style))
      }, [
        (0, import_vue397.renderSlot)(_ctx.$slots, "default")
      ], 6);
    };
  }
});
var Header = /* @__PURE__ */ _export_sfc(_sfc_main57, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/container/src/main.mjs
var import_vue398 = require("vue");
var __default__45 = (0, import_vue398.defineComponent)({
  name: "ElMain"
});
var _sfc_main58 = /* @__PURE__ */ (0, import_vue398.defineComponent)({
  ...__default__45,
  setup(__props) {
    const ns2 = useNamespace("main");
    return (_ctx, _cache) => {
      return (0, import_vue398.openBlock)(), (0, import_vue398.createElementBlock)("main", {
        class: (0, import_vue398.normalizeClass)((0, import_vue398.unref)(ns2).b())
      }, [
        (0, import_vue398.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Main = /* @__PURE__ */ _export_sfc(_sfc_main58, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/container/index.mjs
var ElContainer = withInstall(Container, {
  Aside,
  Footer,
  Header,
  Main
});
var ElAside = withNoopInstall(Aside);
var ElFooter = withNoopInstall(Footer);
var ElHeader = withNoopInstall(Header);
var ElMain = withNoopInstall(Main);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker.mjs
var import_vue409 = require("vue");
var import_dayjs15 = __toESM(require_dayjs_min(), 1);
var import_customParseFormat2 = __toESM(require_customParseFormat(), 1);
var import_advancedFormat = __toESM(require_advancedFormat(), 1);
var import_localeData2 = __toESM(require_localeData(), 1);
var import_weekOfYear = __toESM(require_weekOfYear(), 1);
var import_weekYear = __toESM(require_weekYear(), 1);
var import_dayOfYear = __toESM(require_dayOfYear(), 1);
var import_isSameOrAfter = __toESM(require_isSameOrAfter(), 1);
var import_isSameOrBefore = __toESM(require_isSameOrBefore(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/date-picker.mjs
var datePickerProps = buildProps({
  type: {
    type: definePropType(String),
    default: "date"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-date-pick.mjs
var import_vue403 = require("vue");
var import_dayjs11 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/shared.mjs
var import_shared48 = require("@vue/shared");
var selectionModes = ["date", "dates", "year", "month", "week", "range"];
var datePickerSharedProps = buildProps({
  disabledDate: {
    type: definePropType(Function)
  },
  date: {
    type: definePropType(Object),
    required: true
  },
  minDate: {
    type: definePropType(Object)
  },
  maxDate: {
    type: definePropType(Object)
  },
  parsedValue: {
    type: definePropType([Object, Array])
  },
  rangeState: {
    type: definePropType(Object),
    default: () => ({
      endDate: null,
      selecting: false
    })
  }
});
var panelSharedProps = buildProps({
  type: {
    type: definePropType(String),
    required: true,
    values: datePickTypes
  }
});
var panelRangeSharedProps = buildProps({
  unlinkPanels: Boolean,
  parsedValue: {
    type: definePropType(Array)
  }
});
var selectionModeWithDefault = (mode) => {
  return {
    type: String,
    values: selectionModes,
    default: mode
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/panel-date-pick.mjs
var panelDatePickProps = buildProps({
  ...panelSharedProps,
  parsedValue: {
    type: definePropType([Object, Array])
  },
  visible: {
    type: Boolean
  },
  format: {
    type: String,
    default: ""
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-date-table.mjs
var import_vue400 = require("vue");
var import_dayjs8 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/basic-date-table.mjs
var basicDateTableProps = buildProps({
  ...datePickerSharedProps,
  cellClassName: {
    type: definePropType(Function)
  },
  showWeekNumber: Boolean,
  selectionMode: selectionModeWithDefault("date")
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/utils.mjs
var import_dayjs7 = __toESM(require_dayjs_min(), 1);
var import_shared51 = require("@vue/shared");
var isValidRange2 = (range3) => {
  if (!(0, import_shared51.isArray)(range3))
    return false;
  const [left2, right2] = range3;
  return import_dayjs7.default.isDayjs(left2) && import_dayjs7.default.isDayjs(right2) && left2.isSameOrBefore(right2);
};
var getDefaultValue = (defaultValue, { lang, unit: unit3, unlinkPanels }) => {
  let start;
  if ((0, import_shared51.isArray)(defaultValue)) {
    let [left2, right2] = defaultValue.map((d2) => (0, import_dayjs7.default)(d2).locale(lang));
    if (!unlinkPanels) {
      right2 = left2.add(1, unit3);
    }
    return [left2, right2];
  } else if (defaultValue) {
    start = (0, import_dayjs7.default)(defaultValue);
  } else {
    start = (0, import_dayjs7.default)();
  }
  start = start.locale(lang);
  return [start, start.add(1, unit3)];
};
var buildPickerTable = (dimension, rows, {
  columnIndexOffset,
  startDate,
  nextEndDate,
  now: now2,
  unit: unit3,
  relativeDateGetter,
  setCellMetadata,
  setRowMetadata
}) => {
  for (let rowIndex = 0; rowIndex < dimension.row; rowIndex++) {
    const row = rows[rowIndex];
    for (let columnIndex = 0; columnIndex < dimension.column; columnIndex++) {
      let cell = row[columnIndex + columnIndexOffset];
      if (!cell) {
        cell = {
          row: rowIndex,
          column: columnIndex,
          type: "normal",
          inRange: false,
          start: false,
          end: false
        };
      }
      const index2 = rowIndex * dimension.column + columnIndex;
      const nextStartDate = relativeDateGetter(index2);
      cell.dayjs = nextStartDate;
      cell.date = nextStartDate.toDate();
      cell.timestamp = nextStartDate.valueOf();
      cell.type = "normal";
      cell.inRange = !!(startDate && nextStartDate.isSameOrAfter(startDate, unit3) && nextEndDate && nextStartDate.isSameOrBefore(nextEndDate, unit3)) || !!(startDate && nextStartDate.isSameOrBefore(startDate, unit3) && nextEndDate && nextStartDate.isSameOrAfter(nextEndDate, unit3));
      if (startDate == null ? void 0 : startDate.isSameOrAfter(nextEndDate)) {
        cell.start = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit3);
        cell.end = startDate && nextStartDate.isSame(startDate, unit3);
      } else {
        cell.start = !!startDate && nextStartDate.isSame(startDate, unit3);
        cell.end = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit3);
      }
      const isToday = nextStartDate.isSame(now2, unit3);
      if (isToday) {
        cell.type = "today";
      }
      setCellMetadata == null ? void 0 : setCellMetadata(cell, { rowIndex, columnIndex });
      row[columnIndex + columnIndexOffset] = cell;
    }
    setRowMetadata == null ? void 0 : setRowMetadata(row);
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-cell-render.mjs
var import_vue399 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/basic-cell.mjs
var basicCellProps = buildProps({
  cell: {
    type: definePropType(Object)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-cell-render.mjs
var ElDatePickerCell = (0, import_vue399.defineComponent)({
  name: "ElDatePickerCell",
  props: basicCellProps,
  setup(props) {
    const ns2 = useNamespace("date-table-cell");
    const {
      slots
    } = (0, import_vue399.inject)(ROOT_PICKER_INJECTION_KEY);
    return () => {
      const {
        cell
      } = props;
      if (slots.default) {
        const list = slots.default(cell).filter((item) => {
          return item.patchFlag !== -2 && item.type.toString() !== "Symbol(Comment)";
        });
        if (list.length) {
          return list;
        }
      }
      return (0, import_vue399.createVNode)("div", {
        "class": ns2.b()
      }, [(0, import_vue399.createVNode)("span", {
        "class": ns2.e("text")
      }, [cell == null ? void 0 : cell.text])]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-date-table.mjs
var _hoisted_128 = ["aria-label", "onMousedown"];
var _hoisted_219 = {
  key: 0,
  scope: "col"
};
var _hoisted_37 = ["aria-label"];
var _hoisted_4 = ["aria-current", "aria-selected", "tabindex"];
var _sfc_main59 = /* @__PURE__ */ (0, import_vue400.defineComponent)({
  __name: "basic-date-table",
  props: basicDateTableProps,
  emits: ["changerange", "pick", "select"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("date-table");
    const { t, lang } = useLocale();
    const tbodyRef = (0, import_vue400.ref)();
    const currentCellRef = (0, import_vue400.ref)();
    const lastRow = (0, import_vue400.ref)();
    const lastColumn = (0, import_vue400.ref)();
    const tableRows = (0, import_vue400.ref)([[], [], [], [], [], []]);
    let focusWithClick = false;
    const firstDayOfWeek = props.date.$locale().weekStart || 7;
    const WEEKS_CONSTANT = props.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
    const offsetDay = (0, import_vue400.computed)(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });
    const startDate = (0, import_vue400.computed)(() => {
      const startDayOfMonth = props.date.startOf("month");
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
    });
    const WEEKS = (0, import_vue400.computed)(() => {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    const hasCurrent = (0, import_vue400.computed)(() => {
      return flatten_default(rows.value).some((row) => {
        return row.isCurrent;
      });
    });
    const days = (0, import_vue400.computed)(() => {
      const startOfMonth = props.date.startOf("month");
      const startOfMonthDay = startOfMonth.day() || 7;
      const dateCountOfMonth = startOfMonth.daysInMonth();
      const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
      return {
        startOfMonthDay,
        dateCountOfMonth,
        dateCountOfLastMonth
      };
    });
    const selectedDate = (0, import_vue400.computed)(() => {
      return props.selectionMode === "dates" ? castArray2(props.parsedValue) : [];
    });
    const setDateText = (cell, {
      count,
      rowIndex,
      columnIndex
    }) => {
      const { startOfMonthDay, dateCountOfMonth, dateCountOfLastMonth } = (0, import_vue400.unref)(days);
      const offset2 = (0, import_vue400.unref)(offsetDay);
      if (rowIndex >= 0 && rowIndex <= 1) {
        const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
        if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {
          cell.text = count;
          return true;
        } else {
          cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - columnIndex % 7) + 1 + rowIndex * 7;
          cell.type = "prev-month";
        }
      } else {
        if (count <= dateCountOfMonth) {
          cell.text = count;
        } else {
          cell.text = count - dateCountOfMonth;
          cell.type = "next-month";
        }
        return true;
      }
      return false;
    };
    const setCellMetadata = (cell, {
      columnIndex,
      rowIndex
    }, count) => {
      const { disabledDate: disabledDate2, cellClassName } = props;
      const _selectedDate = (0, import_vue400.unref)(selectedDate);
      const shouldIncrement = setDateText(cell, { count, rowIndex, columnIndex });
      const cellDate = cell.dayjs.toDate();
      cell.selected = _selectedDate.find((d2) => d2.valueOf() === cell.dayjs.valueOf());
      cell.isSelected = !!cell.selected;
      cell.isCurrent = isCurrent(cell);
      cell.disabled = disabledDate2 == null ? void 0 : disabledDate2(cellDate);
      cell.customClass = cellClassName == null ? void 0 : cellClassName(cellDate);
      return shouldIncrement;
    };
    const setRowMetadata = (row) => {
      if (props.selectionMode === "week") {
        const [start, end2] = props.showWeekNumber ? [1, 7] : [0, 6];
        const isActive = isWeekActive(row[start + 1]);
        row[start].inRange = isActive;
        row[start].start = isActive;
        row[end2].inRange = isActive;
        row[end2].end = isActive;
      }
    };
    const rows = (0, import_vue400.computed)(() => {
      const { minDate, maxDate, rangeState, showWeekNumber } = props;
      const offset2 = offsetDay.value;
      const rows_ = tableRows.value;
      const dateUnit = "day";
      let count = 1;
      if (showWeekNumber) {
        for (let rowIndex = 0; rowIndex < 6; rowIndex++) {
          if (!rows_[rowIndex][0]) {
            rows_[rowIndex][0] = {
              type: "week",
              text: startDate.value.add(rowIndex * 7 + 1, dateUnit).week()
            };
          }
        }
      }
      buildPickerTable({ row: 6, column: 7 }, rows_, {
        startDate: minDate,
        columnIndexOffset: showWeekNumber ? 1 : 0,
        nextEndDate: rangeState.endDate || maxDate || rangeState.selecting && minDate || null,
        now: (0, import_dayjs8.default)().locale((0, import_vue400.unref)(lang)).startOf(dateUnit),
        unit: dateUnit,
        relativeDateGetter: (idx) => startDate.value.add(idx - offset2, dateUnit),
        setCellMetadata: (...args) => {
          if (setCellMetadata(...args, count)) {
            count += 1;
          }
        },
        setRowMetadata
      });
      return rows_;
    });
    (0, import_vue400.watch)(() => props.date, async () => {
      var _a2, _b;
      if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
        await (0, import_vue400.nextTick)();
        (_b = currentCellRef.value) == null ? void 0 : _b.focus();
      }
    });
    const focus = async () => {
      var _a2;
      (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
    };
    const isNormalDay = (type4 = "") => {
      return ["normal", "today"].includes(type4);
    };
    const isCurrent = (cell) => {
      return props.selectionMode === "date" && isNormalDay(cell.type) && cellMatchesDate(cell, props.parsedValue);
    };
    const cellMatchesDate = (cell, date5) => {
      if (!date5)
        return false;
      return (0, import_dayjs8.default)(date5).locale(lang.value).isSame(props.date.date(Number(cell.text)), "day");
    };
    const getCellClasses = (cell) => {
      const classes = [];
      if (isNormalDay(cell.type) && !cell.disabled) {
        classes.push("available");
        if (cell.type === "today") {
          classes.push("today");
        }
      } else {
        classes.push(cell.type);
      }
      if (isCurrent(cell)) {
        classes.push("current");
      }
      if (cell.inRange && (isNormalDay(cell.type) || props.selectionMode === "week")) {
        classes.push("in-range");
        if (cell.start) {
          classes.push("start-date");
        }
        if (cell.end) {
          classes.push("end-date");
        }
      }
      if (cell.disabled) {
        classes.push("disabled");
      }
      if (cell.selected) {
        classes.push("selected");
      }
      if (cell.customClass) {
        classes.push(cell.customClass);
      }
      return classes.join(" ");
    };
    const getDateOfCell = (row, column2) => {
      const offsetFromStart = row * 7 + (column2 - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, "day");
    };
    const handleMouseMove = (event) => {
      var _a2;
      if (!props.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "SPAN") {
        target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column2 = target.cellIndex;
      if (rows.value[row][column2].disabled)
        return;
      if (row !== lastRow.value || column2 !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column2;
        emit("changerange", {
          selecting: true,
          endDate: getDateOfCell(row, column2)
        });
      }
    };
    const isSelectedCell = (cell) => {
      return !hasCurrent.value && (cell == null ? void 0 : cell.text) === 1 && cell.type === "normal" || cell.isCurrent;
    };
    const handleFocus = (event) => {
      if (focusWithClick || hasCurrent.value || props.selectionMode !== "date")
        return;
      handlePickDate(event, true);
    };
    const handleMouseDown = (event) => {
      const target = event.target.closest("td");
      if (!target)
        return;
      focusWithClick = true;
    };
    const handleMouseUp = (event) => {
      const target = event.target.closest("td");
      if (!target)
        return;
      focusWithClick = false;
    };
    const handlePickDate = (event, isKeyboardMovement = false) => {
      const target = event.target.closest("td");
      if (!target)
        return;
      const row = target.parentNode.rowIndex - 1;
      const column2 = target.cellIndex;
      const cell = rows.value[row][column2];
      if (cell.disabled || cell.type === "week")
        return;
      const newDate = getDateOfCell(row, column2);
      if (props.selectionMode === "range") {
        if (!props.rangeState.selecting || !props.minDate) {
          emit("pick", { minDate: newDate, maxDate: null });
          emit("select", true);
        } else {
          if (newDate >= props.minDate) {
            emit("pick", { minDate: props.minDate, maxDate: newDate });
          } else {
            emit("pick", { minDate: newDate, maxDate: props.minDate });
          }
          emit("select", false);
        }
      } else if (props.selectionMode === "date") {
        emit("pick", newDate, isKeyboardMovement);
      } else if (props.selectionMode === "week") {
        const weekNumber = newDate.week();
        const value = `${newDate.year()}w${weekNumber}`;
        emit("pick", {
          year: newDate.year(),
          week: weekNumber,
          value,
          date: newDate.startOf("week")
        });
      } else if (props.selectionMode === "dates") {
        const newValue = cell.selected ? castArray2(props.parsedValue).filter((d2) => (d2 == null ? void 0 : d2.valueOf()) !== newDate.valueOf()) : castArray2(props.parsedValue).concat([newDate]);
        emit("pick", newValue);
      }
    };
    const isWeekActive = (cell) => {
      if (props.selectionMode !== "week")
        return false;
      let newDate = props.date.startOf("day");
      if (cell.type === "prev-month") {
        newDate = newDate.subtract(1, "month");
      }
      if (cell.type === "next-month") {
        newDate = newDate.add(1, "month");
      }
      newDate = newDate.date(Number.parseInt(cell.text, 10));
      if (props.parsedValue && !Array.isArray(props.parsedValue)) {
        const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        const weekDate = props.parsedValue.subtract(dayOffset, "day");
        return weekDate.isSame(newDate, "day");
      }
      return false;
    };
    expose({
      focus
    });
    return (_ctx, _cache) => {
      return (0, import_vue400.openBlock)(), (0, import_vue400.createElementBlock)("table", {
        role: "grid",
        "aria-label": (0, import_vue400.unref)(t)("el.datepicker.dateTablePrompt"),
        cellspacing: "0",
        cellpadding: "0",
        class: (0, import_vue400.normalizeClass)([(0, import_vue400.unref)(ns2).b(), { "is-week-mode": _ctx.selectionMode === "week" }]),
        onClick: handlePickDate,
        onMousemove: handleMouseMove,
        onMousedown: (0, import_vue400.withModifiers)(handleMouseDown, ["prevent"]),
        onMouseup: handleMouseUp
      }, [
        (0, import_vue400.createElementVNode)("tbody", {
          ref_key: "tbodyRef",
          ref: tbodyRef
        }, [
          (0, import_vue400.createElementVNode)("tr", null, [
            _ctx.showWeekNumber ? ((0, import_vue400.openBlock)(), (0, import_vue400.createElementBlock)("th", _hoisted_219, (0, import_vue400.toDisplayString)((0, import_vue400.unref)(t)("el.datepicker.week")), 1)) : (0, import_vue400.createCommentVNode)("v-if", true),
            ((0, import_vue400.openBlock)(true), (0, import_vue400.createElementBlock)(import_vue400.Fragment, null, (0, import_vue400.renderList)((0, import_vue400.unref)(WEEKS), (week, key) => {
              return (0, import_vue400.openBlock)(), (0, import_vue400.createElementBlock)("th", {
                key,
                scope: "col",
                "aria-label": (0, import_vue400.unref)(t)("el.datepicker.weeksFull." + week)
              }, (0, import_vue400.toDisplayString)((0, import_vue400.unref)(t)("el.datepicker.weeks." + week)), 9, _hoisted_37);
            }), 128))
          ]),
          ((0, import_vue400.openBlock)(true), (0, import_vue400.createElementBlock)(import_vue400.Fragment, null, (0, import_vue400.renderList)((0, import_vue400.unref)(rows), (row, rowKey2) => {
            return (0, import_vue400.openBlock)(), (0, import_vue400.createElementBlock)("tr", {
              key: rowKey2,
              class: (0, import_vue400.normalizeClass)([(0, import_vue400.unref)(ns2).e("row"), { current: isWeekActive(row[1]) }])
            }, [
              ((0, import_vue400.openBlock)(true), (0, import_vue400.createElementBlock)(import_vue400.Fragment, null, (0, import_vue400.renderList)(row, (cell, columnKey) => {
                return (0, import_vue400.openBlock)(), (0, import_vue400.createElementBlock)("td", {
                  key: `${rowKey2}.${columnKey}`,
                  ref_for: true,
                  ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                  class: (0, import_vue400.normalizeClass)(getCellClasses(cell)),
                  "aria-current": cell.isCurrent ? "date" : void 0,
                  "aria-selected": cell.isCurrent,
                  tabindex: isSelectedCell(cell) ? 0 : -1,
                  onFocus: handleFocus
                }, [
                  (0, import_vue400.createVNode)((0, import_vue400.unref)(ElDatePickerCell), { cell }, null, 8, ["cell"])
                ], 42, _hoisted_4);
              }), 128))
            ], 2);
          }), 128))
        ], 512)
      ], 42, _hoisted_128);
    };
  }
});
var DateTable2 = /* @__PURE__ */ _export_sfc(_sfc_main59, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-month-table.mjs
var import_vue401 = require("vue");
var import_dayjs9 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/basic-month-table.mjs
var basicMonthTableProps = buildProps({
  ...datePickerSharedProps,
  selectionMode: selectionModeWithDefault("month")
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-month-table.mjs
var _hoisted_130 = ["aria-label"];
var _hoisted_220 = ["aria-selected", "aria-label", "tabindex", "onKeydown"];
var _hoisted_39 = { class: "cell" };
var _sfc_main60 = /* @__PURE__ */ (0, import_vue401.defineComponent)({
  __name: "basic-month-table",
  props: basicMonthTableProps,
  emits: ["changerange", "pick", "select"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const datesInMonth = (year, month, lang2) => {
      const firstDay = (0, import_dayjs9.default)().locale(lang2).startOf("month").month(month).year(year);
      const numOfDays = firstDay.daysInMonth();
      return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
    };
    const ns2 = useNamespace("month-table");
    const { t, lang } = useLocale();
    const tbodyRef = (0, import_vue401.ref)();
    const currentCellRef = (0, import_vue401.ref)();
    const months = (0, import_vue401.ref)(props.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
    const tableRows = (0, import_vue401.ref)([
      [],
      [],
      []
    ]);
    const lastRow = (0, import_vue401.ref)();
    const lastColumn = (0, import_vue401.ref)();
    const rows = (0, import_vue401.computed)(() => {
      var _a2, _b;
      const rows2 = tableRows.value;
      const now2 = (0, import_dayjs9.default)().locale(lang.value).startOf("month");
      for (let i = 0; i < 3; i++) {
        const row = rows2[i];
        for (let j = 0; j < 4; j++) {
          const cell = row[j] || (row[j] = {
            row: i,
            column: j,
            type: "normal",
            inRange: false,
            start: false,
            end: false,
            text: -1,
            disabled: false
          });
          cell.type = "normal";
          const index2 = i * 4 + j;
          const calTime = props.date.startOf("year").month(index2);
          const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate || null;
          cell.inRange = !!(props.minDate && calTime.isSameOrAfter(props.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month")) || !!(props.minDate && calTime.isSameOrBefore(props.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month"));
          if ((_a2 = props.minDate) == null ? void 0 : _a2.isSameOrAfter(calEndDate)) {
            cell.start = !!(calEndDate && calTime.isSame(calEndDate, "month"));
            cell.end = props.minDate && calTime.isSame(props.minDate, "month");
          } else {
            cell.start = !!(props.minDate && calTime.isSame(props.minDate, "month"));
            cell.end = !!(calEndDate && calTime.isSame(calEndDate, "month"));
          }
          const isToday = now2.isSame(calTime);
          if (isToday) {
            cell.type = "today";
          }
          cell.text = index2;
          cell.disabled = ((_b = props.disabledDate) == null ? void 0 : _b.call(props, calTime.toDate())) || false;
        }
      }
      return rows2;
    });
    const focus = () => {
      var _a2;
      (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
    };
    const getCellStyle = (cell) => {
      const style = {};
      const year = props.date.year();
      const today = /* @__PURE__ */ new Date();
      const month = cell.text;
      style.disabled = props.disabledDate ? datesInMonth(year, month, lang.value).every(props.disabledDate) : false;
      style.current = castArray2(props.parsedValue).findIndex((date5) => import_dayjs9.default.isDayjs(date5) && date5.year() === year && date5.month() === month) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;
      if (cell.inRange) {
        style["in-range"] = true;
        if (cell.start) {
          style["start-date"] = true;
        }
        if (cell.end) {
          style["end-date"] = true;
        }
      }
      return style;
    };
    const isSelectedCell = (cell) => {
      const year = props.date.year();
      const month = cell.text;
      return castArray2(props.date).findIndex((date5) => date5.year() === year && date5.month() === month) >= 0;
    };
    const handleMouseMove = (event) => {
      var _a2;
      if (!props.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "A") {
        target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex;
      const column2 = target.cellIndex;
      if (rows.value[row][column2].disabled)
        return;
      if (row !== lastRow.value || column2 !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column2;
        emit("changerange", {
          selecting: true,
          endDate: props.date.startOf("year").month(row * 4 + column2)
        });
      }
    };
    const handleMonthTableClick = (event) => {
      var _a2;
      const target = (_a2 = event.target) == null ? void 0 : _a2.closest("td");
      if ((target == null ? void 0 : target.tagName) !== "TD")
        return;
      if (hasClass(target, "disabled"))
        return;
      const column2 = target.cellIndex;
      const row = target.parentNode.rowIndex;
      const month = row * 4 + column2;
      const newDate = props.date.startOf("year").month(month);
      if (props.selectionMode === "range") {
        if (!props.rangeState.selecting) {
          emit("pick", { minDate: newDate, maxDate: null });
          emit("select", true);
        } else {
          if (props.minDate && newDate >= props.minDate) {
            emit("pick", { minDate: props.minDate, maxDate: newDate });
          } else {
            emit("pick", { minDate: newDate, maxDate: props.minDate });
          }
          emit("select", false);
        }
      } else {
        emit("pick", month);
      }
    };
    (0, import_vue401.watch)(() => props.date, async () => {
      var _a2, _b;
      if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
        await (0, import_vue401.nextTick)();
        (_b = currentCellRef.value) == null ? void 0 : _b.focus();
      }
    });
    expose({
      focus
    });
    return (_ctx, _cache) => {
      return (0, import_vue401.openBlock)(), (0, import_vue401.createElementBlock)("table", {
        role: "grid",
        "aria-label": (0, import_vue401.unref)(t)("el.datepicker.monthTablePrompt"),
        class: (0, import_vue401.normalizeClass)((0, import_vue401.unref)(ns2).b()),
        onClick: handleMonthTableClick,
        onMousemove: handleMouseMove
      }, [
        (0, import_vue401.createElementVNode)("tbody", {
          ref_key: "tbodyRef",
          ref: tbodyRef
        }, [
          ((0, import_vue401.openBlock)(true), (0, import_vue401.createElementBlock)(import_vue401.Fragment, null, (0, import_vue401.renderList)((0, import_vue401.unref)(rows), (row, key) => {
            return (0, import_vue401.openBlock)(), (0, import_vue401.createElementBlock)("tr", { key }, [
              ((0, import_vue401.openBlock)(true), (0, import_vue401.createElementBlock)(import_vue401.Fragment, null, (0, import_vue401.renderList)(row, (cell, key_) => {
                return (0, import_vue401.openBlock)(), (0, import_vue401.createElementBlock)("td", {
                  key: key_,
                  ref_for: true,
                  ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                  class: (0, import_vue401.normalizeClass)(getCellStyle(cell)),
                  "aria-selected": `${isSelectedCell(cell)}`,
                  "aria-label": (0, import_vue401.unref)(t)(`el.datepicker.month${+cell.text + 1}`),
                  tabindex: isSelectedCell(cell) ? 0 : -1,
                  onKeydown: [
                    (0, import_vue401.withKeys)((0, import_vue401.withModifiers)(handleMonthTableClick, ["prevent", "stop"]), ["space"]),
                    (0, import_vue401.withKeys)((0, import_vue401.withModifiers)(handleMonthTableClick, ["prevent", "stop"]), ["enter"])
                  ]
                }, [
                  (0, import_vue401.createElementVNode)("div", null, [
                    (0, import_vue401.createElementVNode)("span", _hoisted_39, (0, import_vue401.toDisplayString)((0, import_vue401.unref)(t)("el.datepicker.months." + months.value[cell.text])), 1)
                  ])
                ], 42, _hoisted_220);
              }), 128))
            ]);
          }), 128))
        ], 512)
      ], 42, _hoisted_130);
    };
  }
});
var MonthTable = /* @__PURE__ */ _export_sfc(_sfc_main60, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-year-table.mjs
var import_vue402 = require("vue");
var import_dayjs10 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/basic-year-table.mjs
var { date, disabledDate, parsedValue } = datePickerSharedProps;
var basicYearTableProps = buildProps({
  date,
  disabledDate,
  parsedValue
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-year-table.mjs
var _hoisted_131 = ["aria-label"];
var _hoisted_221 = ["aria-selected", "tabindex", "onKeydown"];
var _hoisted_311 = { class: "cell" };
var _hoisted_42 = { key: 1 };
var _sfc_main61 = /* @__PURE__ */ (0, import_vue402.defineComponent)({
  __name: "basic-year-table",
  props: basicYearTableProps,
  emits: ["pick"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const datesInYear = (year, lang2) => {
      const firstDay = (0, import_dayjs10.default)(String(year)).locale(lang2).startOf("year");
      const lastDay = firstDay.endOf("year");
      const numOfDays = lastDay.dayOfYear();
      return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
    };
    const ns2 = useNamespace("year-table");
    const { t, lang } = useLocale();
    const tbodyRef = (0, import_vue402.ref)();
    const currentCellRef = (0, import_vue402.ref)();
    const startYear = (0, import_vue402.computed)(() => {
      return Math.floor(props.date.year() / 10) * 10;
    });
    const focus = () => {
      var _a2;
      (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
    };
    const getCellKls = (year) => {
      const kls = {};
      const today = (0, import_dayjs10.default)().locale(lang.value);
      kls.disabled = props.disabledDate ? datesInYear(year, lang.value).every(props.disabledDate) : false;
      kls.current = castArray2(props.parsedValue).findIndex((d2) => d2.year() === year) >= 0;
      kls.today = today.year() === year;
      return kls;
    };
    const isSelectedCell = (year) => {
      return year === startYear.value && props.date.year() < startYear.value && props.date.year() > startYear.value + 9 || castArray2(props.date).findIndex((date5) => date5.year() === year) >= 0;
    };
    const handleYearTableClick = (event) => {
      const clickTarget = event.target;
      const target = clickTarget.closest("td");
      if (target && target.textContent) {
        if (hasClass(target, "disabled"))
          return;
        const year = target.textContent || target.innerText;
        emit("pick", Number(year));
      }
    };
    (0, import_vue402.watch)(() => props.date, async () => {
      var _a2, _b;
      if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
        await (0, import_vue402.nextTick)();
        (_b = currentCellRef.value) == null ? void 0 : _b.focus();
      }
    });
    expose({
      focus
    });
    return (_ctx, _cache) => {
      return (0, import_vue402.openBlock)(), (0, import_vue402.createElementBlock)("table", {
        role: "grid",
        "aria-label": (0, import_vue402.unref)(t)("el.datepicker.yearTablePrompt"),
        class: (0, import_vue402.normalizeClass)((0, import_vue402.unref)(ns2).b()),
        onClick: handleYearTableClick
      }, [
        (0, import_vue402.createElementVNode)("tbody", {
          ref_key: "tbodyRef",
          ref: tbodyRef
        }, [
          ((0, import_vue402.openBlock)(), (0, import_vue402.createElementBlock)(import_vue402.Fragment, null, (0, import_vue402.renderList)(3, (_2, i) => {
            return (0, import_vue402.createElementVNode)("tr", { key: i }, [
              ((0, import_vue402.openBlock)(), (0, import_vue402.createElementBlock)(import_vue402.Fragment, null, (0, import_vue402.renderList)(4, (__, j) => {
                return (0, import_vue402.openBlock)(), (0, import_vue402.createElementBlock)(import_vue402.Fragment, {
                  key: i + "_" + j
                }, [
                  i * 4 + j < 10 ? ((0, import_vue402.openBlock)(), (0, import_vue402.createElementBlock)("td", {
                    key: 0,
                    ref_for: true,
                    ref: (el) => isSelectedCell((0, import_vue402.unref)(startYear) + i * 4 + j) && (currentCellRef.value = el),
                    class: (0, import_vue402.normalizeClass)(["available", getCellKls((0, import_vue402.unref)(startYear) + i * 4 + j)]),
                    "aria-selected": `${isSelectedCell((0, import_vue402.unref)(startYear) + i * 4 + j)}`,
                    tabindex: isSelectedCell((0, import_vue402.unref)(startYear) + i * 4 + j) ? 0 : -1,
                    onKeydown: [
                      (0, import_vue402.withKeys)((0, import_vue402.withModifiers)(handleYearTableClick, ["prevent", "stop"]), ["space"]),
                      (0, import_vue402.withKeys)((0, import_vue402.withModifiers)(handleYearTableClick, ["prevent", "stop"]), ["enter"])
                    ]
                  }, [
                    (0, import_vue402.createElementVNode)("span", _hoisted_311, (0, import_vue402.toDisplayString)((0, import_vue402.unref)(startYear) + i * 4 + j), 1)
                  ], 42, _hoisted_221)) : ((0, import_vue402.openBlock)(), (0, import_vue402.createElementBlock)("td", _hoisted_42))
                ], 64);
              }), 64))
            ]);
          }), 64))
        ], 512)
      ], 10, _hoisted_131);
    };
  }
});
var YearTable = /* @__PURE__ */ _export_sfc(_sfc_main61, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-date-pick.mjs
var import_shared54 = require("@vue/shared");
var _hoisted_132 = ["onClick"];
var _hoisted_222 = ["aria-label"];
var _hoisted_313 = ["aria-label"];
var _hoisted_43 = ["aria-label"];
var _hoisted_5 = ["aria-label"];
var _sfc_main62 = /* @__PURE__ */ (0, import_vue403.defineComponent)({
  __name: "panel-date-pick",
  props: panelDatePickProps,
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(__props, { emit: contextEmit }) {
    const props = __props;
    const timeWithinRange = (_2, __, ___) => true;
    const ppNs = useNamespace("picker-panel");
    const dpNs = useNamespace("date-picker");
    const attrs = (0, import_vue403.useAttrs)();
    const slots = (0, import_vue403.useSlots)();
    const { t, lang } = useLocale();
    const pickerBase = (0, import_vue403.inject)("EP_PICKER_BASE");
    const popper = (0, import_vue403.inject)(TOOLTIP_INJECTION_KEY);
    const { shortcuts: shortcuts2, disabledDate: disabledDate2, cellClassName, defaultTime, arrowControl } = pickerBase.props;
    const defaultValue = (0, import_vue403.toRef)(pickerBase.props, "defaultValue");
    const currentViewRef = (0, import_vue403.ref)();
    const innerDate = (0, import_vue403.ref)((0, import_dayjs11.default)().locale(lang.value));
    const isChangeToNow = (0, import_vue403.ref)(false);
    const defaultTimeD = (0, import_vue403.computed)(() => {
      return (0, import_dayjs11.default)(defaultTime).locale(lang.value);
    });
    const month = (0, import_vue403.computed)(() => {
      return innerDate.value.month();
    });
    const year = (0, import_vue403.computed)(() => {
      return innerDate.value.year();
    });
    const selectableRange = (0, import_vue403.ref)([]);
    const userInputDate = (0, import_vue403.ref)(null);
    const userInputTime = (0, import_vue403.ref)(null);
    const checkDateWithinRange = (date5) => {
      return selectableRange.value.length > 0 ? timeWithinRange(date5, selectableRange.value, props.format || "HH:mm:ss") : true;
    };
    const formatEmit = (emitDayjs) => {
      if (defaultTime && !visibleTime.value && !isChangeToNow.value) {
        return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      if (showTime.value)
        return emitDayjs.millisecond(0);
      return emitDayjs.startOf("day");
    };
    const emit = (value, ...args) => {
      if (!value) {
        contextEmit("pick", value, ...args);
      } else if ((0, import_shared54.isArray)(value)) {
        const dates = value.map(formatEmit);
        contextEmit("pick", dates, ...args);
      } else {
        contextEmit("pick", formatEmit(value), ...args);
      }
      userInputDate.value = null;
      userInputTime.value = null;
      isChangeToNow.value = false;
    };
    const handleDatePick = (value, keepOpen) => {
      if (selectionMode.value === "date") {
        value = value;
        let newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
        }
        innerDate.value = newDate;
        emit(newDate, showTime.value || keepOpen);
      } else if (selectionMode.value === "week") {
        emit(value.date);
      } else if (selectionMode.value === "dates") {
        emit(value, true);
      }
    };
    const moveByMonth = (forward) => {
      const action = forward ? "add" : "subtract";
      innerDate.value = innerDate.value[action](1, "month");
      handlePanelChange("month");
    };
    const moveByYear = (forward) => {
      const currentDate = innerDate.value;
      const action = forward ? "add" : "subtract";
      innerDate.value = currentView.value === "year" ? currentDate[action](10, "year") : currentDate[action](1, "year");
      handlePanelChange("year");
    };
    const currentView = (0, import_vue403.ref)("date");
    const yearLabel = (0, import_vue403.computed)(() => {
      const yearTranslation = t("el.datepicker.year");
      if (currentView.value === "year") {
        const startYear = Math.floor(year.value / 10) * 10;
        if (yearTranslation) {
          return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
        }
        return `${startYear} - ${startYear + 9}`;
      }
      return `${year.value} ${yearTranslation}`;
    });
    const handleShortcutClick = (shortcut) => {
      const shortcutValue = (0, import_shared54.isFunction)(shortcut.value) ? shortcut.value() : shortcut.value;
      if (shortcutValue) {
        emit((0, import_dayjs11.default)(shortcutValue).locale(lang.value));
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick({
          attrs,
          slots,
          emit: contextEmit
        });
      }
    };
    const selectionMode = (0, import_vue403.computed)(() => {
      const { type: type4 } = props;
      if (["week", "month", "year", "dates"].includes(type4))
        return type4;
      return "date";
    });
    const keyboardMode = (0, import_vue403.computed)(() => {
      return selectionMode.value === "date" ? currentView.value : selectionMode.value;
    });
    const hasShortcuts = (0, import_vue403.computed)(() => !!shortcuts2.length);
    const handleMonthPick = async (month2) => {
      innerDate.value = innerDate.value.startOf("month").month(month2);
      if (selectionMode.value === "month") {
        emit(innerDate.value, false);
      } else {
        currentView.value = "date";
        if (["month", "year", "date", "week"].includes(selectionMode.value)) {
          emit(innerDate.value, true);
          await (0, import_vue403.nextTick)();
          handleFocusPicker();
        }
      }
      handlePanelChange("month");
    };
    const handleYearPick = async (year2) => {
      if (selectionMode.value === "year") {
        innerDate.value = innerDate.value.startOf("year").year(year2);
        emit(innerDate.value, false);
      } else {
        innerDate.value = innerDate.value.year(year2);
        currentView.value = "month";
        if (["month", "year", "date", "week"].includes(selectionMode.value)) {
          emit(innerDate.value, true);
          await (0, import_vue403.nextTick)();
          handleFocusPicker();
        }
      }
      handlePanelChange("year");
    };
    const showPicker = async (view) => {
      currentView.value = view;
      await (0, import_vue403.nextTick)();
      handleFocusPicker();
    };
    const showTime = (0, import_vue403.computed)(() => props.type === "datetime" || props.type === "datetimerange");
    const footerVisible = (0, import_vue403.computed)(() => {
      return showTime.value || selectionMode.value === "dates";
    });
    const onConfirm = () => {
      if (selectionMode.value === "dates") {
        emit(props.parsedValue);
      } else {
        let result = props.parsedValue;
        if (!result) {
          const defaultTimeD2 = (0, import_dayjs11.default)(defaultTime).locale(lang.value);
          const defaultValueD = getDefaultValue2();
          result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }
        innerDate.value = result;
        emit(result);
      }
    };
    const changeToNow = () => {
      const now2 = (0, import_dayjs11.default)().locale(lang.value);
      const nowDate = now2.toDate();
      isChangeToNow.value = true;
      if ((!disabledDate2 || !disabledDate2(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = (0, import_dayjs11.default)().locale(lang.value);
        emit(innerDate.value);
      }
    };
    const timeFormat = (0, import_vue403.computed)(() => {
      return extractTimeFormat(props.format);
    });
    const dateFormat = (0, import_vue403.computed)(() => {
      return extractDateFormat(props.format);
    });
    const visibleTime = (0, import_vue403.computed)(() => {
      if (userInputTime.value)
        return userInputTime.value;
      if (!props.parsedValue && !defaultValue.value)
        return;
      return (props.parsedValue || innerDate.value).format(timeFormat.value);
    });
    const visibleDate = (0, import_vue403.computed)(() => {
      if (userInputDate.value)
        return userInputDate.value;
      if (!props.parsedValue && !defaultValue.value)
        return;
      return (props.parsedValue || innerDate.value).format(dateFormat.value);
    });
    const timePickerVisible = (0, import_vue403.ref)(false);
    const onTimePickerInputFocus = () => {
      timePickerVisible.value = true;
    };
    const handleTimePickClose = () => {
      timePickerVisible.value = false;
    };
    const getUnits = (date5) => {
      return {
        hour: date5.hour(),
        minute: date5.minute(),
        second: date5.second(),
        year: date5.year(),
        month: date5.month(),
        date: date5.date()
      };
    };
    const handleTimePick = (value, visible, first) => {
      const { hour, minute, second } = getUnits(value);
      const newDate = props.parsedValue ? props.parsedValue.hour(hour).minute(minute).second(second) : value;
      innerDate.value = newDate;
      emit(innerDate.value, true);
      if (!first) {
        timePickerVisible.value = visible;
      }
    };
    const handleVisibleTimeChange = (value) => {
      const newDate = (0, import_dayjs11.default)(value, timeFormat.value).locale(lang.value);
      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        const { year: year2, month: month2, date: date5 } = getUnits(innerDate.value);
        innerDate.value = newDate.year(year2).month(month2).date(date5);
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit(innerDate.value, true);
      }
    };
    const handleVisibleDateChange = (value) => {
      const newDate = (0, import_dayjs11.default)(value, dateFormat.value).locale(lang.value);
      if (newDate.isValid()) {
        if (disabledDate2 && disabledDate2(newDate.toDate())) {
          return;
        }
        const { hour, minute, second } = getUnits(innerDate.value);
        innerDate.value = newDate.hour(hour).minute(minute).second(second);
        userInputDate.value = null;
        emit(innerDate.value, true);
      }
    };
    const isValidValue3 = (date5) => {
      return import_dayjs11.default.isDayjs(date5) && date5.isValid() && (disabledDate2 ? !disabledDate2(date5.toDate()) : true);
    };
    const formatToString = (value) => {
      if (selectionMode.value === "dates") {
        return value.map((_2) => _2.format(props.format));
      }
      return value.format(props.format);
    };
    const parseUserInput = (value) => {
      return (0, import_dayjs11.default)(value, props.format).locale(lang.value);
    };
    const getDefaultValue2 = () => {
      const parseDate2 = (0, import_dayjs11.default)(defaultValue.value).locale(lang.value);
      if (!defaultValue.value) {
        const defaultTimeDValue = defaultTimeD.value;
        return (0, import_dayjs11.default)().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
      }
      return parseDate2;
    };
    const handleFocusPicker = async () => {
      var _a2;
      if (["week", "month", "year", "date"].includes(selectionMode.value)) {
        (_a2 = currentViewRef.value) == null ? void 0 : _a2.focus();
        if (selectionMode.value === "week") {
          handleKeyControl(EVENT_CODE.down);
        }
      }
    };
    const handleKeydownTable = (event) => {
      const { code } = event;
      const validCode = [
        EVENT_CODE.up,
        EVENT_CODE.down,
        EVENT_CODE.left,
        EVENT_CODE.right,
        EVENT_CODE.home,
        EVENT_CODE.end,
        EVENT_CODE.pageUp,
        EVENT_CODE.pageDown
      ];
      if (validCode.includes(code)) {
        handleKeyControl(code);
        event.stopPropagation();
        event.preventDefault();
      }
      if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code) && userInputDate.value === null && userInputTime.value === null) {
        event.preventDefault();
        emit(innerDate.value, false);
      }
    };
    const handleKeyControl = (code) => {
      var _a2;
      const { up: up2, down: down2, left: left2, right: right2, home: home2, end: end2, pageUp: pageUp2, pageDown: pageDown2 } = EVENT_CODE;
      const mapping = {
        year: {
          [up2]: -4,
          [down2]: 4,
          [left2]: -1,
          [right2]: 1,
          offset: (date5, step) => date5.setFullYear(date5.getFullYear() + step)
        },
        month: {
          [up2]: -4,
          [down2]: 4,
          [left2]: -1,
          [right2]: 1,
          offset: (date5, step) => date5.setMonth(date5.getMonth() + step)
        },
        week: {
          [up2]: -1,
          [down2]: 1,
          [left2]: -1,
          [right2]: 1,
          offset: (date5, step) => date5.setDate(date5.getDate() + step * 7)
        },
        date: {
          [up2]: -7,
          [down2]: 7,
          [left2]: -1,
          [right2]: 1,
          [home2]: (date5) => -date5.getDay(),
          [end2]: (date5) => -date5.getDay() + 6,
          [pageUp2]: (date5) => -new Date(date5.getFullYear(), date5.getMonth(), 0).getDate(),
          [pageDown2]: (date5) => new Date(date5.getFullYear(), date5.getMonth() + 1, 0).getDate(),
          offset: (date5, step) => date5.setDate(date5.getDate() + step)
        }
      };
      const newDate = innerDate.value.toDate();
      while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
        const map2 = mapping[keyboardMode.value];
        if (!map2)
          return;
        map2.offset(newDate, (0, import_shared54.isFunction)(map2[code]) ? map2[code](newDate) : (_a2 = map2[code]) != null ? _a2 : 0);
        if (disabledDate2 && disabledDate2(newDate)) {
          break;
        }
        const result = (0, import_dayjs11.default)(newDate).locale(lang.value);
        innerDate.value = result;
        contextEmit("pick", result, true);
        break;
      }
    };
    const handlePanelChange = (mode) => {
      contextEmit("panel-change", innerDate.value.toDate(), mode, currentView.value);
    };
    (0, import_vue403.watch)(() => selectionMode.value, (val) => {
      if (["month", "year"].includes(val)) {
        currentView.value = val;
        return;
      }
      currentView.value = "date";
    }, { immediate: true });
    (0, import_vue403.watch)(() => currentView.value, () => {
      popper == null ? void 0 : popper.updatePopper();
    });
    (0, import_vue403.watch)(() => defaultValue.value, (val) => {
      if (val) {
        innerDate.value = getDefaultValue2();
      }
    }, { immediate: true });
    (0, import_vue403.watch)(() => props.parsedValue, (val) => {
      if (val) {
        if (selectionMode.value === "dates")
          return;
        if (Array.isArray(val))
          return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue2();
      }
    }, { immediate: true });
    contextEmit("set-picker-option", ["isValidValue", isValidValue3]);
    contextEmit("set-picker-option", ["formatToString", formatToString]);
    contextEmit("set-picker-option", ["parseUserInput", parseUserInput]);
    contextEmit("set-picker-option", ["handleFocusPicker", handleFocusPicker]);
    return (_ctx, _cache) => {
      return (0, import_vue403.openBlock)(), (0, import_vue403.createElementBlock)("div", {
        class: (0, import_vue403.normalizeClass)([
          (0, import_vue403.unref)(ppNs).b(),
          (0, import_vue403.unref)(dpNs).b(),
          {
            "has-sidebar": _ctx.$slots.sidebar || (0, import_vue403.unref)(hasShortcuts),
            "has-time": (0, import_vue403.unref)(showTime)
          }
        ])
      }, [
        (0, import_vue403.createElementVNode)("div", {
          class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("body-wrapper"))
        }, [
          (0, import_vue403.renderSlot)(_ctx.$slots, "sidebar", {
            class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("sidebar"))
          }),
          (0, import_vue403.unref)(hasShortcuts) ? ((0, import_vue403.openBlock)(), (0, import_vue403.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("sidebar"))
          }, [
            ((0, import_vue403.openBlock)(true), (0, import_vue403.createElementBlock)(import_vue403.Fragment, null, (0, import_vue403.renderList)((0, import_vue403.unref)(shortcuts2), (shortcut, key) => {
              return (0, import_vue403.openBlock)(), (0, import_vue403.createElementBlock)("button", {
                key,
                type: "button",
                class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("shortcut")),
                onClick: ($event) => handleShortcutClick(shortcut)
              }, (0, import_vue403.toDisplayString)(shortcut.text), 11, _hoisted_132);
            }), 128))
          ], 2)) : (0, import_vue403.createCommentVNode)("v-if", true),
          (0, import_vue403.createElementVNode)("div", {
            class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("body"))
          }, [
            (0, import_vue403.unref)(showTime) ? ((0, import_vue403.openBlock)(), (0, import_vue403.createElementBlock)("div", {
              key: 0,
              class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(dpNs).e("time-header"))
            }, [
              (0, import_vue403.createElementVNode)("span", {
                class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(dpNs).e("editor-wrap"))
              }, [
                (0, import_vue403.createVNode)((0, import_vue403.unref)(ElInput), {
                  placeholder: (0, import_vue403.unref)(t)("el.datepicker.selectDate"),
                  "model-value": (0, import_vue403.unref)(visibleDate),
                  size: "small",
                  "validate-event": false,
                  onInput: _cache[0] || (_cache[0] = (val) => userInputDate.value = val),
                  onChange: handleVisibleDateChange
                }, null, 8, ["placeholder", "model-value"])
              ], 2),
              (0, import_vue403.withDirectives)(((0, import_vue403.openBlock)(), (0, import_vue403.createElementBlock)("span", {
                class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(dpNs).e("editor-wrap"))
              }, [
                (0, import_vue403.createVNode)((0, import_vue403.unref)(ElInput), {
                  placeholder: (0, import_vue403.unref)(t)("el.datepicker.selectTime"),
                  "model-value": (0, import_vue403.unref)(visibleTime),
                  size: "small",
                  "validate-event": false,
                  onFocus: onTimePickerInputFocus,
                  onInput: _cache[1] || (_cache[1] = (val) => userInputTime.value = val),
                  onChange: handleVisibleTimeChange
                }, null, 8, ["placeholder", "model-value"]),
                (0, import_vue403.createVNode)((0, import_vue403.unref)(TimePickPanel), {
                  visible: timePickerVisible.value,
                  format: (0, import_vue403.unref)(timeFormat),
                  "time-arrow-control": (0, import_vue403.unref)(arrowControl),
                  "parsed-value": innerDate.value,
                  onPick: handleTimePick
                }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
              ], 2)), [
                [(0, import_vue403.unref)(ClickOutside), handleTimePickClose]
              ])
            ], 2)) : (0, import_vue403.createCommentVNode)("v-if", true),
            (0, import_vue403.withDirectives)((0, import_vue403.createElementVNode)("div", {
              class: (0, import_vue403.normalizeClass)([
                (0, import_vue403.unref)(dpNs).e("header"),
                (currentView.value === "year" || currentView.value === "month") && (0, import_vue403.unref)(dpNs).e("header--bordered")
              ])
            }, [
              (0, import_vue403.createElementVNode)("span", {
                class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(dpNs).e("prev-btn"))
              }, [
                (0, import_vue403.createElementVNode)("button", {
                  type: "button",
                  "aria-label": (0, import_vue403.unref)(t)(`el.datepicker.prevYear`),
                  class: (0, import_vue403.normalizeClass)(["d-arrow-left", (0, import_vue403.unref)(ppNs).e("icon-btn")]),
                  onClick: _cache[2] || (_cache[2] = ($event) => moveByYear(false))
                }, [
                  (0, import_vue403.createVNode)((0, import_vue403.unref)(ElIcon), null, {
                    default: (0, import_vue403.withCtx)(() => [
                      (0, import_vue403.createVNode)((0, import_vue403.unref)(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_222),
                (0, import_vue403.withDirectives)((0, import_vue403.createElementVNode)("button", {
                  type: "button",
                  "aria-label": (0, import_vue403.unref)(t)(`el.datepicker.prevMonth`),
                  class: (0, import_vue403.normalizeClass)([(0, import_vue403.unref)(ppNs).e("icon-btn"), "arrow-left"]),
                  onClick: _cache[3] || (_cache[3] = ($event) => moveByMonth(false))
                }, [
                  (0, import_vue403.createVNode)((0, import_vue403.unref)(ElIcon), null, {
                    default: (0, import_vue403.withCtx)(() => [
                      (0, import_vue403.createVNode)((0, import_vue403.unref)(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_313), [
                  [import_vue403.vShow, currentView.value === "date"]
                ])
              ], 2),
              (0, import_vue403.createElementVNode)("span", {
                role: "button",
                class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(dpNs).e("header-label")),
                "aria-live": "polite",
                tabindex: "0",
                onKeydown: _cache[4] || (_cache[4] = (0, import_vue403.withKeys)(($event) => showPicker("year"), ["enter"])),
                onClick: _cache[5] || (_cache[5] = ($event) => showPicker("year"))
              }, (0, import_vue403.toDisplayString)((0, import_vue403.unref)(yearLabel)), 35),
              (0, import_vue403.withDirectives)((0, import_vue403.createElementVNode)("span", {
                role: "button",
                "aria-live": "polite",
                tabindex: "0",
                class: (0, import_vue403.normalizeClass)([
                  (0, import_vue403.unref)(dpNs).e("header-label"),
                  { active: currentView.value === "month" }
                ]),
                onKeydown: _cache[6] || (_cache[6] = (0, import_vue403.withKeys)(($event) => showPicker("month"), ["enter"])),
                onClick: _cache[7] || (_cache[7] = ($event) => showPicker("month"))
              }, (0, import_vue403.toDisplayString)((0, import_vue403.unref)(t)(`el.datepicker.month${(0, import_vue403.unref)(month) + 1}`)), 35), [
                [import_vue403.vShow, currentView.value === "date"]
              ]),
              (0, import_vue403.createElementVNode)("span", {
                class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(dpNs).e("next-btn"))
              }, [
                (0, import_vue403.withDirectives)((0, import_vue403.createElementVNode)("button", {
                  type: "button",
                  "aria-label": (0, import_vue403.unref)(t)(`el.datepicker.nextMonth`),
                  class: (0, import_vue403.normalizeClass)([(0, import_vue403.unref)(ppNs).e("icon-btn"), "arrow-right"]),
                  onClick: _cache[8] || (_cache[8] = ($event) => moveByMonth(true))
                }, [
                  (0, import_vue403.createVNode)((0, import_vue403.unref)(ElIcon), null, {
                    default: (0, import_vue403.withCtx)(() => [
                      (0, import_vue403.createVNode)((0, import_vue403.unref)(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_43), [
                  [import_vue403.vShow, currentView.value === "date"]
                ]),
                (0, import_vue403.createElementVNode)("button", {
                  type: "button",
                  "aria-label": (0, import_vue403.unref)(t)(`el.datepicker.nextYear`),
                  class: (0, import_vue403.normalizeClass)([(0, import_vue403.unref)(ppNs).e("icon-btn"), "d-arrow-right"]),
                  onClick: _cache[9] || (_cache[9] = ($event) => moveByYear(true))
                }, [
                  (0, import_vue403.createVNode)((0, import_vue403.unref)(ElIcon), null, {
                    default: (0, import_vue403.withCtx)(() => [
                      (0, import_vue403.createVNode)((0, import_vue403.unref)(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_5)
              ], 2)
            ], 2), [
              [import_vue403.vShow, currentView.value !== "time"]
            ]),
            (0, import_vue403.createElementVNode)("div", {
              class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("content")),
              onKeydown: handleKeydownTable
            }, [
              currentView.value === "date" ? ((0, import_vue403.openBlock)(), (0, import_vue403.createBlock)(DateTable2, {
                key: 0,
                ref_key: "currentViewRef",
                ref: currentViewRef,
                "selection-mode": (0, import_vue403.unref)(selectionMode),
                date: innerDate.value,
                "parsed-value": _ctx.parsedValue,
                "disabled-date": (0, import_vue403.unref)(disabledDate2),
                "cell-class-name": (0, import_vue403.unref)(cellClassName),
                onPick: handleDatePick
              }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : (0, import_vue403.createCommentVNode)("v-if", true),
              currentView.value === "year" ? ((0, import_vue403.openBlock)(), (0, import_vue403.createBlock)(YearTable, {
                key: 1,
                ref_key: "currentViewRef",
                ref: currentViewRef,
                date: innerDate.value,
                "disabled-date": (0, import_vue403.unref)(disabledDate2),
                "parsed-value": _ctx.parsedValue,
                onPick: handleYearPick
              }, null, 8, ["date", "disabled-date", "parsed-value"])) : (0, import_vue403.createCommentVNode)("v-if", true),
              currentView.value === "month" ? ((0, import_vue403.openBlock)(), (0, import_vue403.createBlock)(MonthTable, {
                key: 2,
                ref_key: "currentViewRef",
                ref: currentViewRef,
                date: innerDate.value,
                "parsed-value": _ctx.parsedValue,
                "disabled-date": (0, import_vue403.unref)(disabledDate2),
                onPick: handleMonthPick
              }, null, 8, ["date", "parsed-value", "disabled-date"])) : (0, import_vue403.createCommentVNode)("v-if", true)
            ], 34)
          ], 2)
        ], 2),
        (0, import_vue403.withDirectives)((0, import_vue403.createElementVNode)("div", {
          class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("footer"))
        }, [
          (0, import_vue403.withDirectives)((0, import_vue403.createVNode)((0, import_vue403.unref)(ElButton), {
            text: "",
            size: "small",
            class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("link-btn")),
            onClick: changeToNow
          }, {
            default: (0, import_vue403.withCtx)(() => [
              (0, import_vue403.createTextVNode)((0, import_vue403.toDisplayString)((0, import_vue403.unref)(t)("el.datepicker.now")), 1)
            ]),
            _: 1
          }, 8, ["class"]), [
            [import_vue403.vShow, (0, import_vue403.unref)(selectionMode) !== "dates"]
          ]),
          (0, import_vue403.createVNode)((0, import_vue403.unref)(ElButton), {
            plain: "",
            size: "small",
            class: (0, import_vue403.normalizeClass)((0, import_vue403.unref)(ppNs).e("link-btn")),
            onClick: onConfirm
          }, {
            default: (0, import_vue403.withCtx)(() => [
              (0, import_vue403.createTextVNode)((0, import_vue403.toDisplayString)((0, import_vue403.unref)(t)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class"])
        ], 2), [
          [import_vue403.vShow, (0, import_vue403.unref)(footerVisible) && currentView.value === "date"]
        ])
      ], 2);
    };
  }
});
var DatePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main62, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-date-range.mjs
var import_vue406 = require("vue");
var import_dayjs13 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/panel-date-range.mjs
var panelDateRangeProps = buildProps({
  ...panelSharedProps,
  ...panelRangeSharedProps
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/composables/use-range-picker.mjs
var import_vue405 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/composables/use-shortcut.mjs
var import_vue404 = require("vue");
var import_dayjs12 = __toESM(require_dayjs_min(), 1);
var import_shared56 = require("@vue/shared");
var useShortcut = (lang) => {
  const { emit } = (0, import_vue404.getCurrentInstance)();
  const attrs = (0, import_vue404.useAttrs)();
  const slots = (0, import_vue404.useSlots)();
  const handleShortcutClick = (shortcut) => {
    const shortcutValues = (0, import_shared56.isFunction)(shortcut.value) ? shortcut.value() : shortcut.value;
    if (shortcutValues) {
      emit("pick", [
        (0, import_dayjs12.default)(shortcutValues[0]).locale(lang.value),
        (0, import_dayjs12.default)(shortcutValues[1]).locale(lang.value)
      ]);
      return;
    }
    if (shortcut.onClick) {
      shortcut.onClick({
        attrs,
        slots,
        emit
      });
    }
  };
  return handleShortcutClick;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/composables/use-range-picker.mjs
var import_shared57 = require("@vue/shared");
var useRangePicker = (props, {
  defaultValue,
  leftDate,
  rightDate,
  unit: unit3,
  onParsedValueChanged
}) => {
  const { emit } = (0, import_vue405.getCurrentInstance)();
  const { pickerNs } = (0, import_vue405.inject)(ROOT_PICKER_INJECTION_KEY);
  const drpNs = useNamespace("date-range-picker");
  const { t, lang } = useLocale();
  const handleShortcutClick = useShortcut(lang);
  const minDate = (0, import_vue405.ref)();
  const maxDate = (0, import_vue405.ref)();
  const rangeState = (0, import_vue405.ref)({
    endDate: null,
    selecting: false
  });
  const handleChangeRange = (val) => {
    rangeState.value = val;
  };
  const handleRangeConfirm = (visible = false) => {
    const _minDate = (0, import_vue405.unref)(minDate);
    const _maxDate = (0, import_vue405.unref)(maxDate);
    if (isValidRange2([_minDate, _maxDate])) {
      emit("pick", [_minDate, _maxDate], visible);
    }
  };
  const onSelect = (selecting) => {
    rangeState.value.selecting = selecting;
    if (!selecting) {
      rangeState.value.endDate = null;
    }
  };
  const restoreDefault = () => {
    const [start, end2] = getDefaultValue((0, import_vue405.unref)(defaultValue), {
      lang: (0, import_vue405.unref)(lang),
      unit: unit3,
      unlinkPanels: props.unlinkPanels
    });
    minDate.value = void 0;
    maxDate.value = void 0;
    leftDate.value = start;
    rightDate.value = end2;
  };
  (0, import_vue405.watch)(defaultValue, (val) => {
    if (val) {
      restoreDefault();
    }
  }, { immediate: true });
  (0, import_vue405.watch)(() => props.parsedValue, (parsedValue2) => {
    if ((0, import_shared57.isArray)(parsedValue2) && parsedValue2.length === 2) {
      const [start, end2] = parsedValue2;
      minDate.value = start;
      leftDate.value = start;
      maxDate.value = end2;
      onParsedValueChanged((0, import_vue405.unref)(minDate), (0, import_vue405.unref)(maxDate));
    } else {
      restoreDefault();
    }
  }, { immediate: true });
  return {
    minDate,
    maxDate,
    rangeState,
    lang,
    ppNs: pickerNs,
    drpNs,
    handleChangeRange,
    handleRangeConfirm,
    handleShortcutClick,
    onSelect,
    t
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-date-range.mjs
var import_shared58 = require("@vue/shared");
var _hoisted_133 = ["onClick"];
var _hoisted_223 = ["disabled"];
var _hoisted_315 = ["disabled"];
var _hoisted_45 = ["disabled"];
var _hoisted_52 = ["disabled"];
var unit = "month";
var _sfc_main63 = /* @__PURE__ */ (0, import_vue406.defineComponent)({
  __name: "panel-date-range",
  props: panelDateRangeProps,
  emits: [
    "pick",
    "set-picker-option",
    "calendar-change",
    "panel-change"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const pickerBase = (0, import_vue406.inject)("EP_PICKER_BASE");
    const {
      disabledDate: disabledDate2,
      cellClassName,
      format: format2,
      defaultTime,
      arrowControl,
      clearable
    } = pickerBase.props;
    const shortcuts2 = (0, import_vue406.toRef)(pickerBase.props, "shortcuts");
    const defaultValue = (0, import_vue406.toRef)(pickerBase.props, "defaultValue");
    const { lang } = useLocale();
    const leftDate = (0, import_vue406.ref)((0, import_dayjs13.default)().locale(lang.value));
    const rightDate = (0, import_vue406.ref)((0, import_dayjs13.default)().locale(lang.value).add(1, unit));
    const {
      minDate,
      maxDate,
      rangeState,
      ppNs,
      drpNs,
      handleChangeRange,
      handleRangeConfirm,
      handleShortcutClick,
      onSelect,
      t
    } = useRangePicker(props, {
      defaultValue,
      leftDate,
      rightDate,
      unit,
      onParsedValueChanged
    });
    const dateUserInput = (0, import_vue406.ref)({
      min: null,
      max: null
    });
    const timeUserInput = (0, import_vue406.ref)({
      min: null,
      max: null
    });
    const leftLabel = (0, import_vue406.computed)(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
    });
    const rightLabel = (0, import_vue406.computed)(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
    });
    const leftYear = (0, import_vue406.computed)(() => {
      return leftDate.value.year();
    });
    const leftMonth = (0, import_vue406.computed)(() => {
      return leftDate.value.month();
    });
    const rightYear = (0, import_vue406.computed)(() => {
      return rightDate.value.year();
    });
    const rightMonth = (0, import_vue406.computed)(() => {
      return rightDate.value.month();
    });
    const hasShortcuts = (0, import_vue406.computed)(() => !!shortcuts2.value.length);
    const minVisibleDate = (0, import_vue406.computed)(() => {
      if (dateUserInput.value.min !== null)
        return dateUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(dateFormat.value);
      return "";
    });
    const maxVisibleDate = (0, import_vue406.computed)(() => {
      if (dateUserInput.value.max !== null)
        return dateUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(dateFormat.value);
      return "";
    });
    const minVisibleTime = (0, import_vue406.computed)(() => {
      if (timeUserInput.value.min !== null)
        return timeUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(timeFormat.value);
      return "";
    });
    const maxVisibleTime = (0, import_vue406.computed)(() => {
      if (timeUserInput.value.max !== null)
        return timeUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(timeFormat.value);
      return "";
    });
    const timeFormat = (0, import_vue406.computed)(() => {
      return extractTimeFormat(format2);
    });
    const dateFormat = (0, import_vue406.computed)(() => {
      return extractDateFormat(format2);
    });
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
      handlePanelChange("year");
    };
    const leftPrevMonth = () => {
      leftDate.value = leftDate.value.subtract(1, "month");
      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
      handlePanelChange("month");
    };
    const rightNextYear = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "year");
      }
      handlePanelChange("year");
    };
    const rightNextMonth = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "month");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "month");
      }
      handlePanelChange("month");
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
      handlePanelChange("year");
    };
    const leftNextMonth = () => {
      leftDate.value = leftDate.value.add(1, "month");
      handlePanelChange("month");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
      handlePanelChange("year");
    };
    const rightPrevMonth = () => {
      rightDate.value = rightDate.value.subtract(1, "month");
      handlePanelChange("month");
    };
    const handlePanelChange = (mode) => {
      emit("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
    };
    const enableMonthArrow = (0, import_vue406.computed)(() => {
      const nextMonth = (leftMonth.value + 1) % 12;
      const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    const enableYearArrow = (0, import_vue406.computed)(() => {
      return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });
    const btnDisabled = (0, import_vue406.computed)(() => {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidRange2([minDate.value, maxDate.value]));
    });
    const showTime = (0, import_vue406.computed)(() => props.type === "datetime" || props.type === "datetimerange");
    const formatEmit = (emitDayjs, index2) => {
      if (!emitDayjs)
        return;
      if (defaultTime) {
        const defaultTimeD = (0, import_dayjs13.default)(defaultTime[index2] || defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      return emitDayjs;
    };
    const handleRangePick = (val, close2 = true) => {
      const min_ = val.minDate;
      const max_ = val.maxDate;
      const minDate_ = formatEmit(min_, 0);
      const maxDate_ = formatEmit(max_, 1);
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2 || showTime.value)
        return;
      handleRangeConfirm();
    };
    const minTimePickerVisible = (0, import_vue406.ref)(false);
    const maxTimePickerVisible = (0, import_vue406.ref)(false);
    const handleMinTimeClose = () => {
      minTimePickerVisible.value = false;
    };
    const handleMaxTimeClose = () => {
      maxTimePickerVisible.value = false;
    };
    const handleDateInput = (value, type4) => {
      dateUserInput.value[type4] = value;
      const parsedValueD = (0, import_dayjs13.default)(value, dateFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (disabledDate2 && disabledDate2(parsedValueD.toDate())) {
          return;
        }
        if (type4 === "min") {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, "month");
            maxDate.value = minDate.value.add(1, "month");
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, "month");
            minDate.value = maxDate.value.subtract(1, "month");
          }
        }
      }
    };
    const handleDateChange = (_2, type4) => {
      dateUserInput.value[type4] = null;
    };
    const handleTimeInput = (value, type4) => {
      timeUserInput.value[type4] = value;
      const parsedValueD = (0, import_dayjs13.default)(value, timeFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (type4 === "min") {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;
          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };
    const handleTimeChange = (value, type4) => {
      timeUserInput.value[type4] = null;
      if (type4 === "min") {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };
    const handleMinTimePick = (value, visible, first) => {
      if (timeUserInput.value.min)
        return;
      if (value) {
        leftDate.value = value;
        minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        minTimePickerVisible.value = visible;
      }
      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
        rightDate.value = value;
      }
    };
    const handleMaxTimePick = (value, visible, first) => {
      if (timeUserInput.value.max)
        return;
      if (value) {
        rightDate.value = value;
        maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        maxTimePickerVisible.value = visible;
      }
      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };
    const handleClear = () => {
      leftDate.value = getDefaultValue((0, import_vue406.unref)(defaultValue), {
        lang: (0, import_vue406.unref)(lang),
        unit: "month",
        unlinkPanels: props.unlinkPanels
      })[0];
      rightDate.value = leftDate.value.add(1, "month");
      emit("pick", null);
    };
    const formatToString = (value) => {
      return (0, import_shared58.isArray)(value) ? value.map((_2) => _2.format(format2)) : value.format(format2);
    };
    const parseUserInput = (value) => {
      return (0, import_shared58.isArray)(value) ? value.map((_2) => (0, import_dayjs13.default)(_2, format2).locale(lang.value)) : (0, import_dayjs13.default)(value, format2).locale(lang.value);
    };
    function onParsedValueChanged(minDate2, maxDate2) {
      if (props.unlinkPanels && maxDate2) {
        const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
        const minDateMonth = (minDate2 == null ? void 0 : minDate2.month()) || 0;
        const maxDateYear = maxDate2.year();
        const maxDateMonth = maxDate2.month();
        rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate2.add(1, unit) : maxDate2;
      } else {
        rightDate.value = leftDate.value.add(1, unit);
        if (maxDate2) {
          rightDate.value = rightDate.value.hour(maxDate2.hour()).minute(maxDate2.minute()).second(maxDate2.second());
        }
      }
    }
    emit("set-picker-option", ["isValidValue", isValidRange2]);
    emit("set-picker-option", ["parseUserInput", parseUserInput]);
    emit("set-picker-option", ["formatToString", formatToString]);
    emit("set-picker-option", ["handleClear", handleClear]);
    return (_ctx, _cache) => {
      return (0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("div", {
        class: (0, import_vue406.normalizeClass)([
          (0, import_vue406.unref)(ppNs).b(),
          (0, import_vue406.unref)(drpNs).b(),
          {
            "has-sidebar": _ctx.$slots.sidebar || (0, import_vue406.unref)(hasShortcuts),
            "has-time": (0, import_vue406.unref)(showTime)
          }
        ])
      }, [
        (0, import_vue406.createElementVNode)("div", {
          class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("body-wrapper"))
        }, [
          (0, import_vue406.renderSlot)(_ctx.$slots, "sidebar", {
            class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("sidebar"))
          }),
          (0, import_vue406.unref)(hasShortcuts) ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("sidebar"))
          }, [
            ((0, import_vue406.openBlock)(true), (0, import_vue406.createElementBlock)(import_vue406.Fragment, null, (0, import_vue406.renderList)((0, import_vue406.unref)(shortcuts2), (shortcut, key) => {
              return (0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("button", {
                key,
                type: "button",
                class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("shortcut")),
                onClick: ($event) => (0, import_vue406.unref)(handleShortcutClick)(shortcut)
              }, (0, import_vue406.toDisplayString)(shortcut.text), 11, _hoisted_133);
            }), 128))
          ], 2)) : (0, import_vue406.createCommentVNode)("v-if", true),
          (0, import_vue406.createElementVNode)("div", {
            class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("body"))
          }, [
            (0, import_vue406.unref)(showTime) ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("div", {
              key: 0,
              class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("time-header"))
            }, [
              (0, import_vue406.createElementVNode)("span", {
                class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("editors-wrap"))
              }, [
                (0, import_vue406.createElementVNode)("span", {
                  class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("time-picker-wrap"))
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElInput), {
                    size: "small",
                    disabled: (0, import_vue406.unref)(rangeState).selecting,
                    placeholder: (0, import_vue406.unref)(t)("el.datepicker.startDate"),
                    class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("editor")),
                    "model-value": (0, import_vue406.unref)(minVisibleDate),
                    "validate-event": false,
                    onInput: _cache[0] || (_cache[0] = (val) => handleDateInput(val, "min")),
                    onChange: _cache[1] || (_cache[1] = (val) => handleDateChange(val, "min"))
                  }, null, 8, ["disabled", "placeholder", "class", "model-value"])
                ], 2),
                (0, import_vue406.withDirectives)(((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("span", {
                  class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("time-picker-wrap"))
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElInput), {
                    size: "small",
                    class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("editor")),
                    disabled: (0, import_vue406.unref)(rangeState).selecting,
                    placeholder: (0, import_vue406.unref)(t)("el.datepicker.startTime"),
                    "model-value": (0, import_vue406.unref)(minVisibleTime),
                    "validate-event": false,
                    onFocus: _cache[2] || (_cache[2] = ($event) => minTimePickerVisible.value = true),
                    onInput: _cache[3] || (_cache[3] = (val) => handleTimeInput(val, "min")),
                    onChange: _cache[4] || (_cache[4] = (val) => handleTimeChange(val, "min"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value"]),
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(TimePickPanel), {
                    visible: minTimePickerVisible.value,
                    format: (0, import_vue406.unref)(timeFormat),
                    "datetime-role": "start",
                    "time-arrow-control": (0, import_vue406.unref)(arrowControl),
                    "parsed-value": leftDate.value,
                    onPick: handleMinTimePick
                  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                ], 2)), [
                  [(0, import_vue406.unref)(ClickOutside), handleMinTimeClose]
                ])
              ], 2),
              (0, import_vue406.createElementVNode)("span", null, [
                (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                  default: (0, import_vue406.withCtx)(() => [
                    (0, import_vue406.createVNode)((0, import_vue406.unref)(arrow_right_default))
                  ]),
                  _: 1
                })
              ]),
              (0, import_vue406.createElementVNode)("span", {
                class: (0, import_vue406.normalizeClass)([(0, import_vue406.unref)(drpNs).e("editors-wrap"), "is-right"])
              }, [
                (0, import_vue406.createElementVNode)("span", {
                  class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("time-picker-wrap"))
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElInput), {
                    size: "small",
                    class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("editor")),
                    disabled: (0, import_vue406.unref)(rangeState).selecting,
                    placeholder: (0, import_vue406.unref)(t)("el.datepicker.endDate"),
                    "model-value": (0, import_vue406.unref)(maxVisibleDate),
                    readonly: !(0, import_vue406.unref)(minDate),
                    "validate-event": false,
                    onInput: _cache[5] || (_cache[5] = (val) => handleDateInput(val, "max")),
                    onChange: _cache[6] || (_cache[6] = (val) => handleDateChange(val, "max"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
                ], 2),
                (0, import_vue406.withDirectives)(((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("span", {
                  class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("time-picker-wrap"))
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElInput), {
                    size: "small",
                    class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("editor")),
                    disabled: (0, import_vue406.unref)(rangeState).selecting,
                    placeholder: (0, import_vue406.unref)(t)("el.datepicker.endTime"),
                    "model-value": (0, import_vue406.unref)(maxVisibleTime),
                    readonly: !(0, import_vue406.unref)(minDate),
                    "validate-event": false,
                    onFocus: _cache[7] || (_cache[7] = ($event) => (0, import_vue406.unref)(minDate) && (maxTimePickerVisible.value = true)),
                    onInput: _cache[8] || (_cache[8] = (val) => handleTimeInput(val, "max")),
                    onChange: _cache[9] || (_cache[9] = (val) => handleTimeChange(val, "max"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(TimePickPanel), {
                    "datetime-role": "end",
                    visible: maxTimePickerVisible.value,
                    format: (0, import_vue406.unref)(timeFormat),
                    "time-arrow-control": (0, import_vue406.unref)(arrowControl),
                    "parsed-value": rightDate.value,
                    onPick: handleMaxTimePick
                  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                ], 2)), [
                  [(0, import_vue406.unref)(ClickOutside), handleMaxTimeClose]
                ])
              ], 2)
            ], 2)) : (0, import_vue406.createCommentVNode)("v-if", true),
            (0, import_vue406.createElementVNode)("div", {
              class: (0, import_vue406.normalizeClass)([[(0, import_vue406.unref)(ppNs).e("content"), (0, import_vue406.unref)(drpNs).e("content")], "is-left"])
            }, [
              (0, import_vue406.createElementVNode)("div", {
                class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("header"))
              }, [
                (0, import_vue406.createElementVNode)("button", {
                  type: "button",
                  class: (0, import_vue406.normalizeClass)([(0, import_vue406.unref)(ppNs).e("icon-btn"), "d-arrow-left"]),
                  onClick: leftPrevYear
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                (0, import_vue406.createElementVNode)("button", {
                  type: "button",
                  class: (0, import_vue406.normalizeClass)([(0, import_vue406.unref)(ppNs).e("icon-btn"), "arrow-left"]),
                  onClick: leftPrevMonth
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                _ctx.unlinkPanels ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("button", {
                  key: 0,
                  type: "button",
                  disabled: !(0, import_vue406.unref)(enableYearArrow),
                  class: (0, import_vue406.normalizeClass)([[(0, import_vue406.unref)(ppNs).e("icon-btn"), { "is-disabled": !(0, import_vue406.unref)(enableYearArrow) }], "d-arrow-right"]),
                  onClick: leftNextYear
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_223)) : (0, import_vue406.createCommentVNode)("v-if", true),
                _ctx.unlinkPanels ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("button", {
                  key: 1,
                  type: "button",
                  disabled: !(0, import_vue406.unref)(enableMonthArrow),
                  class: (0, import_vue406.normalizeClass)([[
                    (0, import_vue406.unref)(ppNs).e("icon-btn"),
                    { "is-disabled": !(0, import_vue406.unref)(enableMonthArrow) }
                  ], "arrow-right"]),
                  onClick: leftNextMonth
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_315)) : (0, import_vue406.createCommentVNode)("v-if", true),
                (0, import_vue406.createElementVNode)("div", null, (0, import_vue406.toDisplayString)((0, import_vue406.unref)(leftLabel)), 1)
              ], 2),
              (0, import_vue406.createVNode)(DateTable2, {
                "selection-mode": "range",
                date: leftDate.value,
                "min-date": (0, import_vue406.unref)(minDate),
                "max-date": (0, import_vue406.unref)(maxDate),
                "range-state": (0, import_vue406.unref)(rangeState),
                "disabled-date": (0, import_vue406.unref)(disabledDate2),
                "cell-class-name": (0, import_vue406.unref)(cellClassName),
                onChangerange: (0, import_vue406.unref)(handleChangeRange),
                onPick: handleRangePick,
                onSelect: (0, import_vue406.unref)(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
            ], 2),
            (0, import_vue406.createElementVNode)("div", {
              class: (0, import_vue406.normalizeClass)([[(0, import_vue406.unref)(ppNs).e("content"), (0, import_vue406.unref)(drpNs).e("content")], "is-right"])
            }, [
              (0, import_vue406.createElementVNode)("div", {
                class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(drpNs).e("header"))
              }, [
                _ctx.unlinkPanels ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("button", {
                  key: 0,
                  type: "button",
                  disabled: !(0, import_vue406.unref)(enableYearArrow),
                  class: (0, import_vue406.normalizeClass)([[(0, import_vue406.unref)(ppNs).e("icon-btn"), { "is-disabled": !(0, import_vue406.unref)(enableYearArrow) }], "d-arrow-left"]),
                  onClick: rightPrevYear
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_45)) : (0, import_vue406.createCommentVNode)("v-if", true),
                _ctx.unlinkPanels ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("button", {
                  key: 1,
                  type: "button",
                  disabled: !(0, import_vue406.unref)(enableMonthArrow),
                  class: (0, import_vue406.normalizeClass)([[
                    (0, import_vue406.unref)(ppNs).e("icon-btn"),
                    { "is-disabled": !(0, import_vue406.unref)(enableMonthArrow) }
                  ], "arrow-left"]),
                  onClick: rightPrevMonth
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_52)) : (0, import_vue406.createCommentVNode)("v-if", true),
                (0, import_vue406.createElementVNode)("button", {
                  type: "button",
                  class: (0, import_vue406.normalizeClass)([(0, import_vue406.unref)(ppNs).e("icon-btn"), "d-arrow-right"]),
                  onClick: rightNextYear
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2),
                (0, import_vue406.createElementVNode)("button", {
                  type: "button",
                  class: (0, import_vue406.normalizeClass)([(0, import_vue406.unref)(ppNs).e("icon-btn"), "arrow-right"]),
                  onClick: rightNextMonth
                }, [
                  (0, import_vue406.createVNode)((0, import_vue406.unref)(ElIcon), null, {
                    default: (0, import_vue406.withCtx)(() => [
                      (0, import_vue406.createVNode)((0, import_vue406.unref)(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2),
                (0, import_vue406.createElementVNode)("div", null, (0, import_vue406.toDisplayString)((0, import_vue406.unref)(rightLabel)), 1)
              ], 2),
              (0, import_vue406.createVNode)(DateTable2, {
                "selection-mode": "range",
                date: rightDate.value,
                "min-date": (0, import_vue406.unref)(minDate),
                "max-date": (0, import_vue406.unref)(maxDate),
                "range-state": (0, import_vue406.unref)(rangeState),
                "disabled-date": (0, import_vue406.unref)(disabledDate2),
                "cell-class-name": (0, import_vue406.unref)(cellClassName),
                onChangerange: (0, import_vue406.unref)(handleChangeRange),
                onPick: handleRangePick,
                onSelect: (0, import_vue406.unref)(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2),
        (0, import_vue406.unref)(showTime) ? ((0, import_vue406.openBlock)(), (0, import_vue406.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("footer"))
        }, [
          (0, import_vue406.unref)(clearable) ? ((0, import_vue406.openBlock)(), (0, import_vue406.createBlock)((0, import_vue406.unref)(ElButton), {
            key: 0,
            text: "",
            size: "small",
            class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("link-btn")),
            onClick: handleClear
          }, {
            default: (0, import_vue406.withCtx)(() => [
              (0, import_vue406.createTextVNode)((0, import_vue406.toDisplayString)((0, import_vue406.unref)(t)("el.datepicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["class"])) : (0, import_vue406.createCommentVNode)("v-if", true),
          (0, import_vue406.createVNode)((0, import_vue406.unref)(ElButton), {
            plain: "",
            size: "small",
            class: (0, import_vue406.normalizeClass)((0, import_vue406.unref)(ppNs).e("link-btn")),
            disabled: (0, import_vue406.unref)(btnDisabled),
            onClick: _cache[10] || (_cache[10] = ($event) => (0, import_vue406.unref)(handleRangeConfirm)(false))
          }, {
            default: (0, import_vue406.withCtx)(() => [
              (0, import_vue406.createTextVNode)((0, import_vue406.toDisplayString)((0, import_vue406.unref)(t)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])
        ], 2)) : (0, import_vue406.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var DateRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main63, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-month-range.mjs
var import_vue408 = require("vue");
var import_dayjs14 = __toESM(require_dayjs_min(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/props/panel-month-range.mjs
var panelMonthRangeProps = buildProps({
  ...panelRangeSharedProps
});
var panelMonthRangeEmits = ["pick", "set-picker-option"];

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/composables/use-month-range-header.mjs
var import_vue407 = require("vue");
var useMonthRangeHeader = ({
  unlinkPanels,
  leftDate,
  rightDate
}) => {
  const { t } = useLocale();
  const leftPrevYear = () => {
    leftDate.value = leftDate.value.subtract(1, "year");
    if (!unlinkPanels.value) {
      rightDate.value = rightDate.value.subtract(1, "year");
    }
  };
  const rightNextYear = () => {
    if (!unlinkPanels.value) {
      leftDate.value = leftDate.value.add(1, "year");
    }
    rightDate.value = rightDate.value.add(1, "year");
  };
  const leftNextYear = () => {
    leftDate.value = leftDate.value.add(1, "year");
  };
  const rightPrevYear = () => {
    rightDate.value = rightDate.value.subtract(1, "year");
  };
  const leftLabel = (0, import_vue407.computed)(() => {
    return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
  });
  const rightLabel = (0, import_vue407.computed)(() => {
    return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
  });
  const leftYear = (0, import_vue407.computed)(() => {
    return leftDate.value.year();
  });
  const rightYear = (0, import_vue407.computed)(() => {
    return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
  });
  return {
    leftPrevYear,
    rightNextYear,
    leftNextYear,
    rightPrevYear,
    leftLabel,
    rightLabel,
    leftYear,
    rightYear
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-month-range.mjs
var _hoisted_136 = ["onClick"];
var _hoisted_224 = ["disabled"];
var _hoisted_316 = ["disabled"];
var unit2 = "year";
var __default__46 = (0, import_vue408.defineComponent)({
  name: "DatePickerMonthRange"
});
var _sfc_main64 = /* @__PURE__ */ (0, import_vue408.defineComponent)({
  ...__default__46,
  props: panelMonthRangeProps,
  emits: panelMonthRangeEmits,
  setup(__props, { emit }) {
    const props = __props;
    const { lang } = useLocale();
    const pickerBase = (0, import_vue408.inject)("EP_PICKER_BASE");
    const { shortcuts: shortcuts2, disabledDate: disabledDate2, format: format2 } = pickerBase.props;
    const defaultValue = (0, import_vue408.toRef)(pickerBase.props, "defaultValue");
    const leftDate = (0, import_vue408.ref)((0, import_dayjs14.default)().locale(lang.value));
    const rightDate = (0, import_vue408.ref)((0, import_dayjs14.default)().locale(lang.value).add(1, unit2));
    const {
      minDate,
      maxDate,
      rangeState,
      ppNs,
      drpNs,
      handleChangeRange,
      handleRangeConfirm,
      handleShortcutClick,
      onSelect
    } = useRangePicker(props, {
      defaultValue,
      leftDate,
      rightDate,
      unit: unit2,
      onParsedValueChanged
    });
    const hasShortcuts = (0, import_vue408.computed)(() => !!shortcuts2.length);
    const {
      leftPrevYear,
      rightNextYear,
      leftNextYear,
      rightPrevYear,
      leftLabel,
      rightLabel,
      leftYear,
      rightYear
    } = useMonthRangeHeader({
      unlinkPanels: (0, import_vue408.toRef)(props, "unlinkPanels"),
      leftDate,
      rightDate
    });
    const enableYearArrow = (0, import_vue408.computed)(() => {
      return props.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    const handleRangePick = (val, close2 = true) => {
      const minDate_ = val.minDate;
      const maxDate_ = val.maxDate;
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2)
        return;
      handleRangeConfirm();
    };
    const formatToString = (days) => {
      return days.map((day) => day.format(format2));
    };
    function onParsedValueChanged(minDate2, maxDate2) {
      if (props.unlinkPanels && maxDate2) {
        const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
        const maxDateYear = maxDate2.year();
        rightDate.value = minDateYear === maxDateYear ? maxDate2.add(1, unit2) : maxDate2;
      } else {
        rightDate.value = leftDate.value.add(1, unit2);
      }
    }
    emit("set-picker-option", ["formatToString", formatToString]);
    return (_ctx, _cache) => {
      return (0, import_vue408.openBlock)(), (0, import_vue408.createElementBlock)("div", {
        class: (0, import_vue408.normalizeClass)([
          (0, import_vue408.unref)(ppNs).b(),
          (0, import_vue408.unref)(drpNs).b(),
          {
            "has-sidebar": Boolean(_ctx.$slots.sidebar) || (0, import_vue408.unref)(hasShortcuts)
          }
        ])
      }, [
        (0, import_vue408.createElementVNode)("div", {
          class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(ppNs).e("body-wrapper"))
        }, [
          (0, import_vue408.renderSlot)(_ctx.$slots, "sidebar", {
            class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(ppNs).e("sidebar"))
          }),
          (0, import_vue408.unref)(hasShortcuts) ? ((0, import_vue408.openBlock)(), (0, import_vue408.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(ppNs).e("sidebar"))
          }, [
            ((0, import_vue408.openBlock)(true), (0, import_vue408.createElementBlock)(import_vue408.Fragment, null, (0, import_vue408.renderList)((0, import_vue408.unref)(shortcuts2), (shortcut, key) => {
              return (0, import_vue408.openBlock)(), (0, import_vue408.createElementBlock)("button", {
                key,
                type: "button",
                class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(ppNs).e("shortcut")),
                onClick: ($event) => (0, import_vue408.unref)(handleShortcutClick)(shortcut)
              }, (0, import_vue408.toDisplayString)(shortcut.text), 11, _hoisted_136);
            }), 128))
          ], 2)) : (0, import_vue408.createCommentVNode)("v-if", true),
          (0, import_vue408.createElementVNode)("div", {
            class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(ppNs).e("body"))
          }, [
            (0, import_vue408.createElementVNode)("div", {
              class: (0, import_vue408.normalizeClass)([[(0, import_vue408.unref)(ppNs).e("content"), (0, import_vue408.unref)(drpNs).e("content")], "is-left"])
            }, [
              (0, import_vue408.createElementVNode)("div", {
                class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(drpNs).e("header"))
              }, [
                (0, import_vue408.createElementVNode)("button", {
                  type: "button",
                  class: (0, import_vue408.normalizeClass)([(0, import_vue408.unref)(ppNs).e("icon-btn"), "d-arrow-left"]),
                  onClick: _cache[0] || (_cache[0] = (...args) => (0, import_vue408.unref)(leftPrevYear) && (0, import_vue408.unref)(leftPrevYear)(...args))
                }, [
                  (0, import_vue408.createVNode)((0, import_vue408.unref)(ElIcon), null, {
                    default: (0, import_vue408.withCtx)(() => [
                      (0, import_vue408.createVNode)((0, import_vue408.unref)(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                _ctx.unlinkPanels ? ((0, import_vue408.openBlock)(), (0, import_vue408.createElementBlock)("button", {
                  key: 0,
                  type: "button",
                  disabled: !(0, import_vue408.unref)(enableYearArrow),
                  class: (0, import_vue408.normalizeClass)([[
                    (0, import_vue408.unref)(ppNs).e("icon-btn"),
                    { [(0, import_vue408.unref)(ppNs).is("disabled")]: !(0, import_vue408.unref)(enableYearArrow) }
                  ], "d-arrow-right"]),
                  onClick: _cache[1] || (_cache[1] = (...args) => (0, import_vue408.unref)(leftNextYear) && (0, import_vue408.unref)(leftNextYear)(...args))
                }, [
                  (0, import_vue408.createVNode)((0, import_vue408.unref)(ElIcon), null, {
                    default: (0, import_vue408.withCtx)(() => [
                      (0, import_vue408.createVNode)((0, import_vue408.unref)(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_224)) : (0, import_vue408.createCommentVNode)("v-if", true),
                (0, import_vue408.createElementVNode)("div", null, (0, import_vue408.toDisplayString)((0, import_vue408.unref)(leftLabel)), 1)
              ], 2),
              (0, import_vue408.createVNode)(MonthTable, {
                "selection-mode": "range",
                date: leftDate.value,
                "min-date": (0, import_vue408.unref)(minDate),
                "max-date": (0, import_vue408.unref)(maxDate),
                "range-state": (0, import_vue408.unref)(rangeState),
                "disabled-date": (0, import_vue408.unref)(disabledDate2),
                onChangerange: (0, import_vue408.unref)(handleChangeRange),
                onPick: handleRangePick,
                onSelect: (0, import_vue408.unref)(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
            ], 2),
            (0, import_vue408.createElementVNode)("div", {
              class: (0, import_vue408.normalizeClass)([[(0, import_vue408.unref)(ppNs).e("content"), (0, import_vue408.unref)(drpNs).e("content")], "is-right"])
            }, [
              (0, import_vue408.createElementVNode)("div", {
                class: (0, import_vue408.normalizeClass)((0, import_vue408.unref)(drpNs).e("header"))
              }, [
                _ctx.unlinkPanels ? ((0, import_vue408.openBlock)(), (0, import_vue408.createElementBlock)("button", {
                  key: 0,
                  type: "button",
                  disabled: !(0, import_vue408.unref)(enableYearArrow),
                  class: (0, import_vue408.normalizeClass)([[(0, import_vue408.unref)(ppNs).e("icon-btn"), { "is-disabled": !(0, import_vue408.unref)(enableYearArrow) }], "d-arrow-left"]),
                  onClick: _cache[2] || (_cache[2] = (...args) => (0, import_vue408.unref)(rightPrevYear) && (0, import_vue408.unref)(rightPrevYear)(...args))
                }, [
                  (0, import_vue408.createVNode)((0, import_vue408.unref)(ElIcon), null, {
                    default: (0, import_vue408.withCtx)(() => [
                      (0, import_vue408.createVNode)((0, import_vue408.unref)(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_316)) : (0, import_vue408.createCommentVNode)("v-if", true),
                (0, import_vue408.createElementVNode)("button", {
                  type: "button",
                  class: (0, import_vue408.normalizeClass)([(0, import_vue408.unref)(ppNs).e("icon-btn"), "d-arrow-right"]),
                  onClick: _cache[3] || (_cache[3] = (...args) => (0, import_vue408.unref)(rightNextYear) && (0, import_vue408.unref)(rightNextYear)(...args))
                }, [
                  (0, import_vue408.createVNode)((0, import_vue408.unref)(ElIcon), null, {
                    default: (0, import_vue408.withCtx)(() => [
                      (0, import_vue408.createVNode)((0, import_vue408.unref)(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2),
                (0, import_vue408.createElementVNode)("div", null, (0, import_vue408.toDisplayString)((0, import_vue408.unref)(rightLabel)), 1)
              ], 2),
              (0, import_vue408.createVNode)(MonthTable, {
                "selection-mode": "range",
                date: rightDate.value,
                "min-date": (0, import_vue408.unref)(minDate),
                "max-date": (0, import_vue408.unref)(maxDate),
                "range-state": (0, import_vue408.unref)(rangeState),
                "disabled-date": (0, import_vue408.unref)(disabledDate2),
                onChangerange: (0, import_vue408.unref)(handleChangeRange),
                onPick: handleRangePick,
                onSelect: (0, import_vue408.unref)(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2)
      ], 2);
    };
  }
});
var MonthRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main64, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/panel-utils.mjs
var getPanel = function(type4) {
  switch (type4) {
    case "daterange":
    case "datetimerange": {
      return DateRangePickPanel;
    }
    case "monthrange": {
      return MonthRangePickPanel;
    }
    default: {
      return DatePickPanel;
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/src/date-picker.mjs
import_dayjs15.default.extend(import_localeData2.default);
import_dayjs15.default.extend(import_advancedFormat.default);
import_dayjs15.default.extend(import_customParseFormat2.default);
import_dayjs15.default.extend(import_weekOfYear.default);
import_dayjs15.default.extend(import_weekYear.default);
import_dayjs15.default.extend(import_dayOfYear.default);
import_dayjs15.default.extend(import_isSameOrAfter.default);
import_dayjs15.default.extend(import_isSameOrBefore.default);
var DatePicker = (0, import_vue409.defineComponent)({
  name: "ElDatePicker",
  install: null,
  props: {
    ...timePickerDefaultProps,
    ...datePickerProps
  },
  emits: ["update:modelValue"],
  setup(props, {
    expose,
    emit,
    slots
  }) {
    const ns2 = useNamespace("picker-panel");
    (0, import_vue409.provide)("ElPopperOptions", (0, import_vue409.reactive)((0, import_vue409.toRef)(props, "popperOptions")));
    (0, import_vue409.provide)(ROOT_PICKER_INJECTION_KEY, {
      slots,
      pickerNs: ns2
    });
    const commonPicker = (0, import_vue409.ref)();
    const refProps = {
      focus: (focusStartInput = true) => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.focus(focusStartInput);
      },
      handleOpen: () => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.handleOpen();
      },
      handleClose: () => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.handleClose();
      }
    };
    expose(refProps);
    const onModelValueUpdated = (val) => {
      emit("update:modelValue", val);
    };
    return () => {
      var _a2;
      const format2 = (_a2 = props.format) != null ? _a2 : DEFAULT_FORMATS_DATEPICKER[props.type] || DEFAULT_FORMATS_DATE;
      const Component = getPanel(props.type);
      return (0, import_vue409.createVNode)(CommonPicker, (0, import_vue409.mergeProps)(props, {
        "format": format2,
        "type": props.type,
        "ref": commonPicker,
        "onUpdate:modelValue": onModelValueUpdated
      }), {
        default: (scopedProps) => (0, import_vue409.createVNode)(Component, scopedProps, null),
        "range-separator": slots["range-separator"]
      });
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/date-picker/index.mjs
var _DatePicker = DatePicker;
_DatePicker.install = (app) => {
  app.component(_DatePicker.name, _DatePicker);
};
var ElDatePicker = _DatePicker;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/description2.mjs
var import_vue412 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/descriptions-row2.mjs
var import_vue411 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/descriptions-cell.mjs
var import_vue410 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/token.mjs
var descriptionsKey = "elDescriptions";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/descriptions-cell.mjs
var ElDescriptionsCell = (0, import_vue410.defineComponent)({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String
    },
    type: {
      type: String
    }
  },
  setup() {
    const descriptions = (0, import_vue410.inject)(descriptionsKey, {});
    return {
      descriptions
    };
  },
  render() {
    var _a2, _b, _c, _d, _e, _f;
    const item = getNormalizedProps(this.cell);
    const { border, direction: direction2 } = this.descriptions;
    const isVertical = direction2 === "vertical";
    const label = ((_c = (_b = (_a2 = this.cell) == null ? void 0 : _a2.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item.label;
    const content = (_f = (_e = (_d = this.cell) == null ? void 0 : _d.children) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e);
    const span = item.span;
    const align = item.align ? `is-${item.align}` : "";
    const labelAlign = item.labelAlign ? `is-${item.labelAlign}` : align;
    const className = item.className;
    const labelClassName = item.labelClassName;
    const style = {
      width: addUnit(item.width),
      minWidth: addUnit(item.minWidth)
    };
    const ns2 = useNamespace("descriptions");
    switch (this.type) {
      case "label":
        return (0, import_vue410.h)(this.tag, {
          style,
          class: [
            ns2.e("cell"),
            ns2.e("label"),
            ns2.is("bordered-label", border),
            ns2.is("vertical-label", isVertical),
            labelAlign,
            labelClassName
          ],
          colSpan: isVertical ? span : 1
        }, label);
      case "content":
        return (0, import_vue410.h)(this.tag, {
          style,
          class: [
            ns2.e("cell"),
            ns2.e("content"),
            ns2.is("bordered-content", border),
            ns2.is("vertical-content", isVertical),
            align,
            className
          ],
          colSpan: isVertical ? span : span * 2 - 1
        }, content);
      default:
        return (0, import_vue410.h)("td", {
          style,
          class: [ns2.e("cell"), align],
          colSpan: span
        }, [
          (0, import_vue410.h)("span", {
            class: [ns2.e("label"), labelClassName]
          }, label),
          (0, import_vue410.h)("span", {
            class: [ns2.e("content"), className]
          }, content)
        ]);
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/descriptions-row.mjs
var descriptionsRowProps = buildProps({
  row: {
    type: Array,
    default: () => []
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/descriptions-row2.mjs
var _hoisted_137 = { key: 1 };
var __default__47 = (0, import_vue411.defineComponent)({
  name: "ElDescriptionsRow"
});
var _sfc_main65 = /* @__PURE__ */ (0, import_vue411.defineComponent)({
  ...__default__47,
  props: descriptionsRowProps,
  setup(__props) {
    const descriptions = (0, import_vue411.inject)(descriptionsKey, {});
    return (_ctx, _cache) => {
      return (0, import_vue411.unref)(descriptions).direction === "vertical" ? ((0, import_vue411.openBlock)(), (0, import_vue411.createElementBlock)(import_vue411.Fragment, { key: 0 }, [
        (0, import_vue411.createElementVNode)("tr", null, [
          ((0, import_vue411.openBlock)(true), (0, import_vue411.createElementBlock)(import_vue411.Fragment, null, (0, import_vue411.renderList)(_ctx.row, (cell, index2) => {
            return (0, import_vue411.openBlock)(), (0, import_vue411.createBlock)((0, import_vue411.unref)(ElDescriptionsCell), {
              key: `tr1-${index2}`,
              cell,
              tag: "th",
              type: "label"
            }, null, 8, ["cell"]);
          }), 128))
        ]),
        (0, import_vue411.createElementVNode)("tr", null, [
          ((0, import_vue411.openBlock)(true), (0, import_vue411.createElementBlock)(import_vue411.Fragment, null, (0, import_vue411.renderList)(_ctx.row, (cell, index2) => {
            return (0, import_vue411.openBlock)(), (0, import_vue411.createBlock)((0, import_vue411.unref)(ElDescriptionsCell), {
              key: `tr2-${index2}`,
              cell,
              tag: "td",
              type: "content"
            }, null, 8, ["cell"]);
          }), 128))
        ])
      ], 64)) : ((0, import_vue411.openBlock)(), (0, import_vue411.createElementBlock)("tr", _hoisted_137, [
        ((0, import_vue411.openBlock)(true), (0, import_vue411.createElementBlock)(import_vue411.Fragment, null, (0, import_vue411.renderList)(_ctx.row, (cell, index2) => {
          return (0, import_vue411.openBlock)(), (0, import_vue411.createElementBlock)(import_vue411.Fragment, {
            key: `tr3-${index2}`
          }, [
            (0, import_vue411.unref)(descriptions).border ? ((0, import_vue411.openBlock)(), (0, import_vue411.createElementBlock)(import_vue411.Fragment, { key: 0 }, [
              (0, import_vue411.createVNode)((0, import_vue411.unref)(ElDescriptionsCell), {
                cell,
                tag: "td",
                type: "label"
              }, null, 8, ["cell"]),
              (0, import_vue411.createVNode)((0, import_vue411.unref)(ElDescriptionsCell), {
                cell,
                tag: "td",
                type: "content"
              }, null, 8, ["cell"])
            ], 64)) : ((0, import_vue411.openBlock)(), (0, import_vue411.createBlock)((0, import_vue411.unref)(ElDescriptionsCell), {
              key: 1,
              cell,
              tag: "td",
              type: "both"
            }, null, 8, ["cell"]))
          ], 64);
        }), 128))
      ]));
    };
  }
});
var ElDescriptionsRow = /* @__PURE__ */ _export_sfc(_sfc_main65, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/description.mjs
var descriptionProps = buildProps({
  border: {
    type: Boolean,
    default: false
  },
  column: {
    type: Number,
    default: 3
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  size: useSizeProp,
  title: {
    type: String,
    default: ""
  },
  extra: {
    type: String,
    default: ""
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/description2.mjs
var __default__48 = (0, import_vue412.defineComponent)({
  name: "ElDescriptions"
});
var _sfc_main66 = /* @__PURE__ */ (0, import_vue412.defineComponent)({
  ...__default__48,
  props: descriptionProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("descriptions");
    const descriptionsSize = useSize();
    const slots = (0, import_vue412.useSlots)();
    (0, import_vue412.provide)(descriptionsKey, props);
    const descriptionKls = (0, import_vue412.computed)(() => [ns2.b(), ns2.m(descriptionsSize.value)]);
    const filledNode = (node, span, count, isLast = false) => {
      if (!node.props) {
        node.props = {};
      }
      if (span > count) {
        node.props.span = count;
      }
      if (isLast) {
        node.props.span = span;
      }
      return node;
    };
    const getRows = () => {
      var _a2;
      const children = flattedChildren((_a2 = slots.default) == null ? void 0 : _a2.call(slots)).filter((node) => {
        var _a22;
        return ((_a22 = node == null ? void 0 : node.type) == null ? void 0 : _a22.name) === "ElDescriptionsItem";
      });
      const rows = [];
      let temp = [];
      let count = props.column;
      let totalSpan = 0;
      children.forEach((node, index2) => {
        var _a22;
        const span = ((_a22 = node.props) == null ? void 0 : _a22.span) || 1;
        if (index2 < children.length - 1) {
          totalSpan += span > count ? count : span;
        }
        if (index2 === children.length - 1) {
          const lastSpan = props.column - totalSpan % props.column;
          temp.push(filledNode(node, lastSpan, count, true));
          rows.push(temp);
          return;
        }
        if (span < count) {
          count -= span;
          temp.push(node);
        } else {
          temp.push(filledNode(node, span, count));
          rows.push(temp);
          count = props.column;
          temp = [];
        }
      });
      return rows;
    };
    return (_ctx, _cache) => {
      return (0, import_vue412.openBlock)(), (0, import_vue412.createElementBlock)("div", {
        class: (0, import_vue412.normalizeClass)((0, import_vue412.unref)(descriptionKls))
      }, [
        _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? ((0, import_vue412.openBlock)(), (0, import_vue412.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue412.normalizeClass)((0, import_vue412.unref)(ns2).e("header"))
        }, [
          (0, import_vue412.createElementVNode)("div", {
            class: (0, import_vue412.normalizeClass)((0, import_vue412.unref)(ns2).e("title"))
          }, [
            (0, import_vue412.renderSlot)(_ctx.$slots, "title", {}, () => [
              (0, import_vue412.createTextVNode)((0, import_vue412.toDisplayString)(_ctx.title), 1)
            ])
          ], 2),
          (0, import_vue412.createElementVNode)("div", {
            class: (0, import_vue412.normalizeClass)((0, import_vue412.unref)(ns2).e("extra"))
          }, [
            (0, import_vue412.renderSlot)(_ctx.$slots, "extra", {}, () => [
              (0, import_vue412.createTextVNode)((0, import_vue412.toDisplayString)(_ctx.extra), 1)
            ])
          ], 2)
        ], 2)) : (0, import_vue412.createCommentVNode)("v-if", true),
        (0, import_vue412.createElementVNode)("div", {
          class: (0, import_vue412.normalizeClass)((0, import_vue412.unref)(ns2).e("body"))
        }, [
          (0, import_vue412.createElementVNode)("table", {
            class: (0, import_vue412.normalizeClass)([(0, import_vue412.unref)(ns2).e("table"), (0, import_vue412.unref)(ns2).is("bordered", _ctx.border)])
          }, [
            (0, import_vue412.createElementVNode)("tbody", null, [
              ((0, import_vue412.openBlock)(true), (0, import_vue412.createElementBlock)(import_vue412.Fragment, null, (0, import_vue412.renderList)(getRows(), (row, index2) => {
                return (0, import_vue412.openBlock)(), (0, import_vue412.createBlock)(ElDescriptionsRow, {
                  key: index2,
                  row
                }, null, 8, ["row"]);
              }), 128))
            ])
          ], 2)
        ], 2)
      ], 2);
    };
  }
});
var Descriptions = /* @__PURE__ */ _export_sfc(_sfc_main66, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/src/description-item.mjs
var import_vue413 = require("vue");
var DescriptionsItem = (0, import_vue413.defineComponent)({
  name: "ElDescriptionsItem",
  props: {
    label: {
      type: String,
      default: ""
    },
    span: {
      type: Number,
      default: 1
    },
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    align: {
      type: String,
      default: "left"
    },
    labelAlign: {
      type: String,
      default: ""
    },
    className: {
      type: String,
      default: ""
    },
    labelClassName: {
      type: String,
      default: ""
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/descriptions/index.mjs
var ElDescriptions = withInstall(Descriptions, {
  DescriptionsItem
});
var ElDescriptionsItem = withNoopInstall(DescriptionsItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/dialog2.mjs
var import_vue417 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/overlay/src/overlay.mjs
var import_vue414 = require("vue");
var overlayProps = buildProps({
  mask: {
    type: Boolean,
    default: true
  },
  customMaskEvent: {
    type: Boolean,
    default: false
  },
  overlayClass: {
    type: definePropType([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: definePropType([String, Number])
  }
});
var overlayEmits = {
  click: (evt) => evt instanceof MouseEvent
};
var Overlay = (0, import_vue414.defineComponent)({
  name: "ElOverlay",
  props: overlayProps,
  emits: overlayEmits,
  setup(props, { slots, emit }) {
    const ns2 = useNamespace("overlay");
    const onMaskClick = (e) => {
      emit("click", e);
    };
    const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
    return () => {
      return props.mask ? (0, import_vue414.createVNode)("div", {
        class: [ns2.b(), props.overlayClass],
        style: {
          zIndex: props.zIndex
        },
        onClick,
        onMousedown,
        onMouseup
      }, [(0, import_vue414.renderSlot)(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : (0, import_vue414.h)("div", {
        class: props.overlayClass,
        style: {
          zIndex: props.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [(0, import_vue414.renderSlot)(slots, "default")]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/overlay/index.mjs
var ElOverlay = Overlay;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/dialog-content2.mjs
var import_vue415 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/dialog-content.mjs
var dialogContentProps = buildProps({
  center: {
    type: Boolean,
    default: false
  },
  alignCenter: {
    type: Boolean,
    default: false
  },
  closeIcon: {
    type: iconPropType
  },
  customClass: {
    type: String,
    default: ""
  },
  draggable: {
    type: Boolean,
    default: false
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  }
});
var dialogContentEmits = {
  close: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/dialog-content2.mjs
var _hoisted_138 = ["aria-label"];
var _hoisted_225 = ["id"];
var __default__49 = (0, import_vue415.defineComponent)({ name: "ElDialogContent" });
var _sfc_main67 = /* @__PURE__ */ (0, import_vue415.defineComponent)({
  ...__default__49,
  props: dialogContentProps,
  emits: dialogContentEmits,
  setup(__props) {
    const props = __props;
    const { t } = useLocale();
    const { Close } = CloseComponents;
    const { dialogRef, headerRef, bodyId, ns: ns2, style } = (0, import_vue415.inject)(dialogInjectionKey);
    const { focusTrapRef } = (0, import_vue415.inject)(FOCUS_TRAP_INJECTION_KEY);
    const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
    const draggable2 = (0, import_vue415.computed)(() => props.draggable);
    useDraggable(dialogRef, headerRef, draggable2);
    return (_ctx, _cache) => {
      return (0, import_vue415.openBlock)(), (0, import_vue415.createElementBlock)("div", {
        ref: (0, import_vue415.unref)(composedDialogRef),
        class: (0, import_vue415.normalizeClass)([
          (0, import_vue415.unref)(ns2).b(),
          (0, import_vue415.unref)(ns2).is("fullscreen", _ctx.fullscreen),
          (0, import_vue415.unref)(ns2).is("draggable", (0, import_vue415.unref)(draggable2)),
          (0, import_vue415.unref)(ns2).is("align-center", _ctx.alignCenter),
          { [(0, import_vue415.unref)(ns2).m("center")]: _ctx.center },
          _ctx.customClass
        ]),
        style: (0, import_vue415.normalizeStyle)((0, import_vue415.unref)(style)),
        tabindex: "-1"
      }, [
        (0, import_vue415.createElementVNode)("header", {
          ref_key: "headerRef",
          ref: headerRef,
          class: (0, import_vue415.normalizeClass)((0, import_vue415.unref)(ns2).e("header"))
        }, [
          (0, import_vue415.renderSlot)(_ctx.$slots, "header", {}, () => [
            (0, import_vue415.createElementVNode)("span", {
              role: "heading",
              class: (0, import_vue415.normalizeClass)((0, import_vue415.unref)(ns2).e("title"))
            }, (0, import_vue415.toDisplayString)(_ctx.title), 3)
          ]),
          _ctx.showClose ? ((0, import_vue415.openBlock)(), (0, import_vue415.createElementBlock)("button", {
            key: 0,
            "aria-label": (0, import_vue415.unref)(t)("el.dialog.close"),
            class: (0, import_vue415.normalizeClass)((0, import_vue415.unref)(ns2).e("headerbtn")),
            type: "button",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
          }, [
            (0, import_vue415.createVNode)((0, import_vue415.unref)(ElIcon), {
              class: (0, import_vue415.normalizeClass)((0, import_vue415.unref)(ns2).e("close"))
            }, {
              default: (0, import_vue415.withCtx)(() => [
                ((0, import_vue415.openBlock)(), (0, import_vue415.createBlock)((0, import_vue415.resolveDynamicComponent)(_ctx.closeIcon || (0, import_vue415.unref)(Close))))
              ]),
              _: 1
            }, 8, ["class"])
          ], 10, _hoisted_138)) : (0, import_vue415.createCommentVNode)("v-if", true)
        ], 2),
        (0, import_vue415.createElementVNode)("div", {
          id: (0, import_vue415.unref)(bodyId),
          class: (0, import_vue415.normalizeClass)((0, import_vue415.unref)(ns2).e("body"))
        }, [
          (0, import_vue415.renderSlot)(_ctx.$slots, "default")
        ], 10, _hoisted_225),
        _ctx.$slots.footer ? ((0, import_vue415.openBlock)(), (0, import_vue415.createElementBlock)("footer", {
          key: 0,
          class: (0, import_vue415.normalizeClass)((0, import_vue415.unref)(ns2).e("footer"))
        }, [
          (0, import_vue415.renderSlot)(_ctx.$slots, "footer")
        ], 2)) : (0, import_vue415.createCommentVNode)("v-if", true)
      ], 6);
    };
  }
});
var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main67, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/dialog.mjs
var dialogProps = buildProps({
  ...dialogContentProps,
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: {
    type: definePropType(Function)
  },
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: {
    type: Boolean,
    default: false
  },
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: false
  }
});
var dialogEmits = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
  openAutoFocus: () => true,
  closeAutoFocus: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/use-dialog.mjs
var import_vue416 = require("vue");
var useDialog = (props, targetRef) => {
  const instance = (0, import_vue416.getCurrentInstance)();
  const emit = instance.emit;
  const { nextZIndex } = useZIndex();
  let lastPosition = "";
  const titleId = useId();
  const bodyId = useId();
  const visible = (0, import_vue416.ref)(false);
  const closed = (0, import_vue416.ref)(false);
  const rendered = (0, import_vue416.ref)(false);
  const zIndex2 = (0, import_vue416.ref)(props.zIndex || nextZIndex());
  let openTimer = void 0;
  let closeTimer = void 0;
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const style = (0, import_vue416.computed)(() => {
    const style2 = {};
    const varPrefix = `--${namespace.value}-dialog`;
    if (!props.fullscreen) {
      if (props.top) {
        style2[`${varPrefix}-margin-top`] = props.top;
      }
      if (props.width) {
        style2[`${varPrefix}-width`] = addUnit(props.width);
      }
    }
    return style2;
  });
  const overlayDialogStyle = (0, import_vue416.computed)(() => {
    if (props.alignCenter) {
      return { display: "flex" };
    }
    return {};
  });
  function afterEnter() {
    emit("opened");
  }
  function afterLeave() {
    emit("closed");
    emit(UPDATE_MODEL_EVENT, false);
    if (props.destroyOnClose) {
      rendered.value = false;
    }
  }
  function beforeLeave() {
    emit("close");
  }
  function open() {
    closeTimer == null ? void 0 : closeTimer();
    openTimer == null ? void 0 : openTimer();
    if (props.openDelay && props.openDelay > 0) {
      ;
      ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
    } else {
      doOpen();
    }
  }
  function close2() {
    openTimer == null ? void 0 : openTimer();
    closeTimer == null ? void 0 : closeTimer();
    if (props.closeDelay && props.closeDelay > 0) {
      ;
      ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
    } else {
      doClose();
    }
  }
  function handleClose() {
    function hide2(shouldCancel) {
      if (shouldCancel)
        return;
      closed.value = true;
      visible.value = false;
    }
    if (props.beforeClose) {
      props.beforeClose(hide2);
    } else {
      close2();
    }
  }
  function onModalClick() {
    if (props.closeOnClickModal) {
      handleClose();
    }
  }
  function doOpen() {
    if (!isClient)
      return;
    visible.value = true;
  }
  function doClose() {
    visible.value = false;
  }
  function onOpenAutoFocus() {
    emit("openAutoFocus");
  }
  function onCloseAutoFocus() {
    emit("closeAutoFocus");
  }
  function onFocusoutPrevented(event) {
    var _a2;
    if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
      event.preventDefault();
    }
  }
  if (props.lockScroll) {
    useLockscreen(visible);
  }
  function onCloseRequested() {
    if (props.closeOnPressEscape) {
      handleClose();
    }
  }
  (0, import_vue416.watch)(() => props.modelValue, (val) => {
    if (val) {
      closed.value = false;
      open();
      rendered.value = true;
      zIndex2.value = props.zIndex ? zIndex2.value++ : nextZIndex();
      (0, import_vue416.nextTick)(() => {
        emit("open");
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible.value) {
        close2();
      }
    }
  });
  (0, import_vue416.watch)(() => props.fullscreen, (val) => {
    if (!targetRef.value)
      return;
    if (val) {
      lastPosition = targetRef.value.style.transform;
      targetRef.value.style.transform = "";
    } else {
      targetRef.value.style.transform = lastPosition;
    }
  });
  (0, import_vue416.onMounted)(() => {
    if (props.modelValue) {
      visible.value = true;
      rendered.value = true;
      open();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick,
    close: close2,
    doClose,
    onOpenAutoFocus,
    onCloseAutoFocus,
    onCloseRequested,
    onFocusoutPrevented,
    titleId,
    bodyId,
    closed,
    style,
    overlayDialogStyle,
    rendered,
    visible,
    zIndex: zIndex2
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/src/dialog2.mjs
var _hoisted_139 = ["aria-label", "aria-labelledby", "aria-describedby"];
var __default__50 = (0, import_vue417.defineComponent)({
  name: "ElDialog",
  inheritAttrs: false
});
var _sfc_main68 = /* @__PURE__ */ (0, import_vue417.defineComponent)({
  ...__default__50,
  props: dialogProps,
  emits: dialogEmits,
  setup(__props, { expose }) {
    const props = __props;
    const slots = (0, import_vue417.useSlots)();
    useDeprecated({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, (0, import_vue417.computed)(() => !!slots.title));
    useDeprecated({
      scope: "el-dialog",
      from: "custom-class",
      replacement: "class",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
      type: "Attribute"
    }, (0, import_vue417.computed)(() => !!props.customClass));
    const ns2 = useNamespace("dialog");
    const dialogRef = (0, import_vue417.ref)();
    const headerRef = (0, import_vue417.ref)();
    const dialogContentRef = (0, import_vue417.ref)();
    const {
      visible,
      titleId,
      bodyId,
      style,
      overlayDialogStyle,
      rendered,
      zIndex: zIndex2,
      afterEnter,
      afterLeave,
      beforeLeave,
      handleClose,
      onModalClick,
      onOpenAutoFocus,
      onCloseAutoFocus,
      onCloseRequested,
      onFocusoutPrevented
    } = useDialog(props, dialogRef);
    (0, import_vue417.provide)(dialogInjectionKey, {
      dialogRef,
      headerRef,
      bodyId,
      ns: ns2,
      rendered,
      style
    });
    const overlayEvent = useSameTarget(onModalClick);
    const draggable2 = (0, import_vue417.computed)(() => props.draggable && !props.fullscreen);
    expose({
      visible,
      dialogContentRef
    });
    return (_ctx, _cache) => {
      return (0, import_vue417.openBlock)(), (0, import_vue417.createBlock)(import_vue417.Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
      }, [
        (0, import_vue417.createVNode)(import_vue417.Transition, {
          name: "dialog-fade",
          onAfterEnter: (0, import_vue417.unref)(afterEnter),
          onAfterLeave: (0, import_vue417.unref)(afterLeave),
          onBeforeLeave: (0, import_vue417.unref)(beforeLeave),
          persisted: ""
        }, {
          default: (0, import_vue417.withCtx)(() => [
            (0, import_vue417.withDirectives)((0, import_vue417.createVNode)((0, import_vue417.unref)(ElOverlay), {
              "custom-mask-event": "",
              mask: _ctx.modal,
              "overlay-class": _ctx.modalClass,
              "z-index": (0, import_vue417.unref)(zIndex2)
            }, {
              default: (0, import_vue417.withCtx)(() => [
                (0, import_vue417.createElementVNode)("div", {
                  role: "dialog",
                  "aria-modal": "true",
                  "aria-label": _ctx.title || void 0,
                  "aria-labelledby": !_ctx.title ? (0, import_vue417.unref)(titleId) : void 0,
                  "aria-describedby": (0, import_vue417.unref)(bodyId),
                  class: (0, import_vue417.normalizeClass)(`${(0, import_vue417.unref)(ns2).namespace.value}-overlay-dialog`),
                  style: (0, import_vue417.normalizeStyle)((0, import_vue417.unref)(overlayDialogStyle)),
                  onClick: _cache[0] || (_cache[0] = (...args) => (0, import_vue417.unref)(overlayEvent).onClick && (0, import_vue417.unref)(overlayEvent).onClick(...args)),
                  onMousedown: _cache[1] || (_cache[1] = (...args) => (0, import_vue417.unref)(overlayEvent).onMousedown && (0, import_vue417.unref)(overlayEvent).onMousedown(...args)),
                  onMouseup: _cache[2] || (_cache[2] = (...args) => (0, import_vue417.unref)(overlayEvent).onMouseup && (0, import_vue417.unref)(overlayEvent).onMouseup(...args))
                }, [
                  (0, import_vue417.createVNode)((0, import_vue417.unref)(ElFocusTrap), {
                    loop: "",
                    trapped: (0, import_vue417.unref)(visible),
                    "focus-start-el": "container",
                    onFocusAfterTrapped: (0, import_vue417.unref)(onOpenAutoFocus),
                    onFocusAfterReleased: (0, import_vue417.unref)(onCloseAutoFocus),
                    onFocusoutPrevented: (0, import_vue417.unref)(onFocusoutPrevented),
                    onReleaseRequested: (0, import_vue417.unref)(onCloseRequested)
                  }, {
                    default: (0, import_vue417.withCtx)(() => [
                      (0, import_vue417.unref)(rendered) ? ((0, import_vue417.openBlock)(), (0, import_vue417.createBlock)(ElDialogContent, (0, import_vue417.mergeProps)({
                        key: 0,
                        ref_key: "dialogContentRef",
                        ref: dialogContentRef
                      }, _ctx.$attrs, {
                        "custom-class": _ctx.customClass,
                        center: _ctx.center,
                        "align-center": _ctx.alignCenter,
                        "close-icon": _ctx.closeIcon,
                        draggable: (0, import_vue417.unref)(draggable2),
                        fullscreen: _ctx.fullscreen,
                        "show-close": _ctx.showClose,
                        title: _ctx.title,
                        onClose: (0, import_vue417.unref)(handleClose)
                      }), (0, import_vue417.createSlots)({
                        header: (0, import_vue417.withCtx)(() => [
                          !_ctx.$slots.title ? (0, import_vue417.renderSlot)(_ctx.$slots, "header", {
                            key: 0,
                            close: (0, import_vue417.unref)(handleClose),
                            titleId: (0, import_vue417.unref)(titleId),
                            titleClass: (0, import_vue417.unref)(ns2).e("title")
                          }) : (0, import_vue417.renderSlot)(_ctx.$slots, "title", { key: 1 })
                        ]),
                        default: (0, import_vue417.withCtx)(() => [
                          (0, import_vue417.renderSlot)(_ctx.$slots, "default")
                        ]),
                        _: 2
                      }, [
                        _ctx.$slots.footer ? {
                          name: "footer",
                          fn: (0, import_vue417.withCtx)(() => [
                            (0, import_vue417.renderSlot)(_ctx.$slots, "footer")
                          ])
                        } : void 0
                      ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : (0, import_vue417.createCommentVNode)("v-if", true)
                    ]),
                    _: 3
                  }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                ], 46, _hoisted_139)
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index"]), [
              [import_vue417.vShow, (0, import_vue417.unref)(visible)]
            ])
          ]),
          _: 3
        }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ], 8, ["disabled"]);
    };
  }
});
var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main68, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dialog/index.mjs
var ElDialog = withInstall(Dialog);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/divider/src/divider2.mjs
var import_vue418 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/divider/src/divider.mjs
var dividerProps = buildProps({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: definePropType(String),
    default: "solid"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/divider/src/divider2.mjs
var __default__51 = (0, import_vue418.defineComponent)({
  name: "ElDivider"
});
var _sfc_main69 = /* @__PURE__ */ (0, import_vue418.defineComponent)({
  ...__default__51,
  props: dividerProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("divider");
    const dividerStyle = (0, import_vue418.computed)(() => {
      return ns2.cssVar({
        "border-style": props.borderStyle
      });
    });
    return (_ctx, _cache) => {
      return (0, import_vue418.openBlock)(), (0, import_vue418.createElementBlock)("div", {
        class: (0, import_vue418.normalizeClass)([(0, import_vue418.unref)(ns2).b(), (0, import_vue418.unref)(ns2).m(_ctx.direction)]),
        style: (0, import_vue418.normalizeStyle)((0, import_vue418.unref)(dividerStyle)),
        role: "separator"
      }, [
        _ctx.$slots.default && _ctx.direction !== "vertical" ? ((0, import_vue418.openBlock)(), (0, import_vue418.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue418.normalizeClass)([(0, import_vue418.unref)(ns2).e("text"), (0, import_vue418.unref)(ns2).is(_ctx.contentPosition)])
        }, [
          (0, import_vue418.renderSlot)(_ctx.$slots, "default")
        ], 2)) : (0, import_vue418.createCommentVNode)("v-if", true)
      ], 6);
    };
  }
});
var Divider = /* @__PURE__ */ _export_sfc(_sfc_main69, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/divider/index.mjs
var ElDivider = withInstall(Divider);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/drawer/src/drawer2.mjs
var import_vue419 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/drawer/src/drawer.mjs
var drawerProps = buildProps({
  ...dialogProps,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: true
  },
  modalFade: {
    type: Boolean,
    default: true
  }
});
var drawerEmits = dialogEmits;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/drawer/src/drawer2.mjs
var _sfc_main70 = (0, import_vue419.defineComponent)({
  name: "ElDrawer",
  components: {
    ElOverlay,
    ElFocusTrap,
    ElIcon,
    Close: close_default
  },
  inheritAttrs: false,
  props: drawerProps,
  emits: drawerEmits,
  setup(props, { slots }) {
    useDeprecated({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, (0, import_vue419.computed)(() => !!slots.title));
    useDeprecated({
      scope: "el-drawer",
      from: "custom-class",
      replacement: "class",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#attributes",
      type: "Attribute"
    }, (0, import_vue419.computed)(() => !!props.customClass));
    const drawerRef = (0, import_vue419.ref)();
    const focusStartRef = (0, import_vue419.ref)();
    const ns2 = useNamespace("drawer");
    const { t } = useLocale();
    const isHorizontal2 = (0, import_vue419.computed)(() => props.direction === "rtl" || props.direction === "ltr");
    const drawerSize = (0, import_vue419.computed)(() => addUnit(props.size));
    return {
      ...useDialog(props, drawerRef),
      drawerRef,
      focusStartRef,
      isHorizontal: isHorizontal2,
      drawerSize,
      ns: ns2,
      t
    };
  }
});
var _hoisted_140 = ["aria-label", "aria-labelledby", "aria-describedby"];
var _hoisted_226 = ["id"];
var _hoisted_317 = ["aria-label"];
var _hoisted_46 = ["id"];
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_close = (0, import_vue419.resolveComponent)("close");
  const _component_el_icon = (0, import_vue419.resolveComponent)("el-icon");
  const _component_el_focus_trap = (0, import_vue419.resolveComponent)("el-focus-trap");
  const _component_el_overlay = (0, import_vue419.resolveComponent)("el-overlay");
  return (0, import_vue419.openBlock)(), (0, import_vue419.createBlock)(import_vue419.Teleport, {
    to: "body",
    disabled: !_ctx.appendToBody
  }, [
    (0, import_vue419.createVNode)(import_vue419.Transition, {
      name: _ctx.ns.b("fade"),
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave,
      onBeforeLeave: _ctx.beforeLeave,
      persisted: ""
    }, {
      default: (0, import_vue419.withCtx)(() => [
        (0, import_vue419.withDirectives)((0, import_vue419.createVNode)(_component_el_overlay, {
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": _ctx.zIndex,
          onClick: _ctx.onModalClick
        }, {
          default: (0, import_vue419.withCtx)(() => [
            (0, import_vue419.createVNode)(_component_el_focus_trap, {
              loop: "",
              trapped: _ctx.visible,
              "focus-trap-el": _ctx.drawerRef,
              "focus-start-el": _ctx.focusStartRef,
              onReleaseRequested: _ctx.onCloseRequested
            }, {
              default: (0, import_vue419.withCtx)(() => [
                (0, import_vue419.createElementVNode)("div", (0, import_vue419.mergeProps)({
                  ref: "drawerRef",
                  "aria-modal": "true",
                  "aria-label": _ctx.title || void 0,
                  "aria-labelledby": !_ctx.title ? _ctx.titleId : void 0,
                  "aria-describedby": _ctx.bodyId
                }, _ctx.$attrs, {
                  class: [_ctx.ns.b(), _ctx.direction, _ctx.visible && "open", _ctx.customClass],
                  style: _ctx.isHorizontal ? "width: " + _ctx.drawerSize : "height: " + _ctx.drawerSize,
                  role: "dialog",
                  onClick: _cache[1] || (_cache[1] = (0, import_vue419.withModifiers)(() => {
                  }, ["stop"]))
                }), [
                  (0, import_vue419.createElementVNode)("span", {
                    ref: "focusStartRef",
                    class: (0, import_vue419.normalizeClass)(_ctx.ns.e("sr-focus")),
                    tabindex: "-1"
                  }, null, 2),
                  _ctx.withHeader ? ((0, import_vue419.openBlock)(), (0, import_vue419.createElementBlock)("header", {
                    key: 0,
                    class: (0, import_vue419.normalizeClass)(_ctx.ns.e("header"))
                  }, [
                    !_ctx.$slots.title ? (0, import_vue419.renderSlot)(_ctx.$slots, "header", {
                      key: 0,
                      close: _ctx.handleClose,
                      titleId: _ctx.titleId,
                      titleClass: _ctx.ns.e("title")
                    }, () => [
                      !_ctx.$slots.title ? ((0, import_vue419.openBlock)(), (0, import_vue419.createElementBlock)("span", {
                        key: 0,
                        id: _ctx.titleId,
                        role: "heading",
                        class: (0, import_vue419.normalizeClass)(_ctx.ns.e("title"))
                      }, (0, import_vue419.toDisplayString)(_ctx.title), 11, _hoisted_226)) : (0, import_vue419.createCommentVNode)("v-if", true)
                    ]) : (0, import_vue419.renderSlot)(_ctx.$slots, "title", { key: 1 }, () => [
                      (0, import_vue419.createCommentVNode)(" DEPRECATED SLOT ")
                    ]),
                    _ctx.showClose ? ((0, import_vue419.openBlock)(), (0, import_vue419.createElementBlock)("button", {
                      key: 2,
                      "aria-label": _ctx.t("el.drawer.close"),
                      class: (0, import_vue419.normalizeClass)(_ctx.ns.e("close-btn")),
                      type: "button",
                      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                    }, [
                      (0, import_vue419.createVNode)(_component_el_icon, {
                        class: (0, import_vue419.normalizeClass)(_ctx.ns.e("close"))
                      }, {
                        default: (0, import_vue419.withCtx)(() => [
                          (0, import_vue419.createVNode)(_component_close)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 10, _hoisted_317)) : (0, import_vue419.createCommentVNode)("v-if", true)
                  ], 2)) : (0, import_vue419.createCommentVNode)("v-if", true),
                  _ctx.rendered ? ((0, import_vue419.openBlock)(), (0, import_vue419.createElementBlock)("div", {
                    key: 1,
                    id: _ctx.bodyId,
                    class: (0, import_vue419.normalizeClass)(_ctx.ns.e("body"))
                  }, [
                    (0, import_vue419.renderSlot)(_ctx.$slots, "default")
                  ], 10, _hoisted_46)) : (0, import_vue419.createCommentVNode)("v-if", true),
                  _ctx.$slots.footer ? ((0, import_vue419.openBlock)(), (0, import_vue419.createElementBlock)("div", {
                    key: 2,
                    class: (0, import_vue419.normalizeClass)(_ctx.ns.e("footer"))
                  }, [
                    (0, import_vue419.renderSlot)(_ctx.$slots, "footer")
                  ], 2)) : (0, import_vue419.createCommentVNode)("v-if", true)
                ], 16, _hoisted_140)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
          [import_vue419.vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
var Drawer = /* @__PURE__ */ _export_sfc(_sfc_main70, [["render", _sfc_render13], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/drawer/index.mjs
var ElDrawer = withInstall(Drawer);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown2.mjs
var import_vue426 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/roving-focus-group2.mjs
var import_vue424 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/roving-focus-group-impl.mjs
var import_vue423 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collection/src/collection.mjs
var import_vue422 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collection/src/collection2.mjs
var import_vue420 = require("vue");
var _sfc_main71 = /* @__PURE__ */ (0, import_vue420.defineComponent)({
  inheritAttrs: false
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue420.renderSlot)(_ctx.$slots, "default");
}
var Collection = /* @__PURE__ */ _export_sfc(_sfc_main71, [["render", _sfc_render15], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collection/src/collection-item.mjs
var import_vue421 = require("vue");
var _sfc_main72 = /* @__PURE__ */ (0, import_vue421.defineComponent)({
  name: "ElCollectionItem",
  inheritAttrs: false
});
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue421.renderSlot)(_ctx.$slots, "default");
}
var CollectionItem = /* @__PURE__ */ _export_sfc(_sfc_main72, [["render", _sfc_render16], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/collection/src/collection.mjs
var COLLECTION_ITEM_SIGN = `data-el-collection-item`;
var createCollectionWithScope = (name) => {
  const COLLECTION_NAME = `El${name}Collection`;
  const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
  const COLLECTION_INJECTION_KEY3 = Symbol(COLLECTION_NAME);
  const COLLECTION_ITEM_INJECTION_KEY3 = Symbol(COLLECTION_ITEM_NAME);
  const ElCollection3 = {
    ...Collection,
    name: COLLECTION_NAME,
    setup() {
      const collectionRef = (0, import_vue422.ref)(null);
      const itemMap = /* @__PURE__ */ new Map();
      const getItems = () => {
        const collectionEl = (0, import_vue422.unref)(collectionRef);
        if (!collectionEl)
          return [];
        const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
        const items = [...itemMap.values()];
        return items.sort((a3, b3) => orderedNodes.indexOf(a3.ref) - orderedNodes.indexOf(b3.ref));
      };
      (0, import_vue422.provide)(COLLECTION_INJECTION_KEY3, {
        itemMap,
        getItems,
        collectionRef
      });
    }
  };
  const ElCollectionItem3 = {
    ...CollectionItem,
    name: COLLECTION_ITEM_NAME,
    setup(_2, { attrs }) {
      const collectionItemRef = (0, import_vue422.ref)(null);
      const collectionInjection = (0, import_vue422.inject)(COLLECTION_INJECTION_KEY3, void 0);
      (0, import_vue422.provide)(COLLECTION_ITEM_INJECTION_KEY3, {
        collectionItemRef
      });
      (0, import_vue422.onMounted)(() => {
        const collectionItemEl = (0, import_vue422.unref)(collectionItemRef);
        if (collectionItemEl) {
          collectionInjection.itemMap.set(collectionItemEl, {
            ref: collectionItemEl,
            ...attrs
          });
        }
      });
      (0, import_vue422.onBeforeUnmount)(() => {
        const collectionItemEl = (0, import_vue422.unref)(collectionItemRef);
        collectionInjection.itemMap.delete(collectionItemEl);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY3,
    COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY3,
    ElCollection: ElCollection3,
    ElCollectionItem: ElCollectionItem3
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/roving-focus-group.mjs
var rovingFocusGroupProps = buildProps({
  style: { type: definePropType([String, Array, Object]) },
  currentTabId: {
    type: definePropType(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: definePropType(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
});
var {
  ElCollection,
  ElCollectionItem,
  COLLECTION_INJECTION_KEY,
  COLLECTION_ITEM_INJECTION_KEY
} = createCollectionWithScope("RovingFocusGroup");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/tokens.mjs
var ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
var ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/utils.mjs
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
var getDirectionAwareKey = (key, dir) => {
  if (dir !== "rtl")
    return key;
  switch (key) {
    case EVENT_CODE.right:
      return EVENT_CODE.left;
    case EVENT_CODE.left:
      return EVENT_CODE.right;
    default:
      return key;
  }
};
var getFocusIntent = (event, orientation, dir) => {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
    return void 0;
  if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
};
var reorderArray = (array4, atIdx) => {
  return array4.map((_2, idx) => array4[(idx + atIdx) % array4.length]);
};
var focusFirst = (elements) => {
  const { activeElement: prevActive } = document;
  for (const element of elements) {
    if (element === prevActive)
      return;
    element.focus();
    if (prevActive !== document.activeElement)
      return;
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/roving-focus-group-impl.mjs
var CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
var ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
var EVT_OPTS = { bubbles: false, cancelable: true };
var _sfc_main73 = (0, import_vue423.defineComponent)({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: false,
  props: rovingFocusGroupProps,
  emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
  setup(props, { emit }) {
    var _a2;
    const currentTabbedId = (0, import_vue423.ref)((_a2 = props.currentTabId || props.defaultCurrentTabId) != null ? _a2 : null);
    const isBackingOut = (0, import_vue423.ref)(false);
    const isClickFocus = (0, import_vue423.ref)(false);
    const rovingFocusGroupRef = (0, import_vue423.ref)(null);
    const { getItems } = (0, import_vue423.inject)(COLLECTION_INJECTION_KEY, void 0);
    const rovingFocusGroupRootStyle = (0, import_vue423.computed)(() => {
      return [
        {
          outline: "none"
        },
        props.style
      ];
    });
    const onItemFocus = (tabbedId) => {
      emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
    };
    const onItemShiftTab = () => {
      isBackingOut.value = true;
    };
    const onMousedown = composeEventHandlers((e) => {
      var _a22;
      (_a22 = props.onMousedown) == null ? void 0 : _a22.call(props, e);
    }, () => {
      isClickFocus.value = true;
    });
    const onFocus = composeEventHandlers((e) => {
      var _a22;
      (_a22 = props.onFocus) == null ? void 0 : _a22.call(props, e);
    }, (e) => {
      const isKeyboardFocus = !(0, import_vue423.unref)(isClickFocus);
      const { target, currentTarget } = e;
      if (target === currentTarget && isKeyboardFocus && !(0, import_vue423.unref)(isBackingOut)) {
        const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
        currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
        if (!entryFocusEvt.defaultPrevented) {
          const items = getItems().filter((item) => item.focusable);
          const activeItem = items.find((item) => item.active);
          const currentItem = items.find((item) => item.id === (0, import_vue423.unref)(currentTabbedId));
          const candidates = [activeItem, currentItem, ...items].filter(Boolean);
          const candidateNodes = candidates.map((item) => item.ref);
          focusFirst(candidateNodes);
        }
      }
      isClickFocus.value = false;
    });
    const onBlur = composeEventHandlers((e) => {
      var _a22;
      (_a22 = props.onBlur) == null ? void 0 : _a22.call(props, e);
    }, () => {
      isBackingOut.value = false;
    });
    const handleEntryFocus = (...args) => {
      emit("entryFocus", ...args);
    };
    (0, import_vue423.provide)(ROVING_FOCUS_GROUP_INJECTION_KEY, {
      currentTabbedId: (0, import_vue423.readonly)(currentTabbedId),
      loop: (0, import_vue423.toRef)(props, "loop"),
      tabIndex: (0, import_vue423.computed)(() => {
        return (0, import_vue423.unref)(isBackingOut) ? -1 : 0;
      }),
      rovingFocusGroupRef,
      rovingFocusGroupRootStyle,
      orientation: (0, import_vue423.toRef)(props, "orientation"),
      dir: (0, import_vue423.toRef)(props, "dir"),
      onItemFocus,
      onItemShiftTab,
      onBlur,
      onFocus,
      onMousedown
    });
    (0, import_vue423.watch)(() => props.currentTabId, (val) => {
      currentTabbedId.value = val != null ? val : null;
    });
    useEventListener(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
  }
});
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue423.renderSlot)(_ctx.$slots, "default");
}
var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc(_sfc_main73, [["render", _sfc_render17], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/roving-focus-group2.mjs
var _sfc_main74 = (0, import_vue424.defineComponent)({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: ElCollection,
    ElRovingFocusGroupImpl
  }
});
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_roving_focus_group_impl = (0, import_vue424.resolveComponent)("el-roving-focus-group-impl");
  const _component_el_focus_group_collection = (0, import_vue424.resolveComponent)("el-focus-group-collection");
  return (0, import_vue424.openBlock)(), (0, import_vue424.createBlock)(_component_el_focus_group_collection, null, {
    default: (0, import_vue424.withCtx)(() => [
      (0, import_vue424.createVNode)(_component_el_roving_focus_group_impl, (0, import_vue424.normalizeProps)((0, import_vue424.guardReactiveProps)(_ctx.$attrs)), {
        default: (0, import_vue424.withCtx)(() => [
          (0, import_vue424.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)
    ]),
    _: 3
  });
}
var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc(_sfc_main74, [["render", _sfc_render18], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/roving-focus-group/src/roving-focus-item.mjs
var import_vue425 = require("vue");
var _sfc_main75 = (0, import_vue425.defineComponent)({
  components: {
    ElRovingFocusCollectionItem: ElCollectionItem
  },
  props: {
    focusable: {
      type: Boolean,
      default: true
    },
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(props, { emit }) {
    const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = (0, import_vue425.inject)(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { getItems } = (0, import_vue425.inject)(COLLECTION_INJECTION_KEY, void 0);
    const id2 = useId();
    const rovingFocusGroupItemRef = (0, import_vue425.ref)(null);
    const handleMousedown = composeEventHandlers((e) => {
      emit("mousedown", e);
    }, (e) => {
      if (!props.focusable) {
        e.preventDefault();
      } else {
        onItemFocus((0, import_vue425.unref)(id2));
      }
    });
    const handleFocus = composeEventHandlers((e) => {
      emit("focus", e);
    }, () => {
      onItemFocus((0, import_vue425.unref)(id2));
    });
    const handleKeydown = composeEventHandlers((e) => {
      emit("keydown", e);
    }, (e) => {
      const { key, shiftKey, target, currentTarget } = e;
      if (key === EVENT_CODE.tab && shiftKey) {
        onItemShiftTab();
        return;
      }
      if (target !== currentTarget)
        return;
      const focusIntent = getFocusIntent(e);
      if (focusIntent) {
        e.preventDefault();
        const items = getItems().filter((item) => item.focusable);
        let elements = items.map((item) => item.ref);
        switch (focusIntent) {
          case "last": {
            elements.reverse();
            break;
          }
          case "prev":
          case "next": {
            if (focusIntent === "prev") {
              elements.reverse();
            }
            const currentIdx = elements.indexOf(currentTarget);
            elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
            break;
          }
          default: {
            break;
          }
        }
        (0, import_vue425.nextTick)(() => {
          focusFirst(elements);
        });
      }
    });
    const isCurrentTab = (0, import_vue425.computed)(() => currentTabbedId.value === (0, import_vue425.unref)(id2));
    (0, import_vue425.provide)(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
      rovingFocusGroupItemRef,
      tabIndex: (0, import_vue425.computed)(() => (0, import_vue425.unref)(isCurrentTab) ? 0 : -1),
      handleMousedown,
      handleFocus,
      handleKeydown
    });
    return {
      id: id2,
      handleKeydown,
      handleFocus,
      handleMousedown
    };
  }
});
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_roving_focus_collection_item = (0, import_vue425.resolveComponent)("el-roving-focus-collection-item");
  return (0, import_vue425.openBlock)(), (0, import_vue425.createBlock)(_component_el_roving_focus_collection_item, {
    id: _ctx.id,
    focusable: _ctx.focusable,
    active: _ctx.active
  }, {
    default: (0, import_vue425.withCtx)(() => [
      (0, import_vue425.renderSlot)(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var ElRovingFocusItem = /* @__PURE__ */ _export_sfc(_sfc_main75, [["render", _sfc_render19], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown.mjs
var dropdownProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  effect: {
    ...useTooltipContentProps.effect,
    default: "light"
  },
  type: {
    type: definePropType(String)
  },
  placement: {
    type: definePropType(String),
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: true
  },
  loop: {
    type: Boolean,
    default: true
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: definePropType([Number, String]),
    default: 0
  },
  maxHeight: {
    type: definePropType([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: definePropType(Object)
  },
  teleported: useTooltipContentProps.teleported
});
var dropdownItemProps = buildProps({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: iconPropType
  }
});
var dropdownMenuProps = buildProps({
  onKeydown: { type: definePropType(Function) }
});
var FIRST_KEYS = [
  EVENT_CODE.down,
  EVENT_CODE.pageDown,
  EVENT_CODE.home
];
var LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var {
  ElCollection: ElCollection2,
  ElCollectionItem: ElCollectionItem2,
  COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
  COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2
} = createCollectionWithScope("Dropdown");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/tokens.mjs
var DROPDOWN_INJECTION_KEY = Symbol("elDropdown");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown2.mjs
var { ButtonGroup: ElButtonGroup2 } = ElButton;
var _sfc_main76 = (0, import_vue426.defineComponent)({
  name: "ElDropdown",
  components: {
    ElButton,
    ElButtonGroup: ElButtonGroup2,
    ElScrollbar,
    ElDropdownCollection: ElCollection2,
    ElTooltip,
    ElRovingFocusGroup,
    ElOnlyChild: OnlyChild,
    ElIcon,
    ArrowDown: arrow_down_default
  },
  props: dropdownProps,
  emits: ["visible-change", "click", "command"],
  setup(props, { emit }) {
    const _instance = (0, import_vue426.getCurrentInstance)();
    const ns2 = useNamespace("dropdown");
    const { t } = useLocale();
    const triggeringElementRef = (0, import_vue426.ref)();
    const referenceElementRef = (0, import_vue426.ref)();
    const popperRef = (0, import_vue426.ref)(null);
    const contentRef = (0, import_vue426.ref)(null);
    const scrollbar = (0, import_vue426.ref)(null);
    const currentTabId = (0, import_vue426.ref)(null);
    const isUsingKeyboard = (0, import_vue426.ref)(false);
    const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
    const wrapStyle = (0, import_vue426.computed)(() => ({
      maxHeight: addUnit(props.maxHeight)
    }));
    const dropdownTriggerKls = (0, import_vue426.computed)(() => [ns2.m(dropdownSize.value)]);
    const defaultTriggerId = useId().value;
    const triggerId = (0, import_vue426.computed)(() => {
      return props.id || defaultTriggerId;
    });
    function handleClick() {
      handleClose();
    }
    function handleClose() {
      var _a2;
      (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
    }
    function handleOpen() {
      var _a2;
      (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
    }
    const dropdownSize = useSize();
    function commandHandler(...args) {
      emit("command", ...args);
    }
    function onItemEnter() {
    }
    function onItemLeave() {
      const contentEl = (0, import_vue426.unref)(contentRef);
      contentEl == null ? void 0 : contentEl.focus();
      currentTabId.value = null;
    }
    function handleCurrentTabIdChange(id2) {
      currentTabId.value = id2;
    }
    function handleEntryFocus(e) {
      if (!isUsingKeyboard.value) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    }
    function handleBeforeShowTooltip() {
      emit("visible-change", true);
    }
    function handleShowTooltip(event) {
      if ((event == null ? void 0 : event.type) === "keydown") {
        contentRef.value.focus();
      }
    }
    function handleBeforeHideTooltip() {
      emit("visible-change", false);
    }
    (0, import_vue426.provide)(DROPDOWN_INJECTION_KEY, {
      contentRef,
      role: (0, import_vue426.computed)(() => props.role),
      triggerId,
      isUsingKeyboard,
      onItemEnter,
      onItemLeave
    });
    (0, import_vue426.provide)("elDropdown", {
      instance: _instance,
      dropdownSize,
      handleClick,
      commandHandler,
      trigger: (0, import_vue426.toRef)(props, "trigger"),
      hideOnClick: (0, import_vue426.toRef)(props, "hideOnClick")
    });
    const onFocusAfterTrapped = (e) => {
      var _a2, _b;
      e.preventDefault();
      (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
        preventScroll: true
      });
    };
    const handlerMainButtonClick = (event) => {
      emit("click", event);
    };
    return {
      t,
      ns: ns2,
      scrollbar,
      wrapStyle,
      dropdownTriggerKls,
      dropdownSize,
      triggerId,
      triggerKeys,
      currentTabId,
      handleCurrentTabIdChange,
      handlerMainButtonClick,
      handleEntryFocus,
      handleClose,
      handleOpen,
      handleBeforeShowTooltip,
      handleShowTooltip,
      handleBeforeHideTooltip,
      onFocusAfterTrapped,
      popperRef,
      contentRef,
      triggeringElementRef,
      referenceElementRef
    };
  }
});
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_el_dropdown_collection = (0, import_vue426.resolveComponent)("el-dropdown-collection");
  const _component_el_roving_focus_group = (0, import_vue426.resolveComponent)("el-roving-focus-group");
  const _component_el_scrollbar = (0, import_vue426.resolveComponent)("el-scrollbar");
  const _component_el_only_child = (0, import_vue426.resolveComponent)("el-only-child");
  const _component_el_tooltip = (0, import_vue426.resolveComponent)("el-tooltip");
  const _component_el_button = (0, import_vue426.resolveComponent)("el-button");
  const _component_arrow_down = (0, import_vue426.resolveComponent)("arrow-down");
  const _component_el_icon = (0, import_vue426.resolveComponent)("el-icon");
  const _component_el_button_group = (0, import_vue426.resolveComponent)("el-button-group");
  return (0, import_vue426.openBlock)(), (0, import_vue426.createElementBlock)("div", {
    class: (0, import_vue426.normalizeClass)([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
  }, [
    (0, import_vue426.createVNode)(_component_el_tooltip, {
      ref: "popperRef",
      role: _ctx.role,
      effect: _ctx.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": _ctx.popperOptions,
      "gpu-acceleration": false,
      "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
      "manual-mode": true,
      placement: _ctx.placement,
      "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
      "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
      trigger: _ctx.trigger,
      "trigger-keys": _ctx.triggerKeys,
      "trigger-target-el": _ctx.contentRef,
      "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
      "stop-popper-mouse-event": false,
      "virtual-ref": _ctx.triggeringElementRef,
      "virtual-triggering": _ctx.splitButton,
      disabled: _ctx.disabled,
      transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
      teleported: _ctx.teleported,
      pure: "",
      persistent: "",
      onBeforeShow: _ctx.handleBeforeShowTooltip,
      onShow: _ctx.handleShowTooltip,
      onBeforeHide: _ctx.handleBeforeHideTooltip
    }, (0, import_vue426.createSlots)({
      content: (0, import_vue426.withCtx)(() => [
        (0, import_vue426.createVNode)(_component_el_scrollbar, {
          ref: "scrollbar",
          "wrap-style": _ctx.wrapStyle,
          tag: "div",
          "view-class": _ctx.ns.e("list")
        }, {
          default: (0, import_vue426.withCtx)(() => [
            (0, import_vue426.createVNode)(_component_el_roving_focus_group, {
              loop: _ctx.loop,
              "current-tab-id": _ctx.currentTabId,
              orientation: "horizontal",
              onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
              onEntryFocus: _ctx.handleEntryFocus
            }, {
              default: (0, import_vue426.withCtx)(() => [
                (0, import_vue426.createVNode)(_component_el_dropdown_collection, null, {
                  default: (0, import_vue426.withCtx)(() => [
                    (0, import_vue426.renderSlot)(_ctx.$slots, "dropdown")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
          ]),
          _: 3
        }, 8, ["wrap-style", "view-class"])
      ]),
      _: 2
    }, [
      !_ctx.splitButton ? {
        name: "default",
        fn: (0, import_vue426.withCtx)(() => [
          (0, import_vue426.createVNode)(_component_el_only_child, {
            id: _ctx.triggerId,
            role: "button",
            tabindex: _ctx.tabindex
          }, {
            default: (0, import_vue426.withCtx)(() => [
              (0, import_vue426.renderSlot)(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "tabindex"])
        ])
      } : void 0
    ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
    _ctx.splitButton ? ((0, import_vue426.openBlock)(), (0, import_vue426.createBlock)(_component_el_button_group, { key: 0 }, {
      default: (0, import_vue426.withCtx)(() => [
        (0, import_vue426.createVNode)(_component_el_button, (0, import_vue426.mergeProps)({ ref: "referenceElementRef" }, _ctx.buttonProps, {
          size: _ctx.dropdownSize,
          type: _ctx.type,
          disabled: _ctx.disabled,
          tabindex: _ctx.tabindex,
          onClick: _ctx.handlerMainButtonClick
        }), {
          default: (0, import_vue426.withCtx)(() => [
            (0, import_vue426.renderSlot)(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
        (0, import_vue426.createVNode)(_component_el_button, (0, import_vue426.mergeProps)({
          id: _ctx.triggerId,
          ref: "triggeringElementRef"
        }, _ctx.buttonProps, {
          role: "button",
          size: _ctx.dropdownSize,
          type: _ctx.type,
          class: _ctx.ns.e("caret-button"),
          disabled: _ctx.disabled,
          tabindex: _ctx.tabindex,
          "aria-label": _ctx.t("el.dropdown.toggleDropdown")
        }), {
          default: (0, import_vue426.withCtx)(() => [
            (0, import_vue426.createVNode)(_component_el_icon, {
              class: (0, import_vue426.normalizeClass)(_ctx.ns.e("icon"))
            }, {
              default: (0, import_vue426.withCtx)(() => [
                (0, import_vue426.createVNode)(_component_arrow_down)
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
      ]),
      _: 3
    })) : (0, import_vue426.createCommentVNode)("v-if", true)
  ], 2);
}
var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main76, [["render", _sfc_render20], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown-item.mjs
var import_vue429 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown-item-impl.mjs
var import_vue427 = require("vue");
var _sfc_main77 = (0, import_vue427.defineComponent)({
  name: "DropdownItemImpl",
  components: {
    ElIcon
  },
  props: dropdownItemProps,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(_2, { emit }) {
    const ns2 = useNamespace("dropdown");
    const { role: menuRole } = (0, import_vue427.inject)(DROPDOWN_INJECTION_KEY, void 0);
    const { collectionItemRef: dropdownCollectionItemRef } = (0, import_vue427.inject)(COLLECTION_ITEM_INJECTION_KEY2, void 0);
    const { collectionItemRef: rovingFocusCollectionItemRef } = (0, import_vue427.inject)(COLLECTION_ITEM_INJECTION_KEY, void 0);
    const {
      rovingFocusGroupItemRef,
      tabIndex,
      handleFocus,
      handleKeydown: handleItemKeydown,
      handleMousedown
    } = (0, import_vue427.inject)(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
    const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
    const role = (0, import_vue427.computed)(() => {
      if (menuRole.value === "menu") {
        return "menuitem";
      } else if (menuRole.value === "navigation") {
        return "link";
      }
      return "button";
    });
    const handleKeydown = composeEventHandlers((e) => {
      const { code } = e;
      if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
        e.preventDefault();
        e.stopImmediatePropagation();
        emit("clickimpl", e);
        return true;
      }
    }, handleItemKeydown);
    return {
      ns: ns2,
      itemRef,
      dataset: {
        [COLLECTION_ITEM_SIGN]: ""
      },
      role,
      tabIndex,
      handleFocus,
      handleKeydown,
      handleMousedown
    };
  }
});
var _hoisted_141 = ["aria-disabled", "tabindex", "role"];
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = (0, import_vue427.resolveComponent)("el-icon");
  return (0, import_vue427.openBlock)(), (0, import_vue427.createElementBlock)(import_vue427.Fragment, null, [
    _ctx.divided ? ((0, import_vue427.openBlock)(), (0, import_vue427.createElementBlock)("li", (0, import_vue427.mergeProps)({
      key: 0,
      role: "separator",
      class: _ctx.ns.bem("menu", "item", "divided")
    }, _ctx.$attrs), null, 16)) : (0, import_vue427.createCommentVNode)("v-if", true),
    (0, import_vue427.createElementVNode)("li", (0, import_vue427.mergeProps)({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
      "aria-disabled": _ctx.disabled,
      class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
      tabindex: _ctx.tabIndex,
      role: _ctx.role,
      onClick: _cache[0] || (_cache[0] = (e) => _ctx.$emit("clickimpl", e)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
      onPointermove: _cache[4] || (_cache[4] = (e) => _ctx.$emit("pointermove", e)),
      onPointerleave: _cache[5] || (_cache[5] = (e) => _ctx.$emit("pointerleave", e))
    }), [
      _ctx.icon ? ((0, import_vue427.openBlock)(), (0, import_vue427.createBlock)(_component_el_icon, { key: 0 }, {
        default: (0, import_vue427.withCtx)(() => [
          ((0, import_vue427.openBlock)(), (0, import_vue427.createBlock)((0, import_vue427.resolveDynamicComponent)(_ctx.icon)))
        ]),
        _: 1
      })) : (0, import_vue427.createCommentVNode)("v-if", true),
      (0, import_vue427.renderSlot)(_ctx.$slots, "default")
    ], 16, _hoisted_141)
  ], 64);
}
var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc(_sfc_main77, [["render", _sfc_render21], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/useDropdown.mjs
var import_vue428 = require("vue");
var useDropdown = () => {
  const elDropdown = (0, import_vue428.inject)("elDropdown", {});
  const _elDropdownSize = (0, import_vue428.computed)(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
  return {
    elDropdown,
    _elDropdownSize
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown-item.mjs
var _sfc_main78 = (0, import_vue429.defineComponent)({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: ElCollectionItem2,
    ElRovingFocusItem,
    ElDropdownItemImpl
  },
  inheritAttrs: false,
  props: dropdownItemProps,
  emits: ["pointermove", "pointerleave", "click"],
  setup(props, { emit, attrs }) {
    const { elDropdown } = useDropdown();
    const _instance = (0, import_vue429.getCurrentInstance)();
    const itemRef = (0, import_vue429.ref)(null);
    const textContent = (0, import_vue429.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = (0, import_vue429.unref)(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
    });
    const { onItemEnter, onItemLeave } = (0, import_vue429.inject)(DROPDOWN_INJECTION_KEY, void 0);
    const handlePointerMove = composeEventHandlers((e) => {
      emit("pointermove", e);
      return e.defaultPrevented;
    }, whenMouse((e) => {
      var _a2;
      if (props.disabled) {
        onItemLeave(e);
      } else {
        onItemEnter(e);
        if (!e.defaultPrevented) {
          ;
          (_a2 = e.currentTarget) == null ? void 0 : _a2.focus();
        }
      }
    }));
    const handlePointerLeave = composeEventHandlers((e) => {
      emit("pointerleave", e);
      return e.defaultPrevented;
    }, whenMouse((e) => {
      onItemLeave(e);
    }));
    const handleClick = composeEventHandlers((e) => {
      if (props.disabled) {
        return;
      }
      emit("click", e);
      return e.type !== "keydown" && e.defaultPrevented;
    }, (e) => {
      var _a2, _b, _c;
      if (props.disabled) {
        e.stopImmediatePropagation();
        return;
      }
      if ((_a2 = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a2.value) {
        (_b = elDropdown.handleClick) == null ? void 0 : _b.call(elDropdown);
      }
      (_c = elDropdown.commandHandler) == null ? void 0 : _c.call(elDropdown, props.command, _instance, e);
    });
    const propsAndAttrs = (0, import_vue429.computed)(() => {
      return { ...props, ...attrs };
    });
    return {
      handleClick,
      handlePointerMove,
      handlePointerLeave,
      textContent,
      propsAndAttrs
    };
  }
});
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_el_dropdown_item_impl = (0, import_vue429.resolveComponent)("el-dropdown-item-impl");
  const _component_el_roving_focus_item = (0, import_vue429.resolveComponent)("el-roving-focus-item");
  const _component_el_dropdown_collection_item = (0, import_vue429.resolveComponent)("el-dropdown-collection-item");
  return (0, import_vue429.openBlock)(), (0, import_vue429.createBlock)(_component_el_dropdown_collection_item, {
    disabled: _ctx.disabled,
    "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
  }, {
    default: (0, import_vue429.withCtx)(() => [
      (0, import_vue429.createVNode)(_component_el_roving_focus_item, {
        focusable: !_ctx.disabled
      }, {
        default: (0, import_vue429.withCtx)(() => [
          (0, import_vue429.createVNode)(_component_el_dropdown_item_impl, (0, import_vue429.mergeProps)(_ctx.propsAndAttrs, {
            onPointerleave: _ctx.handlePointerLeave,
            onPointermove: _ctx.handlePointerMove,
            onClickimpl: _ctx.handleClick
          }), {
            default: (0, import_vue429.withCtx)(() => [
              (0, import_vue429.renderSlot)(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
        ]),
        _: 3
      }, 8, ["focusable"])
    ]),
    _: 3
  }, 8, ["disabled", "text-value"]);
}
var DropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main78, [["render", _sfc_render22], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/src/dropdown-menu.mjs
var import_vue430 = require("vue");
var _sfc_main79 = (0, import_vue430.defineComponent)({
  name: "ElDropdownMenu",
  props: dropdownMenuProps,
  setup(props) {
    const ns2 = useNamespace("dropdown");
    const { _elDropdownSize } = useDropdown();
    const size2 = _elDropdownSize.value;
    const { focusTrapRef, onKeydown } = (0, import_vue430.inject)(FOCUS_TRAP_INJECTION_KEY, void 0);
    const { contentRef, role, triggerId } = (0, import_vue430.inject)(DROPDOWN_INJECTION_KEY, void 0);
    const { collectionRef: dropdownCollectionRef, getItems } = (0, import_vue430.inject)(COLLECTION_INJECTION_KEY2, void 0);
    const {
      rovingFocusGroupRef,
      rovingFocusGroupRootStyle,
      tabIndex,
      onBlur,
      onFocus,
      onMousedown
    } = (0, import_vue430.inject)(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { collectionRef: rovingFocusGroupCollectionRef } = (0, import_vue430.inject)(COLLECTION_INJECTION_KEY, void 0);
    const dropdownKls = (0, import_vue430.computed)(() => {
      return [ns2.b("menu"), ns2.bm("menu", size2 == null ? void 0 : size2.value)];
    });
    const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
    const composedKeydown = composeEventHandlers((e) => {
      var _a2;
      (_a2 = props.onKeydown) == null ? void 0 : _a2.call(props, e);
    }, (e) => {
      const { currentTarget, code, target } = e;
      const isKeydownContained = currentTarget.contains(target);
      if (isKeydownContained) {
      }
      if (EVENT_CODE.tab === code) {
        e.stopImmediatePropagation();
      }
      e.preventDefault();
      if (target !== (0, import_vue430.unref)(contentRef))
        return;
      if (!FIRST_LAST_KEYS.includes(code))
        return;
      const items = getItems().filter((item) => !item.disabled);
      const targets = items.map((item) => item.ref);
      if (LAST_KEYS.includes(code)) {
        targets.reverse();
      }
      focusFirst(targets);
    });
    const handleKeydown = (e) => {
      composedKeydown(e);
      onKeydown(e);
    };
    return {
      size: size2,
      rovingFocusGroupRootStyle,
      tabIndex,
      dropdownKls,
      role,
      triggerId,
      dropdownListWrapperRef,
      handleKeydown,
      onBlur,
      onFocus,
      onMousedown
    };
  }
});
var _hoisted_142 = ["role", "aria-labelledby"];
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue430.openBlock)(), (0, import_vue430.createElementBlock)("ul", {
    ref: _ctx.dropdownListWrapperRef,
    class: (0, import_vue430.normalizeClass)(_ctx.dropdownKls),
    style: (0, import_vue430.normalizeStyle)(_ctx.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: _ctx.role,
    "aria-labelledby": _ctx.triggerId,
    onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
    onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
    onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
    onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.onMousedown && _ctx.onMousedown(...args))
  }, [
    (0, import_vue430.renderSlot)(_ctx.$slots, "default")
  ], 46, _hoisted_142);
}
var DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main79, [["render", _sfc_render23], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/dropdown/index.mjs
var ElDropdown = withInstall(Dropdown, {
  DropdownItem,
  DropdownMenu
});
var ElDropdownItem = withNoopInstall(DropdownItem);
var ElDropdownMenu = withNoopInstall(DropdownMenu);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/empty/src/empty2.mjs
var import_vue432 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/empty/src/img-empty.mjs
var import_vue431 = require("vue");
var id = 0;
var _sfc_main80 = (0, import_vue431.defineComponent)({
  name: "ImgEmpty",
  setup() {
    const ns2 = useNamespace("empty");
    return {
      ns: ns2,
      id: ++id
    };
  }
});
var _hoisted_144 = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
var _hoisted_227 = ["id"];
var _hoisted_318 = ["stop-color"];
var _hoisted_47 = ["stop-color"];
var _hoisted_53 = ["id"];
var _hoisted_6 = ["stop-color"];
var _hoisted_7 = ["stop-color"];
var _hoisted_8 = ["id"];
var _hoisted_9 = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
};
var _hoisted_10 = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
};
var _hoisted_11 = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
};
var _hoisted_1210 = ["fill"];
var _hoisted_1310 = ["fill"];
var _hoisted_145 = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
};
var _hoisted_152 = ["fill"];
var _hoisted_162 = ["fill"];
var _hoisted_174 = ["fill"];
var _hoisted_182 = ["fill"];
var _hoisted_192 = ["fill"];
var _hoisted_20 = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
};
var _hoisted_21 = ["fill", "xlink:href"];
var _hoisted_228 = ["fill", "mask"];
var _hoisted_232 = ["fill"];
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue431.openBlock)(), (0, import_vue431.createElementBlock)("svg", _hoisted_144, [
    (0, import_vue431.createElementVNode)("defs", null, [
      (0, import_vue431.createElementVNode)("linearGradient", {
        id: `linearGradient-1-${_ctx.id}`,
        x1: "38.8503086%",
        y1: "0%",
        x2: "61.1496914%",
        y2: "100%"
      }, [
        (0, import_vue431.createElementVNode)("stop", {
          "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-1")})`,
          offset: "0%"
        }, null, 8, _hoisted_318),
        (0, import_vue431.createElementVNode)("stop", {
          "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-4")})`,
          offset: "100%"
        }, null, 8, _hoisted_47)
      ], 8, _hoisted_227),
      (0, import_vue431.createElementVNode)("linearGradient", {
        id: `linearGradient-2-${_ctx.id}`,
        x1: "0%",
        y1: "9.5%",
        x2: "100%",
        y2: "90.5%"
      }, [
        (0, import_vue431.createElementVNode)("stop", {
          "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-1")})`,
          offset: "0%"
        }, null, 8, _hoisted_6),
        (0, import_vue431.createElementVNode)("stop", {
          "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-6")})`,
          offset: "100%"
        }, null, 8, _hoisted_7)
      ], 8, _hoisted_53),
      (0, import_vue431.createElementVNode)("rect", {
        id: `path-3-${_ctx.id}`,
        x: "0",
        y: "0",
        width: "17",
        height: "36"
      }, null, 8, _hoisted_8)
    ]),
    (0, import_vue431.createElementVNode)("g", _hoisted_9, [
      (0, import_vue431.createElementVNode)("g", _hoisted_10, [
        (0, import_vue431.createElementVNode)("g", _hoisted_11, [
          (0, import_vue431.createElementVNode)("path", {
            id: "Oval-Copy-2",
            d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
            fill: `var(${_ctx.ns.cssVarBlockName("fill-color-3")})`
          }, null, 8, _hoisted_1210),
          (0, import_vue431.createElementVNode)("polygon", {
            id: "Rectangle-Copy-14",
            fill: `var(${_ctx.ns.cssVarBlockName("fill-color-7")})`,
            transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
            points: "13 58 53 58 42 45 2 45"
          }, null, 8, _hoisted_1310),
          (0, import_vue431.createElementVNode)("g", _hoisted_145, [
            (0, import_vue431.createElementVNode)("polygon", {
              id: "Rectangle-Copy-10",
              fill: `var(${_ctx.ns.cssVarBlockName("fill-color-7")})`,
              transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
              points: "2.84078316e-14 3 18 3 23 7 5 7"
            }, null, 8, _hoisted_152),
            (0, import_vue431.createElementVNode)("polygon", {
              id: "Rectangle-Copy-11",
              fill: `var(${_ctx.ns.cssVarBlockName("fill-color-5")})`,
              points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
            }, null, 8, _hoisted_162),
            (0, import_vue431.createElementVNode)("rect", {
              id: "Rectangle-Copy-12",
              fill: `url(#linearGradient-1-${_ctx.id})`,
              transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
              x: "38",
              y: "7",
              width: "17",
              height: "36"
            }, null, 8, _hoisted_174),
            (0, import_vue431.createElementVNode)("polygon", {
              id: "Rectangle-Copy-13",
              fill: `var(${_ctx.ns.cssVarBlockName("fill-color-2")})`,
              transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
              points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
            }, null, 8, _hoisted_182)
          ]),
          (0, import_vue431.createElementVNode)("rect", {
            id: "Rectangle-Copy-15",
            fill: `url(#linearGradient-2-${_ctx.id})`,
            x: "13",
            y: "45",
            width: "40",
            height: "36"
          }, null, 8, _hoisted_192),
          (0, import_vue431.createElementVNode)("g", _hoisted_20, [
            (0, import_vue431.createElementVNode)("use", {
              id: "Mask",
              fill: `var(${_ctx.ns.cssVarBlockName("fill-color-8")})`,
              transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
              "xlink:href": `#path-3-${_ctx.id}`
            }, null, 8, _hoisted_21),
            (0, import_vue431.createElementVNode)("polygon", {
              id: "Rectangle-Copy",
              fill: `var(${_ctx.ns.cssVarBlockName("fill-color-9")})`,
              mask: `url(#mask-4-${_ctx.id})`,
              transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
              points: "7 0 24 0 20 18 7 16.5"
            }, null, 8, _hoisted_228)
          ]),
          (0, import_vue431.createElementVNode)("polygon", {
            id: "Rectangle-Copy-18",
            fill: `var(${_ctx.ns.cssVarBlockName("fill-color-2")})`,
            transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
            points: "62 45 79 45 70 58 53 58"
          }, null, 8, _hoisted_232)
        ])
      ])
    ])
  ]);
}
var ImgEmpty = /* @__PURE__ */ _export_sfc(_sfc_main80, [["render", _sfc_render24], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/empty/src/empty.mjs
var emptyProps = {
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/empty/src/empty2.mjs
var _hoisted_146 = ["src"];
var _hoisted_230 = { key: 1 };
var __default__52 = (0, import_vue432.defineComponent)({
  name: "ElEmpty"
});
var _sfc_main81 = /* @__PURE__ */ (0, import_vue432.defineComponent)({
  ...__default__52,
  props: emptyProps,
  setup(__props) {
    const props = __props;
    const { t } = useLocale();
    const ns2 = useNamespace("empty");
    const emptyDescription = (0, import_vue432.computed)(() => props.description || t("el.table.emptyText"));
    const imageStyle = (0, import_vue432.computed)(() => ({
      width: props.imageSize ? `${props.imageSize}px` : ""
    }));
    return (_ctx, _cache) => {
      return (0, import_vue432.openBlock)(), (0, import_vue432.createElementBlock)("div", {
        class: (0, import_vue432.normalizeClass)((0, import_vue432.unref)(ns2).b())
      }, [
        (0, import_vue432.createElementVNode)("div", {
          class: (0, import_vue432.normalizeClass)((0, import_vue432.unref)(ns2).e("image")),
          style: (0, import_vue432.normalizeStyle)((0, import_vue432.unref)(imageStyle))
        }, [
          _ctx.image ? ((0, import_vue432.openBlock)(), (0, import_vue432.createElementBlock)("img", {
            key: 0,
            src: _ctx.image,
            ondragstart: "return false"
          }, null, 8, _hoisted_146)) : (0, import_vue432.renderSlot)(_ctx.$slots, "image", { key: 1 }, () => [
            (0, import_vue432.createVNode)(ImgEmpty)
          ])
        ], 6),
        (0, import_vue432.createElementVNode)("div", {
          class: (0, import_vue432.normalizeClass)((0, import_vue432.unref)(ns2).e("description"))
        }, [
          _ctx.$slots.description ? (0, import_vue432.renderSlot)(_ctx.$slots, "description", { key: 0 }) : ((0, import_vue432.openBlock)(), (0, import_vue432.createElementBlock)("p", _hoisted_230, (0, import_vue432.toDisplayString)((0, import_vue432.unref)(emptyDescription)), 1))
        ], 2),
        _ctx.$slots.default ? ((0, import_vue432.openBlock)(), (0, import_vue432.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue432.normalizeClass)((0, import_vue432.unref)(ns2).e("bottom"))
        }, [
          (0, import_vue432.renderSlot)(_ctx.$slots, "default")
        ], 2)) : (0, import_vue432.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var Empty = /* @__PURE__ */ _export_sfc(_sfc_main81, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/empty/index.mjs
var ElEmpty = withInstall(Empty);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form2.mjs
var import_vue434 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form.mjs
var import_shared60 = require("@vue/shared");
var formProps = buildProps({
  model: Object,
  rules: {
    type: definePropType(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: componentSizes
  },
  disabled: Boolean,
  validateOnRuleChange: {
    type: Boolean,
    default: true
  },
  hideRequiredAsterisk: {
    type: Boolean,
    default: false
  },
  scrollToError: Boolean
});
var formEmits = {
  validate: (prop, isValid, message2) => ((0, import_shared60.isArray)(prop) || (0, import_shared60.isString)(prop)) && isBoolean(isValid) && (0, import_shared60.isString)(message2)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/utils.mjs
var import_vue433 = require("vue");
var SCOPE3 = "ElForm";
function useFormLabelWidth() {
  const potentialLabelWidthArr = (0, import_vue433.ref)([]);
  const autoLabelWidth = (0, import_vue433.computed)(() => {
    if (!potentialLabelWidthArr.value.length)
      return "0";
    const max4 = Math.max(...potentialLabelWidthArr.value);
    return max4 ? `${max4}px` : "";
  });
  function getLabelWidthIndex(width) {
    const index2 = potentialLabelWidthArr.value.indexOf(width);
    if (index2 === -1 && autoLabelWidth.value === "0") {
      debugWarn(SCOPE3, `unexpected width ${width}`);
    }
    return index2;
  }
  function registerLabelWidth(val, oldVal) {
    if (val && oldVal) {
      const index2 = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.value.splice(index2, 1, val);
    } else if (val) {
      potentialLabelWidthArr.value.push(val);
    }
  }
  function deregisterLabelWidth(val) {
    const index2 = getLabelWidthIndex(val);
    if (index2 > -1) {
      potentialLabelWidthArr.value.splice(index2, 1);
    }
  }
  return {
    autoLabelWidth,
    registerLabelWidth,
    deregisterLabelWidth
  };
}
var filterFields = (fields, props) => {
  const normalized = castArray_default(props);
  return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form2.mjs
var import_shared61 = require("@vue/shared");
var COMPONENT_NAME10 = "ElForm";
var __default__53 = (0, import_vue434.defineComponent)({
  name: COMPONENT_NAME10
});
var _sfc_main82 = /* @__PURE__ */ (0, import_vue434.defineComponent)({
  ...__default__53,
  props: formProps,
  emits: formEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const fields = [];
    const formSize = useSize();
    const ns2 = useNamespace("form");
    const formClasses = (0, import_vue434.computed)(() => {
      const { labelPosition, inline: inline2 } = props;
      return [
        ns2.b(),
        ns2.m(formSize.value || "default"),
        {
          [ns2.m(`label-${labelPosition}`)]: labelPosition,
          [ns2.m("inline")]: inline2
        }
      ];
    });
    const addField = (field) => {
      fields.push(field);
    };
    const removeField = (field) => {
      if (field.prop) {
        fields.splice(fields.indexOf(field), 1);
      }
    };
    const resetFields = (properties = []) => {
      if (!props.model) {
        debugWarn(COMPONENT_NAME10, "model is required for resetFields to work.");
        return;
      }
      filterFields(fields, properties).forEach((field) => field.resetField());
    };
    const clearValidate = (props2 = []) => {
      filterFields(fields, props2).forEach((field) => field.clearValidate());
    };
    const isValidatable = (0, import_vue434.computed)(() => {
      const hasModel = !!props.model;
      if (!hasModel) {
        debugWarn(COMPONENT_NAME10, "model is required for validate to work.");
      }
      return hasModel;
    });
    const obtainValidateFields = (props2) => {
      if (fields.length === 0)
        return [];
      const filteredFields = filterFields(fields, props2);
      if (!filteredFields.length) {
        debugWarn(COMPONENT_NAME10, "please pass correct props!");
        return [];
      }
      return filteredFields;
    };
    const validate = async (callback) => validateField(void 0, callback);
    const doValidateField = async (props2 = []) => {
      if (!isValidatable.value)
        return false;
      const fields2 = obtainValidateFields(props2);
      if (fields2.length === 0)
        return true;
      let validationErrors = {};
      for (const field of fields2) {
        try {
          await field.validate("");
        } catch (fields3) {
          validationErrors = {
            ...validationErrors,
            ...fields3
          };
        }
      }
      if (Object.keys(validationErrors).length === 0)
        return true;
      return Promise.reject(validationErrors);
    };
    const validateField = async (modelProps = [], callback) => {
      const shouldThrow = !(0, import_shared61.isFunction)(callback);
      try {
        const result = await doValidateField(modelProps);
        if (result === true) {
          callback == null ? void 0 : callback(result);
        }
        return result;
      } catch (e) {
        if (e instanceof Error)
          throw e;
        const invalidFields = e;
        if (props.scrollToError) {
          scrollToField(Object.keys(invalidFields)[0]);
        }
        callback == null ? void 0 : callback(false, invalidFields);
        return shouldThrow && Promise.reject(invalidFields);
      }
    };
    const scrollToField = (prop) => {
      var _a2;
      const field = filterFields(fields, prop)[0];
      if (field) {
        (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView();
      }
    };
    (0, import_vue434.watch)(() => props.rules, () => {
      if (props.validateOnRuleChange) {
        validate().catch((err) => debugWarn(err));
      }
    }, { deep: true });
    (0, import_vue434.provide)(formContextKey, (0, import_vue434.reactive)({
      ...(0, import_vue434.toRefs)(props),
      emit,
      resetFields,
      clearValidate,
      validateField,
      addField,
      removeField,
      ...useFormLabelWidth()
    }));
    expose({
      validate,
      validateField,
      resetFields,
      clearValidate,
      scrollToField
    });
    return (_ctx, _cache) => {
      return (0, import_vue434.openBlock)(), (0, import_vue434.createElementBlock)("form", {
        class: (0, import_vue434.normalizeClass)((0, import_vue434.unref)(formClasses))
      }, [
        (0, import_vue434.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Form = /* @__PURE__ */ _export_sfc(_sfc_main82, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form-item2.mjs
var import_vue436 = require("vue");

// ../../node_modules/.pnpm/async-validator@4.2.5/node_modules/async-validator/dist-web/index.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a3 = [null];
      a3.push.apply(a3, args2);
      var Constructor = Function.bind.apply(Parent2, a3);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && process.env && process.env.NODE_ENV !== "production" && typeof window !== "undefined" && typeof document !== "undefined") {
  warning = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x3) {
      if (x3 === "%%") {
        return "%";
      }
      if (i >= len) {
        return x3;
      }
      switch (x3) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x3;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total2 = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total2++;
    if (total2 === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a3) {
    func(a3, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option2, func, callback, source) {
  if (option2.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option2.firstFields === true ? Object.keys(objArr) : option2.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total2 = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total2++;
      if (total2 === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue2(value, path) {
  var v3 = value;
  for (var i = 0; i < path.length; i++) {
    if (v3 == void 0) {
      return v3;
    }
    v3 = v3[path[i]];
  }
  return v3;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue2(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s2 in source) {
      if (source.hasOwnProperty(s2)) {
        var value = source[s2];
        if (typeof value === "object" && typeof target[s2] === "object") {
          target[s2] = _extends({}, target[s2], value);
        } else {
          target[s2] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b3 = function b4(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b3(options) + v4 + b3(options) + ")|(?:" + b3(options) + v6 + b3(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b3(options) + v4 + b3(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b3(options) + v6 + b3(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date2(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min4 = typeof rule.min === "number";
  var max4 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min4 && !max4 && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max4 && !min4 && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min4 && max4 && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date3 = function date4(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date3,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone3() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define2(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options = o2;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr = _this2.rules[z2];
      var value = source[z2];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z2] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value,
          source,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errorList = Array.isArray(e) ? e : [e];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data.value, cb, data.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb(error.message);
        }
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form-item.mjs
var formItemValidateStates = [
  "",
  "error",
  "validating",
  "success"
];
var formItemProps = buildProps({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: definePropType([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: definePropType([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: formItemValidateStates
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: componentSizes
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form-label-wrap.mjs
var import_vue435 = require("vue");
var COMPONENT_NAME11 = "ElLabelWrap";
var FormLabelWrap = (0, import_vue435.defineComponent)({
  name: COMPONENT_NAME11,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(props, {
    slots
  }) {
    const formContext = (0, import_vue435.inject)(formContextKey, void 0);
    const formItemContext = (0, import_vue435.inject)(formItemContextKey);
    if (!formItemContext)
      throwError(COMPONENT_NAME11, "usage: <el-form-item><label-wrap /></el-form-item>");
    const ns2 = useNamespace("form");
    const el = (0, import_vue435.ref)();
    const computedWidth = (0, import_vue435.ref)(0);
    const getLabelWidth = () => {
      var _a2;
      if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
        const width = window.getComputedStyle(el.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(width));
      } else {
        return 0;
      }
    };
    const updateLabelWidth = (action = "update") => {
      (0, import_vue435.nextTick)(() => {
        if (slots.default && props.isAutoWidth) {
          if (action === "update") {
            computedWidth.value = getLabelWidth();
          } else if (action === "remove") {
            formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
          }
        }
      });
    };
    const updateLabelWidthFn = () => updateLabelWidth("update");
    (0, import_vue435.onMounted)(() => {
      updateLabelWidthFn();
    });
    (0, import_vue435.onBeforeUnmount)(() => {
      updateLabelWidth("remove");
    });
    (0, import_vue435.onUpdated)(() => updateLabelWidthFn());
    (0, import_vue435.watch)(computedWidth, (val, oldVal) => {
      if (props.updateAll) {
        formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
      }
    });
    useResizeObserver((0, import_vue435.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
    }), updateLabelWidthFn);
    return () => {
      var _a2, _b;
      if (!slots)
        return null;
      const {
        isAutoWidth
      } = props;
      if (isAutoWidth) {
        const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
        const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
        const style = {};
        if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
          const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
          const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
          if (marginWidth) {
            style[marginPosition] = `${marginWidth}px`;
          }
        }
        return (0, import_vue435.createVNode)("div", {
          "ref": el,
          "class": [ns2.be("item", "label-wrap")],
          "style": style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      } else {
        return (0, import_vue435.createVNode)(import_vue435.Fragment, {
          "ref": el
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
      }
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/src/form-item2.mjs
var import_shared62 = require("@vue/shared");
var _hoisted_147 = ["role", "aria-labelledby"];
var __default__54 = (0, import_vue436.defineComponent)({
  name: "ElFormItem"
});
var _sfc_main83 = /* @__PURE__ */ (0, import_vue436.defineComponent)({
  ...__default__54,
  props: formItemProps,
  setup(__props, { expose }) {
    const props = __props;
    const slots = (0, import_vue436.useSlots)();
    const formContext = (0, import_vue436.inject)(formContextKey, void 0);
    const parentFormItemContext = (0, import_vue436.inject)(formItemContextKey, void 0);
    const _size = useSize(void 0, { formItem: false });
    const ns2 = useNamespace("form-item");
    const labelId = useId().value;
    const inputIds = (0, import_vue436.ref)([]);
    const validateState = (0, import_vue436.ref)("");
    const validateStateDebounced = refDebounced(validateState, 100);
    const validateMessage = (0, import_vue436.ref)("");
    const formItemRef = (0, import_vue436.ref)();
    let initialValue = void 0;
    let isResettingField = false;
    const labelStyle = (0, import_vue436.computed)(() => {
      if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
        return {};
      }
      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
      if (labelWidth)
        return { width: labelWidth };
      return {};
    });
    const contentStyle = (0, import_vue436.computed)(() => {
      if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
        return {};
      }
      if (!props.label && !props.labelWidth && isNested) {
        return {};
      }
      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
      if (!props.label && !slots.label) {
        return { marginLeft: labelWidth };
      }
      return {};
    });
    const formItemClasses = (0, import_vue436.computed)(() => [
      ns2.b(),
      ns2.m(_size.value),
      ns2.is("error", validateState.value === "error"),
      ns2.is("validating", validateState.value === "validating"),
      ns2.is("success", validateState.value === "success"),
      ns2.is("required", isRequired.value || props.required),
      ns2.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
      (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      { [ns2.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
    ]);
    const _inlineMessage = (0, import_vue436.computed)(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
    const validateClasses = (0, import_vue436.computed)(() => [
      ns2.e("error"),
      { [ns2.em("error", "inline")]: _inlineMessage.value }
    ]);
    const propString = (0, import_vue436.computed)(() => {
      if (!props.prop)
        return "";
      return (0, import_shared62.isString)(props.prop) ? props.prop : props.prop.join(".");
    });
    const hasLabel = (0, import_vue436.computed)(() => {
      return !!(props.label || slots.label);
    });
    const labelFor = (0, import_vue436.computed)(() => {
      return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
    });
    const isGroup = (0, import_vue436.computed)(() => {
      return !labelFor.value && hasLabel.value;
    });
    const isNested = !!parentFormItemContext;
    const fieldValue = (0, import_vue436.computed)(() => {
      const model = formContext == null ? void 0 : formContext.model;
      if (!model || !props.prop) {
        return;
      }
      return getProp(model, props.prop).value;
    });
    const normalizedRules = (0, import_vue436.computed)(() => {
      const { required: required4 } = props;
      const rules2 = [];
      if (props.rules) {
        rules2.push(...castArray_default(props.rules));
      }
      const formRules = formContext == null ? void 0 : formContext.rules;
      if (formRules && props.prop) {
        const _rules = getProp(formRules, props.prop).value;
        if (_rules) {
          rules2.push(...castArray_default(_rules));
        }
      }
      if (required4 !== void 0) {
        const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
        if (requiredRules.length > 0) {
          for (const [rule, i] of requiredRules) {
            if (rule.required === required4)
              continue;
            rules2[i] = { ...rule, required: required4 };
          }
        } else {
          rules2.push({ required: required4 });
        }
      }
      return rules2;
    });
    const validateEnabled = (0, import_vue436.computed)(() => normalizedRules.value.length > 0);
    const getFilteredRule = (trigger) => {
      const rules2 = normalizedRules.value;
      return rules2.filter((rule) => {
        if (!rule.trigger || !trigger)
          return true;
        if (Array.isArray(rule.trigger)) {
          return rule.trigger.includes(trigger);
        } else {
          return rule.trigger === trigger;
        }
      }).map(({ trigger: trigger2, ...rule }) => rule);
    };
    const isRequired = (0, import_vue436.computed)(() => normalizedRules.value.some((rule) => rule.required));
    const shouldShowError = (0, import_vue436.computed)(() => {
      var _a2;
      return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
    });
    const currentLabel = (0, import_vue436.computed)(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
    const setValidationState = (state) => {
      validateState.value = state;
    };
    const onValidationFailed = (error) => {
      var _a2, _b;
      const { errors, fields } = error;
      if (!errors || !fields) {
        console.error(error);
      }
      setValidationState("error");
      validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
      formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
    };
    const onValidationSucceeded = () => {
      setValidationState("success");
      formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
    };
    const doValidate = async (rules2) => {
      const modelName = propString.value;
      const validator = new Schema({
        [modelName]: rules2
      });
      return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
        onValidationSucceeded();
        return true;
      }).catch((err) => {
        onValidationFailed(err);
        return Promise.reject(err);
      });
    };
    const validate = async (trigger, callback) => {
      if (isResettingField || !props.prop) {
        return false;
      }
      const hasCallback = (0, import_shared62.isFunction)(callback);
      if (!validateEnabled.value) {
        callback == null ? void 0 : callback(false);
        return false;
      }
      const rules2 = getFilteredRule(trigger);
      if (rules2.length === 0) {
        callback == null ? void 0 : callback(true);
        return true;
      }
      setValidationState("validating");
      return doValidate(rules2).then(() => {
        callback == null ? void 0 : callback(true);
        return true;
      }).catch((err) => {
        const { fields } = err;
        callback == null ? void 0 : callback(false, fields);
        return hasCallback ? false : Promise.reject(fields);
      });
    };
    const clearValidate = () => {
      setValidationState("");
      validateMessage.value = "";
      isResettingField = false;
    };
    const resetField = async () => {
      const model = formContext == null ? void 0 : formContext.model;
      if (!model || !props.prop)
        return;
      const computedValue = getProp(model, props.prop);
      isResettingField = true;
      computedValue.value = clone_default(initialValue);
      await (0, import_vue436.nextTick)();
      clearValidate();
      isResettingField = false;
    };
    const addInputId = (id2) => {
      if (!inputIds.value.includes(id2)) {
        inputIds.value.push(id2);
      }
    };
    const removeInputId = (id2) => {
      inputIds.value = inputIds.value.filter((listId) => listId !== id2);
    };
    (0, import_vue436.watch)(() => props.error, (val) => {
      validateMessage.value = val || "";
      setValidationState(val ? "error" : "");
    }, { immediate: true });
    (0, import_vue436.watch)(() => props.validateStatus, (val) => setValidationState(val || ""));
    const context = (0, import_vue436.reactive)({
      ...(0, import_vue436.toRefs)(props),
      $el: formItemRef,
      size: _size,
      validateState,
      labelId,
      inputIds,
      isGroup,
      hasLabel,
      addInputId,
      removeInputId,
      resetField,
      clearValidate,
      validate
    });
    (0, import_vue436.provide)(formItemContextKey, context);
    (0, import_vue436.onMounted)(() => {
      if (props.prop) {
        formContext == null ? void 0 : formContext.addField(context);
        initialValue = clone_default(fieldValue.value);
      }
    });
    (0, import_vue436.onBeforeUnmount)(() => {
      formContext == null ? void 0 : formContext.removeField(context);
    });
    expose({
      size: _size,
      validateMessage,
      validateState,
      validate,
      clearValidate,
      resetField
    });
    return (_ctx, _cache) => {
      var _a2;
      return (0, import_vue436.openBlock)(), (0, import_vue436.createElementBlock)("div", {
        ref_key: "formItemRef",
        ref: formItemRef,
        class: (0, import_vue436.normalizeClass)((0, import_vue436.unref)(formItemClasses)),
        role: (0, import_vue436.unref)(isGroup) ? "group" : void 0,
        "aria-labelledby": (0, import_vue436.unref)(isGroup) ? (0, import_vue436.unref)(labelId) : void 0
      }, [
        (0, import_vue436.createVNode)((0, import_vue436.unref)(FormLabelWrap), {
          "is-auto-width": (0, import_vue436.unref)(labelStyle).width === "auto",
          "update-all": ((_a2 = (0, import_vue436.unref)(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
        }, {
          default: (0, import_vue436.withCtx)(() => [
            (0, import_vue436.unref)(hasLabel) ? ((0, import_vue436.openBlock)(), (0, import_vue436.createBlock)((0, import_vue436.resolveDynamicComponent)((0, import_vue436.unref)(labelFor) ? "label" : "div"), {
              key: 0,
              id: (0, import_vue436.unref)(labelId),
              for: (0, import_vue436.unref)(labelFor),
              class: (0, import_vue436.normalizeClass)((0, import_vue436.unref)(ns2).e("label")),
              style: (0, import_vue436.normalizeStyle)((0, import_vue436.unref)(labelStyle))
            }, {
              default: (0, import_vue436.withCtx)(() => [
                (0, import_vue436.renderSlot)(_ctx.$slots, "label", { label: (0, import_vue436.unref)(currentLabel) }, () => [
                  (0, import_vue436.createTextVNode)((0, import_vue436.toDisplayString)((0, import_vue436.unref)(currentLabel)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : (0, import_vue436.createCommentVNode)("v-if", true)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        (0, import_vue436.createElementVNode)("div", {
          class: (0, import_vue436.normalizeClass)((0, import_vue436.unref)(ns2).e("content")),
          style: (0, import_vue436.normalizeStyle)((0, import_vue436.unref)(contentStyle))
        }, [
          (0, import_vue436.renderSlot)(_ctx.$slots, "default"),
          (0, import_vue436.createVNode)(import_vue436.Transition, {
            name: `${(0, import_vue436.unref)(ns2).namespace.value}-zoom-in-top`
          }, {
            default: (0, import_vue436.withCtx)(() => [
              (0, import_vue436.unref)(shouldShowError) ? (0, import_vue436.renderSlot)(_ctx.$slots, "error", {
                key: 0,
                error: validateMessage.value
              }, () => [
                (0, import_vue436.createElementVNode)("div", {
                  class: (0, import_vue436.normalizeClass)((0, import_vue436.unref)(validateClasses))
                }, (0, import_vue436.toDisplayString)(validateMessage.value), 3)
              ]) : (0, import_vue436.createCommentVNode)("v-if", true)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, _hoisted_147);
    };
  }
});
var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main83, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/form/index.mjs
var ElForm = withInstall(Form, {
  FormItem
});
var ElFormItem = withNoopInstall(FormItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image/src/image2.mjs
var import_vue438 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image-viewer/src/image-viewer2.mjs
var import_vue437 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image-viewer/src/image-viewer.mjs
var imageViewerProps = buildProps({
  urlList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: true
  },
  hideOnClickModal: {
    type: Boolean,
    default: false
  },
  teleported: {
    type: Boolean,
    default: false
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  zoomRate: {
    type: Number,
    default: 1.2
  }
});
var imageViewerEmits = {
  close: () => true,
  switch: (index2) => isNumber(index2)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image-viewer/src/image-viewer2.mjs
var _hoisted_153 = ["src"];
var __default__55 = (0, import_vue437.defineComponent)({
  name: "ElImageViewer"
});
var _sfc_main84 = /* @__PURE__ */ (0, import_vue437.defineComponent)({
  ...__default__55,
  props: imageViewerProps,
  emits: imageViewerEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const modes = {
      CONTAIN: {
        name: "contain",
        icon: (0, import_vue437.markRaw)(full_screen_default)
      },
      ORIGINAL: {
        name: "original",
        icon: (0, import_vue437.markRaw)(scale_to_original_default)
      }
    };
    const mousewheelEventName = isFirefox() ? "DOMMouseScroll" : "mousewheel";
    const { t } = useLocale();
    const ns2 = useNamespace("image-viewer");
    const { nextZIndex } = useZIndex();
    const wrapper = (0, import_vue437.ref)();
    const imgRefs = (0, import_vue437.ref)([]);
    const scopeEventListener = (0, import_vue437.effectScope)();
    const loading = (0, import_vue437.ref)(true);
    const activeIndex = (0, import_vue437.ref)(props.initialIndex);
    const mode = (0, import_vue437.shallowRef)(modes.CONTAIN);
    const transform = (0, import_vue437.ref)({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: false
    });
    const isSingle = (0, import_vue437.computed)(() => {
      const { urlList } = props;
      return urlList.length <= 1;
    });
    const isFirst = (0, import_vue437.computed)(() => {
      return activeIndex.value === 0;
    });
    const isLast = (0, import_vue437.computed)(() => {
      return activeIndex.value === props.urlList.length - 1;
    });
    const currentImg = (0, import_vue437.computed)(() => {
      return props.urlList[activeIndex.value];
    });
    const imgStyle = (0, import_vue437.computed)(() => {
      const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
      let translateX = offsetX / scale;
      let translateY = offsetY / scale;
      switch (deg % 360) {
        case 90:
        case -270:
          ;
          [translateX, translateY] = [translateY, -translateX];
          break;
        case 180:
        case -180:
          ;
          [translateX, translateY] = [-translateX, -translateY];
          break;
        case 270:
        case -90:
          ;
          [translateX, translateY] = [-translateY, translateX];
          break;
      }
      const style = {
        transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
        transition: enableTransition ? "transform .3s" : ""
      };
      if (mode.value.name === modes.CONTAIN.name) {
        style.maxWidth = style.maxHeight = "100%";
      }
      return style;
    });
    const computedZIndex = (0, import_vue437.computed)(() => {
      return isNumber(props.zIndex) ? props.zIndex : nextZIndex();
    });
    function hide2() {
      unregisterEventListener();
      emit("close");
    }
    function registerEventListener() {
      const keydownHandler = throttle_default((e) => {
        switch (e.code) {
          case EVENT_CODE.esc:
            props.closeOnPressEscape && hide2();
            break;
          case EVENT_CODE.space:
            toggleMode();
            break;
          case EVENT_CODE.left:
            prev();
            break;
          case EVENT_CODE.up:
            handleActions("zoomIn");
            break;
          case EVENT_CODE.right:
            next();
            break;
          case EVENT_CODE.down:
            handleActions("zoomOut");
            break;
        }
      });
      const mousewheelHandler = throttle_default((e) => {
        const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
        if (delta > 0) {
          handleActions("zoomIn", {
            zoomRate: props.zoomRate,
            enableTransition: false
          });
        } else {
          handleActions("zoomOut", {
            zoomRate: props.zoomRate,
            enableTransition: false
          });
        }
      });
      scopeEventListener.run(() => {
        useEventListener(document, "keydown", keydownHandler);
        useEventListener(document, mousewheelEventName, mousewheelHandler);
      });
    }
    function unregisterEventListener() {
      scopeEventListener.stop();
    }
    function handleImgLoad() {
      loading.value = false;
    }
    function handleImgError(e) {
      loading.value = false;
      e.target.alt = t("el.image.error");
    }
    function handleMouseDown(e) {
      if (loading.value || e.button !== 0 || !wrapper.value)
        return;
      transform.value.enableTransition = false;
      const { offsetX, offsetY } = transform.value;
      const startX = e.pageX;
      const startY = e.pageY;
      const dragHandler = throttle_default((ev) => {
        transform.value = {
          ...transform.value,
          offsetX: offsetX + ev.pageX - startX,
          offsetY: offsetY + ev.pageY - startY
        };
      });
      const removeMousemove = useEventListener(document, "mousemove", dragHandler);
      useEventListener(document, "mouseup", () => {
        removeMousemove();
      });
      e.preventDefault();
    }
    function reset() {
      transform.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      };
    }
    function toggleMode() {
      if (loading.value)
        return;
      const modeNames = keysOf(modes);
      const modeValues = Object.values(modes);
      const currentMode = mode.value.name;
      const index2 = modeValues.findIndex((i) => i.name === currentMode);
      const nextIndex = (index2 + 1) % modeNames.length;
      mode.value = modes[modeNames[nextIndex]];
      reset();
    }
    function setActiveItem(index2) {
      const len = props.urlList.length;
      activeIndex.value = (index2 + len) % len;
    }
    function prev() {
      if (isFirst.value && !props.infinite)
        return;
      setActiveItem(activeIndex.value - 1);
    }
    function next() {
      if (isLast.value && !props.infinite)
        return;
      setActiveItem(activeIndex.value + 1);
    }
    function handleActions(action, options = {}) {
      if (loading.value)
        return;
      const { zoomRate, rotateDeg, enableTransition } = {
        zoomRate: props.zoomRate,
        rotateDeg: 90,
        enableTransition: true,
        ...options
      };
      switch (action) {
        case "zoomOut":
          if (transform.value.scale > 0.2) {
            transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
          }
          break;
        case "zoomIn":
          if (transform.value.scale < 7) {
            transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
          }
          break;
        case "clockwise":
          transform.value.deg += rotateDeg;
          break;
        case "anticlockwise":
          transform.value.deg -= rotateDeg;
          break;
      }
      transform.value.enableTransition = enableTransition;
    }
    (0, import_vue437.watch)(currentImg, () => {
      (0, import_vue437.nextTick)(() => {
        const $img = imgRefs.value[0];
        if (!($img == null ? void 0 : $img.complete)) {
          loading.value = true;
        }
      });
    });
    (0, import_vue437.watch)(activeIndex, (val) => {
      reset();
      emit("switch", val);
    });
    (0, import_vue437.onMounted)(() => {
      var _a2, _b;
      registerEventListener();
      (_b = (_a2 = wrapper.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    });
    expose({
      setActiveItem
    });
    return (_ctx, _cache) => {
      return (0, import_vue437.openBlock)(), (0, import_vue437.createBlock)(import_vue437.Teleport, {
        to: "body",
        disabled: !_ctx.teleported
      }, [
        (0, import_vue437.createVNode)(import_vue437.Transition, {
          name: "viewer-fade",
          appear: ""
        }, {
          default: (0, import_vue437.withCtx)(() => [
            (0, import_vue437.createElementVNode)("div", {
              ref_key: "wrapper",
              ref: wrapper,
              tabindex: -1,
              class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("wrapper")),
              style: (0, import_vue437.normalizeStyle)({ zIndex: (0, import_vue437.unref)(computedZIndex) })
            }, [
              (0, import_vue437.createElementVNode)("div", {
                class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("mask")),
                onClick: _cache[0] || (_cache[0] = (0, import_vue437.withModifiers)(($event) => _ctx.hideOnClickModal && hide2(), ["self"]))
              }, null, 2),
              (0, import_vue437.createCommentVNode)(" CLOSE "),
              (0, import_vue437.createElementVNode)("span", {
                class: (0, import_vue437.normalizeClass)([(0, import_vue437.unref)(ns2).e("btn"), (0, import_vue437.unref)(ns2).e("close")]),
                onClick: hide2
              }, [
                (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), null, {
                  default: (0, import_vue437.withCtx)(() => [
                    (0, import_vue437.createVNode)((0, import_vue437.unref)(close_default))
                  ]),
                  _: 1
                })
              ], 2),
              (0, import_vue437.createCommentVNode)(" ARROW "),
              !(0, import_vue437.unref)(isSingle) ? ((0, import_vue437.openBlock)(), (0, import_vue437.createElementBlock)(import_vue437.Fragment, { key: 0 }, [
                (0, import_vue437.createElementVNode)("span", {
                  class: (0, import_vue437.normalizeClass)([
                    (0, import_vue437.unref)(ns2).e("btn"),
                    (0, import_vue437.unref)(ns2).e("prev"),
                    (0, import_vue437.unref)(ns2).is("disabled", !_ctx.infinite && (0, import_vue437.unref)(isFirst))
                  ]),
                  onClick: prev
                }, [
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), null, {
                    default: (0, import_vue437.withCtx)(() => [
                      (0, import_vue437.createVNode)((0, import_vue437.unref)(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                (0, import_vue437.createElementVNode)("span", {
                  class: (0, import_vue437.normalizeClass)([
                    (0, import_vue437.unref)(ns2).e("btn"),
                    (0, import_vue437.unref)(ns2).e("next"),
                    (0, import_vue437.unref)(ns2).is("disabled", !_ctx.infinite && (0, import_vue437.unref)(isLast))
                  ]),
                  onClick: next
                }, [
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), null, {
                    default: (0, import_vue437.withCtx)(() => [
                      (0, import_vue437.createVNode)((0, import_vue437.unref)(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2)
              ], 64)) : (0, import_vue437.createCommentVNode)("v-if", true),
              (0, import_vue437.createCommentVNode)(" ACTIONS "),
              (0, import_vue437.createElementVNode)("div", {
                class: (0, import_vue437.normalizeClass)([(0, import_vue437.unref)(ns2).e("btn"), (0, import_vue437.unref)(ns2).e("actions")])
              }, [
                (0, import_vue437.createElementVNode)("div", {
                  class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("actions__inner"))
                }, [
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), {
                    onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                  }, {
                    default: (0, import_vue437.withCtx)(() => [
                      (0, import_vue437.createVNode)((0, import_vue437.unref)(zoom_out_default))
                    ]),
                    _: 1
                  }),
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), {
                    onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                  }, {
                    default: (0, import_vue437.withCtx)(() => [
                      (0, import_vue437.createVNode)((0, import_vue437.unref)(zoom_in_default))
                    ]),
                    _: 1
                  }),
                  (0, import_vue437.createElementVNode)("i", {
                    class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("actions__divider"))
                  }, null, 2),
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), { onClick: toggleMode }, {
                    default: (0, import_vue437.withCtx)(() => [
                      ((0, import_vue437.openBlock)(), (0, import_vue437.createBlock)((0, import_vue437.resolveDynamicComponent)((0, import_vue437.unref)(mode).icon)))
                    ]),
                    _: 1
                  }),
                  (0, import_vue437.createElementVNode)("i", {
                    class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("actions__divider"))
                  }, null, 2),
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), {
                    onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                  }, {
                    default: (0, import_vue437.withCtx)(() => [
                      (0, import_vue437.createVNode)((0, import_vue437.unref)(refresh_left_default))
                    ]),
                    _: 1
                  }),
                  (0, import_vue437.createVNode)((0, import_vue437.unref)(ElIcon), {
                    onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                  }, {
                    default: (0, import_vue437.withCtx)(() => [
                      (0, import_vue437.createVNode)((0, import_vue437.unref)(refresh_right_default))
                    ]),
                    _: 1
                  })
                ], 2)
              ], 2),
              (0, import_vue437.createCommentVNode)(" CANVAS "),
              (0, import_vue437.createElementVNode)("div", {
                class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("canvas"))
              }, [
                ((0, import_vue437.openBlock)(true), (0, import_vue437.createElementBlock)(import_vue437.Fragment, null, (0, import_vue437.renderList)(_ctx.urlList, (url2, i) => {
                  return (0, import_vue437.withDirectives)(((0, import_vue437.openBlock)(), (0, import_vue437.createElementBlock)("img", {
                    ref_for: true,
                    ref: (el) => imgRefs.value[i] = el,
                    key: url2,
                    src: url2,
                    style: (0, import_vue437.normalizeStyle)((0, import_vue437.unref)(imgStyle)),
                    class: (0, import_vue437.normalizeClass)((0, import_vue437.unref)(ns2).e("img")),
                    onLoad: handleImgLoad,
                    onError: handleImgError,
                    onMousedown: handleMouseDown
                  }, null, 46, _hoisted_153)), [
                    [import_vue437.vShow, i === activeIndex.value]
                  ]);
                }), 128))
              ], 2),
              (0, import_vue437.renderSlot)(_ctx.$slots, "default")
            ], 6)
          ]),
          _: 3
        })
      ], 8, ["disabled"]);
    };
  }
});
var ImageViewer = /* @__PURE__ */ _export_sfc(_sfc_main84, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image-viewer/index.mjs
var ElImageViewer = withInstall(ImageViewer);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image/src/image.mjs
var imageProps = buildProps({
  hideOnClickModal: {
    type: Boolean,
    default: false
  },
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: {
    type: Boolean,
    default: false
  },
  scrollContainer: {
    type: definePropType([String, Object])
  },
  previewSrcList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  previewTeleported: {
    type: Boolean,
    default: false
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  zoomRate: {
    type: Number,
    default: 1.2
  }
});
var imageEmits = {
  load: (evt) => evt instanceof Event,
  error: (evt) => evt instanceof Event,
  switch: (val) => isNumber(val),
  close: () => true,
  show: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image/src/image2.mjs
var import_shared63 = require("@vue/shared");
var _hoisted_155 = ["src", "loading"];
var _hoisted_231 = { key: 0 };
var __default__56 = (0, import_vue438.defineComponent)({
  name: "ElImage",
  inheritAttrs: false
});
var _sfc_main85 = /* @__PURE__ */ (0, import_vue438.defineComponent)({
  ...__default__56,
  props: imageProps,
  emits: imageEmits,
  setup(__props, { emit }) {
    const props = __props;
    let prevOverflow = "";
    const { t } = useLocale();
    const ns2 = useNamespace("image");
    const rawAttrs = (0, import_vue438.useAttrs)();
    const attrs = useAttrs();
    const imageSrc = (0, import_vue438.ref)();
    const hasLoadError = (0, import_vue438.ref)(false);
    const isLoading = (0, import_vue438.ref)(true);
    const showViewer = (0, import_vue438.ref)(false);
    const container = (0, import_vue438.ref)();
    const _scrollContainer = (0, import_vue438.ref)();
    const supportLoading = isClient && "loading" in HTMLImageElement.prototype;
    let stopScrollListener;
    let stopWheelListener;
    const containerStyle = (0, import_vue438.computed)(() => rawAttrs.style);
    const imageStyle = (0, import_vue438.computed)(() => {
      const { fit } = props;
      if (isClient && fit) {
        return { objectFit: fit };
      }
      return {};
    });
    const preview = (0, import_vue438.computed)(() => {
      const { previewSrcList } = props;
      return Array.isArray(previewSrcList) && previewSrcList.length > 0;
    });
    const imageIndex = (0, import_vue438.computed)(() => {
      const { previewSrcList, initialIndex } = props;
      let previewIndex = initialIndex;
      if (initialIndex > previewSrcList.length - 1) {
        previewIndex = 0;
      }
      return previewIndex;
    });
    const isManual = (0, import_vue438.computed)(() => {
      if (props.loading === "eager")
        return false;
      return !supportLoading && props.loading === "lazy" || props.lazy;
    });
    const loadImage = () => {
      if (!isClient)
        return;
      isLoading.value = true;
      hasLoadError.value = false;
      imageSrc.value = props.src;
    };
    function handleLoad(event) {
      isLoading.value = false;
      hasLoadError.value = false;
      emit("load", event);
    }
    function handleError(event) {
      isLoading.value = false;
      hasLoadError.value = true;
      emit("error", event);
    }
    function handleLazyLoad() {
      if (isInContainer(container.value, _scrollContainer.value)) {
        loadImage();
        removeLazyLoadListener();
      }
    }
    const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200);
    async function addLazyLoadListener() {
      var _a2;
      if (!isClient)
        return;
      await (0, import_vue438.nextTick)();
      const { scrollContainer } = props;
      if (isElement(scrollContainer)) {
        _scrollContainer.value = scrollContainer;
      } else if ((0, import_shared63.isString)(scrollContainer) && scrollContainer !== "") {
        _scrollContainer.value = (_a2 = document.querySelector(scrollContainer)) != null ? _a2 : void 0;
      } else if (container.value) {
        _scrollContainer.value = getScrollContainer(container.value);
      }
      if (_scrollContainer.value) {
        stopScrollListener = useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
        setTimeout(() => handleLazyLoad(), 100);
      }
    }
    function removeLazyLoadListener() {
      if (!isClient || !_scrollContainer.value || !lazyLoadHandler)
        return;
      stopScrollListener == null ? void 0 : stopScrollListener();
      _scrollContainer.value = void 0;
    }
    function wheelHandler(e) {
      if (!e.ctrlKey)
        return;
      if (e.deltaY < 0) {
        e.preventDefault();
        return false;
      } else if (e.deltaY > 0) {
        e.preventDefault();
        return false;
      }
    }
    function clickHandler() {
      if (!preview.value)
        return;
      stopWheelListener = useEventListener("wheel", wheelHandler, {
        passive: false
      });
      prevOverflow = document.body.style.overflow;
      document.body.style.overflow = "hidden";
      showViewer.value = true;
      emit("show");
    }
    function closeViewer() {
      stopWheelListener == null ? void 0 : stopWheelListener();
      document.body.style.overflow = prevOverflow;
      showViewer.value = false;
      emit("close");
    }
    function switchViewer(val) {
      emit("switch", val);
    }
    (0, import_vue438.watch)(() => props.src, () => {
      if (isManual.value) {
        isLoading.value = true;
        hasLoadError.value = false;
        removeLazyLoadListener();
        addLazyLoadListener();
      } else {
        loadImage();
      }
    });
    (0, import_vue438.onMounted)(() => {
      if (isManual.value) {
        addLazyLoadListener();
      } else {
        loadImage();
      }
    });
    return (_ctx, _cache) => {
      return (0, import_vue438.openBlock)(), (0, import_vue438.createElementBlock)("div", {
        ref_key: "container",
        ref: container,
        class: (0, import_vue438.normalizeClass)([(0, import_vue438.unref)(ns2).b(), _ctx.$attrs.class]),
        style: (0, import_vue438.normalizeStyle)((0, import_vue438.unref)(containerStyle))
      }, [
        imageSrc.value !== void 0 && !hasLoadError.value ? ((0, import_vue438.openBlock)(), (0, import_vue438.createElementBlock)("img", (0, import_vue438.mergeProps)({ key: 0 }, (0, import_vue438.unref)(attrs), {
          src: imageSrc.value,
          loading: _ctx.loading,
          style: (0, import_vue438.unref)(imageStyle),
          class: [
            (0, import_vue438.unref)(ns2).e("inner"),
            (0, import_vue438.unref)(preview) && (0, import_vue438.unref)(ns2).e("preview"),
            isLoading.value && (0, import_vue438.unref)(ns2).is("loading")
          ],
          onClick: clickHandler,
          onLoad: handleLoad,
          onError: handleError
        }), null, 16, _hoisted_155)) : (0, import_vue438.createCommentVNode)("v-if", true),
        isLoading.value || hasLoadError.value ? ((0, import_vue438.openBlock)(), (0, import_vue438.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue438.normalizeClass)((0, import_vue438.unref)(ns2).e("wrapper"))
        }, [
          isLoading.value ? (0, import_vue438.renderSlot)(_ctx.$slots, "placeholder", { key: 0 }, () => [
            (0, import_vue438.createElementVNode)("div", {
              class: (0, import_vue438.normalizeClass)((0, import_vue438.unref)(ns2).e("placeholder"))
            }, null, 2)
          ]) : hasLoadError.value ? (0, import_vue438.renderSlot)(_ctx.$slots, "error", { key: 1 }, () => [
            (0, import_vue438.createElementVNode)("div", {
              class: (0, import_vue438.normalizeClass)((0, import_vue438.unref)(ns2).e("error"))
            }, (0, import_vue438.toDisplayString)((0, import_vue438.unref)(t)("el.image.error")), 3)
          ]) : (0, import_vue438.createCommentVNode)("v-if", true)
        ], 2)) : (0, import_vue438.createCommentVNode)("v-if", true),
        (0, import_vue438.unref)(preview) ? ((0, import_vue438.openBlock)(), (0, import_vue438.createElementBlock)(import_vue438.Fragment, { key: 2 }, [
          showViewer.value ? ((0, import_vue438.openBlock)(), (0, import_vue438.createBlock)((0, import_vue438.unref)(ElImageViewer), {
            key: 0,
            "z-index": _ctx.zIndex,
            "initial-index": (0, import_vue438.unref)(imageIndex),
            infinite: _ctx.infinite,
            "zoom-rate": _ctx.zoomRate,
            "url-list": _ctx.previewSrcList,
            "hide-on-click-modal": _ctx.hideOnClickModal,
            teleported: _ctx.previewTeleported,
            "close-on-press-escape": _ctx.closeOnPressEscape,
            onClose: closeViewer,
            onSwitch: switchViewer
          }, {
            default: (0, import_vue438.withCtx)(() => [
              _ctx.$slots.viewer ? ((0, import_vue438.openBlock)(), (0, import_vue438.createElementBlock)("div", _hoisted_231, [
                (0, import_vue438.renderSlot)(_ctx.$slots, "viewer")
              ])) : (0, import_vue438.createCommentVNode)("v-if", true)
            ]),
            _: 3
          }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : (0, import_vue438.createCommentVNode)("v-if", true)
        ], 64)) : (0, import_vue438.createCommentVNode)("v-if", true)
      ], 6);
    };
  }
});
var Image2 = /* @__PURE__ */ _export_sfc(_sfc_main85, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/image/index.mjs
var ElImage = withInstall(Image2);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input-number/src/input-number2.mjs
var import_vue439 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input-number/src/input-number.mjs
var inputNumberProps = buildProps({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: useSizeProp,
  controls: {
    type: Boolean,
    default: true
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var inputNumberEmits = {
  [CHANGE_EVENT]: (cur, prev) => prev !== cur,
  blur: (e) => e instanceof FocusEvent,
  focus: (e) => e instanceof FocusEvent,
  [INPUT_EVENT]: (val) => isNumber(val) || isNil_default(val),
  [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil_default(val)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input-number/src/input-number2.mjs
var import_shared64 = require("@vue/shared");
var _hoisted_157 = ["aria-label", "onKeydown"];
var _hoisted_233 = ["aria-label", "onKeydown"];
var __default__57 = (0, import_vue439.defineComponent)({
  name: "ElInputNumber"
});
var _sfc_main86 = /* @__PURE__ */ (0, import_vue439.defineComponent)({
  ...__default__57,
  props: inputNumberProps,
  emits: inputNumberEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { t } = useLocale();
    const ns2 = useNamespace("input-number");
    const input = (0, import_vue439.ref)();
    const data = (0, import_vue439.reactive)({
      currentValue: props.modelValue,
      userInput: null
    });
    const { formItem } = useFormItem();
    const minDisabled = (0, import_vue439.computed)(() => isNumber(props.modelValue) && props.modelValue <= props.min);
    const maxDisabled = (0, import_vue439.computed)(() => isNumber(props.modelValue) && props.modelValue >= props.max);
    const numPrecision = (0, import_vue439.computed)(() => {
      const stepPrecision = getPrecision(props.step);
      if (!isUndefined(props.precision)) {
        if (stepPrecision > props.precision) {
          debugWarn("InputNumber", "precision should not be less than the decimal places of step");
        }
        return props.precision;
      } else {
        return Math.max(getPrecision(props.modelValue), stepPrecision);
      }
    });
    const controlsAtRight = (0, import_vue439.computed)(() => {
      return props.controls && props.controlsPosition === "right";
    });
    const inputNumberSize = useSize();
    const inputNumberDisabled = useDisabled();
    const displayValue = (0, import_vue439.computed)(() => {
      if (data.userInput !== null) {
        return data.userInput;
      }
      let currentValue = data.currentValue;
      if (isNil_default(currentValue))
        return "";
      if (isNumber(currentValue)) {
        if (Number.isNaN(currentValue))
          return "";
        if (!isUndefined(props.precision)) {
          currentValue = currentValue.toFixed(props.precision);
        }
      }
      return currentValue;
    });
    const toPrecision = (num, pre) => {
      if (isUndefined(pre))
        pre = numPrecision.value;
      if (pre === 0)
        return Math.round(num);
      let snum = String(num);
      const pointPos = snum.indexOf(".");
      if (pointPos === -1)
        return num;
      const nums = snum.replace(".", "").split("");
      const datum = nums[pointPos + pre];
      if (!datum)
        return num;
      const length = snum.length;
      if (snum.charAt(length - 1) === "5") {
        snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
      }
      return Number.parseFloat(Number(snum).toFixed(pre));
    };
    const getPrecision = (value) => {
      if (isNil_default(value))
        return 0;
      const valueString = value.toString();
      const dotPosition = valueString.indexOf(".");
      let precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    };
    const ensurePrecision = (val, coefficient = 1) => {
      if (!isNumber(val))
        return data.currentValue;
      return toPrecision(val + props.step * coefficient);
    };
    const increase = () => {
      if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
        return;
      const value = Number(displayValue.value) || 0;
      const newVal = ensurePrecision(value);
      setCurrentValue(newVal);
      emit(INPUT_EVENT, data.currentValue);
    };
    const decrease = () => {
      if (props.readonly || inputNumberDisabled.value || minDisabled.value)
        return;
      const value = Number(displayValue.value) || 0;
      const newVal = ensurePrecision(value, -1);
      setCurrentValue(newVal);
      emit(INPUT_EVENT, data.currentValue);
    };
    const verifyValue = (value, update) => {
      const { max: max4, min: min4, step, precision, stepStrictly, valueOnClear } = props;
      let newVal = Number(value);
      if (isNil_default(value) || Number.isNaN(newVal)) {
        return null;
      }
      if (value === "") {
        if (valueOnClear === null) {
          return null;
        }
        newVal = (0, import_shared64.isString)(valueOnClear) ? { min: min4, max: max4 }[valueOnClear] : valueOnClear;
      }
      if (stepStrictly) {
        newVal = toPrecision(Math.round(newVal / step) * step, precision);
      }
      if (!isUndefined(precision)) {
        newVal = toPrecision(newVal, precision);
      }
      if (newVal > max4 || newVal < min4) {
        newVal = newVal > max4 ? max4 : min4;
        update && emit(UPDATE_MODEL_EVENT, newVal);
      }
      return newVal;
    };
    const setCurrentValue = (value, emitChange = true) => {
      var _a2;
      const oldVal = data.currentValue;
      const newVal = verifyValue(value);
      if (oldVal === newVal)
        return;
      if (!emitChange) {
        emit(UPDATE_MODEL_EVENT, newVal);
        return;
      }
      data.userInput = null;
      emit(UPDATE_MODEL_EVENT, newVal);
      emit(CHANGE_EVENT, newVal, oldVal);
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn(err));
      }
      data.currentValue = newVal;
    };
    const handleInput = (value) => {
      data.userInput = value;
      const newVal = value === "" ? null : Number(value);
      emit(INPUT_EVENT, newVal);
      setCurrentValue(newVal, false);
    };
    const handleInputChange = (value) => {
      const newVal = value !== "" ? Number(value) : "";
      if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
        setCurrentValue(newVal);
      }
      data.userInput = null;
    };
    const focus = () => {
      var _a2, _b;
      (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    };
    const blur = () => {
      var _a2, _b;
      (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
    };
    const handleFocus = (event) => {
      emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a2;
      emit("blur", event);
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn(err));
      }
    };
    (0, import_vue439.watch)(() => props.modelValue, (value) => {
      const userInput = verifyValue(data.userInput);
      const newValue = verifyValue(value, true);
      if (!isNumber(userInput) && (!userInput || userInput !== newValue)) {
        data.currentValue = newValue;
        data.userInput = null;
      }
    }, { immediate: true });
    (0, import_vue439.onMounted)(() => {
      var _a2;
      const { min: min4, max: max4, modelValue } = props;
      const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
      innerInput.setAttribute("role", "spinbutton");
      if (Number.isFinite(max4)) {
        innerInput.setAttribute("aria-valuemax", String(max4));
      } else {
        innerInput.removeAttribute("aria-valuemax");
      }
      if (Number.isFinite(min4)) {
        innerInput.setAttribute("aria-valuemin", String(min4));
      } else {
        innerInput.removeAttribute("aria-valuemin");
      }
      innerInput.setAttribute("aria-valuenow", String(data.currentValue));
      innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
      if (!isNumber(modelValue) && modelValue != null) {
        let val = Number(modelValue);
        if (Number.isNaN(val)) {
          val = null;
        }
        emit(UPDATE_MODEL_EVENT, val);
      }
    });
    (0, import_vue439.onUpdated)(() => {
      var _a2;
      const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
      innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${data.currentValue}`);
    });
    expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return (0, import_vue439.openBlock)(), (0, import_vue439.createElementBlock)("div", {
        class: (0, import_vue439.normalizeClass)([
          (0, import_vue439.unref)(ns2).b(),
          (0, import_vue439.unref)(ns2).m((0, import_vue439.unref)(inputNumberSize)),
          (0, import_vue439.unref)(ns2).is("disabled", (0, import_vue439.unref)(inputNumberDisabled)),
          (0, import_vue439.unref)(ns2).is("without-controls", !_ctx.controls),
          (0, import_vue439.unref)(ns2).is("controls-right", (0, import_vue439.unref)(controlsAtRight))
        ]),
        onDragstart: _cache[0] || (_cache[0] = (0, import_vue439.withModifiers)(() => {
        }, ["prevent"]))
      }, [
        _ctx.controls ? (0, import_vue439.withDirectives)(((0, import_vue439.openBlock)(), (0, import_vue439.createElementBlock)("span", {
          key: 0,
          role: "button",
          "aria-label": (0, import_vue439.unref)(t)("el.inputNumber.decrease"),
          class: (0, import_vue439.normalizeClass)([(0, import_vue439.unref)(ns2).e("decrease"), (0, import_vue439.unref)(ns2).is("disabled", (0, import_vue439.unref)(minDisabled))]),
          onKeydown: (0, import_vue439.withKeys)(decrease, ["enter"])
        }, [
          (0, import_vue439.createVNode)((0, import_vue439.unref)(ElIcon), null, {
            default: (0, import_vue439.withCtx)(() => [
              (0, import_vue439.unref)(controlsAtRight) ? ((0, import_vue439.openBlock)(), (0, import_vue439.createBlock)((0, import_vue439.unref)(arrow_down_default), { key: 0 })) : ((0, import_vue439.openBlock)(), (0, import_vue439.createBlock)((0, import_vue439.unref)(minus_default), { key: 1 }))
            ]),
            _: 1
          })
        ], 42, _hoisted_157)), [
          [(0, import_vue439.unref)(vRepeatClick), decrease]
        ]) : (0, import_vue439.createCommentVNode)("v-if", true),
        _ctx.controls ? (0, import_vue439.withDirectives)(((0, import_vue439.openBlock)(), (0, import_vue439.createElementBlock)("span", {
          key: 1,
          role: "button",
          "aria-label": (0, import_vue439.unref)(t)("el.inputNumber.increase"),
          class: (0, import_vue439.normalizeClass)([(0, import_vue439.unref)(ns2).e("increase"), (0, import_vue439.unref)(ns2).is("disabled", (0, import_vue439.unref)(maxDisabled))]),
          onKeydown: (0, import_vue439.withKeys)(increase, ["enter"])
        }, [
          (0, import_vue439.createVNode)((0, import_vue439.unref)(ElIcon), null, {
            default: (0, import_vue439.withCtx)(() => [
              (0, import_vue439.unref)(controlsAtRight) ? ((0, import_vue439.openBlock)(), (0, import_vue439.createBlock)((0, import_vue439.unref)(arrow_up_default), { key: 0 })) : ((0, import_vue439.openBlock)(), (0, import_vue439.createBlock)((0, import_vue439.unref)(plus_default), { key: 1 }))
            ]),
            _: 1
          })
        ], 42, _hoisted_233)), [
          [(0, import_vue439.unref)(vRepeatClick), increase]
        ]) : (0, import_vue439.createCommentVNode)("v-if", true),
        (0, import_vue439.createVNode)((0, import_vue439.unref)(ElInput), {
          id: _ctx.id,
          ref_key: "input",
          ref: input,
          type: "number",
          step: _ctx.step,
          "model-value": (0, import_vue439.unref)(displayValue),
          placeholder: _ctx.placeholder,
          readonly: _ctx.readonly,
          disabled: (0, import_vue439.unref)(inputNumberDisabled),
          size: (0, import_vue439.unref)(inputNumberSize),
          max: _ctx.max,
          min: _ctx.min,
          name: _ctx.name,
          label: _ctx.label,
          "validate-event": false,
          onKeydown: [
            (0, import_vue439.withKeys)((0, import_vue439.withModifiers)(increase, ["prevent"]), ["up"]),
            (0, import_vue439.withKeys)((0, import_vue439.withModifiers)(decrease, ["prevent"]), ["down"])
          ],
          onBlur: handleBlur,
          onFocus: handleFocus,
          onInput: handleInput,
          onChange: handleInputChange
        }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
      ], 34);
    };
  }
});
var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main86, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/input-number/index.mjs
var ElInputNumber = withInstall(InputNumber);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/link/src/link2.mjs
var import_vue440 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/link/src/link.mjs
var linkProps = buildProps({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: "default"
  },
  underline: {
    type: Boolean,
    default: true
  },
  disabled: { type: Boolean, default: false },
  href: { type: String, default: "" },
  icon: {
    type: iconPropType
  }
});
var linkEmits = {
  click: (evt) => evt instanceof MouseEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/link/src/link2.mjs
var _hoisted_158 = ["href"];
var __default__58 = (0, import_vue440.defineComponent)({
  name: "ElLink"
});
var _sfc_main87 = /* @__PURE__ */ (0, import_vue440.defineComponent)({
  ...__default__58,
  props: linkProps,
  emits: linkEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("link");
    const linkKls = (0, import_vue440.computed)(() => [
      ns2.b(),
      ns2.m(props.type),
      ns2.is("disabled", props.disabled),
      ns2.is("underline", props.underline && !props.disabled)
    ]);
    function handleClick(event) {
      if (!props.disabled)
        emit("click", event);
    }
    return (_ctx, _cache) => {
      return (0, import_vue440.openBlock)(), (0, import_vue440.createElementBlock)("a", {
        class: (0, import_vue440.normalizeClass)((0, import_vue440.unref)(linkKls)),
        href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
        onClick: handleClick
      }, [
        _ctx.icon ? ((0, import_vue440.openBlock)(), (0, import_vue440.createBlock)((0, import_vue440.unref)(ElIcon), { key: 0 }, {
          default: (0, import_vue440.withCtx)(() => [
            ((0, import_vue440.openBlock)(), (0, import_vue440.createBlock)((0, import_vue440.resolveDynamicComponent)(_ctx.icon)))
          ]),
          _: 1
        })) : (0, import_vue440.createCommentVNode)("v-if", true),
        _ctx.$slots.default ? ((0, import_vue440.openBlock)(), (0, import_vue440.createElementBlock)("span", {
          key: 1,
          class: (0, import_vue440.normalizeClass)((0, import_vue440.unref)(ns2).e("inner"))
        }, [
          (0, import_vue440.renderSlot)(_ctx.$slots, "default")
        ], 2)) : (0, import_vue440.createCommentVNode)("v-if", true),
        _ctx.$slots.icon ? (0, import_vue440.renderSlot)(_ctx.$slots, "icon", { key: 2 }) : (0, import_vue440.createCommentVNode)("v-if", true)
      ], 10, _hoisted_158);
    };
  }
});
var Link = /* @__PURE__ */ _export_sfc(_sfc_main87, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/link/index.mjs
var ElLink = withInstall(Link);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu.mjs
var import_vue446 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/utils/submenu.mjs
var SubMenu = class {
  constructor(parent, domNode) {
    this.parent = parent;
    this.domNode = domNode;
    this.subIndex = 0;
    this.subIndex = 0;
    this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li");
    this.addListeners();
  }
  gotoSubIndex(idx) {
    if (idx === this.subMenuItems.length) {
      idx = 0;
    } else if (idx < 0) {
      idx = this.subMenuItems.length - 1;
    }
    ;
    this.subMenuItems[idx].focus();
    this.subIndex = idx;
  }
  addListeners() {
    const parentNode = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (el) => {
      el.addEventListener("keydown", (event) => {
        let prevDef = false;
        switch (event.code) {
          case EVENT_CODE.down: {
            this.gotoSubIndex(this.subIndex + 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.up: {
            this.gotoSubIndex(this.subIndex - 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.tab: {
            triggerEvent(parentNode, "mouseleave");
            break;
          }
          case EVENT_CODE.enter:
          case EVENT_CODE.space: {
            prevDef = true;
            event.currentTarget.click();
            break;
          }
        }
        if (prevDef) {
          event.preventDefault();
          event.stopPropagation();
        }
        return false;
      });
    });
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/utils/menu-item.mjs
var MenuItem = class {
  constructor(domNode, namespace) {
    this.domNode = domNode;
    this.submenu = null;
    this.submenu = null;
    this.init(namespace);
  }
  init(namespace) {
    this.domNode.setAttribute("tabindex", "0");
    const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
    if (menuChild) {
      this.submenu = new SubMenu(this, menuChild);
    }
    this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (event) => {
      let prevDef = false;
      switch (event.code) {
        case EVENT_CODE.down: {
          triggerEvent(event.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(0);
          prevDef = true;
          break;
        }
        case EVENT_CODE.up: {
          triggerEvent(event.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
          prevDef = true;
          break;
        }
        case EVENT_CODE.tab: {
          triggerEvent(event.currentTarget, "mouseleave");
          break;
        }
        case EVENT_CODE.enter:
        case EVENT_CODE.space: {
          prevDef = true;
          event.currentTarget.click();
          break;
        }
      }
      if (prevDef) {
        event.preventDefault();
      }
    });
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/utils/menu-bar.mjs
var Menu = class {
  constructor(domNode, namespace) {
    this.domNode = domNode;
    this.init(namespace);
  }
  init(namespace) {
    const menuChildren = this.domNode.childNodes;
    Array.from(menuChildren).forEach((child) => {
      if (child.nodeType === 1) {
        new MenuItem(child, namespace);
      }
    });
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-collapse-transition.mjs
var import_vue441 = require("vue");
var _sfc_main88 = (0, import_vue441.defineComponent)({
  name: "ElMenuCollapseTransition",
  setup() {
    const ns2 = useNamespace("menu");
    const listeners = {
      onBeforeEnter: (el) => el.style.opacity = "0.2",
      onEnter(el, done) {
        addClass(el, `${ns2.namespace.value}-opacity-transition`);
        el.style.opacity = "1";
        done();
      },
      onAfterEnter(el) {
        removeClass(el, `${ns2.namespace.value}-opacity-transition`);
        el.style.opacity = "";
      },
      onBeforeLeave(el) {
        if (!el.dataset) {
          ;
          el.dataset = {};
        }
        if (hasClass(el, ns2.m("collapse"))) {
          removeClass(el, ns2.m("collapse"));
          el.dataset.oldOverflow = el.style.overflow;
          el.dataset.scrollWidth = el.clientWidth.toString();
          addClass(el, ns2.m("collapse"));
        } else {
          addClass(el, ns2.m("collapse"));
          el.dataset.oldOverflow = el.style.overflow;
          el.dataset.scrollWidth = el.clientWidth.toString();
          removeClass(el, ns2.m("collapse"));
        }
        el.style.width = `${el.scrollWidth}px`;
        el.style.overflow = "hidden";
      },
      onLeave(el) {
        addClass(el, "horizontal-collapse-transition");
        el.style.width = `${el.dataset.scrollWidth}px`;
      }
    };
    return {
      listeners
    };
  }
});
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue441.openBlock)(), (0, import_vue441.createBlock)(import_vue441.Transition, (0, import_vue441.mergeProps)({ mode: "out-in" }, _ctx.listeners), {
    default: (0, import_vue441.withCtx)(() => [
      (0, import_vue441.renderSlot)(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main88, [["render", _sfc_render25], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/sub-menu.mjs
var import_vue445 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/use-menu.mjs
var import_vue442 = require("vue");
function useMenu(instance, currentIndex) {
  const indexPath = (0, import_vue442.computed)(() => {
    let parent = instance.parent;
    const path = [currentIndex.value];
    while (parent.type.name !== "ElMenu") {
      if (parent.props.index) {
        path.unshift(parent.props.index);
      }
      parent = parent.parent;
    }
    return path;
  });
  const parentMenu = (0, import_vue442.computed)(() => {
    let parent = instance.parent;
    while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) {
      parent = parent.parent;
    }
    return parent;
  });
  return {
    parentMenu,
    indexPath
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/use-menu-css-var.mjs
var import_vue444 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/use-menu-color.mjs
var import_vue443 = require("vue");
function useMenuColor(props) {
  const menuBarColor = (0, import_vue443.computed)(() => {
    const color = props.backgroundColor;
    if (!color) {
      return "";
    } else {
      return new TinyColor(color).shade(20).toString();
    }
  });
  return menuBarColor;
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/use-menu-css-var.mjs
var useMenuCssVar = (props, level) => {
  const ns2 = useNamespace("menu");
  return (0, import_vue444.computed)(() => {
    return ns2.cssVarBlock({
      "text-color": props.textColor || "",
      "hover-text-color": props.textColor || "",
      "bg-color": props.backgroundColor || "",
      "hover-bg-color": useMenuColor(props).value || "",
      "active-color": props.activeTextColor || "",
      level: `${level}`
    });
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/sub-menu.mjs
var import_shared65 = require("@vue/shared");
var subMenuProps = buildProps({
  index: {
    type: String,
    required: true
  },
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  },
  popperClass: String,
  disabled: Boolean,
  popperAppendToBody: {
    type: Boolean,
    default: void 0
  },
  popperOffset: {
    type: Number,
    default: 6
  },
  expandCloseIcon: {
    type: iconPropType
  },
  expandOpenIcon: {
    type: iconPropType
  },
  collapseCloseIcon: {
    type: iconPropType
  },
  collapseOpenIcon: {
    type: iconPropType
  }
});
var COMPONENT_NAME12 = "ElSubMenu";
var SubMenu2 = (0, import_vue445.defineComponent)({
  name: COMPONENT_NAME12,
  props: subMenuProps,
  setup(props, { slots, expose }) {
    const instance = (0, import_vue445.getCurrentInstance)();
    const { indexPath, parentMenu } = useMenu(instance, (0, import_vue445.computed)(() => props.index));
    const nsMenu = useNamespace("menu");
    const nsSubMenu = useNamespace("sub-menu");
    const rootMenu = (0, import_vue445.inject)("rootMenu");
    if (!rootMenu)
      throwError(COMPONENT_NAME12, "can not inject root menu");
    const subMenu = (0, import_vue445.inject)(`subMenu:${parentMenu.value.uid}`);
    if (!subMenu)
      throwError(COMPONENT_NAME12, "can not inject sub menu");
    const items = (0, import_vue445.ref)({});
    const subMenus = (0, import_vue445.ref)({});
    let timeout;
    const mouseInChild = (0, import_vue445.ref)(false);
    const verticalTitleRef = (0, import_vue445.ref)();
    const vPopper = (0, import_vue445.ref)(null);
    const currentPlacement = (0, import_vue445.computed)(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
    const subMenuTitleIcon = (0, import_vue445.computed)(() => {
      return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? props.expandCloseIcon && props.expandOpenIcon ? opened.value ? props.expandOpenIcon : props.expandCloseIcon : arrow_down_default : props.collapseCloseIcon && props.collapseOpenIcon ? opened.value ? props.collapseOpenIcon : props.collapseCloseIcon : arrow_right_default;
    });
    const isFirstLevel = (0, import_vue445.computed)(() => {
      return subMenu.level === 0;
    });
    const appendToBody = (0, import_vue445.computed)(() => {
      return props.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props.popperAppendToBody);
    });
    const menuTransitionName = (0, import_vue445.computed)(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
    const fallbackPlacements = (0, import_vue445.computed)(() => mode.value === "horizontal" && isFirstLevel.value ? [
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end",
      "right-start",
      "left-start"
    ] : [
      "right-start",
      "left-start",
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end"
    ]);
    const opened = (0, import_vue445.computed)(() => rootMenu.openedMenus.includes(props.index));
    const active = (0, import_vue445.computed)(() => {
      let isActive = false;
      Object.values(items.value).forEach((item2) => {
        if (item2.active) {
          isActive = true;
        }
      });
      Object.values(subMenus.value).forEach((subItem) => {
        if (subItem.active) {
          isActive = true;
        }
      });
      return isActive;
    });
    const backgroundColor = (0, import_vue445.computed)(() => rootMenu.props.backgroundColor || "");
    const activeTextColor = (0, import_vue445.computed)(() => rootMenu.props.activeTextColor || "");
    const textColor = (0, import_vue445.computed)(() => rootMenu.props.textColor || "");
    const mode = (0, import_vue445.computed)(() => rootMenu.props.mode);
    const item = (0, import_vue445.reactive)({
      index: props.index,
      indexPath,
      active
    });
    const titleStyle = (0, import_vue445.computed)(() => {
      if (mode.value !== "horizontal") {
        return {
          color: textColor.value
        };
      }
      return {
        borderBottomColor: active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : "" : "transparent",
        color: active.value ? activeTextColor.value : textColor.value
      };
    });
    const doDestroy = () => {
      var _a2, _b, _c;
      return (_c = (_b = (_a2 = vPopper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
    };
    const handleCollapseToggle = (value) => {
      if (!value) {
        doDestroy();
      }
    };
    const handleClick = () => {
      if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled)
        return;
      rootMenu.handleSubMenuClick({
        index: props.index,
        indexPath: indexPath.value,
        active: active.value
      });
    };
    const handleMouseenter = (event, showTimeout = props.showTimeout) => {
      var _a2;
      if (event.type === "focus") {
        return;
      }
      if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) {
        return;
      }
      subMenu.mouseInChild.value = true;
      timeout == null ? void 0 : timeout();
      ({ stop: timeout } = useTimeoutFn(() => {
        rootMenu.openMenu(props.index, indexPath.value);
      }, showTimeout));
      if (appendToBody.value) {
        (_a2 = parentMenu.value.vnode.el) == null ? void 0 : _a2.dispatchEvent(new MouseEvent("mouseenter"));
      }
    };
    const handleMouseleave = (deepDispatch = false) => {
      var _a2, _b;
      if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
        return;
      }
      timeout == null ? void 0 : timeout();
      subMenu.mouseInChild.value = false;
      ({ stop: timeout } = useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value), props.hideTimeout));
      if (appendToBody.value && deepDispatch) {
        if (((_a2 = instance.parent) == null ? void 0 : _a2.type.name) === "ElSubMenu") {
          (_b = subMenu.handleMouseleave) == null ? void 0 : _b.call(subMenu, true);
        }
      }
    };
    (0, import_vue445.watch)(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
    {
      const addSubMenu = (item2) => {
        subMenus.value[item2.index] = item2;
      };
      const removeSubMenu = (item2) => {
        delete subMenus.value[item2.index];
      };
      (0, import_vue445.provide)(`subMenu:${instance.uid}`, {
        addSubMenu,
        removeSubMenu,
        handleMouseleave,
        mouseInChild,
        level: subMenu.level + 1
      });
    }
    expose({
      opened
    });
    (0, import_vue445.onMounted)(() => {
      rootMenu.addSubMenu(item);
      subMenu.addSubMenu(item);
    });
    (0, import_vue445.onBeforeUnmount)(() => {
      subMenu.removeSubMenu(item);
      rootMenu.removeSubMenu(item);
    });
    return () => {
      var _a2;
      const titleTag = [
        (_a2 = slots.title) == null ? void 0 : _a2.call(slots),
        (0, import_vue445.h)(ElIcon, {
          class: nsSubMenu.e("icon-arrow"),
          style: {
            transform: opened.value ? props.expandCloseIcon && props.expandOpenIcon || props.collapseCloseIcon && props.collapseOpenIcon && rootMenu.props.collapse ? "none" : "rotateZ(180deg)" : "none"
          }
        }, {
          default: () => (0, import_shared65.isString)(subMenuTitleIcon.value) ? (0, import_vue445.h)(instance.appContext.components[subMenuTitleIcon.value]) : (0, import_vue445.h)(subMenuTitleIcon.value)
        })
      ];
      const ulStyle = useMenuCssVar(rootMenu.props, subMenu.level + 1);
      const child = rootMenu.isMenuPopup ? (0, import_vue445.h)(ElTooltip, {
        ref: vPopper,
        visible: opened.value,
        effect: "light",
        pure: true,
        offset: props.popperOffset,
        showArrow: false,
        persistent: true,
        popperClass: props.popperClass,
        placement: currentPlacement.value,
        teleported: appendToBody.value,
        fallbackPlacements: fallbackPlacements.value,
        transition: menuTransitionName.value,
        gpuAcceleration: false
      }, {
        content: () => {
          var _a22;
          return (0, import_vue445.h)("div", {
            class: [
              nsMenu.m(mode.value),
              nsMenu.m("popup-container"),
              props.popperClass
            ],
            onMouseenter: (evt) => handleMouseenter(evt, 100),
            onMouseleave: () => handleMouseleave(true),
            onFocus: (evt) => handleMouseenter(evt, 100)
          }, [
            (0, import_vue445.h)("ul", {
              class: [
                nsMenu.b(),
                nsMenu.m("popup"),
                nsMenu.m(`popup-${currentPlacement.value}`)
              ],
              style: ulStyle.value
            }, [(_a22 = slots.default) == null ? void 0 : _a22.call(slots)])
          ]);
        },
        default: () => (0, import_vue445.h)("div", {
          class: nsSubMenu.e("title"),
          style: [
            titleStyle.value,
            { backgroundColor: backgroundColor.value }
          ],
          onClick: handleClick
        }, titleTag)
      }) : (0, import_vue445.h)(import_vue445.Fragment, {}, [
        (0, import_vue445.h)("div", {
          class: nsSubMenu.e("title"),
          style: [
            titleStyle.value,
            { backgroundColor: backgroundColor.value }
          ],
          ref: verticalTitleRef,
          onClick: handleClick
        }, titleTag),
        (0, import_vue445.h)(_CollapseTransition, {}, {
          default: () => {
            var _a22;
            return (0, import_vue445.withDirectives)((0, import_vue445.h)("ul", {
              role: "menu",
              class: [nsMenu.b(), nsMenu.m("inline")],
              style: ulStyle.value
            }, [(_a22 = slots.default) == null ? void 0 : _a22.call(slots)]), [[import_vue445.vShow, opened.value]]);
          }
        })
      ]);
      return (0, import_vue445.h)("li", {
        class: [
          nsSubMenu.b(),
          nsSubMenu.is("active", active.value),
          nsSubMenu.is("opened", opened.value),
          nsSubMenu.is("disabled", props.disabled)
        ],
        role: "menuitem",
        ariaHaspopup: true,
        ariaExpanded: opened.value,
        onMouseenter: handleMouseenter,
        onMouseleave: () => handleMouseleave(true),
        onFocus: handleMouseenter
      }, [child]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu.mjs
var import_shared66 = require("@vue/shared");
var menuProps = buildProps({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  collapseTransition: {
    type: Boolean,
    default: true
  },
  ellipsis: {
    type: Boolean,
    default: true
  },
  popperEffect: {
    type: String,
    values: ["dark", "light"],
    default: "dark"
  }
});
var checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => (0, import_shared66.isString)(path));
var menuEmits = {
  close: (index2, indexPath) => (0, import_shared66.isString)(index2) && checkIndexPath(indexPath),
  open: (index2, indexPath) => (0, import_shared66.isString)(index2) && checkIndexPath(indexPath),
  select: (index2, indexPath, item, routerResult) => (0, import_shared66.isString)(index2) && checkIndexPath(indexPath) && (0, import_shared66.isObject)(item) && (routerResult === void 0 || routerResult instanceof Promise)
};
var Menu2 = (0, import_vue446.defineComponent)({
  name: "ElMenu",
  props: menuProps,
  emits: menuEmits,
  setup(props, { emit, slots, expose }) {
    const instance = (0, import_vue446.getCurrentInstance)();
    const router = instance.appContext.config.globalProperties.$router;
    const menu = (0, import_vue446.ref)();
    const nsMenu = useNamespace("menu");
    const nsSubMenu = useNamespace("sub-menu");
    const sliceIndex = (0, import_vue446.ref)(-1);
    const openedMenus = (0, import_vue446.ref)(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
    const activeIndex = (0, import_vue446.ref)(props.defaultActive);
    const items = (0, import_vue446.ref)({});
    const subMenus = (0, import_vue446.ref)({});
    const isMenuPopup = (0, import_vue446.computed)(() => {
      return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
    });
    const initMenu = () => {
      const activeItem = activeIndex.value && items.value[activeIndex.value];
      if (!activeItem || props.mode === "horizontal" || props.collapse)
        return;
      const indexPath = activeItem.indexPath;
      indexPath.forEach((index2) => {
        const subMenu = subMenus.value[index2];
        subMenu && openMenu(index2, subMenu.indexPath);
      });
    };
    const openMenu = (index2, indexPath) => {
      if (openedMenus.value.includes(index2))
        return;
      if (props.uniqueOpened) {
        openedMenus.value = openedMenus.value.filter((index22) => indexPath.includes(index22));
      }
      openedMenus.value.push(index2);
      emit("open", index2, indexPath);
    };
    const closeMenu = (index2, indexPath) => {
      const i = openedMenus.value.indexOf(index2);
      if (i !== -1) {
        openedMenus.value.splice(i, 1);
      }
      emit("close", index2, indexPath);
    };
    const handleSubMenuClick = ({
      index: index2,
      indexPath
    }) => {
      const isOpened = openedMenus.value.includes(index2);
      if (isOpened) {
        closeMenu(index2, indexPath);
      } else {
        openMenu(index2, indexPath);
      }
    };
    const handleMenuItemClick = (menuItem) => {
      if (props.mode === "horizontal" || props.collapse) {
        openedMenus.value = [];
      }
      const { index: index2, indexPath } = menuItem;
      if (index2 === void 0 || indexPath === void 0)
        return;
      if (props.router && router) {
        const route = menuItem.route || index2;
        const routerResult = router.push(route).then((res) => {
          if (!res)
            activeIndex.value = index2;
          return res;
        });
        emit("select", index2, indexPath, { index: index2, indexPath, route }, routerResult);
      } else {
        activeIndex.value = index2;
        emit("select", index2, indexPath, { index: index2, indexPath });
      }
    };
    const updateActiveIndex = (val) => {
      const itemsInData = items.value;
      const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
      if (item) {
        activeIndex.value = item.index;
      } else {
        activeIndex.value = val;
      }
    };
    const calcSliceIndex = () => {
      var _a2, _b;
      if (!menu.value)
        return -1;
      const items2 = Array.from((_b = (_a2 = menu.value) == null ? void 0 : _a2.childNodes) != null ? _b : []).filter((item) => item.nodeName !== "#text" || item.nodeValue);
      const moreItemWidth = 64;
      const paddingLeft = Number.parseInt(getComputedStyle(menu.value).paddingLeft, 10);
      const paddingRight = Number.parseInt(getComputedStyle(menu.value).paddingRight, 10);
      const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
      let calcWidth = 0;
      let sliceIndex2 = 0;
      items2.forEach((item, index2) => {
        calcWidth += item.offsetWidth || 0;
        if (calcWidth <= menuWidth - moreItemWidth) {
          sliceIndex2 = index2 + 1;
        }
      });
      return sliceIndex2 === items2.length ? -1 : sliceIndex2;
    };
    const debounce2 = (fn2, wait = 33.34) => {
      let timmer;
      return () => {
        timmer && clearTimeout(timmer);
        timmer = setTimeout(() => {
          fn2();
        }, wait);
      };
    };
    let isFirstTimeRender = true;
    const handleResize = () => {
      const callback = () => {
        sliceIndex.value = -1;
        (0, import_vue446.nextTick)(() => {
          sliceIndex.value = calcSliceIndex();
        });
      };
      isFirstTimeRender ? callback() : debounce2(callback)();
      isFirstTimeRender = false;
    };
    (0, import_vue446.watch)(() => props.defaultActive, (currentActive) => {
      if (!items.value[currentActive]) {
        activeIndex.value = "";
      }
      updateActiveIndex(currentActive);
    });
    (0, import_vue446.watch)(() => props.collapse, (value) => {
      if (value)
        openedMenus.value = [];
    });
    (0, import_vue446.watch)(items.value, initMenu);
    let resizeStopper;
    (0, import_vue446.watchEffect)(() => {
      if (props.mode === "horizontal" && props.ellipsis)
        resizeStopper = useResizeObserver(menu, handleResize).stop;
      else
        resizeStopper == null ? void 0 : resizeStopper();
    });
    {
      const addSubMenu = (item) => {
        subMenus.value[item.index] = item;
      };
      const removeSubMenu = (item) => {
        delete subMenus.value[item.index];
      };
      const addMenuItem = (item) => {
        items.value[item.index] = item;
      };
      const removeMenuItem = (item) => {
        delete items.value[item.index];
      };
      (0, import_vue446.provide)("rootMenu", (0, import_vue446.reactive)({
        props,
        openedMenus,
        items,
        subMenus,
        activeIndex,
        isMenuPopup,
        addMenuItem,
        removeMenuItem,
        addSubMenu,
        removeSubMenu,
        openMenu,
        closeMenu,
        handleMenuItemClick,
        handleSubMenuClick
      }));
      (0, import_vue446.provide)(`subMenu:${instance.uid}`, {
        addSubMenu,
        removeSubMenu,
        mouseInChild: (0, import_vue446.ref)(false),
        level: 0
      });
    }
    (0, import_vue446.onMounted)(() => {
      if (props.mode === "horizontal") {
        new Menu(instance.vnode.el, nsMenu.namespace.value);
      }
    });
    {
      const open = (index2) => {
        const { indexPath } = subMenus.value[index2];
        indexPath.forEach((i) => openMenu(i, indexPath));
      };
      expose({
        open,
        close: closeMenu,
        handleResize
      });
    }
    return () => {
      var _a2, _b;
      let slot = (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : [];
      const vShowMore = [];
      if (props.mode === "horizontal" && menu.value) {
        const originalSlot = flattedChildren(slot);
        const slotDefault = sliceIndex.value === -1 ? originalSlot : originalSlot.slice(0, sliceIndex.value);
        const slotMore = sliceIndex.value === -1 ? [] : originalSlot.slice(sliceIndex.value);
        if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
          slot = slotDefault;
          vShowMore.push((0, import_vue446.h)(SubMenu2, {
            index: "sub-menu-more",
            class: nsSubMenu.e("hide-arrow")
          }, {
            title: () => (0, import_vue446.h)(ElIcon, {
              class: nsSubMenu.e("icon-more")
            }, { default: () => (0, import_vue446.h)(more_default) }),
            default: () => slotMore
          }));
        }
      }
      const ulStyle = useMenuCssVar(props, 0);
      const vMenu = (0, import_vue446.h)("ul", {
        key: String(props.collapse),
        role: "menubar",
        ref: menu,
        style: ulStyle.value,
        class: {
          [nsMenu.b()]: true,
          [nsMenu.m(props.mode)]: true,
          [nsMenu.m("collapse")]: props.collapse
        }
      }, [...slot, ...vShowMore]);
      if (props.collapseTransition && props.mode === "vertical") {
        return (0, import_vue446.h)(ElMenuCollapseTransition, () => vMenu);
      }
      return vMenu;
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-item2.mjs
var import_vue447 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-item.mjs
var import_shared67 = require("@vue/shared");
var menuItemProps = buildProps({
  index: {
    type: definePropType([String, null]),
    default: null
  },
  route: {
    type: definePropType([String, Object])
  },
  disabled: Boolean
});
var menuItemEmits = {
  click: (item) => (0, import_shared67.isString)(item.index) && Array.isArray(item.indexPath)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-item2.mjs
var COMPONENT_NAME13 = "ElMenuItem";
var _sfc_main89 = (0, import_vue447.defineComponent)({
  name: COMPONENT_NAME13,
  components: {
    ElTooltip
  },
  props: menuItemProps,
  emits: menuItemEmits,
  setup(props, { emit }) {
    const instance = (0, import_vue447.getCurrentInstance)();
    const rootMenu = (0, import_vue447.inject)("rootMenu");
    const nsMenu = useNamespace("menu");
    const nsMenuItem = useNamespace("menu-item");
    if (!rootMenu)
      throwError(COMPONENT_NAME13, "can not inject root menu");
    const { parentMenu, indexPath } = useMenu(instance, (0, import_vue447.toRef)(props, "index"));
    const subMenu = (0, import_vue447.inject)(`subMenu:${parentMenu.value.uid}`);
    if (!subMenu)
      throwError(COMPONENT_NAME13, "can not inject sub menu");
    const active = (0, import_vue447.computed)(() => props.index === rootMenu.activeIndex);
    const item = (0, import_vue447.reactive)({
      index: props.index,
      indexPath,
      active
    });
    const handleClick = () => {
      if (!props.disabled) {
        rootMenu.handleMenuItemClick({
          index: props.index,
          indexPath: indexPath.value,
          route: props.route
        });
        emit("click", item);
      }
    };
    (0, import_vue447.onMounted)(() => {
      subMenu.addSubMenu(item);
      rootMenu.addMenuItem(item);
    });
    (0, import_vue447.onBeforeUnmount)(() => {
      subMenu.removeSubMenu(item);
      rootMenu.removeMenuItem(item);
    });
    return {
      parentMenu,
      rootMenu,
      active,
      nsMenu,
      nsMenuItem,
      handleClick
    };
  }
});
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = (0, import_vue447.resolveComponent)("el-tooltip");
  return (0, import_vue447.openBlock)(), (0, import_vue447.createElementBlock)("li", {
    class: (0, import_vue447.normalizeClass)([
      _ctx.nsMenuItem.b(),
      _ctx.nsMenuItem.is("active", _ctx.active),
      _ctx.nsMenuItem.is("disabled", _ctx.disabled)
    ]),
    role: "menuitem",
    tabindex: "-1",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? ((0, import_vue447.openBlock)(), (0, import_vue447.createBlock)(_component_el_tooltip, {
      key: 0,
      effect: _ctx.rootMenu.props.popperEffect,
      placement: "right",
      "fallback-placements": ["left"],
      persistent: ""
    }, {
      content: (0, import_vue447.withCtx)(() => [
        (0, import_vue447.renderSlot)(_ctx.$slots, "title")
      ]),
      default: (0, import_vue447.withCtx)(() => [
        (0, import_vue447.createElementVNode)("div", {
          class: (0, import_vue447.normalizeClass)(_ctx.nsMenu.be("tooltip", "trigger"))
        }, [
          (0, import_vue447.renderSlot)(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["effect"])) : ((0, import_vue447.openBlock)(), (0, import_vue447.createElementBlock)(import_vue447.Fragment, { key: 1 }, [
      (0, import_vue447.renderSlot)(_ctx.$slots, "default"),
      (0, import_vue447.renderSlot)(_ctx.$slots, "title")
    ], 64))
  ], 2);
}
var MenuItem2 = /* @__PURE__ */ _export_sfc(_sfc_main89, [["render", _sfc_render26], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-item-group2.mjs
var import_vue448 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-item-group.mjs
var menuItemGroupProps = {
  title: String
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/src/menu-item-group2.mjs
var COMPONENT_NAME14 = "ElMenuItemGroup";
var _sfc_main90 = (0, import_vue448.defineComponent)({
  name: COMPONENT_NAME14,
  props: menuItemGroupProps,
  setup() {
    const ns2 = useNamespace("menu-item-group");
    return {
      ns: ns2
    };
  }
});
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue448.openBlock)(), (0, import_vue448.createElementBlock)("li", {
    class: (0, import_vue448.normalizeClass)(_ctx.ns.b())
  }, [
    (0, import_vue448.createElementVNode)("div", {
      class: (0, import_vue448.normalizeClass)(_ctx.ns.e("title"))
    }, [
      !_ctx.$slots.title ? ((0, import_vue448.openBlock)(), (0, import_vue448.createElementBlock)(import_vue448.Fragment, { key: 0 }, [
        (0, import_vue448.createTextVNode)((0, import_vue448.toDisplayString)(_ctx.title), 1)
      ], 64)) : (0, import_vue448.renderSlot)(_ctx.$slots, "title", { key: 1 })
    ], 2),
    (0, import_vue448.createElementVNode)("ul", null, [
      (0, import_vue448.renderSlot)(_ctx.$slots, "default")
    ])
  ], 2);
}
var MenuItemGroup = /* @__PURE__ */ _export_sfc(_sfc_main90, [["render", _sfc_render27], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/menu/index.mjs
var ElMenu = withInstall(Menu2, {
  MenuItem: MenuItem2,
  MenuItemGroup,
  SubMenu: SubMenu2
});
var ElMenuItem = withNoopInstall(MenuItem2);
var ElMenuItemGroup = withNoopInstall(MenuItemGroup);
var ElSubMenu = withNoopInstall(SubMenu2);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/page-header/src/page-header2.mjs
var import_vue449 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/page-header/src/page-header.mjs
var pageHeaderProps = buildProps({
  icon: {
    type: iconPropType,
    default: () => back_default
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
});
var pageHeaderEmits = {
  back: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/page-header/src/page-header2.mjs
var _hoisted_159 = ["aria-label"];
var __default__59 = (0, import_vue449.defineComponent)({
  name: "ElPageHeader"
});
var _sfc_main91 = /* @__PURE__ */ (0, import_vue449.defineComponent)({
  ...__default__59,
  props: pageHeaderProps,
  emits: pageHeaderEmits,
  setup(__props, { emit }) {
    const slots = (0, import_vue449.useSlots)();
    const { t } = useLocale();
    const ns2 = useNamespace("page-header");
    const kls = (0, import_vue449.computed)(() => {
      return [
        ns2.b(),
        {
          [ns2.m("has-breadcrumb")]: !!slots.breadcrumb,
          [ns2.m("has-extra")]: !!slots.extra,
          [ns2.is("contentful")]: !!slots.default
        }
      ];
    });
    function handleClick() {
      emit("back");
    }
    return (_ctx, _cache) => {
      return (0, import_vue449.openBlock)(), (0, import_vue449.createElementBlock)("div", {
        class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(kls))
      }, [
        _ctx.$slots.breadcrumb ? ((0, import_vue449.openBlock)(), (0, import_vue449.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("breadcrumb"))
        }, [
          (0, import_vue449.renderSlot)(_ctx.$slots, "breadcrumb")
        ], 2)) : (0, import_vue449.createCommentVNode)("v-if", true),
        (0, import_vue449.createElementVNode)("div", {
          class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("header"))
        }, [
          (0, import_vue449.createElementVNode)("div", {
            class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("left"))
          }, [
            (0, import_vue449.createElementVNode)("div", {
              class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("back")),
              role: "button",
              tabindex: "0",
              onClick: handleClick
            }, [
              _ctx.icon || _ctx.$slots.icon ? ((0, import_vue449.openBlock)(), (0, import_vue449.createElementBlock)("div", {
                key: 0,
                "aria-label": _ctx.title || (0, import_vue449.unref)(t)("el.pageHeader.title"),
                class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("icon"))
              }, [
                (0, import_vue449.renderSlot)(_ctx.$slots, "icon", {}, () => [
                  _ctx.icon ? ((0, import_vue449.openBlock)(), (0, import_vue449.createBlock)((0, import_vue449.unref)(ElIcon), { key: 0 }, {
                    default: (0, import_vue449.withCtx)(() => [
                      ((0, import_vue449.openBlock)(), (0, import_vue449.createBlock)((0, import_vue449.resolveDynamicComponent)(_ctx.icon)))
                    ]),
                    _: 1
                  })) : (0, import_vue449.createCommentVNode)("v-if", true)
                ])
              ], 10, _hoisted_159)) : (0, import_vue449.createCommentVNode)("v-if", true),
              (0, import_vue449.createElementVNode)("div", {
                class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("title"))
              }, [
                (0, import_vue449.renderSlot)(_ctx.$slots, "title", {}, () => [
                  (0, import_vue449.createTextVNode)((0, import_vue449.toDisplayString)(_ctx.title || (0, import_vue449.unref)(t)("el.pageHeader.title")), 1)
                ])
              ], 2)
            ], 2),
            (0, import_vue449.createVNode)((0, import_vue449.unref)(ElDivider), { direction: "vertical" }),
            (0, import_vue449.createElementVNode)("div", {
              class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("content"))
            }, [
              (0, import_vue449.renderSlot)(_ctx.$slots, "content", {}, () => [
                (0, import_vue449.createTextVNode)((0, import_vue449.toDisplayString)(_ctx.content), 1)
              ])
            ], 2)
          ], 2),
          _ctx.$slots.extra ? ((0, import_vue449.openBlock)(), (0, import_vue449.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("extra"))
          }, [
            (0, import_vue449.renderSlot)(_ctx.$slots, "extra")
          ], 2)) : (0, import_vue449.createCommentVNode)("v-if", true)
        ], 2),
        _ctx.$slots.default ? ((0, import_vue449.openBlock)(), (0, import_vue449.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue449.normalizeClass)((0, import_vue449.unref)(ns2).e("main"))
        }, [
          (0, import_vue449.renderSlot)(_ctx.$slots, "default")
        ], 2)) : (0, import_vue449.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var PageHeader = /* @__PURE__ */ _export_sfc(_sfc_main91, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/page-header/index.mjs
var ElPageHeader = withInstall(PageHeader);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/pagination.mjs
var import_vue463 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/prev2.mjs
var import_vue450 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/prev.mjs
var paginationPrevProps = buildProps({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: iconPropType
  }
});
var paginationPrevEmits = {
  click: (evt) => evt instanceof MouseEvent
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/prev2.mjs
var _hoisted_160 = ["disabled", "aria-disabled"];
var _hoisted_236 = { key: 0 };
var __default__60 = (0, import_vue450.defineComponent)({
  name: "ElPaginationPrev"
});
var _sfc_main92 = /* @__PURE__ */ (0, import_vue450.defineComponent)({
  ...__default__60,
  props: paginationPrevProps,
  emits: paginationPrevEmits,
  setup(__props) {
    const props = __props;
    const internalDisabled = (0, import_vue450.computed)(() => props.disabled || props.currentPage <= 1);
    return (_ctx, _cache) => {
      return (0, import_vue450.openBlock)(), (0, import_vue450.createElementBlock)("button", {
        type: "button",
        class: "btn-prev",
        disabled: (0, import_vue450.unref)(internalDisabled),
        "aria-disabled": (0, import_vue450.unref)(internalDisabled),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, [
        _ctx.prevText ? ((0, import_vue450.openBlock)(), (0, import_vue450.createElementBlock)("span", _hoisted_236, (0, import_vue450.toDisplayString)(_ctx.prevText), 1)) : ((0, import_vue450.openBlock)(), (0, import_vue450.createBlock)((0, import_vue450.unref)(ElIcon), { key: 1 }, {
          default: (0, import_vue450.withCtx)(() => [
            ((0, import_vue450.openBlock)(), (0, import_vue450.createBlock)((0, import_vue450.resolveDynamicComponent)(_ctx.prevIcon)))
          ]),
          _: 1
        }))
      ], 8, _hoisted_160);
    };
  }
});
var Prev = /* @__PURE__ */ _export_sfc(_sfc_main92, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/next2.mjs
var import_vue451 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/next.mjs
var paginationNextProps = buildProps({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: iconPropType
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/next2.mjs
var _hoisted_161 = ["disabled", "aria-disabled"];
var _hoisted_237 = { key: 0 };
var __default__61 = (0, import_vue451.defineComponent)({
  name: "ElPaginationNext"
});
var _sfc_main93 = /* @__PURE__ */ (0, import_vue451.defineComponent)({
  ...__default__61,
  props: paginationNextProps,
  emits: ["click"],
  setup(__props) {
    const props = __props;
    const internalDisabled = (0, import_vue451.computed)(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
    return (_ctx, _cache) => {
      return (0, import_vue451.openBlock)(), (0, import_vue451.createElementBlock)("button", {
        type: "button",
        class: "btn-next",
        disabled: (0, import_vue451.unref)(internalDisabled),
        "aria-disabled": (0, import_vue451.unref)(internalDisabled),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, [
        _ctx.nextText ? ((0, import_vue451.openBlock)(), (0, import_vue451.createElementBlock)("span", _hoisted_237, (0, import_vue451.toDisplayString)(_ctx.nextText), 1)) : ((0, import_vue451.openBlock)(), (0, import_vue451.createBlock)((0, import_vue451.unref)(ElIcon), { key: 1 }, {
          default: (0, import_vue451.withCtx)(() => [
            ((0, import_vue451.openBlock)(), (0, import_vue451.createBlock)((0, import_vue451.resolveDynamicComponent)(_ctx.nextIcon)))
          ]),
          _: 1
        }))
      ], 8, _hoisted_161);
    };
  }
});
var Next = /* @__PURE__ */ _export_sfc(_sfc_main93, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/sizes2.mjs
var import_vue459 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/select.mjs
var import_vue456 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/option.mjs
var import_vue453 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/useOption.mjs
var import_vue452 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/token.mjs
var selectGroupKey = "ElSelectGroup";
var selectKey = "ElSelect";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/useOption.mjs
function useOption(props, states) {
  const select = (0, import_vue452.inject)(selectKey);
  const selectGroup = (0, import_vue452.inject)(selectGroupKey, { disabled: false });
  const isObject27 = (0, import_vue452.computed)(() => {
    return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
  });
  const itemSelected = (0, import_vue452.computed)(() => {
    if (!select.props.multiple) {
      return isEqual3(props.value, select.props.modelValue);
    } else {
      return contains(select.props.modelValue, props.value);
    }
  });
  const limitReached = (0, import_vue452.computed)(() => {
    if (select.props.multiple) {
      const modelValue = select.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  const currentLabel = (0, import_vue452.computed)(() => {
    return props.label || (isObject27.value ? "" : props.value);
  });
  const currentValue = (0, import_vue452.computed)(() => {
    return props.value || props.label || "";
  });
  const isDisabled = (0, import_vue452.computed)(() => {
    return props.disabled || states.groupDisabled || limitReached.value;
  });
  const instance = (0, import_vue452.getCurrentInstance)();
  const contains = (arr = [], target) => {
    if (!isObject27.value) {
      return arr && arr.includes(target);
    } else {
      const valueKey = select.props.valueKey;
      return arr && arr.some((item) => {
        return (0, import_vue452.toRaw)(get_default(item, valueKey)) === get_default(target, valueKey);
      });
    }
  };
  const isEqual3 = (a3, b3) => {
    if (!isObject27.value) {
      return a3 === b3;
    } else {
      const { valueKey } = select.props;
      return get_default(a3, valueKey) === get_default(b3, valueKey);
    }
  };
  const hoverItem = () => {
    if (!props.disabled && !selectGroup.disabled) {
      select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
    }
  };
  (0, import_vue452.watch)(() => currentLabel.value, () => {
    if (!props.created && !select.props.remote)
      select.setSelected();
  });
  (0, import_vue452.watch)(() => props.value, (val, oldVal) => {
    const { remote, valueKey } = select.props;
    if (!Object.is(val, oldVal)) {
      select.onOptionDestroy(oldVal, instance.proxy);
      select.onOptionCreate(instance.proxy);
    }
    if (!props.created && !remote) {
      if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
        return;
      }
      select.setSelected();
    }
  });
  (0, import_vue452.watch)(() => selectGroup.disabled, () => {
    states.groupDisabled = selectGroup.disabled;
  }, { immediate: true });
  const { queryChange } = (0, import_vue452.toRaw)(select);
  (0, import_vue452.watch)(queryChange, (changes) => {
    const { query } = (0, import_vue452.unref)(changes);
    const regexp4 = new RegExp(escapeStringRegexp(query), "i");
    states.visible = regexp4.test(currentLabel.value) || props.created;
    if (!states.visible) {
      select.filteredOptionsCount--;
    }
  });
  return {
    select,
    currentLabel,
    currentValue,
    itemSelected,
    isDisabled,
    hoverItem
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/option.mjs
var _sfc_main94 = (0, import_vue453.defineComponent)({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: true,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const ns2 = useNamespace("select");
    const states = (0, import_vue453.reactive)({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });
    const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption(props, states);
    const { visible, hover } = (0, import_vue453.toRefs)(states);
    const vm = (0, import_vue453.getCurrentInstance)().proxy;
    select.onOptionCreate(vm);
    (0, import_vue453.onBeforeUnmount)(() => {
      const key = vm.value;
      const { selected } = select;
      const selectedOptions = select.props.multiple ? selected : [selected];
      const doesSelected = selectedOptions.some((item) => {
        return item.value === vm.value;
      });
      (0, import_vue453.nextTick)(() => {
        if (select.cachedOptions.get(key) === vm && !doesSelected) {
          select.cachedOptions.delete(key);
        }
      });
      select.onOptionDestroy(key, vm);
    });
    function selectOptionClick() {
      if (props.disabled !== true && states.groupDisabled !== true) {
        select.handleOptionSelect(vm, true);
      }
    }
    return {
      ns: ns2,
      currentLabel,
      itemSelected,
      isDisabled,
      select,
      hoverItem,
      visible,
      hover,
      selectOptionClick,
      states
    };
  }
});
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue453.withDirectives)(((0, import_vue453.openBlock)(), (0, import_vue453.createElementBlock)("li", {
    class: (0, import_vue453.normalizeClass)([
      _ctx.ns.be("dropdown", "item"),
      _ctx.ns.is("disabled", _ctx.isDisabled),
      {
        selected: _ctx.itemSelected,
        hover: _ctx.hover
      }
    ]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = (0, import_vue453.withModifiers)((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    (0, import_vue453.renderSlot)(_ctx.$slots, "default", {}, () => [
      (0, import_vue453.createElementVNode)("span", null, (0, import_vue453.toDisplayString)(_ctx.currentLabel), 1)
    ])
  ], 34)), [
    [import_vue453.vShow, _ctx.visible]
  ]);
}
var Option = /* @__PURE__ */ _export_sfc(_sfc_main94, [["render", _sfc_render28], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/select-dropdown.mjs
var import_vue454 = require("vue");
var _sfc_main95 = (0, import_vue454.defineComponent)({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const select = (0, import_vue454.inject)(selectKey);
    const ns2 = useNamespace("select");
    const popperClass = (0, import_vue454.computed)(() => select.props.popperClass);
    const isMultiple = (0, import_vue454.computed)(() => select.props.multiple);
    const isFitInputWidth = (0, import_vue454.computed)(() => select.props.fitInputWidth);
    const minWidth = (0, import_vue454.ref)("");
    function updateMinWidth() {
      var _a2;
      minWidth.value = `${(_a2 = select.selectWrapper) == null ? void 0 : _a2.offsetWidth}px`;
    }
    (0, import_vue454.onMounted)(() => {
      updateMinWidth();
      useResizeObserver(select.selectWrapper, updateMinWidth);
    });
    return {
      ns: ns2,
      minWidth,
      popperClass,
      isMultiple,
      isFitInputWidth
    };
  }
});
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue454.openBlock)(), (0, import_vue454.createElementBlock)("div", {
    class: (0, import_vue454.normalizeClass)([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
    style: (0, import_vue454.normalizeStyle)({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
  }, [
    (0, import_vue454.renderSlot)(_ctx.$slots, "default")
  ], 6);
}
var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main95, [["render", _sfc_render30], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/useSelect.mjs
var import_vue455 = require("vue");
var import_shared68 = require("@vue/shared");
function useSelectStates(props) {
  const { t } = useLocale();
  return (0, import_vue455.reactive)({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    prefixWidth: 11,
    tagInMultiLine: false,
    mouseEnter: false
  });
}
var useSelect = (props, states, ctx) => {
  const { t } = useLocale();
  const ns2 = useNamespace("select");
  useDeprecated({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, (0, import_vue455.computed)(() => props.suffixTransition === false));
  const reference = (0, import_vue455.ref)(null);
  const input = (0, import_vue455.ref)(null);
  const tooltipRef = (0, import_vue455.ref)(null);
  const tags = (0, import_vue455.ref)(null);
  const selectWrapper = (0, import_vue455.ref)(null);
  const scrollbar = (0, import_vue455.ref)(null);
  const hoverOption = (0, import_vue455.ref)(-1);
  const queryChange = (0, import_vue455.shallowRef)({ query: "" });
  const groupQueryChange = (0, import_vue455.shallowRef)("");
  const { form, formItem } = useFormItem();
  const readonly5 = (0, import_vue455.computed)(() => !props.filterable || props.multiple || !states.visible);
  const selectDisabled = (0, import_vue455.computed)(() => props.disabled || (form == null ? void 0 : form.disabled));
  const showClose = (0, import_vue455.computed)(() => {
    const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
    const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
    return criteria;
  });
  const iconComponent = (0, import_vue455.computed)(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
  const iconReverse = (0, import_vue455.computed)(() => ns2.is("reverse", iconComponent.value && states.visible && props.suffixTransition));
  const debounce$1 = (0, import_vue455.computed)(() => props.remote ? 300 : 0);
  const emptyText = (0, import_vue455.computed)(() => {
    if (props.loading) {
      return props.loadingText || t("el.select.loading");
    } else {
      if (props.remote && states.query === "" && states.options.size === 0)
        return false;
      if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props.noMatchText || t("el.select.noMatch");
      }
      if (states.options.size === 0) {
        return props.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const optionsArray = (0, import_vue455.computed)(() => Array.from(states.options.values()));
  const cachedOptionsArray = (0, import_vue455.computed)(() => Array.from(states.cachedOptions.values()));
  const showNewOption = (0, import_vue455.computed)(() => {
    const hasExistingOption = optionsArray.value.filter((option2) => {
      return !option2.created;
    }).some((option2) => {
      return option2.currentLabel === states.query;
    });
    return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
  });
  const selectSize = useSize();
  const collapseTagSize = (0, import_vue455.computed)(() => ["small"].includes(selectSize.value) ? "small" : "default");
  const dropMenuVisible = (0, import_vue455.computed)({
    get() {
      return states.visible && emptyText.value !== false;
    },
    set(val) {
      states.visible = val;
    }
  });
  (0, import_vue455.watch)([() => selectDisabled.value, () => selectSize.value, () => form == null ? void 0 : form.size], () => {
    (0, import_vue455.nextTick)(() => {
      resetInputHeight();
    });
  });
  (0, import_vue455.watch)(() => props.placeholder, (val) => {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  (0, import_vue455.watch)(() => props.modelValue, (val, oldVal) => {
    if (props.multiple) {
      resetInputHeight();
      if (val && val.length > 0 || input.value && states.query !== "") {
        states.currentPlaceholder = "";
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }
      if (props.filterable && !props.reserveKeyword) {
        states.query = "";
        handleQueryChange(states.query);
      }
    }
    setSelected();
    if (props.filterable && !props.multiple) {
      states.inputLength = 20;
    }
    if (!isEqual_default(val, oldVal) && props.validateEvent) {
      formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
    }
  }, {
    flush: "post",
    deep: true
  });
  (0, import_vue455.watch)(() => states.visible, (val) => {
    var _a2, _b, _c;
    if (!val) {
      if (props.filterable) {
        if ((0, import_shared68.isFunction)(props.filterMethod)) {
          props.filterMethod("");
        }
        if ((0, import_shared68.isFunction)(props.remoteMethod)) {
          props.remoteMethod("");
        }
      }
      input.value && input.value.blur();
      states.query = "";
      states.previousQuery = null;
      states.selectedLabel = "";
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      (0, import_vue455.nextTick)(() => {
        if (input.value && input.value.value === "" && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });
      if (!props.multiple) {
        if (states.selected) {
          if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }
          if (props.filterable)
            states.query = states.selectedLabel;
        }
        if (props.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      if (props.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props.remote ? "" : states.selectedLabel;
        if (props.multiple) {
          (_c = input.value) == null ? void 0 : _c.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = `${states.selectedLabel}`;
            states.selectedLabel = "";
          }
        }
        handleQueryChange(states.query);
        if (!props.multiple && !props.remote) {
          queryChange.value.query = "";
          (0, import_vue455.triggerRef)(queryChange);
          (0, import_vue455.triggerRef)(groupQueryChange);
        }
      }
    }
    ctx.emit("visible-change", val);
  });
  (0, import_vue455.watch)(() => states.options.entries(), () => {
    var _a2, _b, _c;
    if (!isClient)
      return;
    (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
    if (props.multiple) {
      resetInputHeight();
    }
    const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
    if (!Array.from(inputs).includes(document.activeElement)) {
      setSelected();
    }
    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: "post"
  });
  (0, import_vue455.watch)(() => states.hoverIndex, (val) => {
    if (isNumber(val) && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    } else {
      hoverOption.value = {};
    }
    optionsArray.value.forEach((option2) => {
      option2.hover = hoverOption.value === option2;
    });
  });
  const resetInputHeight = () => {
    if (props.collapseTags && !props.filterable)
      return;
    (0, import_vue455.nextTick)(() => {
      var _a2, _b;
      if (!reference.value)
        return;
      const input2 = reference.value.$el.querySelector("input");
      const _tags = tags.value;
      const sizeInMap = getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
      input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`;
      states.tagInMultiLine = Number.parseFloat(input2.style.height) >= sizeInMap;
      if (states.visible && emptyText.value !== false) {
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      }
    });
  };
  const handleQueryChange = async (val) => {
    if (states.previousQuery === val || states.isOnComposition)
      return;
    if (states.previousQuery === null && ((0, import_shared68.isFunction)(props.filterMethod) || (0, import_shared68.isFunction)(props.remoteMethod))) {
      states.previousQuery = val;
      return;
    }
    states.previousQuery = val;
    (0, import_vue455.nextTick)(() => {
      var _a2, _b;
      if (states.visible)
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
    });
    states.hoverIndex = -1;
    if (props.multiple && props.filterable) {
      (0, import_vue455.nextTick)(() => {
        const length = input.value.value.length * 15 + 20;
        states.inputLength = props.collapseTags ? Math.min(50, length) : length;
        managePlaceholder();
        resetInputHeight();
      });
    }
    if (props.remote && (0, import_shared68.isFunction)(props.remoteMethod)) {
      states.hoverIndex = -1;
      props.remoteMethod(val);
    } else if ((0, import_shared68.isFunction)(props.filterMethod)) {
      props.filterMethod(val);
      (0, import_vue455.triggerRef)(groupQueryChange);
    } else {
      states.filteredOptionsCount = states.optionsCount;
      queryChange.value.query = val;
      (0, import_vue455.triggerRef)(queryChange);
      (0, import_vue455.triggerRef)(groupQueryChange);
    }
    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
      await (0, import_vue455.nextTick)();
      checkDefaultFirstOption();
    }
  };
  const managePlaceholder = () => {
    if (states.currentPlaceholder !== "") {
      states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
    }
  };
  const checkDefaultFirstOption = () => {
    const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
    const userCreatedOption = optionsInDropdown.find((n) => n.created);
    const firstOriginOption = optionsInDropdown[0];
    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
  };
  const setSelected = () => {
    var _a2;
    if (!props.multiple) {
      const option2 = getOption(props.modelValue);
      if ((_a2 = option2.props) == null ? void 0 : _a2.created) {
        states.createdLabel = option2.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }
      states.selectedLabel = option2.currentLabel;
      states.selected = option2;
      if (props.filterable)
        states.query = states.selectedLabel;
      return;
    } else {
      states.selectedLabel = "";
    }
    const result = [];
    if (Array.isArray(props.modelValue)) {
      props.modelValue.forEach((value) => {
        result.push(getOption(value));
      });
    }
    states.selected = result;
    (0, import_vue455.nextTick)(() => {
      resetInputHeight();
    });
  };
  const getOption = (value) => {
    let option2;
    const isObjectValue = (0, import_shared68.toRawType)(value).toLowerCase() === "object";
    const isNull = (0, import_shared68.toRawType)(value).toLowerCase() === "null";
    const isUndefined2 = (0, import_shared68.toRawType)(value).toLowerCase() === "undefined";
    for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
      const cachedOption = cachedOptionsArray.value[i];
      const isEqualValue = isObjectValue ? get_default(cachedOption.value, props.valueKey) === get_default(value, props.valueKey) : cachedOption.value === value;
      if (isEqualValue) {
        option2 = {
          value,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }
    if (option2)
      return option2;
    const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
    const newOption = {
      value,
      currentLabel: label
    };
    if (props.multiple) {
      ;
      newOption.hitState = false;
    }
    return newOption;
  };
  const resetHoverIndex = () => {
    setTimeout(() => {
      const valueKey = props.valueKey;
      if (!props.multiple) {
        states.hoverIndex = optionsArray.value.findIndex((item) => {
          return getValueKey(item) === getValueKey(states.selected);
        });
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
            return optionsArray.value.findIndex((item) => {
              return get_default(item, valueKey) === get_default(selected, valueKey);
            });
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };
  const handleResize = () => {
    var _a2, _b;
    resetInputWidth();
    (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
    if (props.multiple && !props.filterable)
      resetInputHeight();
  };
  const resetInputWidth = () => {
    var _a2;
    states.inputWidth = (_a2 = reference.value) == null ? void 0 : _a2.$el.getBoundingClientRect().width;
  };
  const onInputChange = () => {
    if (props.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };
  const debouncedOnInputChange = debounce_default(() => {
    onInputChange();
  }, debounce$1.value);
  const debouncedQueryChange = debounce_default((e) => {
    handleQueryChange(e.target.value);
  }, debounce$1.value);
  const emitChange = (val) => {
    if (!isEqual_default(props.modelValue, val)) {
      ctx.emit(CHANGE_EVENT, val);
    }
  };
  const deletePrevTag = (e) => {
    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
      const value = props.modelValue.slice();
      value.pop();
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
    }
    if (e.target.value.length === 1 && props.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };
  const deleteTag = (event, tag) => {
    const index2 = states.selected.indexOf(tag);
    if (index2 > -1 && !selectDisabled.value) {
      const value = props.modelValue.slice();
      value.splice(index2, 1);
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      ctx.emit("remove-tag", tag.value);
    }
    event.stopPropagation();
  };
  const deleteSelected = (event) => {
    event.stopPropagation();
    const value = props.multiple ? [] : "";
    if (!(0, import_shared68.isString)(value)) {
      for (const item of states.selected) {
        if (item.isDisabled)
          value.push(item.value);
      }
    }
    ctx.emit(UPDATE_MODEL_EVENT, value);
    emitChange(value);
    states.hoverIndex = -1;
    states.visible = false;
    ctx.emit("clear");
  };
  const handleOptionSelect = (option2, byClick) => {
    var _a2;
    if (props.multiple) {
      const value = (props.modelValue || []).slice();
      const optionIndex = getValueIndex(value, option2.value);
      if (optionIndex > -1) {
        value.splice(optionIndex, 1);
      } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
        value.push(option2.value);
      }
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      if (option2.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props.filterable)
        (_a2 = input.value) == null ? void 0 : _a2.focus();
    } else {
      ctx.emit(UPDATE_MODEL_EVENT, option2.value);
      emitChange(option2.value);
      states.visible = false;
    }
    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible)
      return;
    (0, import_vue455.nextTick)(() => {
      scrollToOption(option2);
    });
  };
  const getValueIndex = (arr = [], value) => {
    if (!(0, import_shared68.isObject)(value))
      return arr.indexOf(value);
    const valueKey = props.valueKey;
    let index2 = -1;
    arr.some((item, i) => {
      if ((0, import_vue455.toRaw)(get_default(item, valueKey)) === get_default(value, valueKey)) {
        index2 = i;
        return true;
      }
      return false;
    });
    return index2;
  };
  const setSoftFocus = () => {
    states.softFocus = true;
    const _input = input.value || reference.value;
    if (_input) {
      _input == null ? void 0 : _input.focus();
    }
  };
  const scrollToOption = (option2) => {
    var _a2, _b, _c, _d, _e;
    const targetOption = Array.isArray(option2) ? option2[0] : option2;
    let target = null;
    if (targetOption == null ? void 0 : targetOption.value) {
      const options = optionsArray.value.filter((item) => item.value === targetOption.value);
      if (options.length > 0) {
        target = options[0].$el;
      }
    }
    if (tooltipRef.value && target) {
      const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns2.be("dropdown", "wrap")}`);
      if (menu) {
        scrollIntoView(menu, target);
      }
    }
    (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
  };
  const onOptionCreate = (vm) => {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };
  const onOptionDestroy = (key, vm) => {
    if (states.options.get(key) === vm) {
      states.optionsCount--;
      states.filteredOptionsCount--;
      states.options.delete(key);
    }
  };
  const resetInputState = (e) => {
    if (e.code !== EVENT_CODE.backspace)
      toggleLastOptionHitState(false);
    states.inputLength = input.value.value.length * 15 + 20;
    resetInputHeight();
  };
  const toggleLastOptionHitState = (hit) => {
    if (!Array.isArray(states.selected))
      return;
    const option2 = states.selected[states.selected.length - 1];
    if (!option2)
      return;
    if (hit === true || hit === false) {
      option2.hitState = hit;
      return hit;
    }
    option2.hitState = !option2.hitState;
    return option2.hitState;
  };
  const handleComposition = (event) => {
    const text = event.target.value;
    if (event.type === "compositionend") {
      states.isOnComposition = false;
      (0, import_vue455.nextTick)(() => handleQueryChange(text));
    } else {
      const lastCharacter = text[text.length - 1] || "";
      states.isOnComposition = !isKorean(lastCharacter);
    }
  };
  const handleMenuEnter = () => {
    (0, import_vue455.nextTick)(() => scrollToOption(states.selected));
  };
  const handleFocus = (event) => {
    if (!states.softFocus) {
      if (props.automaticDropdown || props.filterable) {
        if (props.filterable && !states.visible) {
          states.menuVisibleOnFocus = true;
        }
        states.visible = true;
      }
      ctx.emit("focus", event);
    } else {
      states.softFocus = false;
    }
  };
  const blur = () => {
    var _a2;
    states.visible = false;
    (_a2 = reference.value) == null ? void 0 : _a2.blur();
  };
  const handleBlur = (event) => {
    (0, import_vue455.nextTick)(() => {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx.emit("blur", event);
      }
    });
    states.softFocus = false;
  };
  const handleClearClick = (event) => {
    deleteSelected(event);
  };
  const handleClose = () => {
    states.visible = false;
  };
  const handleKeydownEscape = (event) => {
    if (states.visible) {
      event.preventDefault();
      event.stopPropagation();
      states.visible = false;
    }
  };
  const toggleMenu = (e) => {
    var _a2;
    if (e && !states.mouseEnter) {
      return;
    }
    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        if (!tooltipRef.value || !tooltipRef.value.isFocusInsideContent()) {
          states.visible = !states.visible;
        }
      }
      if (states.visible) {
        ;
        (_a2 = input.value || reference.value) == null ? void 0 : _a2.focus();
      }
    }
  };
  const selectOption = () => {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
      }
    }
  };
  const getValueKey = (item) => {
    return (0, import_shared68.isObject)(item.value) ? get_default(item.value, props.valueKey) : item.value;
  };
  const optionsAllDisabled = (0, import_vue455.computed)(() => optionsArray.value.filter((option2) => option2.visible).every((option2) => option2.disabled));
  const navigateOptions = (direction2) => {
    if (!states.visible) {
      states.visible = true;
      return;
    }
    if (states.options.size === 0 || states.filteredOptionsCount === 0)
      return;
    if (states.isOnComposition)
      return;
    if (!optionsAllDisabled.value) {
      if (direction2 === "next") {
        states.hoverIndex++;
        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction2 === "prev") {
        states.hoverIndex--;
        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }
      const option2 = optionsArray.value[states.hoverIndex];
      if (option2.disabled === true || option2.states.groupDisabled === true || !option2.visible) {
        navigateOptions(direction2);
      }
      (0, import_vue455.nextTick)(() => scrollToOption(hoverOption.value));
    }
  };
  const handleMouseEnter = () => {
    states.mouseEnter = true;
  };
  const handleMouseLeave = () => {
    states.mouseEnter = false;
  };
  return {
    optionsArray,
    selectSize,
    handleResize,
    debouncedOnInputChange,
    debouncedQueryChange,
    deletePrevTag,
    deleteTag,
    deleteSelected,
    handleOptionSelect,
    scrollToOption,
    readonly: readonly5,
    resetInputHeight,
    showClose,
    iconComponent,
    iconReverse,
    showNewOption,
    collapseTagSize,
    setSelected,
    managePlaceholder,
    selectDisabled,
    emptyText,
    toggleLastOptionHitState,
    resetInputState,
    handleComposition,
    onOptionCreate,
    onOptionDestroy,
    handleMenuEnter,
    handleFocus,
    blur,
    handleBlur,
    handleClearClick,
    handleClose,
    handleKeydownEscape,
    toggleMenu,
    selectOption,
    getValueKey,
    navigateOptions,
    dropMenuVisible,
    queryChange,
    groupQueryChange,
    reference,
    input,
    tooltipRef,
    tags,
    selectWrapper,
    scrollbar,
    handleMouseEnter,
    handleMouseLeave
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/select.mjs
var COMPONENT_NAME15 = "ElSelect";
var _sfc_main96 = (0, import_vue456.defineComponent)({
  name: COMPONENT_NAME15,
  componentName: COMPONENT_NAME15,
  components: {
    ElInput,
    ElSelectMenu,
    ElOption: Option,
    ElTag,
    ElScrollbar,
    ElTooltip,
    ElIcon
  },
  directives: { ClickOutside },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: true
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: {
      type: Boolean,
      default: false
    },
    teleported: useTooltipContentProps.teleported,
    persistent: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: iconPropType,
      default: circle_close_default
    },
    fitInputWidth: {
      type: Boolean,
      default: false
    },
    suffixIcon: {
      type: iconPropType,
      default: arrow_down_default
    },
    tagType: { ...tagProps.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: true
    },
    remoteShowSuffix: {
      type: Boolean,
      default: false
    },
    suffixTransition: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      values: Ee,
      default: "bottom-start"
    }
  },
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(props, ctx) {
    const nsSelect = useNamespace("select");
    const nsInput = useNamespace("input");
    const { t } = useLocale();
    const states = useSelectStates(props);
    const {
      optionsArray,
      selectSize,
      readonly: readonly5,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      setSelected,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconComponent,
      iconReverse,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      handleKeydownEscape,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      reference,
      input,
      tooltipRef,
      tags,
      selectWrapper,
      scrollbar,
      queryChange,
      groupQueryChange,
      handleMouseEnter,
      handleMouseLeave
    } = useSelect(props, states, ctx);
    const { focus } = useFocus(reference);
    const {
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options,
      cachedOptions,
      optionsCount,
      prefixWidth,
      tagInMultiLine
    } = (0, import_vue456.toRefs)(states);
    const wrapperKls = (0, import_vue456.computed)(() => {
      const classList = [nsSelect.b()];
      const _selectSize = (0, import_vue456.unref)(selectSize);
      if (_selectSize) {
        classList.push(nsSelect.m(_selectSize));
      }
      if (props.disabled) {
        classList.push(nsSelect.m("disabled"));
      }
      return classList;
    });
    const selectTagsStyle = (0, import_vue456.computed)(() => ({
      maxWidth: `${(0, import_vue456.unref)(inputWidth) - 32}px`,
      width: "100%"
    }));
    const tagTextStyle = (0, import_vue456.computed)(() => {
      const maxWidth = (0, import_vue456.unref)(inputWidth) > 123 ? (0, import_vue456.unref)(inputWidth) - 123 : (0, import_vue456.unref)(inputWidth) - 75;
      return { maxWidth: `${maxWidth}px` };
    });
    (0, import_vue456.provide)(selectKey, (0, import_vue456.reactive)({
      props,
      options,
      optionsArray,
      cachedOptions,
      optionsCount,
      filteredOptionsCount,
      hoverIndex,
      handleOptionSelect,
      onOptionCreate,
      onOptionDestroy,
      selectWrapper,
      selected,
      setSelected,
      queryChange,
      groupQueryChange
    }));
    (0, import_vue456.onMounted)(() => {
      states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || t("el.select.placeholder");
      if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
        currentPlaceholder.value = "";
      }
      useResizeObserver(selectWrapper, handleResize);
      if (props.remote && props.multiple) {
        resetInputHeight();
      }
      (0, import_vue456.nextTick)(() => {
        const refEl = reference.value && reference.value.$el;
        if (!refEl)
          return;
        inputWidth.value = refEl.getBoundingClientRect().width;
        if (ctx.slots.prefix) {
          const prefix = refEl.querySelector(`.${nsInput.e("prefix")}`);
          prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
        }
      });
      setSelected();
    });
    if (props.multiple && !Array.isArray(props.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, []);
    }
    if (!props.multiple && Array.isArray(props.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, "");
    }
    const popperPaneRef = (0, import_vue456.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
    });
    return {
      tagInMultiLine,
      prefixWidth,
      selectSize,
      readonly: readonly5,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconComponent,
      iconReverse,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      handleKeydownEscape,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      focus,
      reference,
      input,
      tooltipRef,
      popperPaneRef,
      tags,
      selectWrapper,
      scrollbar,
      wrapperKls,
      selectTagsStyle,
      nsSelect,
      tagTextStyle,
      handleMouseEnter,
      handleMouseLeave
    };
  }
});
var _hoisted_163 = ["disabled", "autocomplete"];
var _hoisted_238 = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = (0, import_vue456.resolveComponent)("el-tag");
  const _component_el_tooltip = (0, import_vue456.resolveComponent)("el-tooltip");
  const _component_el_icon = (0, import_vue456.resolveComponent)("el-icon");
  const _component_el_input = (0, import_vue456.resolveComponent)("el-input");
  const _component_el_option = (0, import_vue456.resolveComponent)("el-option");
  const _component_el_scrollbar = (0, import_vue456.resolveComponent)("el-scrollbar");
  const _component_el_select_menu = (0, import_vue456.resolveComponent)("el-select-menu");
  const _directive_click_outside = (0, import_vue456.resolveDirective)("click-outside");
  return (0, import_vue456.withDirectives)(((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("div", {
    ref: "selectWrapper",
    class: (0, import_vue456.normalizeClass)(_ctx.wrapperKls),
    onMouseenter: _cache[22] || (_cache[22] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[23] || (_cache[23] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onClick: _cache[24] || (_cache[24] = (0, import_vue456.withModifiers)((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
  }, [
    (0, import_vue456.createVNode)(_component_el_tooltip, {
      ref: "tooltipRef",
      visible: _ctx.dropMenuVisible,
      placement: _ctx.placement,
      teleported: _ctx.teleported,
      "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: _ctx.effect,
      pure: "",
      trigger: "click",
      transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      persistent: _ctx.persistent,
      onShow: _ctx.handleMenuEnter
    }, {
      default: (0, import_vue456.withCtx)(() => [
        (0, import_vue456.createElementVNode)("div", {
          class: "select-trigger",
          onMouseenter: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = true),
          onMouseleave: _cache[21] || (_cache[21] = ($event) => _ctx.inputHovering = false)
        }, [
          _ctx.multiple ? ((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("div", {
            key: 0,
            ref: "tags",
            class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("tags")),
            style: (0, import_vue456.normalizeStyle)(_ctx.selectTagsStyle)
          }, [
            _ctx.collapseTags && _ctx.selected.length ? ((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("span", {
              key: 0,
              class: (0, import_vue456.normalizeClass)([
                _ctx.nsSelect.b("tags-wrapper"),
                { "has-prefix": _ctx.prefixWidth && _ctx.selected.length }
              ])
            }, [
              (0, import_vue456.createVNode)(_component_el_tag, {
                closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                size: _ctx.collapseTagSize,
                hit: _ctx.selected[0].hitState,
                type: _ctx.tagType,
                "disable-transitions": "",
                onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.selected[0]))
              }, {
                default: (0, import_vue456.withCtx)(() => [
                  (0, import_vue456.createElementVNode)("span", {
                    class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("tags-text")),
                    style: (0, import_vue456.normalizeStyle)(_ctx.tagTextStyle)
                  }, (0, import_vue456.toDisplayString)(_ctx.selected[0].currentLabel), 7)
                ]),
                _: 1
              }, 8, ["closable", "size", "hit", "type"]),
              _ctx.selected.length > 1 ? ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_tag, {
                key: 0,
                closable: false,
                size: _ctx.collapseTagSize,
                type: _ctx.tagType,
                "disable-transitions": ""
              }, {
                default: (0, import_vue456.withCtx)(() => [
                  _ctx.collapseTagsTooltip ? ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_tooltip, {
                    key: 0,
                    disabled: _ctx.dropMenuVisible,
                    "fallback-placements": ["bottom", "top", "right", "left"],
                    effect: _ctx.effect,
                    placement: "bottom",
                    teleported: _ctx.teleported
                  }, {
                    default: (0, import_vue456.withCtx)(() => [
                      (0, import_vue456.createElementVNode)("span", {
                        class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("tags-text"))
                      }, "+ " + (0, import_vue456.toDisplayString)(_ctx.selected.length - 1), 3)
                    ]),
                    content: (0, import_vue456.withCtx)(() => [
                      (0, import_vue456.createElementVNode)("div", {
                        class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("collapse-tags"))
                      }, [
                        ((0, import_vue456.openBlock)(true), (0, import_vue456.createElementBlock)(import_vue456.Fragment, null, (0, import_vue456.renderList)(_ctx.selected.slice(1), (item, idx) => {
                          return (0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("div", {
                            key: idx,
                            class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("collapse-tag"))
                          }, [
                            ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_tag, {
                              key: _ctx.getValueKey(item),
                              class: "in-tooltip",
                              closable: !_ctx.selectDisabled && !item.isDisabled,
                              size: _ctx.collapseTagSize,
                              hit: item.hitState,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: { margin: "2px" },
                              onClose: ($event) => _ctx.deleteTag($event, item)
                            }, {
                              default: (0, import_vue456.withCtx)(() => [
                                (0, import_vue456.createElementVNode)("span", {
                                  class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("tags-text")),
                                  style: (0, import_vue456.normalizeStyle)({
                                    maxWidth: _ctx.inputWidth - 75 + "px"
                                  })
                                }, (0, import_vue456.toDisplayString)(item.currentLabel), 7)
                              ]),
                              _: 2
                            }, 1032, ["closable", "size", "hit", "type", "onClose"]))
                          ], 2);
                        }), 128))
                      ], 2)
                    ]),
                    _: 1
                  }, 8, ["disabled", "effect", "teleported"])) : ((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("span", {
                    key: 1,
                    class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("tags-text"))
                  }, "+ " + (0, import_vue456.toDisplayString)(_ctx.selected.length - 1), 3))
                ]),
                _: 1
              }, 8, ["size", "type"])) : (0, import_vue456.createCommentVNode)("v-if", true)
            ], 2)) : (0, import_vue456.createCommentVNode)("v-if", true),
            (0, import_vue456.createCommentVNode)(" <div> "),
            !_ctx.collapseTags ? ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(import_vue456.Transition, {
              key: 1,
              onAfterLeave: _ctx.resetInputHeight
            }, {
              default: (0, import_vue456.withCtx)(() => [
                (0, import_vue456.createElementVNode)("span", {
                  class: (0, import_vue456.normalizeClass)([
                    _ctx.nsSelect.b("tags-wrapper"),
                    { "has-prefix": _ctx.prefixWidth && _ctx.selected.length }
                  ])
                }, [
                  ((0, import_vue456.openBlock)(true), (0, import_vue456.createElementBlock)(import_vue456.Fragment, null, (0, import_vue456.renderList)(_ctx.selected, (item) => {
                    return (0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_tag, {
                      key: _ctx.getValueKey(item),
                      closable: !_ctx.selectDisabled && !item.isDisabled,
                      size: _ctx.collapseTagSize,
                      hit: item.hitState,
                      type: _ctx.tagType,
                      "disable-transitions": "",
                      onClose: ($event) => _ctx.deleteTag($event, item)
                    }, {
                      default: (0, import_vue456.withCtx)(() => [
                        (0, import_vue456.createElementVNode)("span", {
                          class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.e("tags-text")),
                          style: (0, import_vue456.normalizeStyle)({ maxWidth: _ctx.inputWidth - 75 + "px" })
                        }, (0, import_vue456.toDisplayString)(item.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                  }), 128))
                ], 2)
              ]),
              _: 1
            }, 8, ["onAfterLeave"])) : (0, import_vue456.createCommentVNode)("v-if", true),
            (0, import_vue456.createCommentVNode)(" </div> "),
            _ctx.filterable ? (0, import_vue456.withDirectives)(((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("input", {
              key: 2,
              ref: "input",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
              type: "text",
              class: (0, import_vue456.normalizeClass)([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
              disabled: _ctx.selectDisabled,
              autocomplete: _ctx.autocomplete,
              style: (0, import_vue456.normalizeStyle)({
                marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : "",
                flexGrow: 1,
                width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
                maxWidth: `${_ctx.inputWidth - 42}px`
              }),
              onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
              onKeydown: [
                _cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                _cache[6] || (_cache[6] = (0, import_vue456.withKeys)((0, import_vue456.withModifiers)(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                _cache[7] || (_cache[7] = (0, import_vue456.withKeys)((0, import_vue456.withModifiers)(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                _cache[8] || (_cache[8] = (0, import_vue456.withKeys)((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
                _cache[9] || (_cache[9] = (0, import_vue456.withKeys)((0, import_vue456.withModifiers)((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                _cache[10] || (_cache[10] = (0, import_vue456.withKeys)((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                _cache[11] || (_cache[11] = (0, import_vue456.withKeys)(($event) => _ctx.visible = false, ["tab"]))
              ],
              onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
            }, null, 46, _hoisted_163)), [
              [import_vue456.vModelText, _ctx.query]
            ]) : (0, import_vue456.createCommentVNode)("v-if", true)
          ], 6)) : (0, import_vue456.createCommentVNode)("v-if", true),
          (0, import_vue456.createVNode)(_component_el_input, {
            id: _ctx.id,
            ref: "reference",
            modelValue: _ctx.selectedLabel,
            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selectedLabel = $event),
            type: "text",
            placeholder: _ctx.currentPlaceholder,
            name: _ctx.name,
            autocomplete: _ctx.autocomplete,
            size: _ctx.selectSize,
            disabled: _ctx.selectDisabled,
            readonly: _ctx.readonly,
            "validate-event": false,
            class: (0, import_vue456.normalizeClass)([_ctx.nsSelect.is("focus", _ctx.visible)]),
            tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
            onFocus: _ctx.handleFocus,
            onBlur: _ctx.handleBlur,
            onInput: _ctx.debouncedOnInputChange,
            onPaste: _ctx.debouncedOnInputChange,
            onCompositionstart: _ctx.handleComposition,
            onCompositionupdate: _ctx.handleComposition,
            onCompositionend: _ctx.handleComposition,
            onKeydown: [
              _cache[17] || (_cache[17] = (0, import_vue456.withKeys)((0, import_vue456.withModifiers)(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
              _cache[18] || (_cache[18] = (0, import_vue456.withKeys)((0, import_vue456.withModifiers)(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
              (0, import_vue456.withKeys)((0, import_vue456.withModifiers)(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
              (0, import_vue456.withKeys)(_ctx.handleKeydownEscape, ["esc"]),
              _cache[19] || (_cache[19] = (0, import_vue456.withKeys)(($event) => _ctx.visible = false, ["tab"]))
            ]
          }, (0, import_vue456.createSlots)({
            suffix: (0, import_vue456.withCtx)(() => [
              _ctx.iconComponent && !_ctx.showClose ? ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_icon, {
                key: 0,
                class: (0, import_vue456.normalizeClass)([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
              }, {
                default: (0, import_vue456.withCtx)(() => [
                  ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)((0, import_vue456.resolveDynamicComponent)(_ctx.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])) : (0, import_vue456.createCommentVNode)("v-if", true),
              _ctx.showClose && _ctx.clearIcon ? ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_icon, {
                key: 1,
                class: (0, import_vue456.normalizeClass)([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                onClick: _ctx.handleClearClick
              }, {
                default: (0, import_vue456.withCtx)(() => [
                  ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)((0, import_vue456.resolveDynamicComponent)(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (0, import_vue456.createCommentVNode)("v-if", true)
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: (0, import_vue456.withCtx)(() => [
                (0, import_vue456.createElementVNode)("div", _hoisted_238, [
                  (0, import_vue456.renderSlot)(_ctx.$slots, "prefix")
                ])
              ])
            } : void 0
          ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
        ], 32)
      ]),
      content: (0, import_vue456.withCtx)(() => [
        (0, import_vue456.createVNode)(_component_el_select_menu, null, {
          default: (0, import_vue456.withCtx)(() => [
            (0, import_vue456.withDirectives)((0, import_vue456.createVNode)(_component_el_scrollbar, {
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
              "view-class": _ctx.nsSelect.be("dropdown", "list"),
              class: (0, import_vue456.normalizeClass)([
                _ctx.nsSelect.is("empty", !_ctx.allowCreate && Boolean(_ctx.query) && _ctx.filteredOptionsCount === 0)
              ])
            }, {
              default: (0, import_vue456.withCtx)(() => [
                _ctx.showNewOption ? ((0, import_vue456.openBlock)(), (0, import_vue456.createBlock)(_component_el_option, {
                  key: 0,
                  value: _ctx.query,
                  created: true
                }, null, 8, ["value"])) : (0, import_vue456.createCommentVNode)("v-if", true),
                (0, import_vue456.renderSlot)(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["wrap-class", "view-class", "class"]), [
              [import_vue456.vShow, _ctx.options.size > 0 && !_ctx.loading]
            ]),
            _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? ((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)(import_vue456.Fragment, { key: 0 }, [
              _ctx.$slots.empty ? (0, import_vue456.renderSlot)(_ctx.$slots, "empty", { key: 0 }) : ((0, import_vue456.openBlock)(), (0, import_vue456.createElementBlock)("p", {
                key: 1,
                class: (0, import_vue456.normalizeClass)(_ctx.nsSelect.be("dropdown", "empty"))
              }, (0, import_vue456.toDisplayString)(_ctx.emptyText), 3))
            ], 64)) : (0, import_vue456.createCommentVNode)("v-if", true)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "effect", "transition", "persistent", "onShow"])
  ], 34)), [
    [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
  ]);
}
var Select = /* @__PURE__ */ _export_sfc(_sfc_main96, [["render", _sfc_render31], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/src/option-group.mjs
var import_vue457 = require("vue");
var _sfc_main97 = (0, import_vue457.defineComponent)({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const ns2 = useNamespace("select");
    const visible = (0, import_vue457.ref)(true);
    const instance = (0, import_vue457.getCurrentInstance)();
    const children = (0, import_vue457.ref)([]);
    (0, import_vue457.provide)(selectGroupKey, (0, import_vue457.reactive)({
      ...(0, import_vue457.toRefs)(props)
    }));
    const select = (0, import_vue457.inject)(selectKey);
    (0, import_vue457.onMounted)(() => {
      children.value = flattedChildren2(instance.subTree);
    });
    const flattedChildren2 = (node) => {
      const children2 = [];
      if (Array.isArray(node.children)) {
        node.children.forEach((child) => {
          var _a2;
          if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
            children2.push(child.component.proxy);
          } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
            children2.push(...flattedChildren2(child));
          }
        });
      }
      return children2;
    };
    const { groupQueryChange } = (0, import_vue457.toRaw)(select);
    (0, import_vue457.watch)(groupQueryChange, () => {
      visible.value = children.value.some((option2) => option2.visible === true);
    }, { flush: "post" });
    return {
      visible,
      ns: ns2
    };
  }
});
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue457.withDirectives)(((0, import_vue457.openBlock)(), (0, import_vue457.createElementBlock)("ul", {
    class: (0, import_vue457.normalizeClass)(_ctx.ns.be("group", "wrap"))
  }, [
    (0, import_vue457.createElementVNode)("li", {
      class: (0, import_vue457.normalizeClass)(_ctx.ns.be("group", "title"))
    }, (0, import_vue457.toDisplayString)(_ctx.label), 3),
    (0, import_vue457.createElementVNode)("li", null, [
      (0, import_vue457.createElementVNode)("ul", {
        class: (0, import_vue457.normalizeClass)(_ctx.ns.b("group"))
      }, [
        (0, import_vue457.renderSlot)(_ctx.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [import_vue457.vShow, _ctx.visible]
  ]);
}
var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main97, [["render", _sfc_render32], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select/index.mjs
var ElSelect = withInstall(Select, {
  Option,
  OptionGroup
});
var ElOption = withNoopInstall(Option);
var ElOptionGroup = withNoopInstall(OptionGroup);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/usePagination.mjs
var import_vue458 = require("vue");
var usePagination = () => (0, import_vue458.inject)(elPaginationKey, {});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/sizes.mjs
var paginationSizesProps = buildProps({
  pageSize: {
    type: Number,
    required: true
  },
  pageSizes: {
    type: definePropType(Array),
    default: () => mutable([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  size: {
    type: String,
    values: componentSizes
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/sizes2.mjs
var __default__62 = (0, import_vue459.defineComponent)({
  name: "ElPaginationSizes"
});
var _sfc_main98 = /* @__PURE__ */ (0, import_vue459.defineComponent)({
  ...__default__62,
  props: paginationSizesProps,
  emits: ["page-size-change"],
  setup(__props, { emit }) {
    const props = __props;
    const { t } = useLocale();
    const ns2 = useNamespace("pagination");
    const pagination = usePagination();
    const innerPageSize = (0, import_vue459.ref)(props.pageSize);
    (0, import_vue459.watch)(() => props.pageSizes, (newVal, oldVal) => {
      if (isEqual_default(newVal, oldVal))
        return;
      if (Array.isArray(newVal)) {
        const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
        emit("page-size-change", pageSize);
      }
    });
    (0, import_vue459.watch)(() => props.pageSize, (newVal) => {
      innerPageSize.value = newVal;
    });
    const innerPageSizes = (0, import_vue459.computed)(() => props.pageSizes);
    function handleChange(val) {
      var _a2;
      if (val !== innerPageSize.value) {
        innerPageSize.value = val;
        (_a2 = pagination.handleSizeChange) == null ? void 0 : _a2.call(pagination, Number(val));
      }
    }
    return (_ctx, _cache) => {
      return (0, import_vue459.openBlock)(), (0, import_vue459.createElementBlock)("span", {
        class: (0, import_vue459.normalizeClass)((0, import_vue459.unref)(ns2).e("sizes"))
      }, [
        (0, import_vue459.createVNode)((0, import_vue459.unref)(ElSelect), {
          "model-value": innerPageSize.value,
          disabled: _ctx.disabled,
          "popper-class": _ctx.popperClass,
          size: _ctx.size,
          "validate-event": false,
          onChange: handleChange
        }, {
          default: (0, import_vue459.withCtx)(() => [
            ((0, import_vue459.openBlock)(true), (0, import_vue459.createElementBlock)(import_vue459.Fragment, null, (0, import_vue459.renderList)((0, import_vue459.unref)(innerPageSizes), (item) => {
              return (0, import_vue459.openBlock)(), (0, import_vue459.createBlock)((0, import_vue459.unref)(ElOption), {
                key: item,
                value: item,
                label: item + (0, import_vue459.unref)(t)("el.pagination.pagesize")
              }, null, 8, ["value", "label"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["model-value", "disabled", "popper-class", "size"])
      ], 2);
    };
  }
});
var Sizes = /* @__PURE__ */ _export_sfc(_sfc_main98, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/jumper2.mjs
var import_vue460 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/jumper.mjs
var paginationJumperProps = buildProps({
  size: {
    type: String,
    values: componentSizes
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/jumper2.mjs
var _hoisted_164 = ["disabled"];
var __default__63 = (0, import_vue460.defineComponent)({
  name: "ElPaginationJumper"
});
var _sfc_main99 = /* @__PURE__ */ (0, import_vue460.defineComponent)({
  ...__default__63,
  props: paginationJumperProps,
  setup(__props) {
    const { t } = useLocale();
    const ns2 = useNamespace("pagination");
    const { pageCount, disabled, currentPage, changeEvent } = usePagination();
    const userInput = (0, import_vue460.ref)();
    const innerValue = (0, import_vue460.computed)(() => {
      var _a2;
      return (_a2 = userInput.value) != null ? _a2 : currentPage == null ? void 0 : currentPage.value;
    });
    function handleInput(val) {
      userInput.value = +val;
    }
    function handleChange(val) {
      val = Math.trunc(+val);
      changeEvent == null ? void 0 : changeEvent(+val);
      userInput.value = void 0;
    }
    return (_ctx, _cache) => {
      return (0, import_vue460.openBlock)(), (0, import_vue460.createElementBlock)("span", {
        class: (0, import_vue460.normalizeClass)((0, import_vue460.unref)(ns2).e("jump")),
        disabled: (0, import_vue460.unref)(disabled)
      }, [
        (0, import_vue460.createElementVNode)("span", {
          class: (0, import_vue460.normalizeClass)([(0, import_vue460.unref)(ns2).e("goto")])
        }, (0, import_vue460.toDisplayString)((0, import_vue460.unref)(t)("el.pagination.goto")), 3),
        (0, import_vue460.createVNode)((0, import_vue460.unref)(ElInput), {
          size: _ctx.size,
          class: (0, import_vue460.normalizeClass)([(0, import_vue460.unref)(ns2).e("editor"), (0, import_vue460.unref)(ns2).is("in-pagination")]),
          min: 1,
          max: (0, import_vue460.unref)(pageCount),
          disabled: (0, import_vue460.unref)(disabled),
          "model-value": (0, import_vue460.unref)(innerValue),
          "validate-event": false,
          type: "number",
          "onUpdate:modelValue": handleInput,
          onChange: handleChange
        }, null, 8, ["size", "class", "max", "disabled", "model-value"]),
        (0, import_vue460.createElementVNode)("span", {
          class: (0, import_vue460.normalizeClass)([(0, import_vue460.unref)(ns2).e("classifier")])
        }, (0, import_vue460.toDisplayString)((0, import_vue460.unref)(t)("el.pagination.pageClassifier")), 3)
      ], 10, _hoisted_164);
    };
  }
});
var Jumper = /* @__PURE__ */ _export_sfc(_sfc_main99, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/total2.mjs
var import_vue461 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/total.mjs
var paginationTotalProps = buildProps({
  total: {
    type: Number,
    default: 1e3
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/total2.mjs
var _hoisted_165 = ["disabled"];
var __default__64 = (0, import_vue461.defineComponent)({
  name: "ElPaginationTotal"
});
var _sfc_main100 = /* @__PURE__ */ (0, import_vue461.defineComponent)({
  ...__default__64,
  props: paginationTotalProps,
  setup(__props) {
    const { t } = useLocale();
    const ns2 = useNamespace("pagination");
    const { disabled } = usePagination();
    return (_ctx, _cache) => {
      return (0, import_vue461.openBlock)(), (0, import_vue461.createElementBlock)("span", {
        class: (0, import_vue461.normalizeClass)((0, import_vue461.unref)(ns2).e("total")),
        disabled: (0, import_vue461.unref)(disabled)
      }, (0, import_vue461.toDisplayString)((0, import_vue461.unref)(t)("el.pagination.total", {
        total: _ctx.total
      })), 11, _hoisted_165);
    };
  }
});
var Total = /* @__PURE__ */ _export_sfc(_sfc_main100, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/pager2.mjs
var import_vue462 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/pager.mjs
var paginationPagerProps = buildProps({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: true
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/components/pager2.mjs
var _hoisted_166 = ["onKeyup"];
var _hoisted_239 = ["aria-current", "tabindex"];
var _hoisted_319 = ["tabindex"];
var _hoisted_48 = ["aria-current", "tabindex"];
var _hoisted_54 = ["tabindex"];
var _hoisted_62 = ["aria-current", "tabindex"];
var __default__65 = (0, import_vue462.defineComponent)({
  name: "ElPaginationPager"
});
var _sfc_main101 = /* @__PURE__ */ (0, import_vue462.defineComponent)({
  ...__default__65,
  props: paginationPagerProps,
  emits: ["change"],
  setup(__props, { emit }) {
    const props = __props;
    const nsPager = useNamespace("pager");
    const nsIcon = useNamespace("icon");
    const showPrevMore = (0, import_vue462.ref)(false);
    const showNextMore = (0, import_vue462.ref)(false);
    const quickPrevHover = (0, import_vue462.ref)(false);
    const quickNextHover = (0, import_vue462.ref)(false);
    const quickPrevFocus = (0, import_vue462.ref)(false);
    const quickNextFocus = (0, import_vue462.ref)(false);
    const pagers = (0, import_vue462.computed)(() => {
      const pagerCount = props.pagerCount;
      const halfPagerCount = (pagerCount - 1) / 2;
      const currentPage = Number(props.currentPage);
      const pageCount = Number(props.pageCount);
      let showPrevMore2 = false;
      let showNextMore2 = false;
      if (pageCount > pagerCount) {
        if (currentPage > pagerCount - halfPagerCount) {
          showPrevMore2 = true;
        }
        if (currentPage < pageCount - halfPagerCount) {
          showNextMore2 = true;
        }
      }
      const array4 = [];
      if (showPrevMore2 && !showNextMore2) {
        const startPage = pageCount - (pagerCount - 2);
        for (let i = startPage; i < pageCount; i++) {
          array4.push(i);
        }
      } else if (!showPrevMore2 && showNextMore2) {
        for (let i = 2; i < pagerCount; i++) {
          array4.push(i);
        }
      } else if (showPrevMore2 && showNextMore2) {
        const offset2 = Math.floor(pagerCount / 2) - 1;
        for (let i = currentPage - offset2; i <= currentPage + offset2; i++) {
          array4.push(i);
        }
      } else {
        for (let i = 2; i < pageCount; i++) {
          array4.push(i);
        }
      }
      return array4;
    });
    const tabindex = (0, import_vue462.computed)(() => props.disabled ? -1 : 0);
    (0, import_vue462.watchEffect)(() => {
      const halfPagerCount = (props.pagerCount - 1) / 2;
      showPrevMore.value = false;
      showNextMore.value = false;
      if (props.pageCount > props.pagerCount) {
        if (props.currentPage > props.pagerCount - halfPagerCount) {
          showPrevMore.value = true;
        }
        if (props.currentPage < props.pageCount - halfPagerCount) {
          showNextMore.value = true;
        }
      }
    });
    function onMouseEnter(forward = false) {
      if (props.disabled)
        return;
      if (forward) {
        quickPrevHover.value = true;
      } else {
        quickNextHover.value = true;
      }
    }
    function onFocus(forward = false) {
      if (forward) {
        quickPrevFocus.value = true;
      } else {
        quickNextFocus.value = true;
      }
    }
    function onEnter(e) {
      const target = e.target;
      if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
        const newPage = Number(target.textContent);
        if (newPage !== props.currentPage) {
          emit("change", newPage);
        }
      } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
        onPagerClick(e);
      }
    }
    function onPagerClick(event) {
      const target = event.target;
      if (target.tagName.toLowerCase() === "ul" || props.disabled) {
        return;
      }
      let newPage = Number(target.textContent);
      const pageCount = props.pageCount;
      const currentPage = props.currentPage;
      const pagerCountOffset = props.pagerCount - 2;
      if (target.className.includes("more")) {
        if (target.className.includes("quickprev")) {
          newPage = currentPage - pagerCountOffset;
        } else if (target.className.includes("quicknext")) {
          newPage = currentPage + pagerCountOffset;
        }
      }
      if (!Number.isNaN(+newPage)) {
        if (newPage < 1) {
          newPage = 1;
        }
        if (newPage > pageCount) {
          newPage = pageCount;
        }
      }
      if (newPage !== currentPage) {
        emit("change", newPage);
      }
    }
    return (_ctx, _cache) => {
      return (0, import_vue462.openBlock)(), (0, import_vue462.createElementBlock)("ul", {
        class: (0, import_vue462.normalizeClass)((0, import_vue462.unref)(nsPager).b()),
        onClick: onPagerClick,
        onKeyup: (0, import_vue462.withKeys)(onEnter, ["enter"])
      }, [
        _ctx.pageCount > 0 ? ((0, import_vue462.openBlock)(), (0, import_vue462.createElementBlock)("li", {
          key: 0,
          class: (0, import_vue462.normalizeClass)([[
            (0, import_vue462.unref)(nsPager).is("active", _ctx.currentPage === 1),
            (0, import_vue462.unref)(nsPager).is("disabled", _ctx.disabled)
          ], "number"]),
          "aria-current": _ctx.currentPage === 1,
          tabindex: (0, import_vue462.unref)(tabindex)
        }, " 1 ", 10, _hoisted_239)) : (0, import_vue462.createCommentVNode)("v-if", true),
        showPrevMore.value ? ((0, import_vue462.openBlock)(), (0, import_vue462.createElementBlock)("li", {
          key: 1,
          class: (0, import_vue462.normalizeClass)([
            "more",
            "btn-quickprev",
            (0, import_vue462.unref)(nsIcon).b(),
            (0, import_vue462.unref)(nsPager).is("disabled", _ctx.disabled)
          ]),
          tabindex: (0, import_vue462.unref)(tabindex),
          onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
          onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
          onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
          onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
        }, [
          (quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? ((0, import_vue462.openBlock)(), (0, import_vue462.createBlock)((0, import_vue462.unref)(d_arrow_left_default), { key: 0 })) : ((0, import_vue462.openBlock)(), (0, import_vue462.createBlock)((0, import_vue462.unref)(more_filled_default), { key: 1 }))
        ], 42, _hoisted_319)) : (0, import_vue462.createCommentVNode)("v-if", true),
        ((0, import_vue462.openBlock)(true), (0, import_vue462.createElementBlock)(import_vue462.Fragment, null, (0, import_vue462.renderList)((0, import_vue462.unref)(pagers), (pager) => {
          return (0, import_vue462.openBlock)(), (0, import_vue462.createElementBlock)("li", {
            key: pager,
            class: (0, import_vue462.normalizeClass)([[
              (0, import_vue462.unref)(nsPager).is("active", _ctx.currentPage === pager),
              (0, import_vue462.unref)(nsPager).is("disabled", _ctx.disabled)
            ], "number"]),
            "aria-current": _ctx.currentPage === pager,
            tabindex: (0, import_vue462.unref)(tabindex)
          }, (0, import_vue462.toDisplayString)(pager), 11, _hoisted_48);
        }), 128)),
        showNextMore.value ? ((0, import_vue462.openBlock)(), (0, import_vue462.createElementBlock)("li", {
          key: 2,
          class: (0, import_vue462.normalizeClass)([
            "more",
            "btn-quicknext",
            (0, import_vue462.unref)(nsIcon).b(),
            (0, import_vue462.unref)(nsPager).is("disabled", _ctx.disabled)
          ]),
          tabindex: (0, import_vue462.unref)(tabindex),
          onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
          onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
          onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
          onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
        }, [
          (quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? ((0, import_vue462.openBlock)(), (0, import_vue462.createBlock)((0, import_vue462.unref)(d_arrow_right_default), { key: 0 })) : ((0, import_vue462.openBlock)(), (0, import_vue462.createBlock)((0, import_vue462.unref)(more_filled_default), { key: 1 }))
        ], 42, _hoisted_54)) : (0, import_vue462.createCommentVNode)("v-if", true),
        _ctx.pageCount > 1 ? ((0, import_vue462.openBlock)(), (0, import_vue462.createElementBlock)("li", {
          key: 3,
          class: (0, import_vue462.normalizeClass)([[
            (0, import_vue462.unref)(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
            (0, import_vue462.unref)(nsPager).is("disabled", _ctx.disabled)
          ], "number"]),
          "aria-current": _ctx.currentPage === _ctx.pageCount,
          tabindex: (0, import_vue462.unref)(tabindex)
        }, (0, import_vue462.toDisplayString)(_ctx.pageCount), 11, _hoisted_62)) : (0, import_vue462.createCommentVNode)("v-if", true)
      ], 42, _hoisted_166);
    };
  }
});
var Pager = /* @__PURE__ */ _export_sfc(_sfc_main101, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/src/pagination.mjs
var isAbsent = (v3) => typeof v3 !== "number";
var paginationProps = buildProps({
  total: Number,
  pageSize: Number,
  defaultPageSize: Number,
  currentPage: Number,
  defaultCurrentPage: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (value) => {
      return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
    },
    default: 7
  },
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: definePropType(Array),
    default: () => mutable([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: iconPropType,
    default: () => arrow_left_default
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: iconPropType,
    default: () => arrow_right_default
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
});
var paginationEmits = {
  "update:current-page": (val) => isNumber(val),
  "update:page-size": (val) => isNumber(val),
  "size-change": (val) => isNumber(val),
  "current-change": (val) => isNumber(val),
  "prev-click": (val) => isNumber(val),
  "next-click": (val) => isNumber(val)
};
var componentName = "ElPagination";
var Pagination = (0, import_vue463.defineComponent)({
  name: componentName,
  props: paginationProps,
  emits: paginationEmits,
  setup(props, { emit, slots }) {
    const { t } = useLocale();
    const ns2 = useNamespace("pagination");
    const vnodeProps = (0, import_vue463.getCurrentInstance)().vnode.props || {};
    const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
    const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
    const assertValidUsage = (0, import_vue463.computed)(() => {
      if (isAbsent(props.total) && isAbsent(props.pageCount))
        return false;
      if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
        return false;
      if (props.layout.includes("sizes")) {
        if (!isAbsent(props.pageCount)) {
          if (!hasPageSizeListener)
            return false;
        } else if (!isAbsent(props.total)) {
          if (!isAbsent(props.pageSize)) {
            if (!hasPageSizeListener) {
              return false;
            }
          } else {
          }
        }
      }
      return true;
    });
    const innerPageSize = (0, import_vue463.ref)(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
    const innerCurrentPage = (0, import_vue463.ref)(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
    const pageSizeBridge = (0, import_vue463.computed)({
      get() {
        return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
      },
      set(v3) {
        if (isAbsent(props.pageSize)) {
          innerPageSize.value = v3;
        }
        if (hasPageSizeListener) {
          emit("update:page-size", v3);
          emit("size-change", v3);
        }
      }
    });
    const pageCountBridge = (0, import_vue463.computed)(() => {
      let pageCount = 0;
      if (!isAbsent(props.pageCount)) {
        pageCount = props.pageCount;
      } else if (!isAbsent(props.total)) {
        pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
      }
      return pageCount;
    });
    const currentPageBridge = (0, import_vue463.computed)({
      get() {
        return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
      },
      set(v3) {
        let newCurrentPage = v3;
        if (v3 < 1) {
          newCurrentPage = 1;
        } else if (v3 > pageCountBridge.value) {
          newCurrentPage = pageCountBridge.value;
        }
        if (isAbsent(props.currentPage)) {
          innerCurrentPage.value = newCurrentPage;
        }
        if (hasCurrentPageListener) {
          emit("update:current-page", newCurrentPage);
          emit("current-change", newCurrentPage);
        }
      }
    });
    (0, import_vue463.watch)(pageCountBridge, (val) => {
      if (currentPageBridge.value > val)
        currentPageBridge.value = val;
    });
    function handleCurrentChange2(val) {
      currentPageBridge.value = val;
    }
    function handleSizeChange(val) {
      pageSizeBridge.value = val;
      const newPageCount = pageCountBridge.value;
      if (currentPageBridge.value > newPageCount) {
        currentPageBridge.value = newPageCount;
      }
    }
    function prev() {
      if (props.disabled)
        return;
      currentPageBridge.value -= 1;
      emit("prev-click", currentPageBridge.value);
    }
    function next() {
      if (props.disabled)
        return;
      currentPageBridge.value += 1;
      emit("next-click", currentPageBridge.value);
    }
    function addClass2(element, cls) {
      if (element) {
        if (!element.props) {
          element.props = {};
        }
        element.props.class = [element.props.class, cls].join(" ");
      }
    }
    (0, import_vue463.provide)(elPaginationKey, {
      pageCount: pageCountBridge,
      disabled: (0, import_vue463.computed)(() => props.disabled),
      currentPage: currentPageBridge,
      changeEvent: handleCurrentChange2,
      handleSizeChange
    });
    return () => {
      var _a2, _b;
      if (!assertValidUsage.value) {
        debugWarn(componentName, t("el.pagination.deprecationWarning"));
        return null;
      }
      if (!props.layout)
        return null;
      if (props.hideOnSinglePage && pageCountBridge.value <= 1)
        return null;
      const rootChildren = [];
      const rightWrapperChildren = [];
      const rightWrapperRoot = (0, import_vue463.h)("div", { class: ns2.e("rightwrapper") }, rightWrapperChildren);
      const TEMPLATE_MAP = {
        prev: (0, import_vue463.h)(Prev, {
          disabled: props.disabled,
          currentPage: currentPageBridge.value,
          prevText: props.prevText,
          prevIcon: props.prevIcon,
          onClick: prev
        }),
        jumper: (0, import_vue463.h)(Jumper, {
          size: props.small ? "small" : "default"
        }),
        pager: (0, import_vue463.h)(Pager, {
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          pagerCount: props.pagerCount,
          onChange: handleCurrentChange2,
          disabled: props.disabled
        }),
        next: (0, import_vue463.h)(Next, {
          disabled: props.disabled,
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          nextText: props.nextText,
          nextIcon: props.nextIcon,
          onClick: next
        }),
        sizes: (0, import_vue463.h)(Sizes, {
          pageSize: pageSizeBridge.value,
          pageSizes: props.pageSizes,
          popperClass: props.popperClass,
          disabled: props.disabled,
          size: props.small ? "small" : "default"
        }),
        slot: (_b = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : null,
        total: (0, import_vue463.h)(Total, { total: isAbsent(props.total) ? 0 : props.total })
      };
      const components = props.layout.split(",").map((item) => item.trim());
      let haveRightWrapper = false;
      components.forEach((c2) => {
        if (c2 === "->") {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) {
          rootChildren.push(TEMPLATE_MAP[c2]);
        } else {
          rightWrapperChildren.push(TEMPLATE_MAP[c2]);
        }
      });
      addClass2(rootChildren[0], ns2.is("first"));
      addClass2(rootChildren[rootChildren.length - 1], ns2.is("last"));
      if (haveRightWrapper && rightWrapperChildren.length > 0) {
        addClass2(rightWrapperChildren[0], ns2.is("first"));
        addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns2.is("last"));
        rootChildren.push(rightWrapperRoot);
      }
      return (0, import_vue463.h)("div", {
        role: "pagination",
        "aria-label": "pagination",
        class: [
          ns2.b(),
          ns2.is("background", props.background),
          {
            [ns2.m("small")]: props.small
          }
        ]
      }, rootChildren);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/pagination/index.mjs
var ElPagination = withInstall(Pagination);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popconfirm/src/popconfirm2.mjs
var import_vue464 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popconfirm/src/popconfirm.mjs
var popconfirmProps = buildProps({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: buttonTypes,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: buttonTypes,
    default: "text"
  },
  icon: {
    type: iconPropType,
    default: () => question_filled_default
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: false
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  onConfirm: {
    type: definePropType(Function)
  },
  onCancel: {
    type: definePropType(Function)
  },
  teleported: useTooltipContentProps.teleported,
  persistent: useTooltipContentProps.persistent,
  width: {
    type: [String, Number],
    default: 150
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popconfirm/src/popconfirm2.mjs
var __default__66 = (0, import_vue464.defineComponent)({
  name: "ElPopconfirm"
});
var _sfc_main102 = /* @__PURE__ */ (0, import_vue464.defineComponent)({
  ...__default__66,
  props: popconfirmProps,
  setup(__props) {
    const props = __props;
    const { t } = useLocale();
    const ns2 = useNamespace("popconfirm");
    const tooltipRef = (0, import_vue464.ref)();
    const hidePopper = () => {
      var _a2, _b;
      (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.onClose) == null ? void 0 : _b.call(_a2);
    };
    const style = (0, import_vue464.computed)(() => {
      return {
        width: addUnit(props.width)
      };
    });
    const confirm = (e) => {
      var _a2;
      (_a2 = props.onConfirm) == null ? void 0 : _a2.call(props, e);
      hidePopper();
    };
    const cancel = (e) => {
      var _a2;
      (_a2 = props.onCancel) == null ? void 0 : _a2.call(props, e);
      hidePopper();
    };
    const finalConfirmButtonText = (0, import_vue464.computed)(() => props.confirmButtonText || t("el.popconfirm.confirmButtonText"));
    const finalCancelButtonText = (0, import_vue464.computed)(() => props.cancelButtonText || t("el.popconfirm.cancelButtonText"));
    return (_ctx, _cache) => {
      return (0, import_vue464.openBlock)(), (0, import_vue464.createBlock)((0, import_vue464.unref)(ElTooltip), (0, import_vue464.mergeProps)({
        ref_key: "tooltipRef",
        ref: tooltipRef,
        trigger: "click",
        effect: "light"
      }, _ctx.$attrs, {
        "popper-class": `${(0, import_vue464.unref)(ns2).namespace.value}-popover`,
        "popper-style": (0, import_vue464.unref)(style),
        teleported: _ctx.teleported,
        "fallback-placements": ["bottom", "top", "right", "left"],
        "hide-after": _ctx.hideAfter,
        persistent: _ctx.persistent
      }), {
        content: (0, import_vue464.withCtx)(() => [
          (0, import_vue464.createElementVNode)("div", {
            class: (0, import_vue464.normalizeClass)((0, import_vue464.unref)(ns2).b())
          }, [
            (0, import_vue464.createElementVNode)("div", {
              class: (0, import_vue464.normalizeClass)((0, import_vue464.unref)(ns2).e("main"))
            }, [
              !_ctx.hideIcon && _ctx.icon ? ((0, import_vue464.openBlock)(), (0, import_vue464.createBlock)((0, import_vue464.unref)(ElIcon), {
                key: 0,
                class: (0, import_vue464.normalizeClass)((0, import_vue464.unref)(ns2).e("icon")),
                style: (0, import_vue464.normalizeStyle)({ color: _ctx.iconColor })
              }, {
                default: (0, import_vue464.withCtx)(() => [
                  ((0, import_vue464.openBlock)(), (0, import_vue464.createBlock)((0, import_vue464.resolveDynamicComponent)(_ctx.icon)))
                ]),
                _: 1
              }, 8, ["class", "style"])) : (0, import_vue464.createCommentVNode)("v-if", true),
              (0, import_vue464.createTextVNode)(" " + (0, import_vue464.toDisplayString)(_ctx.title), 1)
            ], 2),
            (0, import_vue464.createElementVNode)("div", {
              class: (0, import_vue464.normalizeClass)((0, import_vue464.unref)(ns2).e("action"))
            }, [
              (0, import_vue464.createVNode)((0, import_vue464.unref)(ElButton), {
                size: "small",
                type: _ctx.cancelButtonType === "text" ? "" : _ctx.cancelButtonType,
                text: _ctx.cancelButtonType === "text",
                onClick: cancel
              }, {
                default: (0, import_vue464.withCtx)(() => [
                  (0, import_vue464.createTextVNode)((0, import_vue464.toDisplayString)((0, import_vue464.unref)(finalCancelButtonText)), 1)
                ]),
                _: 1
              }, 8, ["type", "text"]),
              (0, import_vue464.createVNode)((0, import_vue464.unref)(ElButton), {
                size: "small",
                type: _ctx.confirmButtonType === "text" ? "" : _ctx.confirmButtonType,
                text: _ctx.confirmButtonType === "text",
                onClick: confirm
              }, {
                default: (0, import_vue464.withCtx)(() => [
                  (0, import_vue464.createTextVNode)((0, import_vue464.toDisplayString)((0, import_vue464.unref)(finalConfirmButtonText)), 1)
                ]),
                _: 1
              }, 8, ["type", "text"])
            ], 2)
          ], 2)
        ]),
        default: (0, import_vue464.withCtx)(() => [
          _ctx.$slots.reference ? (0, import_vue464.renderSlot)(_ctx.$slots, "reference", { key: 0 }) : (0, import_vue464.createCommentVNode)("v-if", true)
        ]),
        _: 3
      }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]);
    };
  }
});
var Popconfirm = /* @__PURE__ */ _export_sfc(_sfc_main102, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popconfirm/index.mjs
var ElPopconfirm = withInstall(Popconfirm);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popover/src/popover2.mjs
var import_vue465 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popover/src/popover.mjs
var popoverProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  placement: dropdownProps.placement,
  disabled: useTooltipTriggerProps.disabled,
  visible: useTooltipContentProps.visible,
  transition: useTooltipContentProps.transition,
  popperOptions: dropdownProps.popperOptions,
  tabindex: dropdownProps.tabindex,
  content: useTooltipContentProps.content,
  popperStyle: useTooltipContentProps.popperStyle,
  popperClass: useTooltipContentProps.popperClass,
  enterable: {
    ...useTooltipContentProps.enterable,
    default: true
  },
  effect: {
    ...useTooltipContentProps.effect,
    default: "light"
  },
  teleported: useTooltipContentProps.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  },
  "onUpdate:visible": {
    type: Function
  }
});
var popoverEmits = {
  "update:visible": (value) => isBoolean(value),
  "before-enter": () => true,
  "before-leave": () => true,
  "after-enter": () => true,
  "after-leave": () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popover/src/popover2.mjs
var updateEventKeyRaw = `onUpdate:visible`;
var __default__67 = (0, import_vue465.defineComponent)({
  name: "ElPopover"
});
var _sfc_main103 = /* @__PURE__ */ (0, import_vue465.defineComponent)({
  ...__default__67,
  props: popoverProps,
  emits: popoverEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const onUpdateVisible = (0, import_vue465.computed)(() => {
      return props[updateEventKeyRaw];
    });
    const ns2 = useNamespace("popover");
    const tooltipRef = (0, import_vue465.ref)();
    const popperRef = (0, import_vue465.computed)(() => {
      var _a2;
      return (_a2 = (0, import_vue465.unref)(tooltipRef)) == null ? void 0 : _a2.popperRef;
    });
    const style = (0, import_vue465.computed)(() => {
      return [
        {
          width: addUnit(props.width)
        },
        props.popperStyle
      ];
    });
    const kls = (0, import_vue465.computed)(() => {
      return [ns2.b(), props.popperClass, { [ns2.m("plain")]: !!props.content }];
    });
    const gpuAcceleration = (0, import_vue465.computed)(() => {
      return props.transition === `${ns2.namespace.value}-fade-in-linear`;
    });
    const hide2 = () => {
      var _a2;
      (_a2 = tooltipRef.value) == null ? void 0 : _a2.hide();
    };
    const beforeEnter = () => {
      emit("before-enter");
    };
    const beforeLeave = () => {
      emit("before-leave");
    };
    const afterEnter = () => {
      emit("after-enter");
    };
    const afterLeave = () => {
      emit("update:visible", false);
      emit("after-leave");
    };
    expose({
      popperRef,
      hide: hide2
    });
    return (_ctx, _cache) => {
      return (0, import_vue465.openBlock)(), (0, import_vue465.createBlock)((0, import_vue465.unref)(ElTooltip), (0, import_vue465.mergeProps)({
        ref_key: "tooltipRef",
        ref: tooltipRef
      }, _ctx.$attrs, {
        trigger: _ctx.trigger,
        placement: _ctx.placement,
        disabled: _ctx.disabled,
        visible: _ctx.visible,
        transition: _ctx.transition,
        "popper-options": _ctx.popperOptions,
        tabindex: _ctx.tabindex,
        content: _ctx.content,
        offset: _ctx.offset,
        "show-after": _ctx.showAfter,
        "hide-after": _ctx.hideAfter,
        "auto-close": _ctx.autoClose,
        "show-arrow": _ctx.showArrow,
        "aria-label": _ctx.title,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "popper-class": (0, import_vue465.unref)(kls),
        "popper-style": (0, import_vue465.unref)(style),
        teleported: _ctx.teleported,
        persistent: _ctx.persistent,
        "gpu-acceleration": (0, import_vue465.unref)(gpuAcceleration),
        "onUpdate:visible": (0, import_vue465.unref)(onUpdateVisible),
        onBeforeShow: beforeEnter,
        onBeforeHide: beforeLeave,
        onShow: afterEnter,
        onHide: afterLeave
      }), {
        content: (0, import_vue465.withCtx)(() => [
          _ctx.title ? ((0, import_vue465.openBlock)(), (0, import_vue465.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue465.normalizeClass)((0, import_vue465.unref)(ns2).e("title")),
            role: "title"
          }, (0, import_vue465.toDisplayString)(_ctx.title), 3)) : (0, import_vue465.createCommentVNode)("v-if", true),
          (0, import_vue465.renderSlot)(_ctx.$slots, "default", {}, () => [
            (0, import_vue465.createTextVNode)((0, import_vue465.toDisplayString)(_ctx.content), 1)
          ])
        ]),
        default: (0, import_vue465.withCtx)(() => [
          _ctx.$slots.reference ? (0, import_vue465.renderSlot)(_ctx.$slots, "reference", { key: 0 }) : (0, import_vue465.createCommentVNode)("v-if", true)
        ]),
        _: 3
      }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]);
    };
  }
});
var Popover = /* @__PURE__ */ _export_sfc(_sfc_main103, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popover/src/directive.mjs
var attachEvents = (el, binding) => {
  const popperComponent = binding.arg || binding.value;
  const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
  if (popover) {
    popover.triggerRef = el;
  }
};
var PopoverDirective = {
  mounted(el, binding) {
    attachEvents(el, binding);
  },
  updated(el, binding) {
    attachEvents(el, binding);
  }
};
var VPopover = "popover";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/popover/index.mjs
var ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
var ElPopover = withInstall(Popover, {
  directive: ElPopoverDirective
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/progress/src/progress2.mjs
var import_vue466 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/progress/src/progress.mjs
var progressProps = buildProps({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (val) => val >= 0 && val <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: definePropType(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: true
  },
  color: {
    type: definePropType([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  format: {
    type: definePropType(Function),
    default: (percentage) => `${percentage}%`
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/progress/src/progress2.mjs
var import_shared69 = require("@vue/shared");
var _hoisted_167 = ["aria-valuenow"];
var _hoisted_240 = { viewBox: "0 0 100 100" };
var _hoisted_320 = ["d", "stroke", "stroke-width"];
var _hoisted_49 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
var _hoisted_55 = { key: 0 };
var __default__68 = (0, import_vue466.defineComponent)({
  name: "ElProgress"
});
var _sfc_main104 = /* @__PURE__ */ (0, import_vue466.defineComponent)({
  ...__default__68,
  props: progressProps,
  setup(__props) {
    const props = __props;
    const STATUS_COLOR_MAP = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    };
    const ns2 = useNamespace("progress");
    const barStyle = (0, import_vue466.computed)(() => ({
      width: `${props.percentage}%`,
      animationDuration: `${props.duration}s`,
      backgroundColor: getCurrentColor(props.percentage)
    }));
    const relativeStrokeWidth = (0, import_vue466.computed)(() => (props.strokeWidth / props.width * 100).toFixed(1));
    const radius = (0, import_vue466.computed)(() => {
      if (["circle", "dashboard"].includes(props.type)) {
        return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
      }
      return 0;
    });
    const trackPath = (0, import_vue466.computed)(() => {
      const r = radius.value;
      const isDashboard = props.type === "dashboard";
      return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
    });
    const perimeter = (0, import_vue466.computed)(() => 2 * Math.PI * radius.value);
    const rate = (0, import_vue466.computed)(() => props.type === "dashboard" ? 0.75 : 1);
    const strokeDashoffset = (0, import_vue466.computed)(() => {
      const offset2 = -1 * perimeter.value * (1 - rate.value) / 2;
      return `${offset2}px`;
    });
    const trailPathStyle = (0, import_vue466.computed)(() => ({
      strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value
    }));
    const circlePathStyle = (0, import_vue466.computed)(() => ({
      strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    }));
    const stroke = (0, import_vue466.computed)(() => {
      let ret;
      if (props.color) {
        ret = getCurrentColor(props.percentage);
      } else {
        ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
      }
      return ret;
    });
    const statusIcon = (0, import_vue466.computed)(() => {
      if (props.status === "warning") {
        return warning_filled_default;
      }
      if (props.type === "line") {
        return props.status === "success" ? circle_check_default : circle_close_default;
      } else {
        return props.status === "success" ? check_default : close_default;
      }
    });
    const progressTextSize = (0, import_vue466.computed)(() => {
      return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
    });
    const content = (0, import_vue466.computed)(() => props.format(props.percentage));
    function getColors(color) {
      const span = 100 / color.length;
      const seriesColors = color.map((seriesColor, index2) => {
        if ((0, import_shared69.isString)(seriesColor)) {
          return {
            color: seriesColor,
            percentage: (index2 + 1) * span
          };
        }
        return seriesColor;
      });
      return seriesColors.sort((a3, b3) => a3.percentage - b3.percentage);
    }
    const getCurrentColor = (percentage) => {
      var _a2;
      const { color } = props;
      if ((0, import_shared69.isFunction)(color)) {
        return color(percentage);
      } else if ((0, import_shared69.isString)(color)) {
        return color;
      } else {
        const colors = getColors(color);
        for (const color2 of colors) {
          if (color2.percentage > percentage)
            return color2.color;
        }
        return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
      }
    };
    return (_ctx, _cache) => {
      return (0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("div", {
        class: (0, import_vue466.normalizeClass)([
          (0, import_vue466.unref)(ns2).b(),
          (0, import_vue466.unref)(ns2).m(_ctx.type),
          (0, import_vue466.unref)(ns2).is(_ctx.status),
          {
            [(0, import_vue466.unref)(ns2).m("without-text")]: !_ctx.showText,
            [(0, import_vue466.unref)(ns2).m("text-inside")]: _ctx.textInside
          }
        ]),
        role: "progressbar",
        "aria-valuenow": _ctx.percentage,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
      }, [
        _ctx.type === "line" ? ((0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).b("bar"))
        }, [
          (0, import_vue466.createElementVNode)("div", {
            class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).be("bar", "outer")),
            style: (0, import_vue466.normalizeStyle)({ height: `${_ctx.strokeWidth}px` })
          }, [
            (0, import_vue466.createElementVNode)("div", {
              class: (0, import_vue466.normalizeClass)([
                (0, import_vue466.unref)(ns2).be("bar", "inner"),
                { [(0, import_vue466.unref)(ns2).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate }
              ]),
              style: (0, import_vue466.normalizeStyle)((0, import_vue466.unref)(barStyle))
            }, [
              (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? ((0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("div", {
                key: 0,
                class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).be("bar", "innerText"))
              }, [
                (0, import_vue466.renderSlot)(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  (0, import_vue466.createElementVNode)("span", null, (0, import_vue466.toDisplayString)((0, import_vue466.unref)(content)), 1)
                ])
              ], 2)) : (0, import_vue466.createCommentVNode)("v-if", true)
            ], 6)
          ], 6)
        ], 2)) : ((0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).b("circle")),
          style: (0, import_vue466.normalizeStyle)({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
        }, [
          ((0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("svg", _hoisted_240, [
            (0, import_vue466.createElementVNode)("path", {
              class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).be("circle", "track")),
              d: (0, import_vue466.unref)(trackPath),
              stroke: `var(${(0, import_vue466.unref)(ns2).cssVarName("fill-color-light")}, #e5e9f2)`,
              "stroke-width": (0, import_vue466.unref)(relativeStrokeWidth),
              fill: "none",
              style: (0, import_vue466.normalizeStyle)((0, import_vue466.unref)(trailPathStyle))
            }, null, 14, _hoisted_320),
            (0, import_vue466.createElementVNode)("path", {
              class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).be("circle", "path")),
              d: (0, import_vue466.unref)(trackPath),
              stroke: (0, import_vue466.unref)(stroke),
              fill: "none",
              opacity: _ctx.percentage ? 1 : 0,
              "stroke-linecap": _ctx.strokeLinecap,
              "stroke-width": (0, import_vue466.unref)(relativeStrokeWidth),
              style: (0, import_vue466.normalizeStyle)((0, import_vue466.unref)(circlePathStyle))
            }, null, 14, _hoisted_49)
          ]))
        ], 6)),
        (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? ((0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("div", {
          key: 2,
          class: (0, import_vue466.normalizeClass)((0, import_vue466.unref)(ns2).e("text")),
          style: (0, import_vue466.normalizeStyle)({ fontSize: `${(0, import_vue466.unref)(progressTextSize)}px` })
        }, [
          (0, import_vue466.renderSlot)(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
            !_ctx.status ? ((0, import_vue466.openBlock)(), (0, import_vue466.createElementBlock)("span", _hoisted_55, (0, import_vue466.toDisplayString)((0, import_vue466.unref)(content)), 1)) : ((0, import_vue466.openBlock)(), (0, import_vue466.createBlock)((0, import_vue466.unref)(ElIcon), { key: 1 }, {
              default: (0, import_vue466.withCtx)(() => [
                ((0, import_vue466.openBlock)(), (0, import_vue466.createBlock)((0, import_vue466.resolveDynamicComponent)((0, import_vue466.unref)(statusIcon))))
              ]),
              _: 1
            }))
          ])
        ], 6)) : (0, import_vue466.createCommentVNode)("v-if", true)
      ], 10, _hoisted_167);
    };
  }
});
var Progress = /* @__PURE__ */ _export_sfc(_sfc_main104, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/progress/index.mjs
var ElProgress = withInstall(Progress);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/rate/src/rate2.mjs
var import_vue467 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/rate/src/rate.mjs
var rateProps = buildProps({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: definePropType([Array, Object]),
    default: () => mutable(["", "", ""])
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: definePropType([Array, Object]),
    default: () => [star_filled_default, star_filled_default, star_filled_default]
  },
  voidIcon: {
    type: iconPropType,
    default: () => star_default
  },
  disabledVoidIcon: {
    type: iconPropType,
    default: () => star_filled_default
  },
  disabled: {
    type: Boolean
  },
  allowHalf: {
    type: Boolean
  },
  showText: {
    type: Boolean
  },
  showScore: {
    type: Boolean
  },
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: definePropType(Array),
    default: () => mutable([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  label: {
    type: String,
    default: void 0
  },
  clearable: {
    type: Boolean,
    default: false
  }
});
var rateEmits = {
  [CHANGE_EVENT]: (value) => isNumber(value),
  [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/rate/src/rate2.mjs
var import_shared70 = require("@vue/shared");
var _hoisted_168 = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"];
var _hoisted_241 = ["onMousemove", "onClick"];
var __default__69 = (0, import_vue467.defineComponent)({
  name: "ElRate"
});
var _sfc_main105 = /* @__PURE__ */ (0, import_vue467.defineComponent)({
  ...__default__69,
  props: rateProps,
  emits: rateEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    function getValueFromMap(value, map2) {
      const isExcludedObject = (val) => (0, import_shared70.isObject)(val);
      const matchedKeys = Object.keys(map2).map((key) => +key).filter((key) => {
        const val = map2[key];
        const excluded = isExcludedObject(val) ? val.excluded : false;
        return excluded ? value < key : value <= key;
      }).sort((a3, b3) => a3 - b3);
      const matchedValue = map2[matchedKeys[0]];
      return isExcludedObject(matchedValue) && matchedValue.value || matchedValue;
    }
    const formContext = (0, import_vue467.inject)(formContextKey, void 0);
    const formItemContext = (0, import_vue467.inject)(formItemContextKey, void 0);
    const rateSize = useSize();
    const ns2 = useNamespace("rate");
    const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
      formItemContext
    });
    const currentValue = (0, import_vue467.ref)(props.modelValue);
    const hoverIndex = (0, import_vue467.ref)(-1);
    const pointerAtLeftHalf = (0, import_vue467.ref)(true);
    const rateClasses = (0, import_vue467.computed)(() => [ns2.b(), ns2.m(rateSize.value)]);
    const rateDisabled = (0, import_vue467.computed)(() => props.disabled || (formContext == null ? void 0 : formContext.disabled));
    const rateStyles = (0, import_vue467.computed)(() => {
      return ns2.cssVarBlock({
        "void-color": props.voidColor,
        "disabled-void-color": props.disabledVoidColor,
        "fill-color": activeColor.value
      });
    });
    const text = (0, import_vue467.computed)(() => {
      let result = "";
      if (props.showScore) {
        result = props.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props.modelValue}` : `${currentValue.value}`);
      } else if (props.showText) {
        result = props.texts[Math.ceil(currentValue.value) - 1];
      }
      return result;
    });
    const valueDecimal = (0, import_vue467.computed)(() => props.modelValue * 100 - Math.floor(props.modelValue) * 100);
    const colorMap = (0, import_vue467.computed)(() => (0, import_shared70.isArray)(props.colors) ? {
      [props.lowThreshold]: props.colors[0],
      [props.highThreshold]: { value: props.colors[1], excluded: true },
      [props.max]: props.colors[2]
    } : props.colors);
    const activeColor = (0, import_vue467.computed)(() => {
      const color = getValueFromMap(currentValue.value, colorMap.value);
      return (0, import_shared70.isObject)(color) ? "" : color;
    });
    const decimalStyle = (0, import_vue467.computed)(() => {
      let width = "";
      if (rateDisabled.value) {
        width = `${valueDecimal.value}%`;
      } else if (props.allowHalf) {
        width = "50%";
      }
      return {
        color: activeColor.value,
        width
      };
    });
    const componentMap = (0, import_vue467.computed)(() => {
      let icons = (0, import_shared70.isArray)(props.icons) ? [...props.icons] : { ...props.icons };
      icons = (0, import_vue467.markRaw)(icons);
      return (0, import_shared70.isArray)(icons) ? {
        [props.lowThreshold]: icons[0],
        [props.highThreshold]: {
          value: icons[1],
          excluded: true
        },
        [props.max]: icons[2]
      } : icons;
    });
    const decimalIconComponent = (0, import_vue467.computed)(() => getValueFromMap(props.modelValue, componentMap.value));
    const voidComponent = (0, import_vue467.computed)(() => rateDisabled.value ? (0, import_shared70.isString)(props.disabledVoidIcon) ? props.disabledVoidIcon : (0, import_vue467.markRaw)(props.disabledVoidIcon) : (0, import_shared70.isString)(props.voidIcon) ? props.voidIcon : (0, import_vue467.markRaw)(props.voidIcon));
    const activeComponent = (0, import_vue467.computed)(() => getValueFromMap(currentValue.value, componentMap.value));
    function showDecimalIcon(item) {
      const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props.modelValue && item > props.modelValue;
      const showWhenAllowHalf = props.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
      return showWhenDisabled || showWhenAllowHalf;
    }
    function emitValue(value) {
      if (props.clearable && value === props.modelValue) {
        value = 0;
      }
      emit(UPDATE_MODEL_EVENT, value);
      if (props.modelValue !== value) {
        emit("change", value);
      }
    }
    function selectValue(value) {
      if (rateDisabled.value) {
        return;
      }
      if (props.allowHalf && pointerAtLeftHalf.value) {
        emitValue(currentValue.value);
      } else {
        emitValue(value);
      }
    }
    function handleKey(e) {
      if (rateDisabled.value) {
        return;
      }
      let _currentValue = currentValue.value;
      const code = e.code;
      if (code === EVENT_CODE.up || code === EVENT_CODE.right) {
        if (props.allowHalf) {
          _currentValue += 0.5;
        } else {
          _currentValue += 1;
        }
        e.stopPropagation();
        e.preventDefault();
      } else if (code === EVENT_CODE.left || code === EVENT_CODE.down) {
        if (props.allowHalf) {
          _currentValue -= 0.5;
        } else {
          _currentValue -= 1;
        }
        e.stopPropagation();
        e.preventDefault();
      }
      _currentValue = _currentValue < 0 ? 0 : _currentValue;
      _currentValue = _currentValue > props.max ? props.max : _currentValue;
      emit(UPDATE_MODEL_EVENT, _currentValue);
      emit("change", _currentValue);
      return _currentValue;
    }
    function setCurrentValue(value, event) {
      if (rateDisabled.value) {
        return;
      }
      if (props.allowHalf) {
        let target = event.target;
        if (hasClass(target, ns2.e("item"))) {
          target = target.querySelector(`.${ns2.e("icon")}`);
        }
        if (target.clientWidth === 0 || hasClass(target, ns2.e("decimal"))) {
          target = target.parentNode;
        }
        pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
        currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
      } else {
        currentValue.value = value;
      }
      hoverIndex.value = value;
    }
    function resetCurrentValue() {
      if (rateDisabled.value) {
        return;
      }
      if (props.allowHalf) {
        pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
      }
      currentValue.value = props.modelValue;
      hoverIndex.value = -1;
    }
    (0, import_vue467.watch)(() => props.modelValue, (val) => {
      currentValue.value = val;
      pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
    });
    if (!props.modelValue) {
      emit(UPDATE_MODEL_EVENT, 0);
    }
    expose({
      setCurrentValue,
      resetCurrentValue
    });
    return (_ctx, _cache) => {
      var _a2;
      return (0, import_vue467.openBlock)(), (0, import_vue467.createElementBlock)("div", {
        id: (0, import_vue467.unref)(inputId),
        class: (0, import_vue467.normalizeClass)([(0, import_vue467.unref)(rateClasses), (0, import_vue467.unref)(ns2).is("disabled", (0, import_vue467.unref)(rateDisabled))]),
        role: "slider",
        "aria-label": !(0, import_vue467.unref)(isLabeledByFormItem) ? _ctx.label || "rating" : void 0,
        "aria-labelledby": (0, import_vue467.unref)(isLabeledByFormItem) ? (_a2 = (0, import_vue467.unref)(formItemContext)) == null ? void 0 : _a2.labelId : void 0,
        "aria-valuenow": currentValue.value,
        "aria-valuetext": (0, import_vue467.unref)(text) || void 0,
        "aria-valuemin": "0",
        "aria-valuemax": _ctx.max,
        tabindex: "0",
        style: (0, import_vue467.normalizeStyle)((0, import_vue467.unref)(rateStyles)),
        onKeydown: handleKey
      }, [
        ((0, import_vue467.openBlock)(true), (0, import_vue467.createElementBlock)(import_vue467.Fragment, null, (0, import_vue467.renderList)(_ctx.max, (item, key) => {
          return (0, import_vue467.openBlock)(), (0, import_vue467.createElementBlock)("span", {
            key,
            class: (0, import_vue467.normalizeClass)((0, import_vue467.unref)(ns2).e("item")),
            onMousemove: ($event) => setCurrentValue(item, $event),
            onMouseleave: resetCurrentValue,
            onClick: ($event) => selectValue(item)
          }, [
            (0, import_vue467.createVNode)((0, import_vue467.unref)(ElIcon), {
              class: (0, import_vue467.normalizeClass)([
                (0, import_vue467.unref)(ns2).e("icon"),
                { hover: hoverIndex.value === item },
                (0, import_vue467.unref)(ns2).is("active", item <= currentValue.value)
              ])
            }, {
              default: (0, import_vue467.withCtx)(() => [
                !showDecimalIcon(item) ? ((0, import_vue467.openBlock)(), (0, import_vue467.createElementBlock)(import_vue467.Fragment, { key: 0 }, [
                  (0, import_vue467.withDirectives)(((0, import_vue467.openBlock)(), (0, import_vue467.createBlock)((0, import_vue467.resolveDynamicComponent)((0, import_vue467.unref)(activeComponent)), null, null, 512)), [
                    [import_vue467.vShow, item <= currentValue.value]
                  ]),
                  (0, import_vue467.withDirectives)(((0, import_vue467.openBlock)(), (0, import_vue467.createBlock)((0, import_vue467.resolveDynamicComponent)((0, import_vue467.unref)(voidComponent)), null, null, 512)), [
                    [import_vue467.vShow, !(item <= currentValue.value)]
                  ])
                ], 64)) : (0, import_vue467.createCommentVNode)("v-if", true),
                showDecimalIcon(item) ? ((0, import_vue467.openBlock)(), (0, import_vue467.createBlock)((0, import_vue467.unref)(ElIcon), {
                  key: 1,
                  style: (0, import_vue467.normalizeStyle)((0, import_vue467.unref)(decimalStyle)),
                  class: (0, import_vue467.normalizeClass)([(0, import_vue467.unref)(ns2).e("icon"), (0, import_vue467.unref)(ns2).e("decimal")])
                }, {
                  default: (0, import_vue467.withCtx)(() => [
                    ((0, import_vue467.openBlock)(), (0, import_vue467.createBlock)((0, import_vue467.resolveDynamicComponent)((0, import_vue467.unref)(decimalIconComponent))))
                  ]),
                  _: 1
                }, 8, ["style", "class"])) : (0, import_vue467.createCommentVNode)("v-if", true)
              ]),
              _: 2
            }, 1032, ["class"])
          ], 42, _hoisted_241);
        }), 128)),
        _ctx.showText || _ctx.showScore ? ((0, import_vue467.openBlock)(), (0, import_vue467.createElementBlock)("span", {
          key: 0,
          class: (0, import_vue467.normalizeClass)((0, import_vue467.unref)(ns2).e("text"))
        }, (0, import_vue467.toDisplayString)((0, import_vue467.unref)(text)), 3)) : (0, import_vue467.createCommentVNode)("v-if", true)
      ], 46, _hoisted_168);
    };
  }
});
var Rate = /* @__PURE__ */ _export_sfc(_sfc_main105, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/rate/index.mjs
var ElRate = withInstall(Rate);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/result/src/result2.mjs
var import_vue468 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/result/src/result.mjs
var IconMap = {
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
};
var IconComponentMap = {
  [IconMap.success]: circle_check_filled_default,
  [IconMap.warning]: warning_filled_default,
  [IconMap.error]: circle_close_filled_default,
  [IconMap.info]: info_filled_default
};
var resultProps = buildProps({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["success", "warning", "info", "error"],
    default: "info"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/result/src/result2.mjs
var __default__70 = (0, import_vue468.defineComponent)({
  name: "ElResult"
});
var _sfc_main106 = /* @__PURE__ */ (0, import_vue468.defineComponent)({
  ...__default__70,
  props: resultProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("result");
    const resultIcon = (0, import_vue468.computed)(() => {
      const icon = props.icon;
      const iconClass = icon && IconMap[icon] ? IconMap[icon] : "icon-info";
      const iconComponent = IconComponentMap[iconClass] || IconComponentMap["icon-info"];
      return {
        class: iconClass,
        component: iconComponent
      };
    });
    return (_ctx, _cache) => {
      return (0, import_vue468.openBlock)(), (0, import_vue468.createElementBlock)("div", {
        class: (0, import_vue468.normalizeClass)((0, import_vue468.unref)(ns2).b())
      }, [
        (0, import_vue468.createElementVNode)("div", {
          class: (0, import_vue468.normalizeClass)((0, import_vue468.unref)(ns2).e("icon"))
        }, [
          (0, import_vue468.renderSlot)(_ctx.$slots, "icon", {}, () => [
            (0, import_vue468.unref)(resultIcon).component ? ((0, import_vue468.openBlock)(), (0, import_vue468.createBlock)((0, import_vue468.resolveDynamicComponent)((0, import_vue468.unref)(resultIcon).component), {
              key: 0,
              class: (0, import_vue468.normalizeClass)((0, import_vue468.unref)(resultIcon).class)
            }, null, 8, ["class"])) : (0, import_vue468.createCommentVNode)("v-if", true)
          ])
        ], 2),
        _ctx.title || _ctx.$slots.title ? ((0, import_vue468.openBlock)(), (0, import_vue468.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue468.normalizeClass)((0, import_vue468.unref)(ns2).e("title"))
        }, [
          (0, import_vue468.renderSlot)(_ctx.$slots, "title", {}, () => [
            (0, import_vue468.createElementVNode)("p", null, (0, import_vue468.toDisplayString)(_ctx.title), 1)
          ])
        ], 2)) : (0, import_vue468.createCommentVNode)("v-if", true),
        _ctx.subTitle || _ctx.$slots["sub-title"] ? ((0, import_vue468.openBlock)(), (0, import_vue468.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue468.normalizeClass)((0, import_vue468.unref)(ns2).e("subtitle"))
        }, [
          (0, import_vue468.renderSlot)(_ctx.$slots, "sub-title", {}, () => [
            (0, import_vue468.createElementVNode)("p", null, (0, import_vue468.toDisplayString)(_ctx.subTitle), 1)
          ])
        ], 2)) : (0, import_vue468.createCommentVNode)("v-if", true),
        _ctx.$slots.extra ? ((0, import_vue468.openBlock)(), (0, import_vue468.createElementBlock)("div", {
          key: 2,
          class: (0, import_vue468.normalizeClass)((0, import_vue468.unref)(ns2).e("extra"))
        }, [
          (0, import_vue468.renderSlot)(_ctx.$slots, "extra")
        ], 2)) : (0, import_vue468.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var Result = /* @__PURE__ */ _export_sfc(_sfc_main106, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/result/index.mjs
var ElResult = withInstall(Result);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/row/src/row2.mjs
var import_vue469 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/row/src/row.mjs
var RowJustify = [
  "start",
  "center",
  "end",
  "space-around",
  "space-between",
  "space-evenly"
];
var RowAlign = ["top", "middle", "bottom"];
var rowProps = buildProps({
  tag: {
    type: String,
    default: "div"
  },
  gutter: {
    type: Number,
    default: 0
  },
  justify: {
    type: String,
    values: RowJustify,
    default: "start"
  },
  align: {
    type: String,
    values: RowAlign,
    default: "top"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/row/src/row2.mjs
var __default__71 = (0, import_vue469.defineComponent)({
  name: "ElRow"
});
var _sfc_main107 = /* @__PURE__ */ (0, import_vue469.defineComponent)({
  ...__default__71,
  props: rowProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("row");
    const gutter = (0, import_vue469.computed)(() => props.gutter);
    (0, import_vue469.provide)(rowContextKey, {
      gutter
    });
    const style = (0, import_vue469.computed)(() => {
      const styles = {};
      if (!props.gutter) {
        return styles;
      }
      styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
      return styles;
    });
    const rowKls = (0, import_vue469.computed)(() => [
      ns2.b(),
      ns2.is(`justify-${props.justify}`, props.justify !== "start"),
      ns2.is(`align-${props.align}`, props.align !== "top")
    ]);
    return (_ctx, _cache) => {
      return (0, import_vue469.openBlock)(), (0, import_vue469.createBlock)((0, import_vue469.resolveDynamicComponent)(_ctx.tag), {
        class: (0, import_vue469.normalizeClass)((0, import_vue469.unref)(rowKls)),
        style: (0, import_vue469.normalizeStyle)((0, import_vue469.unref)(style))
      }, {
        default: (0, import_vue469.withCtx)(() => [
          (0, import_vue469.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]);
    };
  }
});
var Row = /* @__PURE__ */ _export_sfc(_sfc_main107, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/row/index.mjs
var ElRow = withInstall(Row);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/select.mjs
var import_vue480 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/select-dropdown.mjs
var import_vue476 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/builders/build-list.mjs
var import_vue472 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/hooks/use-cache.mjs
var import_vue470 = require("vue");

// ../../node_modules/.pnpm/memoize-one@6.0.0/node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual2(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual2(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual3) {
  if (isEqual3 === void 0) {
    isEqual3 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual3(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/hooks/use-cache.mjs
var useCache = () => {
  const vm = (0, import_vue470.getCurrentInstance)();
  const props = vm.proxy.$props;
  return (0, import_vue470.computed)(() => {
    const _getItemStyleCache = (_2, __, ___) => ({});
    return props.perfMode ? memoize_default(_getItemStyleCache) : memoizeOne(_getItemStyleCache);
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/defaults.mjs
var DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
var ITEM_RENDER_EVT = "itemRendered";
var SCROLL_EVT = "scroll";
var FORWARD = "forward";
var BACKWARD = "backward";
var AUTO_ALIGNMENT = "auto";
var SMART_ALIGNMENT = "smart";
var START_ALIGNMENT = "start";
var CENTERED_ALIGNMENT = "center";
var END_ALIGNMENT = "end";
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LTR = "ltr";
var RTL = "rtl";
var RTL_OFFSET_NAG = "negative";
var RTL_OFFSET_POS_ASC = "positive-ascending";
var RTL_OFFSET_POS_DESC = "positive-descending";
var PageKey = {
  [HORIZONTAL]: "pageX",
  [VERTICAL]: "pageY"
};
var ScrollbarSizeKey = {
  [HORIZONTAL]: "height",
  [VERTICAL]: "width"
};
var ScrollbarDirKey = {
  [HORIZONTAL]: "left",
  [VERTICAL]: "top"
};
var SCROLLBAR_MIN_SIZE = 20;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/hooks/use-wheel.mjs
var LayoutKeys = {
  [HORIZONTAL]: "deltaX",
  [VERTICAL]: "deltaY"
};
var useWheel = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
  let frameHandle;
  let offset2 = 0;
  const hasReachedEdge = (offset22) => {
    const edgeReached = offset22 < 0 && atStartEdge.value || offset22 > 0 && atEndEdge.value;
    return edgeReached;
  };
  const onWheel = (e) => {
    cAF(frameHandle);
    const newOffset = e[LayoutKeys[layout2.value]];
    if (hasReachedEdge(offset2) && hasReachedEdge(offset2 + newOffset))
      return;
    offset2 += newOffset;
    if (!isFirefox()) {
      e.preventDefault();
    }
    frameHandle = rAF(() => {
      onWheelDelta(offset2);
      offset2 = 0;
    });
  };
  return {
    hasReachedEdge,
    onWheel
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/components/scrollbar.mjs
var import_vue471 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/props.mjs
var itemSize = buildProp({
  type: definePropType([Number, Function]),
  required: true
});
var estimatedItemSize = buildProp({
  type: Number
});
var cache = buildProp({
  type: Number,
  default: 2
});
var direction = buildProp({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
});
var initScrollOffset = buildProp({
  type: Number,
  default: 0
});
var total = buildProp({
  type: Number,
  required: true
});
var layout = buildProp({
  type: String,
  values: ["horizontal", "vertical"],
  default: VERTICAL
});
var virtualizedProps = buildProps({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: definePropType([String, Object]),
    default: "div"
  },
  data: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  direction,
  height: {
    type: [String, Number],
    required: true
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: definePropType([Object, String, Array])
  },
  useIsScrolling: {
    type: Boolean,
    default: false
  },
  width: {
    type: [Number, String],
    required: false
  },
  perfMode: {
    type: Boolean,
    default: true
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  }
});
var virtualizedListProps = buildProps({
  cache,
  estimatedItemSize,
  layout,
  initScrollOffset,
  total,
  itemSize,
  ...virtualizedProps
});
var scrollbarSize = {
  type: Number,
  default: 6
};
var startGap = { type: Number, default: 0 };
var endGap = { type: Number, default: 2 };
var virtualizedGridProps = buildProps({
  columnCache: cache,
  columnWidth: itemSize,
  estimatedColumnWidth: estimatedItemSize,
  estimatedRowHeight: estimatedItemSize,
  initScrollLeft: initScrollOffset,
  initScrollTop: initScrollOffset,
  itemKey: {
    type: definePropType(Function),
    default: ({
      columnIndex,
      rowIndex
    }) => `${rowIndex}:${columnIndex}`
  },
  rowCache: cache,
  rowHeight: itemSize,
  totalColumn: total,
  totalRow: total,
  hScrollbarSize: scrollbarSize,
  vScrollbarSize: scrollbarSize,
  scrollbarStartGap: startGap,
  scrollbarEndGap: endGap,
  ...virtualizedProps
});
var virtualizedScrollbarProps = buildProps({
  alwaysOn: Boolean,
  class: String,
  layout,
  total,
  ratio: {
    type: Number,
    required: true
  },
  clientSize: {
    type: Number,
    required: true
  },
  scrollFrom: {
    type: Number,
    required: true
  },
  scrollbarSize,
  startGap,
  endGap,
  visible: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/utils.mjs
var getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
var isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
var isRTL = (dir) => dir === RTL;
var cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
  if (cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = RTL_OFFSET_POS_DESC;
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = RTL_OFFSET_NAG;
      } else {
        cachedRTLResult = RTL_OFFSET_POS_ASC;
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
function renderThumbStyle2({ move, size: size2, bar }, layout2) {
  const style = {};
  const translate2 = `translate${bar.axis}(${move}px)`;
  style[bar.size] = size2;
  style.transform = translate2;
  style.msTransform = translate2;
  style.webkitTransform = translate2;
  if (layout2 === "horizontal") {
    style.height = "100%";
  } else {
    style.width = "100%";
  }
  return style;
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/components/scrollbar.mjs
var ScrollBar = (0, import_vue471.defineComponent)({
  name: "ElVirtualScrollBar",
  props: virtualizedScrollbarProps,
  emits: ["scroll", "start-move", "stop-move"],
  setup(props, { emit }) {
    const GAP2 = (0, import_vue471.computed)(() => props.startGap + props.endGap);
    const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
    const nsScrollbar = useNamespace("scrollbar");
    const trackRef = (0, import_vue471.ref)();
    const thumbRef = (0, import_vue471.ref)();
    let frameHandle = null;
    let onselectstartStore = null;
    const state = (0, import_vue471.reactive)({
      isDragging: false,
      traveled: 0
    });
    const bar = (0, import_vue471.computed)(() => BAR_MAP[props.layout]);
    const trackSize = (0, import_vue471.computed)(() => props.clientSize - (0, import_vue471.unref)(GAP2));
    const trackStyle = (0, import_vue471.computed)(() => ({
      position: "absolute",
      width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,
      height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,
      [ScrollbarDirKey[props.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    }));
    const thumbSize = (0, import_vue471.computed)(() => {
      const ratio = props.ratio;
      const clientSize = props.clientSize;
      if (ratio >= 100) {
        return Number.POSITIVE_INFINITY;
      }
      if (ratio >= 50) {
        return ratio * clientSize / 100;
      }
      const SCROLLBAR_MAX_SIZE = clientSize / 3;
      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
    });
    const thumbStyle = (0, import_vue471.computed)(() => {
      if (!Number.isFinite(thumbSize.value)) {
        return {
          display: "none"
        };
      }
      const thumb = `${thumbSize.value}px`;
      const style = renderThumbStyle2({
        bar: bar.value,
        size: thumb,
        move: state.traveled
      }, props.layout);
      return style;
    });
    const totalSteps = (0, import_vue471.computed)(() => Math.floor(props.clientSize - thumbSize.value - (0, import_vue471.unref)(GAP2)));
    const attachEvents2 = () => {
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      const thumbEl = (0, import_vue471.unref)(thumbRef);
      if (!thumbEl)
        return;
      onselectstartStore = document.onselectstart;
      document.onselectstart = () => false;
      thumbEl.addEventListener("touchmove", onMouseMove);
      thumbEl.addEventListener("touchend", onMouseUp);
    };
    const detachEvents = () => {
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
      document.onselectstart = onselectstartStore;
      onselectstartStore = null;
      const thumbEl = (0, import_vue471.unref)(thumbRef);
      if (!thumbEl)
        return;
      thumbEl.removeEventListener("touchmove", onMouseMove);
      thumbEl.removeEventListener("touchend", onMouseUp);
    };
    const onThumbMouseDown = (e) => {
      e.stopImmediatePropagation();
      if (e.ctrlKey || [1, 2].includes(e.button)) {
        return;
      }
      state.isDragging = true;
      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
      emit("start-move");
      attachEvents2();
    };
    const onMouseUp = () => {
      state.isDragging = false;
      state[bar.value.axis] = 0;
      emit("stop-move");
      detachEvents();
    };
    const onMouseMove = (e) => {
      const { isDragging: isDragging2 } = state;
      if (!isDragging2)
        return;
      if (!thumbRef.value || !trackRef.value)
        return;
      const prevPage = state[bar.value.axis];
      if (!prevPage)
        return;
      cAF(frameHandle);
      const offset2 = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
      const distance = offset2 - thumbClickPosition;
      frameHandle = rAF(() => {
        state.traveled = Math.max(props.startGap, Math.min(distance, totalSteps.value));
        emit("scroll", distance, totalSteps.value);
      });
    };
    const clickTrackHandler = (e) => {
      const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumbRef.value[bar.value.offset] / 2;
      const distance = offset2 - thumbHalf;
      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
      emit("scroll", distance, totalSteps.value);
    };
    (0, import_vue471.watch)(() => props.scrollFrom, (v3) => {
      if (state.isDragging)
        return;
      state.traveled = Math.ceil(v3 * totalSteps.value);
    });
    (0, import_vue471.onBeforeUnmount)(() => {
      detachEvents();
    });
    return () => {
      return (0, import_vue471.h)("div", {
        role: "presentation",
        ref: trackRef,
        class: [
          nsVirtualScrollbar.b(),
          props.class,
          (props.alwaysOn || state.isDragging) && "always-on"
        ],
        style: trackStyle.value,
        onMousedown: (0, import_vue471.withModifiers)(clickTrackHandler, ["stop", "prevent"]),
        onTouchstartPrevent: onThumbMouseDown
      }, (0, import_vue471.h)("div", {
        ref: thumbRef,
        class: nsScrollbar.e("thumb"),
        style: thumbStyle.value,
        onMousedown: onThumbMouseDown
      }, []));
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/builders/build-list.mjs
var import_shared71 = require("@vue/shared");
var createList = ({
  name,
  getOffset: getOffset3,
  getItemSize,
  getItemOffset,
  getEstimatedTotalSize: getEstimatedTotalSize2,
  getStartIndexForOffset,
  getStopIndexForStartIndex,
  initCache,
  clearCache,
  validateProps
}) => {
  return (0, import_vue472.defineComponent)({
    name: name != null ? name : "ElVirtualList",
    props: virtualizedListProps,
    emits: [ITEM_RENDER_EVT, SCROLL_EVT],
    setup(props, { emit, expose }) {
      validateProps(props);
      const instance = (0, import_vue472.getCurrentInstance)();
      const ns2 = useNamespace("vl");
      const dynamicSizeCache = (0, import_vue472.ref)(initCache(props, instance));
      const getItemStyleCache = useCache();
      const windowRef = (0, import_vue472.ref)();
      const innerRef = (0, import_vue472.ref)();
      const scrollbarRef = (0, import_vue472.ref)();
      const states = (0, import_vue472.ref)({
        isScrolling: false,
        scrollDir: "forward",
        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,
        updateRequested: false,
        isScrollbarDragging: false,
        scrollbarAlwaysOn: props.scrollbarAlwaysOn
      });
      const itemsToRender = (0, import_vue472.computed)(() => {
        const { total: total2, cache: cache2 } = props;
        const { isScrolling, scrollDir, scrollOffset } = (0, import_vue472.unref)(states);
        if (total2 === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getStartIndexForOffset(props, scrollOffset, (0, import_vue472.unref)(dynamicSizeCache));
        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, (0, import_vue472.unref)(dynamicSizeCache));
        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const estimatedTotalSize = (0, import_vue472.computed)(() => getEstimatedTotalSize2(props, (0, import_vue472.unref)(dynamicSizeCache)));
      const _isHorizontal = (0, import_vue472.computed)(() => isHorizontal(props.layout));
      const windowStyle = (0, import_vue472.computed)(() => [
        {
          position: "relative",
          [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: props.direction,
          height: isNumber(props.height) ? `${props.height}px` : props.height,
          width: isNumber(props.width) ? `${props.width}px` : props.width
        },
        props.style
      ]);
      const innerStyle = (0, import_vue472.computed)(() => {
        const size2 = (0, import_vue472.unref)(estimatedTotalSize);
        const horizontal = (0, import_vue472.unref)(_isHorizontal);
        return {
          height: horizontal ? "100%" : `${size2}px`,
          pointerEvents: (0, import_vue472.unref)(states).isScrolling ? "none" : void 0,
          width: horizontal ? `${size2}px` : "100%"
        };
      });
      const clientSize = (0, import_vue472.computed)(() => _isHorizontal.value ? props.width : props.height);
      const { onWheel } = useWheel({
        atStartEdge: (0, import_vue472.computed)(() => states.value.scrollOffset <= 0),
        atEndEdge: (0, import_vue472.computed)(() => states.value.scrollOffset >= estimatedTotalSize.value),
        layout: (0, import_vue472.computed)(() => props.layout)
      }, (offset2) => {
        var _a2, _b;
        ;
        (_b = (_a2 = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a2);
        scrollTo(Math.min(states.value.scrollOffset + offset2, estimatedTotalSize.value - clientSize.value));
      });
      const emitEvents = () => {
        const { total: total2 } = props;
        if (total2 > 0) {
          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = (0, import_vue472.unref)(itemsToRender);
          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
        }
        const { scrollDir, scrollOffset, updateRequested } = (0, import_vue472.unref)(states);
        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
      };
      const scrollVertically = (e) => {
        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;
        const _states = (0, import_vue472.unref)(states);
        if (_states.scrollOffset === scrollTop) {
          return;
        }
        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
        states.value = {
          ..._states,
          isScrolling: true,
          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
          scrollOffset,
          updateRequested: false
        };
        (0, import_vue472.nextTick)(resetIsScrolling);
      };
      const scrollHorizontally = (e) => {
        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;
        const _states = (0, import_vue472.unref)(states);
        if (_states.scrollOffset === scrollLeft) {
          return;
        }
        const { direction: direction2 } = props;
        let scrollOffset = scrollLeft;
        if (direction2 === RTL) {
          switch (getRTLOffsetType()) {
            case RTL_OFFSET_NAG: {
              scrollOffset = -scrollLeft;
              break;
            }
            case RTL_OFFSET_POS_DESC: {
              scrollOffset = scrollWidth - clientWidth - scrollLeft;
              break;
            }
          }
        }
        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
        states.value = {
          ..._states,
          isScrolling: true,
          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
          scrollOffset,
          updateRequested: false
        };
        (0, import_vue472.nextTick)(resetIsScrolling);
      };
      const onScroll = (e) => {
        (0, import_vue472.unref)(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
        emitEvents();
      };
      const onScrollbarScroll = (distanceToGo, totalSteps) => {
        const offset2 = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset2));
      };
      const scrollTo = (offset2) => {
        offset2 = Math.max(offset2, 0);
        if (offset2 === (0, import_vue472.unref)(states).scrollOffset) {
          return;
        }
        states.value = {
          ...(0, import_vue472.unref)(states),
          scrollOffset: offset2,
          scrollDir: getScrollDir((0, import_vue472.unref)(states).scrollOffset, offset2),
          updateRequested: true
        };
        (0, import_vue472.nextTick)(resetIsScrolling);
      };
      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
        const { scrollOffset } = (0, import_vue472.unref)(states);
        idx = Math.max(0, Math.min(idx, props.total - 1));
        scrollTo(getOffset3(props, idx, alignment, scrollOffset, (0, import_vue472.unref)(dynamicSizeCache)));
      };
      const getItemStyle = (idx) => {
        const { direction: direction2, itemSize: itemSize3, layout: layout2 } = props;
        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize3, clearCache && layout2, clearCache && direction2);
        let style;
        if ((0, import_shared71.hasOwn)(itemStyleCache, String(idx))) {
          style = itemStyleCache[idx];
        } else {
          const offset2 = getItemOffset(props, idx, (0, import_vue472.unref)(dynamicSizeCache));
          const size2 = getItemSize(props, idx, (0, import_vue472.unref)(dynamicSizeCache));
          const horizontal = (0, import_vue472.unref)(_isHorizontal);
          const isRtl = direction2 === RTL;
          const offsetHorizontal = horizontal ? offset2 : 0;
          itemStyleCache[idx] = style = {
            position: "absolute",
            left: isRtl ? void 0 : `${offsetHorizontal}px`,
            right: isRtl ? `${offsetHorizontal}px` : void 0,
            top: !horizontal ? `${offset2}px` : 0,
            height: !horizontal ? `${size2}px` : "100%",
            width: horizontal ? `${size2}px` : "100%"
          };
        }
        return style;
      };
      const resetIsScrolling = () => {
        states.value.isScrolling = false;
        (0, import_vue472.nextTick)(() => {
          getItemStyleCache.value(-1, null, null);
        });
      };
      const resetScrollTop = () => {
        const window2 = windowRef.value;
        if (window2) {
          window2.scrollTop = 0;
        }
      };
      (0, import_vue472.onMounted)(() => {
        if (!isClient)
          return;
        const { initScrollOffset: initScrollOffset2 } = props;
        const windowElement = (0, import_vue472.unref)(windowRef);
        if (isNumber(initScrollOffset2) && windowElement) {
          if ((0, import_vue472.unref)(_isHorizontal)) {
            windowElement.scrollLeft = initScrollOffset2;
          } else {
            windowElement.scrollTop = initScrollOffset2;
          }
        }
        emitEvents();
      });
      (0, import_vue472.onUpdated)(() => {
        const { direction: direction2, layout: layout2 } = props;
        const { scrollOffset, updateRequested } = (0, import_vue472.unref)(states);
        const windowElement = (0, import_vue472.unref)(windowRef);
        if (updateRequested && windowElement) {
          if (layout2 === HORIZONTAL) {
            if (direction2 === RTL) {
              switch (getRTLOffsetType()) {
                case RTL_OFFSET_NAG: {
                  windowElement.scrollLeft = -scrollOffset;
                  break;
                }
                case RTL_OFFSET_POS_ASC: {
                  windowElement.scrollLeft = scrollOffset;
                  break;
                }
                default: {
                  const { clientWidth, scrollWidth } = windowElement;
                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                  break;
                }
              }
            } else {
              windowElement.scrollLeft = scrollOffset;
            }
          } else {
            windowElement.scrollTop = scrollOffset;
          }
        }
      });
      const api = {
        ns: ns2,
        clientSize,
        estimatedTotalSize,
        windowStyle,
        windowRef,
        innerRef,
        innerStyle,
        itemsToRender,
        scrollbarRef,
        states,
        getItemStyle,
        onScroll,
        onScrollbarScroll,
        onWheel,
        scrollTo,
        scrollToItem,
        resetScrollTop
      };
      expose({
        windowRef,
        innerRef,
        getItemStyleCache,
        scrollTo,
        scrollToItem,
        resetScrollTop,
        states
      });
      return api;
    },
    render(ctx) {
      var _a2;
      const {
        $slots,
        className,
        clientSize,
        containerElement,
        data,
        getItemStyle,
        innerElement,
        itemsToRender,
        innerStyle,
        layout: layout2,
        total: total2,
        onScroll,
        onScrollbarScroll,
        onWheel,
        states,
        useIsScrolling,
        windowStyle,
        ns: ns2
      } = ctx;
      const [start, end2] = itemsToRender;
      const Container2 = (0, import_vue472.resolveDynamicComponent)(containerElement);
      const Inner = (0, import_vue472.resolveDynamicComponent)(innerElement);
      const children = [];
      if (total2 > 0) {
        for (let i = start; i <= end2; i++) {
          children.push((_a2 = $slots.default) == null ? void 0 : _a2.call($slots, {
            data,
            key: i,
            index: i,
            isScrolling: useIsScrolling ? states.isScrolling : void 0,
            style: getItemStyle(i)
          }));
        }
      }
      const InnerNode = [
        (0, import_vue472.h)(Inner, {
          style: innerStyle,
          ref: "innerRef"
        }, !(0, import_shared71.isString)(Inner) ? {
          default: () => children
        } : children)
      ];
      const scrollbar = (0, import_vue472.h)(ScrollBar, {
        ref: "scrollbarRef",
        clientSize,
        layout: layout2,
        onScroll: onScrollbarScroll,
        ratio: clientSize * 100 / this.estimatedTotalSize,
        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
        total: total2
      });
      const listContainer = (0, import_vue472.h)(Container2, {
        class: [ns2.e("window"), className],
        style: windowStyle,
        onScroll,
        onWheel,
        ref: "windowRef",
        key: 0
      }, !(0, import_shared71.isString)(Container2) ? { default: () => [InnerNode] } : [InnerNode]);
      return (0, import_vue472.h)("div", {
        key: 0,
        class: [ns2.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
      }, [listContainer, scrollbar]);
    }
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/components/fixed-size-list.mjs
var import_shared72 = require("@vue/shared");
var FixedSizeList = createList({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: itemSize3 }, index2) => index2 * itemSize3,
  getItemSize: ({ itemSize: itemSize3 }) => itemSize3,
  getEstimatedTotalSize: ({ total: total2, itemSize: itemSize3 }) => itemSize3 * total2,
  getOffset: ({ height, total: total2, itemSize: itemSize3, layout: layout2, width }, index2, alignment, scrollOffset) => {
    const size2 = isHorizontal(layout2) ? width : height;
    if (process.env.NODE_ENV !== "production" && (0, import_shared72.isString)(size2)) {
      throwError("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
    }
    const lastItemOffset = Math.max(0, total2 * itemSize3 - size2);
    const maxOffset = Math.min(lastItemOffset, index2 * itemSize3);
    const minOffset = Math.max(0, (index2 + 1) * itemSize3 - size2);
    if (alignment === SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT: {
        return maxOffset;
      }
      case END_ALIGNMENT: {
        return minOffset;
      }
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size2 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  },
  getStartIndexForOffset: ({ total: total2, itemSize: itemSize3 }, offset2) => Math.max(0, Math.min(total2 - 1, Math.floor(offset2 / itemSize3))),
  getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize3, layout: layout2, width }, startIndex, scrollOffset) => {
    const offset2 = startIndex * itemSize3;
    const size2 = isHorizontal(layout2) ? width : height;
    const numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize3);
    return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
  },
  initCache() {
    return void 0;
  },
  clearCache: true,
  validateProps() {
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/components/dynamic-size-list.mjs
var SCOPE4 = "ElDynamicSizeList";
var getItemFromCache = (props, index2, listCache) => {
  const { itemSize: itemSize3 } = props;
  const { items, lastVisitedIndex } = listCache;
  if (index2 > lastVisitedIndex) {
    let offset2 = 0;
    if (lastVisitedIndex >= 0) {
      const item = items[lastVisitedIndex];
      offset2 = item.offset + item.size;
    }
    for (let i = lastVisitedIndex + 1; i <= index2; i++) {
      const size2 = itemSize3(i);
      items[i] = {
        offset: offset2,
        size: size2
      };
      offset2 += size2;
    }
    listCache.lastVisitedIndex = index2;
  }
  return items[index2];
};
var findItem = (props, listCache, offset2) => {
  const { items, lastVisitedIndex } = listCache;
  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
  if (lastVisitedOffset >= offset2) {
    return bs(props, listCache, 0, lastVisitedIndex, offset2);
  }
  return es(props, listCache, Math.max(0, lastVisitedIndex), offset2);
};
var bs = (props, listCache, low, high, offset2) => {
  while (low <= high) {
    const mid = low + Math.floor((high - low) / 2);
    const currentOffset = getItemFromCache(props, mid, listCache).offset;
    if (currentOffset === offset2) {
      return mid;
    } else if (currentOffset < offset2) {
      low = mid + 1;
    } else if (currentOffset > offset2) {
      high = mid - 1;
    }
  }
  return Math.max(0, low - 1);
};
var es = (props, listCache, index2, offset2) => {
  const { total: total2 } = props;
  let exponent = 1;
  while (index2 < total2 && getItemFromCache(props, index2, listCache).offset < offset2) {
    index2 += exponent;
    exponent *= 2;
  }
  return bs(props, listCache, Math.floor(index2 / 2), Math.min(index2, total2 - 1), offset2);
};
var getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
  let totalSizeOfMeasuredItems = 0;
  if (lastVisitedIndex >= total2) {
    lastVisitedIndex = total2 - 1;
  }
  if (lastVisitedIndex >= 0) {
    const item = items[lastVisitedIndex];
    totalSizeOfMeasuredItems = item.offset + item.size;
  }
  const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
var DynamicSizeList = createList({
  name: "ElDynamicSizeList",
  getItemOffset: (props, index2, listCache) => getItemFromCache(props, index2, listCache).offset,
  getItemSize: (_2, index2, { items }) => items[index2].size,
  getEstimatedTotalSize,
  getOffset: (props, index2, alignment, scrollOffset, listCache) => {
    const { height, layout: layout2, width } = props;
    const size2 = isHorizontal(layout2) ? width : height;
    const item = getItemFromCache(props, index2, listCache);
    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);
    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, item.offset));
    const minOffset = Math.max(0, item.offset - size2 + item.size);
    if (alignment === SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT: {
        return maxOffset;
      }
      case END_ALIGNMENT: {
        return minOffset;
      }
      case CENTERED_ALIGNMENT: {
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      }
      case AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  },
  getStartIndexForOffset: (props, offset2, listCache) => findItem(props, listCache, offset2),
  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {
    const { height, total: total2, layout: layout2, width } = props;
    const size2 = isHorizontal(layout2) ? width : height;
    const item = getItemFromCache(props, startIndex, listCache);
    const maxOffset = scrollOffset + size2;
    let offset2 = item.offset + item.size;
    let stopIndex = startIndex;
    while (stopIndex < total2 - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemFromCache(props, stopIndex, listCache).size;
    }
    return stopIndex;
  },
  initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
    const cache2 = {
      items: {},
      estimatedItemSize: estimatedItemSize2,
      lastVisitedIndex: -1
    };
    cache2.clearCacheAfterIndex = (index2, forceUpdate = true) => {
      var _a2, _b;
      cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index2 - 1);
      (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache(-1);
      if (forceUpdate) {
        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
      }
    };
    return cache2;
  },
  clearCache: false,
  validateProps: ({ itemSize: itemSize3 }) => {
    if (process.env.NODE_ENV !== "production") {
      if (typeof itemSize3 !== "function") {
        throwError(SCOPE4, `
          itemSize is required as function, but the given value was ${typeof itemSize3}
        `);
      }
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/builders/build-grid.mjs
var import_vue473 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/hooks/use-grid-wheel.mjs
var useGridWheel = ({ atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }, onWheelDelta) => {
  let frameHandle = null;
  let xOffset = 0;
  let yOffset = 0;
  const hasReachedEdge = (x3, y2) => {
    const xEdgeReached = x3 < 0 && atXStartEdge.value || x3 > 0 && atXEndEdge.value;
    const yEdgeReached = y2 < 0 && atYStartEdge.value || y2 > 0 && atYEndEdge.value;
    return xEdgeReached && yEdgeReached;
  };
  const onWheel = (e) => {
    cAF(frameHandle);
    let x3 = e.deltaX;
    let y2 = e.deltaY;
    if (Math.abs(x3) > Math.abs(y2)) {
      y2 = 0;
    } else {
      x3 = 0;
    }
    if (e.shiftKey && y2 !== 0) {
      x3 = y2;
      y2 = 0;
    }
    if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x3, yOffset + y2))
      return;
    xOffset += x3;
    yOffset += y2;
    if (!isFirefox()) {
      e.preventDefault();
    }
    frameHandle = rAF(() => {
      onWheelDelta(xOffset, yOffset);
      xOffset = 0;
      yOffset = 0;
    });
  };
  return {
    hasReachedEdge,
    onWheel
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/builders/build-grid.mjs
var import_shared73 = require("@vue/shared");
var createGrid = ({
  name,
  clearCache,
  getColumnPosition,
  getColumnStartIndexForOffset,
  getColumnStopIndexForStartIndex,
  getEstimatedTotalHeight: getEstimatedTotalHeight2,
  getEstimatedTotalWidth: getEstimatedTotalWidth2,
  getColumnOffset,
  getRowOffset,
  getRowPosition,
  getRowStartIndexForOffset,
  getRowStopIndexForStartIndex,
  initCache,
  injectToInstance,
  validateProps
}) => {
  return (0, import_vue473.defineComponent)({
    name: name != null ? name : "ElVirtualList",
    props: virtualizedGridProps,
    emits: [ITEM_RENDER_EVT, SCROLL_EVT],
    setup(props, { emit, expose, slots }) {
      const ns2 = useNamespace("vl");
      validateProps(props);
      const instance = (0, import_vue473.getCurrentInstance)();
      const cache2 = (0, import_vue473.ref)(initCache(props, instance));
      injectToInstance == null ? void 0 : injectToInstance(instance, cache2);
      const windowRef = (0, import_vue473.ref)();
      const hScrollbar = (0, import_vue473.ref)();
      const vScrollbar = (0, import_vue473.ref)();
      const innerRef = (0, import_vue473.ref)(null);
      const states = (0, import_vue473.ref)({
        isScrolling: false,
        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,
        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,
        updateRequested: false,
        xAxisScrollDir: FORWARD,
        yAxisScrollDir: FORWARD
      });
      const getItemStyleCache = useCache();
      const parsedHeight = (0, import_vue473.computed)(() => Number.parseInt(`${props.height}`, 10));
      const parsedWidth = (0, import_vue473.computed)(() => Number.parseInt(`${props.width}`, 10));
      const columnsToRender = (0, import_vue473.computed)(() => {
        const { totalColumn, totalRow, columnCache } = props;
        const { isScrolling, xAxisScrollDir, scrollLeft } = (0, import_vue473.unref)(states);
        if (totalColumn === 0 || totalRow === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, (0, import_vue473.unref)(cache2));
        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, (0, import_vue473.unref)(cache2));
        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;
        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const rowsToRender = (0, import_vue473.computed)(() => {
        const { totalColumn, totalRow, rowCache } = props;
        const { isScrolling, yAxisScrollDir, scrollTop } = (0, import_vue473.unref)(states);
        if (totalColumn === 0 || totalRow === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getRowStartIndexForOffset(props, scrollTop, (0, import_vue473.unref)(cache2));
        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, (0, import_vue473.unref)(cache2));
        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;
        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const estimatedTotalHeight = (0, import_vue473.computed)(() => getEstimatedTotalHeight2(props, (0, import_vue473.unref)(cache2)));
      const estimatedTotalWidth = (0, import_vue473.computed)(() => getEstimatedTotalWidth2(props, (0, import_vue473.unref)(cache2)));
      const windowStyle = (0, import_vue473.computed)(() => {
        var _a2;
        return [
          {
            position: "relative",
            overflow: "hidden",
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          },
          {
            direction: props.direction,
            height: isNumber(props.height) ? `${props.height}px` : props.height,
            width: isNumber(props.width) ? `${props.width}px` : props.width
          },
          (_a2 = props.style) != null ? _a2 : {}
        ];
      });
      const innerStyle = (0, import_vue473.computed)(() => {
        const width = `${(0, import_vue473.unref)(estimatedTotalWidth)}px`;
        const height = `${(0, import_vue473.unref)(estimatedTotalHeight)}px`;
        return {
          height,
          pointerEvents: (0, import_vue473.unref)(states).isScrolling ? "none" : void 0,
          width
        };
      });
      const emitEvents = () => {
        const { totalColumn, totalRow } = props;
        if (totalColumn > 0 && totalRow > 0) {
          const [
            columnCacheStart,
            columnCacheEnd,
            columnVisibleStart,
            columnVisibleEnd
          ] = (0, import_vue473.unref)(columnsToRender);
          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = (0, import_vue473.unref)(rowsToRender);
          emit(ITEM_RENDER_EVT, {
            columnCacheStart,
            columnCacheEnd,
            rowCacheStart,
            rowCacheEnd,
            columnVisibleStart,
            columnVisibleEnd,
            rowVisibleStart,
            rowVisibleEnd
          });
        }
        const {
          scrollLeft,
          scrollTop,
          updateRequested,
          xAxisScrollDir,
          yAxisScrollDir
        } = (0, import_vue473.unref)(states);
        emit(SCROLL_EVT, {
          xAxisScrollDir,
          scrollLeft,
          yAxisScrollDir,
          scrollTop,
          updateRequested
        });
      };
      const onScroll = (e) => {
        const {
          clientHeight,
          clientWidth,
          scrollHeight,
          scrollLeft,
          scrollTop,
          scrollWidth
        } = e.currentTarget;
        const _states = (0, import_vue473.unref)(states);
        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {
          return;
        }
        let _scrollLeft = scrollLeft;
        if (isRTL(props.direction)) {
          switch (getRTLOffsetType()) {
            case RTL_OFFSET_NAG:
              _scrollLeft = -scrollLeft;
              break;
            case RTL_OFFSET_POS_DESC:
              _scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        }
        states.value = {
          ..._states,
          isScrolling: true,
          scrollLeft: _scrollLeft,
          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),
          updateRequested: true,
          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),
          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)
        };
        (0, import_vue473.nextTick)(() => resetIsScrolling());
        onUpdated9();
        emitEvents();
      };
      const onVerticalScroll = (distance, totalSteps) => {
        const height = (0, import_vue473.unref)(parsedHeight);
        const offset2 = (estimatedTotalHeight.value - height) / totalSteps * distance;
        scrollTo({
          scrollTop: Math.min(estimatedTotalHeight.value - height, offset2)
        });
      };
      const onHorizontalScroll = (distance, totalSteps) => {
        const width = (0, import_vue473.unref)(parsedWidth);
        const offset2 = (estimatedTotalWidth.value - width) / totalSteps * distance;
        scrollTo({
          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset2)
        });
      };
      const { onWheel } = useGridWheel({
        atXStartEdge: (0, import_vue473.computed)(() => states.value.scrollLeft <= 0),
        atXEndEdge: (0, import_vue473.computed)(() => states.value.scrollLeft >= estimatedTotalWidth.value),
        atYStartEdge: (0, import_vue473.computed)(() => states.value.scrollTop <= 0),
        atYEndEdge: (0, import_vue473.computed)(() => states.value.scrollTop >= estimatedTotalHeight.value)
      }, (x3, y2) => {
        var _a2, _b, _c, _d;
        (_b = (_a2 = hScrollbar.value) == null ? void 0 : _a2.onMouseUp) == null ? void 0 : _b.call(_a2);
        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);
        const width = (0, import_vue473.unref)(parsedWidth);
        const height = (0, import_vue473.unref)(parsedHeight);
        scrollTo({
          scrollLeft: Math.min(states.value.scrollLeft + x3, estimatedTotalWidth.value - width),
          scrollTop: Math.min(states.value.scrollTop + y2, estimatedTotalHeight.value - height)
        });
      });
      const scrollTo = ({
        scrollLeft = states.value.scrollLeft,
        scrollTop = states.value.scrollTop
      }) => {
        scrollLeft = Math.max(scrollLeft, 0);
        scrollTop = Math.max(scrollTop, 0);
        const _states = (0, import_vue473.unref)(states);
        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {
          return;
        }
        states.value = {
          ..._states,
          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),
          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),
          scrollLeft,
          scrollTop,
          updateRequested: true
        };
        (0, import_vue473.nextTick)(() => resetIsScrolling());
        onUpdated9();
        emitEvents();
      };
      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {
        const _states = (0, import_vue473.unref)(states);
        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));
        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));
        const scrollBarWidth2 = getScrollBarWidth(ns2.namespace.value);
        const _cache = (0, import_vue473.unref)(cache2);
        const estimatedHeight = getEstimatedTotalHeight2(props, _cache);
        const estimatedWidth = getEstimatedTotalWidth2(props, _cache);
        scrollTo({
          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth2 : 0),
          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth2 : 0)
        });
      };
      const getItemStyle = (rowIndex, columnIndex) => {
        const { columnWidth, direction: direction2, rowHeight } = props;
        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction2);
        const key = `${rowIndex},${columnIndex}`;
        if ((0, import_shared73.hasOwn)(itemStyleCache, key)) {
          return itemStyleCache[key];
        } else {
          const [, left2] = getColumnPosition(props, columnIndex, (0, import_vue473.unref)(cache2));
          const _cache = (0, import_vue473.unref)(cache2);
          const rtl = isRTL(direction2);
          const [height, top] = getRowPosition(props, rowIndex, _cache);
          const [width] = getColumnPosition(props, columnIndex, _cache);
          itemStyleCache[key] = {
            position: "absolute",
            left: rtl ? void 0 : `${left2}px`,
            right: rtl ? `${left2}px` : void 0,
            top: `${top}px`,
            height: `${height}px`,
            width: `${width}px`
          };
          return itemStyleCache[key];
        }
      };
      const resetIsScrolling = () => {
        states.value.isScrolling = false;
        (0, import_vue473.nextTick)(() => {
          getItemStyleCache.value(-1, null, null);
        });
      };
      (0, import_vue473.onMounted)(() => {
        if (!isClient)
          return;
        const { initScrollLeft, initScrollTop } = props;
        const windowElement = (0, import_vue473.unref)(windowRef);
        if (windowElement) {
          if (isNumber(initScrollLeft)) {
            windowElement.scrollLeft = initScrollLeft;
          }
          if (isNumber(initScrollTop)) {
            windowElement.scrollTop = initScrollTop;
          }
        }
        emitEvents();
      });
      const onUpdated9 = () => {
        const { direction: direction2 } = props;
        const { scrollLeft, scrollTop, updateRequested } = (0, import_vue473.unref)(states);
        const windowElement = (0, import_vue473.unref)(windowRef);
        if (updateRequested && windowElement) {
          if (direction2 === RTL) {
            switch (getRTLOffsetType()) {
              case RTL_OFFSET_NAG: {
                windowElement.scrollLeft = -scrollLeft;
                break;
              }
              case RTL_OFFSET_POS_ASC: {
                windowElement.scrollLeft = scrollLeft;
                break;
              }
              default: {
                const { clientWidth, scrollWidth } = windowElement;
                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
              }
            }
          } else {
            windowElement.scrollLeft = Math.max(0, scrollLeft);
          }
          windowElement.scrollTop = Math.max(0, scrollTop);
        }
      };
      const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } = instance.proxy;
      expose({
        windowRef,
        innerRef,
        getItemStyleCache,
        scrollTo,
        scrollToItem,
        states,
        resetAfterColumnIndex,
        resetAfterRowIndex,
        resetAfter
      });
      const renderScrollbars = () => {
        const {
          scrollbarAlwaysOn,
          scrollbarStartGap,
          scrollbarEndGap,
          totalColumn,
          totalRow
        } = props;
        const width = (0, import_vue473.unref)(parsedWidth);
        const height = (0, import_vue473.unref)(parsedHeight);
        const estimatedWidth = (0, import_vue473.unref)(estimatedTotalWidth);
        const estimatedHeight = (0, import_vue473.unref)(estimatedTotalHeight);
        const { scrollLeft, scrollTop } = (0, import_vue473.unref)(states);
        const horizontalScrollbar = (0, import_vue473.h)(ScrollBar, {
          ref: hScrollbar,
          alwaysOn: scrollbarAlwaysOn,
          startGap: scrollbarStartGap,
          endGap: scrollbarEndGap,
          class: ns2.e("horizontal"),
          clientSize: width,
          layout: "horizontal",
          onScroll: onHorizontalScroll,
          ratio: width * 100 / estimatedWidth,
          scrollFrom: scrollLeft / (estimatedWidth - width),
          total: totalRow,
          visible: true
        });
        const verticalScrollbar = (0, import_vue473.h)(ScrollBar, {
          ref: vScrollbar,
          alwaysOn: scrollbarAlwaysOn,
          startGap: scrollbarStartGap,
          endGap: scrollbarEndGap,
          class: ns2.e("vertical"),
          clientSize: height,
          layout: "vertical",
          onScroll: onVerticalScroll,
          ratio: height * 100 / estimatedHeight,
          scrollFrom: scrollTop / (estimatedHeight - height),
          total: totalColumn,
          visible: true
        });
        return {
          horizontalScrollbar,
          verticalScrollbar
        };
      };
      const renderItems = () => {
        var _a2;
        const [columnStart, columnEnd] = (0, import_vue473.unref)(columnsToRender);
        const [rowStart, rowEnd] = (0, import_vue473.unref)(rowsToRender);
        const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props;
        const children = [];
        if (totalRow > 0 && totalColumn > 0) {
          for (let row = rowStart; row <= rowEnd; row++) {
            for (let column2 = columnStart; column2 <= columnEnd; column2++) {
              children.push((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                columnIndex: column2,
                data,
                key: itemKey({ columnIndex: column2, data, rowIndex: row }),
                isScrolling: useIsScrolling ? (0, import_vue473.unref)(states).isScrolling : void 0,
                style: getItemStyle(row, column2),
                rowIndex: row
              }));
            }
          }
        }
        return children;
      };
      const renderInner = () => {
        const Inner = (0, import_vue473.resolveDynamicComponent)(props.innerElement);
        const children = renderItems();
        return [
          (0, import_vue473.h)(Inner, {
            style: (0, import_vue473.unref)(innerStyle),
            ref: innerRef
          }, !(0, import_shared73.isString)(Inner) ? {
            default: () => children
          } : children)
        ];
      };
      const renderWindow = () => {
        const Container2 = (0, import_vue473.resolveDynamicComponent)(props.containerElement);
        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();
        const Inner = renderInner();
        return (0, import_vue473.h)("div", {
          key: 0,
          class: ns2.e("wrapper")
        }, [
          (0, import_vue473.h)(Container2, {
            class: props.className,
            style: (0, import_vue473.unref)(windowStyle),
            onScroll,
            onWheel,
            ref: windowRef
          }, !(0, import_shared73.isString)(Container2) ? { default: () => Inner } : Inner),
          horizontalScrollbar,
          verticalScrollbar
        ]);
      };
      return renderWindow;
    }
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/components/fixed-size-grid.mjs
var SCOPE5 = "ElFixedSizeGrid";
var FixedSizeGrid = createGrid({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth }, index2) => [
    columnWidth,
    index2 * columnWidth
  ],
  getRowPosition: ({ rowHeight }, index2) => [
    rowHeight,
    index2 * rowHeight
  ],
  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,
  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,
  getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _2, scrollBarWidth2) => {
    width = Number(width);
    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);
    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth2 + columnWidth);
    if (alignment === "smart") {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT:
        return maxOffset;
      case END_ALIGNMENT:
        return minOffset;
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(width / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _2, scrollBarWidth2) => {
    height = Number(height);
    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth2 + rowHeight);
    if (align === SMART_ALIGNMENT) {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = AUTO_ALIGNMENT;
      } else {
        align = CENTERED_ALIGNMENT;
      }
    }
    switch (align) {
      case START_ALIGNMENT:
        return maxOffset;
      case END_ALIGNMENT:
        return minOffset;
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(height / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),
  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {
    const left2 = startIndex * columnWidth;
    const visibleColumnsCount = Math.ceil((width + scrollLeft - left2) / columnWidth);
    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));
  },
  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),
  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {
    const top = startIndex * rowHeight;
    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);
    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));
  },
  initCache: () => void 0,
  clearCache: true,
  validateProps: ({ columnWidth, rowHeight }) => {
    if (process.env.NODE_ENV !== "production") {
      if (!isNumber(columnWidth)) {
        throwError(SCOPE5, `
          "columnWidth" must be passed as number,
            instead ${typeof columnWidth} was given.
        `);
      }
      if (!isNumber(rowHeight)) {
        throwError(SCOPE5, `
          "columnWidth" must be passed as number,
            instead ${typeof rowHeight} was given.
        `);
      }
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/virtual-list/src/components/dynamic-size-grid.mjs
var import_shared74 = require("@vue/shared");
var { max: max3, min: min3, floor } = Math;
var SCOPE6 = "ElDynamicSizeGrid";
var ACCESS_SIZER_KEY_MAP = {
  column: "columnWidth",
  row: "rowHeight"
};
var ACCESS_LAST_VISITED_KEY_MAP = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
};
var getItemFromCache2 = (props, index2, gridCache, type4) => {
  const [cachedItems, sizer, lastVisited] = [
    gridCache[type4],
    props[ACCESS_SIZER_KEY_MAP[type4]],
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type4]]
  ];
  if (index2 > lastVisited) {
    let offset2 = 0;
    if (lastVisited >= 0) {
      const item = cachedItems[lastVisited];
      offset2 = item.offset + item.size;
    }
    for (let i = lastVisited + 1; i <= index2; i++) {
      const size2 = sizer(i);
      cachedItems[i] = {
        offset: offset2,
        size: size2
      };
      offset2 += size2;
    }
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type4]] = index2;
  }
  return cachedItems[index2];
};
var bs2 = (props, gridCache, low, high, offset2, type4) => {
  while (low <= high) {
    const mid = low + floor((high - low) / 2);
    const currentOffset = getItemFromCache2(props, mid, gridCache, type4).offset;
    if (currentOffset === offset2) {
      return mid;
    } else if (currentOffset < offset2) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return max3(0, low - 1);
};
var es2 = (props, gridCache, idx, offset2, type4) => {
  const total2 = type4 === "column" ? props.totalColumn : props.totalRow;
  let exponent = 1;
  while (idx < total2 && getItemFromCache2(props, idx, gridCache, type4).offset < offset2) {
    idx += exponent;
    exponent *= 2;
  }
  return bs2(props, gridCache, floor(idx / 2), min3(idx, total2 - 1), offset2, type4);
};
var findItem2 = (props, gridCache, offset2, type4) => {
  const [cache2, lastVisitedIndex] = [
    gridCache[type4],
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type4]]
  ];
  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache2[lastVisitedIndex].offset : 0;
  if (lastVisitedItemOffset >= offset2) {
    return bs2(props, gridCache, 0, lastVisitedIndex, offset2, type4);
  }
  return es2(props, gridCache, max3(0, lastVisitedIndex), offset2, type4);
};
var getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row }) => {
  let sizeOfVisitedRows = 0;
  if (lastVisitedRowIndex >= totalRow) {
    lastVisitedRowIndex = totalRow - 1;
  }
  if (lastVisitedRowIndex >= 0) {
    const item = row[lastVisitedRowIndex];
    sizeOfVisitedRows = item.offset + item.size;
  }
  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
  return sizeOfVisitedRows + sizeOfUnvisitedItems;
};
var getEstimatedTotalWidth = ({ totalColumn }, { column: column2, estimatedColumnWidth, lastVisitedColumnIndex }) => {
  let sizeOfVisitedColumns = 0;
  if (lastVisitedColumnIndex > totalColumn) {
    lastVisitedColumnIndex = totalColumn - 1;
  }
  if (lastVisitedColumnIndex >= 0) {
    const item = column2[lastVisitedColumnIndex];
    sizeOfVisitedColumns = item.offset + item.size;
  }
  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
  return sizeOfVisitedColumns + sizeOfUnvisitedItems;
};
var ACCESS_ESTIMATED_SIZE_KEY_MAP = {
  column: getEstimatedTotalWidth,
  row: getEstimatedTotalHeight
};
var getOffset = (props, index2, alignment, scrollOffset, cache2, type4, scrollBarWidth2) => {
  const [size2, estimatedSizeAssociates] = [
    type4 === "row" ? props.height : props.width,
    ACCESS_ESTIMATED_SIZE_KEY_MAP[type4]
  ];
  const item = getItemFromCache2(props, index2, cache2, type4);
  const estimatedSize = estimatedSizeAssociates(props, cache2);
  const maxOffset = max3(0, min3(estimatedSize - size2, item.offset));
  const minOffset = max3(0, item.offset - size2 + scrollBarWidth2 + item.size);
  if (alignment === SMART_ALIGNMENT) {
    if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
      alignment = AUTO_ALIGNMENT;
    } else {
      alignment = CENTERED_ALIGNMENT;
    }
  }
  switch (alignment) {
    case START_ALIGNMENT: {
      return maxOffset;
    }
    case END_ALIGNMENT: {
      return minOffset;
    }
    case CENTERED_ALIGNMENT: {
      return Math.round(minOffset + (maxOffset - minOffset) / 2);
    }
    case AUTO_ALIGNMENT:
    default: {
      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
        return scrollOffset;
      } else if (minOffset > maxOffset) {
        return minOffset;
      } else if (scrollOffset < minOffset) {
        return minOffset;
      } else {
        return maxOffset;
      }
    }
  }
};
var DynamicSizeGrid = createGrid({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (props, idx, cache2) => {
    const item = getItemFromCache2(props, idx, cache2, "column");
    return [item.size, item.offset];
  },
  getRowPosition: (props, idx, cache2) => {
    const item = getItemFromCache2(props, idx, cache2, "row");
    return [item.size, item.offset];
  },
  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache2, scrollBarWidth2) => getOffset(props, columnIndex, alignment, scrollLeft, cache2, "column", scrollBarWidth2),
  getRowOffset: (props, rowIndex, alignment, scrollTop, cache2, scrollBarWidth2) => getOffset(props, rowIndex, alignment, scrollTop, cache2, "row", scrollBarWidth2),
  getColumnStartIndexForOffset: (props, scrollLeft, cache2) => findItem2(props, cache2, scrollLeft, "column"),
  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache2) => {
    const item = getItemFromCache2(props, startIndex, cache2, "column");
    const maxOffset = scrollLeft + props.width;
    let offset2 = item.offset + item.size;
    let stopIndex = startIndex;
    while (stopIndex < props.totalColumn - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemFromCache2(props, startIndex, cache2, "column").size;
    }
    return stopIndex;
  },
  getEstimatedTotalHeight,
  getEstimatedTotalWidth,
  getRowStartIndexForOffset: (props, scrollTop, cache2) => findItem2(props, cache2, scrollTop, "row"),
  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache2) => {
    const { totalRow, height } = props;
    const item = getItemFromCache2(props, startIndex, cache2, "row");
    const maxOffset = scrollTop + height;
    let offset2 = item.size + item.offset;
    let stopIndex = startIndex;
    while (stopIndex < totalRow - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemFromCache2(props, stopIndex, cache2, "row").size;
    }
    return stopIndex;
  },
  injectToInstance: (instance, cache2) => {
    const resetAfter = ({ columnIndex, rowIndex }, forceUpdate) => {
      var _a2, _b;
      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;
      if (isNumber(columnIndex)) {
        cache2.value.lastVisitedColumnIndex = Math.min(cache2.value.lastVisitedColumnIndex, columnIndex - 1);
      }
      if (isNumber(rowIndex)) {
        cache2.value.lastVisitedRowIndex = Math.min(cache2.value.lastVisitedRowIndex, rowIndex - 1);
      }
      (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache.value(-1, null, null);
      if (forceUpdate)
        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
    };
    const resetAfterColumnIndex = (columnIndex, forceUpdate) => {
      resetAfter({
        columnIndex
      }, forceUpdate);
    };
    const resetAfterRowIndex = (rowIndex, forceUpdate) => {
      resetAfter({
        rowIndex
      }, forceUpdate);
    };
    Object.assign(instance.proxy, {
      resetAfterColumnIndex,
      resetAfterRowIndex,
      resetAfter
    });
  },
  initCache: ({
    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,
    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE
  }) => {
    const cache2 = {
      column: {},
      estimatedColumnWidth,
      estimatedRowHeight,
      lastVisitedColumnIndex: -1,
      lastVisitedRowIndex: -1,
      row: {}
    };
    return cache2;
  },
  clearCache: false,
  validateProps: ({ columnWidth, rowHeight }) => {
    if (process.env.NODE_ENV !== "production") {
      if (!(0, import_shared74.isFunction)(columnWidth)) {
        throwError(SCOPE6, `
          "columnWidth" must be passed as function,
            instead ${typeof columnWidth} was given.
        `);
      }
      if (!(0, import_shared74.isFunction)(rowHeight)) {
        throwError(SCOPE6, `
          "rowHeight" must be passed as function,
            instead ${typeof rowHeight} was given.
        `);
      }
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/group-item.mjs
var import_vue474 = require("vue");
var _sfc_main108 = (0, import_vue474.defineComponent)({
  props: {
    item: {
      type: Object,
      required: true
    },
    style: Object,
    height: Number
  },
  setup() {
    const ns2 = useNamespace("select");
    return {
      ns: ns2
    };
  }
});
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.item.isTitle ? ((0, import_vue474.openBlock)(), (0, import_vue474.createElementBlock)("div", {
    key: 0,
    class: (0, import_vue474.normalizeClass)(_ctx.ns.be("group", "title")),
    style: (0, import_vue474.normalizeStyle)([_ctx.style, { lineHeight: `${_ctx.height}px` }])
  }, (0, import_vue474.toDisplayString)(_ctx.item.label), 7)) : ((0, import_vue474.openBlock)(), (0, import_vue474.createElementBlock)("div", {
    key: 1,
    class: (0, import_vue474.normalizeClass)(_ctx.ns.be("group", "split")),
    style: (0, import_vue474.normalizeStyle)(_ctx.style)
  }, [
    (0, import_vue474.createElementVNode)("span", {
      class: (0, import_vue474.normalizeClass)(_ctx.ns.be("group", "split-dash")),
      style: (0, import_vue474.normalizeStyle)({ top: `${_ctx.height / 2}px` })
    }, null, 6)
  ], 6));
}
var GroupItem = /* @__PURE__ */ _export_sfc(_sfc_main108, [["render", _sfc_render33], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/option-item.mjs
var import_vue475 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/useOption.mjs
function useOption2(props, { emit }) {
  return {
    hoverItem: () => {
      if (!props.disabled) {
        emit("hover", props.index);
      }
    },
    selectOptionClick: () => {
      if (!props.disabled) {
        emit("select", props.item, props.index);
      }
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/defaults.mjs
var SelectProps = {
  allowCreate: Boolean,
  autocomplete: {
    type: String,
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: [String, Object],
    default: circle_close_default
  },
  effect: {
    type: String,
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: {
    type: Boolean,
    default: false
  },
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 170
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  label: String,
  modelValue: [Array, String, Number, Boolean, Object],
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: {
    type: Boolean,
    default: true
  },
  options: {
    type: Array,
    required: true
  },
  placeholder: {
    type: String
  },
  teleported: useTooltipContentProps.teleported,
  persistent: {
    type: Boolean,
    default: true
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  remote: Boolean,
  size: {
    type: String,
    validator: isValidComponentSize
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  placement: {
    type: definePropType(String),
    values: Ee,
    default: "bottom-start"
  }
};
var OptionProps = {
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: Object,
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/option-item.mjs
var _sfc_main109 = (0, import_vue475.defineComponent)({
  props: OptionProps,
  emits: ["select", "hover"],
  setup(props, { emit }) {
    const ns2 = useNamespace("select");
    const { hoverItem, selectOptionClick } = useOption2(props, { emit });
    return {
      ns: ns2,
      hoverItem,
      selectOptionClick
    };
  }
});
var _hoisted_169 = ["aria-selected"];
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, import_vue475.openBlock)(), (0, import_vue475.createElementBlock)("li", {
    "aria-selected": _ctx.selected,
    style: (0, import_vue475.normalizeStyle)(_ctx.style),
    class: (0, import_vue475.normalizeClass)([
      _ctx.ns.be("dropdown", "option-item"),
      _ctx.ns.is("selected", _ctx.selected),
      _ctx.ns.is("disabled", _ctx.disabled),
      _ctx.ns.is("created", _ctx.created),
      { hover: _ctx.hovering }
    ]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = (0, import_vue475.withModifiers)((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    (0, import_vue475.renderSlot)(_ctx.$slots, "default", {
      item: _ctx.item,
      index: _ctx.index,
      disabled: _ctx.disabled
    }, () => [
      (0, import_vue475.createElementVNode)("span", null, (0, import_vue475.toDisplayString)(_ctx.item.label), 1)
    ])
  ], 46, _hoisted_169);
}
var OptionItem = /* @__PURE__ */ _export_sfc(_sfc_main109, [["render", _sfc_render36], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/token.mjs
var selectV2InjectionKey = "ElSelectV2Injection";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/select-dropdown.mjs
var import_shared75 = require("@vue/shared");
var ElSelectMenu2 = (0, import_vue476.defineComponent)({
  name: "ElSelectDropdown",
  props: {
    data: {
      type: Array,
      required: true
    },
    hoveringIndex: Number,
    width: Number
  },
  setup(props, {
    slots,
    expose
  }) {
    const select = (0, import_vue476.inject)(selectV2InjectionKey);
    const ns2 = useNamespace("select");
    const cachedHeights = (0, import_vue476.ref)([]);
    const listRef = (0, import_vue476.ref)();
    const size2 = (0, import_vue476.computed)(() => props.data.length);
    (0, import_vue476.watch)(() => size2.value, () => {
      var _a2, _b;
      (_b = (_a2 = select.popper.value).updatePopper) == null ? void 0 : _b.call(_a2);
    });
    const isSized = (0, import_vue476.computed)(() => isUndefined(select.props.estimatedOptionHeight));
    const listProps = (0, import_vue476.computed)(() => {
      if (isSized.value) {
        return {
          itemSize: select.props.itemHeight
        };
      }
      return {
        estimatedSize: select.props.estimatedOptionHeight,
        itemSize: (idx) => cachedHeights.value[idx]
      };
    });
    const contains = (arr = [], target) => {
      const {
        props: {
          valueKey
        }
      } = select;
      if (!(0, import_shared75.isObject)(target)) {
        return arr.includes(target);
      }
      return arr && arr.some((item) => {
        return get_default(item, valueKey) === get_default(target, valueKey);
      });
    };
    const isEqual3 = (selected, target) => {
      if (!(0, import_shared75.isObject)(target)) {
        return selected === target;
      } else {
        const {
          valueKey
        } = select.props;
        return get_default(selected, valueKey) === get_default(target, valueKey);
      }
    };
    const isItemSelected = (modelValue, target) => {
      const {
        valueKey
      } = select.props;
      if (select.props.multiple) {
        return contains(modelValue, get_default(target, valueKey));
      }
      return isEqual3(modelValue, get_default(target, valueKey));
    };
    const isItemDisabled = (modelValue, selected) => {
      const {
        disabled,
        multiple,
        multipleLimit
      } = select.props;
      return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
    };
    const isItemHovering = (target) => props.hoveringIndex === target;
    const scrollToItem = (index2) => {
      const list = listRef.value;
      if (list) {
        list.scrollToItem(index2);
      }
    };
    const resetScrollTop = () => {
      const list = listRef.value;
      if (list) {
        list.resetScrollTop();
      }
    };
    expose({
      listRef,
      isSized,
      isItemDisabled,
      isItemHovering,
      isItemSelected,
      scrollToItem,
      resetScrollTop
    });
    const Item = (itemProps) => {
      const {
        index: index2,
        data,
        style
      } = itemProps;
      const sized = (0, import_vue476.unref)(isSized);
      const {
        itemSize: itemSize3,
        estimatedSize
      } = (0, import_vue476.unref)(listProps);
      const {
        modelValue
      } = select.props;
      const {
        onSelect,
        onHover
      } = select;
      const item = data[index2];
      if (item.type === "Group") {
        return (0, import_vue476.createVNode)(GroupItem, {
          "item": item,
          "style": style,
          "height": sized ? itemSize3 : estimatedSize
        }, null);
      }
      const isSelected = isItemSelected(modelValue, item);
      const isDisabled = isItemDisabled(modelValue, isSelected);
      const isHovering = isItemHovering(index2);
      return (0, import_vue476.createVNode)(OptionItem, (0, import_vue476.mergeProps)(itemProps, {
        "selected": isSelected,
        "disabled": item.disabled || isDisabled,
        "created": !!item.created,
        "hovering": isHovering,
        "item": item,
        "onSelect": onSelect,
        "onHover": onHover
      }), {
        default: (props2) => {
          var _a2;
          return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, props2)) || (0, import_vue476.createVNode)("span", null, [item.label]);
        }
      });
    };
    const {
      onKeyboardNavigate,
      onKeyboardSelect
    } = select;
    const onForward = () => {
      onKeyboardNavigate("forward");
    };
    const onBackward = () => {
      onKeyboardNavigate("backward");
    };
    const onEscOrTab = () => {
      select.expanded = false;
    };
    const onKeydown = (e) => {
      const {
        code
      } = e;
      const {
        tab,
        esc,
        down: down2,
        up: up2,
        enter
      } = EVENT_CODE;
      if (code !== tab) {
        e.preventDefault();
        e.stopPropagation();
      }
      switch (code) {
        case tab:
        case esc: {
          onEscOrTab();
          break;
        }
        case down2: {
          onForward();
          break;
        }
        case up2: {
          onBackward();
          break;
        }
        case enter: {
          onKeyboardSelect();
          break;
        }
      }
    };
    return () => {
      var _a2;
      const {
        data,
        width
      } = props;
      const {
        height,
        multiple,
        scrollbarAlwaysOn
      } = select.props;
      if (data.length === 0) {
        return (0, import_vue476.createVNode)("div", {
          "class": ns2.b("dropdown"),
          "style": {
            width: `${width}px`
          }
        }, [(_a2 = slots.empty) == null ? void 0 : _a2.call(slots)]);
      }
      const List = (0, import_vue476.unref)(isSized) ? FixedSizeList : DynamicSizeList;
      return (0, import_vue476.createVNode)("div", {
        "class": [ns2.b("dropdown"), ns2.is("multiple", multiple)]
      }, [(0, import_vue476.createVNode)(List, (0, import_vue476.mergeProps)({
        "ref": listRef
      }, (0, import_vue476.unref)(listProps), {
        "className": ns2.be("dropdown", "list"),
        "scrollbarAlwaysOn": scrollbarAlwaysOn,
        "data": data,
        "height": height,
        "width": width,
        "total": data.length,
        "onKeydown": onKeydown
      }), {
        default: (props2) => (0, import_vue476.createVNode)(Item, props2, null)
      })]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/useSelect.mjs
var import_vue479 = require("vue");
var import_shared78 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/useAllowCreate.mjs
var import_vue477 = require("vue");
function useAllowCreate(props, states) {
  const createOptionCount = (0, import_vue477.ref)(0);
  const cachedSelectedOption = (0, import_vue477.ref)(null);
  const enableAllowCreateMode = (0, import_vue477.computed)(() => {
    return props.allowCreate && props.filterable;
  });
  function hasExistingOption(query) {
    const hasValue = (option2) => option2.value === query;
    return props.options && props.options.some(hasValue) || states.createdOptions.some(hasValue);
  }
  function selectNewOption(option2) {
    if (!enableAllowCreateMode.value) {
      return;
    }
    if (props.multiple && option2.created) {
      createOptionCount.value++;
    } else {
      cachedSelectedOption.value = option2;
    }
  }
  function createNewOption(query) {
    if (enableAllowCreateMode.value) {
      if (query && query.length > 0 && !hasExistingOption(query)) {
        const newOption = {
          value: query,
          label: query,
          created: true,
          disabled: false
        };
        if (states.createdOptions.length >= createOptionCount.value) {
          states.createdOptions[createOptionCount.value] = newOption;
        } else {
          states.createdOptions.push(newOption);
        }
      } else {
        if (props.multiple) {
          states.createdOptions.length = createOptionCount.value;
        } else {
          const selectedOption = cachedSelectedOption.value;
          states.createdOptions.length = 0;
          if (selectedOption && selectedOption.created) {
            states.createdOptions.push(selectedOption);
          }
        }
      }
    }
  }
  function removeNewOption(option2) {
    if (!enableAllowCreateMode.value || !option2 || !option2.created || option2.created && props.reserveKeyword && states.inputValue === option2.label) {
      return;
    }
    const idx = states.createdOptions.findIndex((it2) => it2.value === option2.value);
    if (~idx) {
      states.createdOptions.splice(idx, 1);
      createOptionCount.value--;
    }
  }
  function clearAllNewOption() {
    if (enableAllowCreateMode.value) {
      states.createdOptions.length = 0;
      createOptionCount.value = 0;
    }
  }
  return {
    createNewOption,
    removeNewOption,
    selectNewOption,
    clearAllNewOption
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/util.mjs
var import_shared76 = require("@vue/shared");
var flattenOptions = (options) => {
  const flattened = [];
  options.forEach((option2) => {
    if ((0, import_shared76.isArray)(option2.options)) {
      flattened.push({
        label: option2.label,
        isTitle: true,
        type: "Group"
      });
      option2.options.forEach((o2) => {
        flattened.push(o2);
      });
      flattened.push({
        type: "Group"
      });
    } else {
      flattened.push(option2);
    }
  });
  return flattened;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/useInput.mjs
var import_vue478 = require("vue");
var import_shared77 = require("@vue/shared");
function useInput(handleInput) {
  const isComposing = (0, import_vue478.ref)(false);
  const handleCompositionStart = () => {
    isComposing.value = true;
  };
  const handleCompositionUpdate = (event) => {
    const text = event.target.value;
    const lastCharacter = text[text.length - 1] || "";
    isComposing.value = !isKorean(lastCharacter);
  };
  const handleCompositionEnd = (event) => {
    if (isComposing.value) {
      isComposing.value = false;
      if ((0, import_shared77.isFunction)(handleInput)) {
        handleInput(event);
      }
    }
  };
  return {
    handleCompositionStart,
    handleCompositionUpdate,
    handleCompositionEnd
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/useSelect.mjs
var DEFAULT_INPUT_PLACEHOLDER = "";
var MINIMUM_INPUT_WIDTH = 11;
var TAG_BASE_WIDTH = {
  larget: 51,
  default: 42,
  small: 33
};
var useSelect2 = (props, emit) => {
  const { t } = useLocale();
  const nsSelectV2 = useNamespace("select-v2");
  const nsInput = useNamespace("input");
  const { form: elForm, formItem: elFormItem } = useFormItem();
  const states = (0, import_vue479.reactive)({
    inputValue: DEFAULT_INPUT_PLACEHOLDER,
    displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
    calculatedWidth: 0,
    cachedPlaceholder: "",
    cachedOptions: [],
    createdOptions: [],
    createdLabel: "",
    createdSelected: false,
    currentPlaceholder: "",
    hoveringIndex: -1,
    comboBoxHovering: false,
    isOnComposition: false,
    isSilentBlur: false,
    isComposing: false,
    inputLength: 20,
    selectWidth: 200,
    initialInputHeight: 0,
    previousQuery: null,
    previousValue: void 0,
    query: "",
    selectedLabel: "",
    softFocus: false,
    tagInMultiLine: false
  });
  const selectedIndex = (0, import_vue479.ref)(-1);
  const popperSize = (0, import_vue479.ref)(-1);
  const controlRef = (0, import_vue479.ref)(null);
  const inputRef = (0, import_vue479.ref)(null);
  const menuRef = (0, import_vue479.ref)(null);
  const popper = (0, import_vue479.ref)(null);
  const selectRef = (0, import_vue479.ref)(null);
  const selectionRef = (0, import_vue479.ref)(null);
  const calculatorRef = (0, import_vue479.ref)(null);
  const expanded = (0, import_vue479.ref)(false);
  const selectDisabled = (0, import_vue479.computed)(() => props.disabled || (elForm == null ? void 0 : elForm.disabled));
  const popupHeight = (0, import_vue479.computed)(() => {
    const totalHeight = filteredOptions.value.length * 34;
    return totalHeight > props.height ? props.height : totalHeight;
  });
  const hasModelValue = (0, import_vue479.computed)(() => {
    return !isNil_default(props.modelValue);
  });
  const showClearBtn = (0, import_vue479.computed)(() => {
    const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : hasModelValue.value;
    const criteria = props.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
    return criteria;
  });
  const iconComponent = (0, import_vue479.computed)(() => props.remote && props.filterable ? "" : arrow_up_default);
  const iconReverse = (0, import_vue479.computed)(() => iconComponent.value && nsSelectV2.is("reverse", expanded.value));
  const validateState = (0, import_vue479.computed)(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
  const validateIcon = (0, import_vue479.computed)(() => ValidateComponentsMap[validateState.value]);
  const debounce$1 = (0, import_vue479.computed)(() => props.remote ? 300 : 0);
  const emptyText = (0, import_vue479.computed)(() => {
    const options = filteredOptions.value;
    if (props.loading) {
      return props.loadingText || t("el.select.loading");
    } else {
      if (props.remote && states.inputValue === "" && options.length === 0)
        return false;
      if (props.filterable && states.inputValue && options.length > 0) {
        return props.noMatchText || t("el.select.noMatch");
      }
      if (options.length === 0) {
        return props.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const filteredOptions = (0, import_vue479.computed)(() => {
    const isValidOption = (o2) => {
      const query = states.inputValue;
      const regexp4 = new RegExp(escapeStringRegexp(query), "i");
      const containsQueryString = query ? regexp4.test(o2.label || "") : true;
      return containsQueryString;
    };
    if (props.loading) {
      return [];
    }
    return flattenOptions(props.options.concat(states.createdOptions).map((v3) => {
      if ((0, import_shared78.isArray)(v3.options)) {
        const filtered = v3.options.filter(isValidOption);
        if (filtered.length > 0) {
          return {
            ...v3,
            options: filtered
          };
        }
      } else {
        if (props.remote || isValidOption(v3)) {
          return v3;
        }
      }
      return null;
    }).filter((v3) => v3 !== null));
  });
  const optionsAllDisabled = (0, import_vue479.computed)(() => filteredOptions.value.every((option2) => option2.disabled));
  const selectSize = useSize();
  const collapseTagSize = (0, import_vue479.computed)(() => selectSize.value === "small" ? "small" : "default");
  const tagMaxWidth = (0, import_vue479.computed)(() => {
    const select = selectionRef.value;
    const size2 = collapseTagSize.value || "default";
    const paddingLeft = select ? Number.parseInt(getComputedStyle(select).paddingLeft) : 0;
    const paddingRight = select ? Number.parseInt(getComputedStyle(select).paddingRight) : 0;
    return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size2];
  });
  const calculatePopperSize = () => {
    var _a2;
    popperSize.value = ((_a2 = selectRef.value) == null ? void 0 : _a2.offsetWidth) || 200;
  };
  const inputWrapperStyle = (0, import_vue479.computed)(() => {
    return {
      width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
    };
  });
  const shouldShowPlaceholder = (0, import_vue479.computed)(() => {
    if ((0, import_shared78.isArray)(props.modelValue)) {
      return props.modelValue.length === 0 && !states.displayInputValue;
    }
    return props.filterable ? states.displayInputValue.length === 0 : true;
  });
  const currentPlaceholder = (0, import_vue479.computed)(() => {
    const _placeholder = props.placeholder || t("el.select.placeholder");
    return props.multiple || isNil_default(props.modelValue) ? _placeholder : states.selectedLabel;
  });
  const popperRef = (0, import_vue479.computed)(() => {
    var _a2, _b;
    return (_b = (_a2 = popper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
  });
  const indexRef = (0, import_vue479.computed)(() => {
    if (props.multiple) {
      const len = props.modelValue.length;
      if (props.modelValue.length > 0) {
        return filteredOptions.value.findIndex((o2) => o2.value === props.modelValue[len - 1]);
      }
    } else {
      if (props.modelValue) {
        return filteredOptions.value.findIndex((o2) => o2.value === props.modelValue);
      }
    }
    return -1;
  });
  const dropdownMenuVisible = (0, import_vue479.computed)({
    get() {
      return expanded.value && emptyText.value !== false;
    },
    set(val) {
      expanded.value = val;
    }
  });
  const {
    createNewOption,
    removeNewOption,
    selectNewOption,
    clearAllNewOption
  } = useAllowCreate(props, states);
  const {
    handleCompositionStart,
    handleCompositionUpdate,
    handleCompositionEnd
  } = useInput((e) => onInput(e));
  const focusAndUpdatePopup = () => {
    var _a2, _b, _c;
    (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
    (_c = popper.value) == null ? void 0 : _c.updatePopper();
  };
  const toggleMenu = () => {
    if (props.automaticDropdown)
      return;
    if (!selectDisabled.value) {
      if (states.isComposing)
        states.softFocus = true;
      return (0, import_vue479.nextTick)(() => {
        var _a2, _b;
        expanded.value = !expanded.value;
        (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
      });
    }
  };
  const onInputChange = () => {
    if (props.filterable && states.inputValue !== states.selectedLabel) {
      states.query = states.selectedLabel;
    }
    handleQueryChange(states.inputValue);
    return (0, import_vue479.nextTick)(() => {
      createNewOption(states.inputValue);
    });
  };
  const debouncedOnInputChange = debounce_default(onInputChange, debounce$1.value);
  const handleQueryChange = (val) => {
    if (states.previousQuery === val) {
      return;
    }
    states.previousQuery = val;
    if (props.filterable && (0, import_shared78.isFunction)(props.filterMethod)) {
      props.filterMethod(val);
    } else if (props.filterable && props.remote && (0, import_shared78.isFunction)(props.remoteMethod)) {
      props.remoteMethod(val);
    }
  };
  const emitChange = (val) => {
    if (!isEqual_default(props.modelValue, val)) {
      emit(CHANGE_EVENT, val);
    }
  };
  const update = (val) => {
    emit(UPDATE_MODEL_EVENT, val);
    emitChange(val);
    states.previousValue = val == null ? void 0 : val.toString();
  };
  const getValueIndex = (arr = [], value) => {
    if (!(0, import_shared78.isObject)(value)) {
      return arr.indexOf(value);
    }
    const valueKey = props.valueKey;
    let index2 = -1;
    arr.some((item, i) => {
      if (get_default(item, valueKey) === get_default(value, valueKey)) {
        index2 = i;
        return true;
      }
      return false;
    });
    return index2;
  };
  const getValueKey = (item) => {
    return (0, import_shared78.isObject)(item) ? get_default(item, props.valueKey) : item;
  };
  const getLabel = (item) => {
    return (0, import_shared78.isObject)(item) ? item.label : item;
  };
  const resetInputHeight = () => {
    if (props.collapseTags && !props.filterable) {
      return;
    }
    return (0, import_vue479.nextTick)(() => {
      var _a2, _b;
      if (!inputRef.value)
        return;
      const selection = selectionRef.value;
      selectRef.value.height = selection.offsetHeight;
      if (expanded.value && emptyText.value !== false) {
        (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      }
    });
  };
  const handleResize = () => {
    var _a2, _b;
    resetInputWidth();
    calculatePopperSize();
    (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
    if (props.multiple) {
      return resetInputHeight();
    }
  };
  const resetInputWidth = () => {
    const select = selectionRef.value;
    if (select) {
      states.selectWidth = select.getBoundingClientRect().width;
    }
  };
  const onSelect = (option2, idx, byClick = true) => {
    var _a2, _b;
    if (props.multiple) {
      let selectedOptions = props.modelValue.slice();
      const index2 = getValueIndex(selectedOptions, getValueKey(option2));
      if (index2 > -1) {
        selectedOptions = [
          ...selectedOptions.slice(0, index2),
          ...selectedOptions.slice(index2 + 1)
        ];
        states.cachedOptions.splice(index2, 1);
        removeNewOption(option2);
      } else if (props.multipleLimit <= 0 || selectedOptions.length < props.multipleLimit) {
        selectedOptions = [...selectedOptions, getValueKey(option2)];
        states.cachedOptions.push(option2);
        selectNewOption(option2);
        updateHoveringIndex(idx);
      }
      update(selectedOptions);
      if (option2.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props.filterable && !props.reserveKeyword) {
        (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
        onUpdateInputValue("");
      }
      if (props.filterable) {
        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
      }
      resetInputHeight();
      setSoftFocus();
    } else {
      selectedIndex.value = idx;
      states.selectedLabel = option2.label;
      update(getValueKey(option2));
      expanded.value = false;
      states.isComposing = false;
      states.isSilentBlur = byClick;
      selectNewOption(option2);
      if (!option2.created) {
        clearAllNewOption();
      }
      updateHoveringIndex(idx);
    }
  };
  const deleteTag = (event, tag) => {
    const { valueKey } = props;
    const index2 = props.modelValue.indexOf(get_default(tag, valueKey));
    if (index2 > -1 && !selectDisabled.value) {
      const value = [
        ...props.modelValue.slice(0, index2),
        ...props.modelValue.slice(index2 + 1)
      ];
      states.cachedOptions.splice(index2, 1);
      update(value);
      emit("remove-tag", get_default(tag, valueKey));
      states.softFocus = true;
      removeNewOption(tag);
      return (0, import_vue479.nextTick)(focusAndUpdatePopup);
    }
    event.stopPropagation();
  };
  const handleFocus = (event) => {
    const focused = states.isComposing;
    states.isComposing = true;
    if (!states.softFocus) {
      if (!focused)
        emit("focus", event);
    } else {
      states.softFocus = false;
    }
  };
  const handleBlur = (event) => {
    states.softFocus = false;
    return (0, import_vue479.nextTick)(() => {
      var _a2, _b;
      (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
      if (calculatorRef.value) {
        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
      }
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        if (states.isComposing) {
          emit("blur", event);
        }
      }
      states.isComposing = false;
    });
  };
  const handleEsc = () => {
    if (states.displayInputValue.length > 0) {
      onUpdateInputValue("");
    } else {
      expanded.value = false;
    }
  };
  const handleDel = (e) => {
    if (states.displayInputValue.length === 0) {
      e.preventDefault();
      const selected = props.modelValue.slice();
      selected.pop();
      removeNewOption(states.cachedOptions.pop());
      update(selected);
    }
  };
  const handleClear = () => {
    let emptyValue;
    if ((0, import_shared78.isArray)(props.modelValue)) {
      emptyValue = [];
    } else {
      emptyValue = void 0;
    }
    states.softFocus = true;
    if (props.multiple) {
      states.cachedOptions = [];
    } else {
      states.selectedLabel = "";
    }
    expanded.value = false;
    update(emptyValue);
    emit("clear");
    clearAllNewOption();
    return (0, import_vue479.nextTick)(focusAndUpdatePopup);
  };
  const onUpdateInputValue = (val) => {
    states.displayInputValue = val;
    states.inputValue = val;
  };
  const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
    const options = filteredOptions.value;
    if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {
      return;
    }
    if (!expanded.value) {
      return toggleMenu();
    }
    if (hoveringIndex === void 0) {
      hoveringIndex = states.hoveringIndex;
    }
    let newIndex2 = -1;
    if (direction2 === "forward") {
      newIndex2 = hoveringIndex + 1;
      if (newIndex2 >= options.length) {
        newIndex2 = 0;
      }
    } else if (direction2 === "backward") {
      newIndex2 = hoveringIndex - 1;
      if (newIndex2 < 0 || newIndex2 >= options.length) {
        newIndex2 = options.length - 1;
      }
    }
    const option2 = options[newIndex2];
    if (option2.disabled || option2.type === "Group") {
      return onKeyboardNavigate(direction2, newIndex2);
    } else {
      updateHoveringIndex(newIndex2);
      scrollToItem(newIndex2);
    }
  };
  const onKeyboardSelect = () => {
    if (!expanded.value) {
      return toggleMenu();
    } else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) {
      onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
    }
  };
  const updateHoveringIndex = (idx) => {
    states.hoveringIndex = idx;
  };
  const resetHoveringIndex = () => {
    states.hoveringIndex = -1;
  };
  const setSoftFocus = () => {
    var _a2;
    const _input = inputRef.value;
    if (_input) {
      (_a2 = _input.focus) == null ? void 0 : _a2.call(_input);
    }
  };
  const onInput = (event) => {
    const value = event.target.value;
    onUpdateInputValue(value);
    if (states.displayInputValue.length > 0 && !expanded.value) {
      expanded.value = true;
    }
    states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
    if (props.multiple) {
      resetInputHeight();
    }
    if (props.remote) {
      debouncedOnInputChange();
    } else {
      return onInputChange();
    }
  };
  const handleClickOutside = () => {
    expanded.value = false;
    return handleBlur();
  };
  const handleMenuEnter = () => {
    states.inputValue = states.displayInputValue;
    return (0, import_vue479.nextTick)(() => {
      if (~indexRef.value) {
        updateHoveringIndex(indexRef.value);
        scrollToItem(states.hoveringIndex);
      }
    });
  };
  const scrollToItem = (index2) => {
    menuRef.value.scrollToItem(index2);
  };
  const initStates = () => {
    resetHoveringIndex();
    if (props.multiple) {
      if (props.modelValue.length > 0) {
        let initHovering = false;
        states.cachedOptions.length = 0;
        states.previousValue = props.modelValue.toString();
        props.modelValue.forEach((selected) => {
          const itemIndex = filteredOptions.value.findIndex((option2) => getValueKey(option2) === selected);
          if (~itemIndex) {
            states.cachedOptions.push(filteredOptions.value[itemIndex]);
            if (!initHovering) {
              updateHoveringIndex(itemIndex);
            }
            initHovering = true;
          }
        });
      } else {
        states.cachedOptions = [];
        states.previousValue = void 0;
      }
    } else {
      if (hasModelValue.value) {
        states.previousValue = props.modelValue;
        const options = filteredOptions.value;
        const selectedItemIndex = options.findIndex((option2) => getValueKey(option2) === getValueKey(props.modelValue));
        if (~selectedItemIndex) {
          states.selectedLabel = options[selectedItemIndex].label;
          updateHoveringIndex(selectedItemIndex);
        } else {
          states.selectedLabel = `${props.modelValue}`;
        }
      } else {
        states.selectedLabel = "";
        states.previousValue = void 0;
      }
    }
    clearAllNewOption();
    calculatePopperSize();
  };
  (0, import_vue479.watch)(expanded, (val) => {
    var _a2, _b;
    emit("visible-change", val);
    if (val) {
      (_b = (_a2 = popper.value).update) == null ? void 0 : _b.call(_a2);
    } else {
      states.displayInputValue = "";
      states.previousQuery = null;
      createNewOption("");
    }
  });
  (0, import_vue479.watch)(() => props.modelValue, (val, oldVal) => {
    var _a2;
    if (!val || val.toString() !== states.previousValue) {
      initStates();
    }
    if (!isEqual_default(val, oldVal) && props.validateEvent) {
      (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn(err));
    }
  }, {
    deep: true
  });
  (0, import_vue479.watch)(() => props.options, () => {
    const input = inputRef.value;
    if (!input || input && document.activeElement !== input) {
      initStates();
    }
  }, {
    deep: true
  });
  (0, import_vue479.watch)(filteredOptions, () => {
    return (0, import_vue479.nextTick)(menuRef.value.resetScrollTop);
  });
  (0, import_vue479.onMounted)(() => {
    initStates();
  });
  useResizeObserver(selectRef, handleResize);
  return {
    collapseTagSize,
    currentPlaceholder,
    expanded,
    emptyText,
    popupHeight,
    debounce: debounce$1,
    filteredOptions,
    iconComponent,
    iconReverse,
    inputWrapperStyle,
    popperSize,
    dropdownMenuVisible,
    hasModelValue,
    shouldShowPlaceholder,
    selectDisabled,
    selectSize,
    showClearBtn,
    states,
    tagMaxWidth,
    nsSelectV2,
    nsInput,
    calculatorRef,
    controlRef,
    inputRef,
    menuRef,
    popper,
    selectRef,
    selectionRef,
    popperRef,
    validateState,
    validateIcon,
    debouncedOnInputChange,
    deleteTag,
    getLabel,
    getValueKey,
    handleBlur,
    handleClear,
    handleClickOutside,
    handleDel,
    handleEsc,
    handleFocus,
    handleMenuEnter,
    handleResize,
    toggleMenu,
    scrollTo: scrollToItem,
    onInput,
    onKeyboardNavigate,
    onKeyboardSelect,
    onSelect,
    onHover: updateHoveringIndex,
    onUpdateInputValue,
    handleCompositionStart,
    handleCompositionEnd,
    handleCompositionUpdate
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/src/select.mjs
var import_shared79 = require("@vue/shared");
var _sfc_main110 = (0, import_vue480.defineComponent)({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: ElSelectMenu2,
    ElTag,
    ElTooltip,
    ElIcon
  },
  directives: { ClickOutside, ModelText: import_vue480.vModelText },
  props: SelectProps,
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(props, { emit }) {
    const modelValue = (0, import_vue480.computed)(() => {
      const { modelValue: rawModelValue, multiple } = props;
      const fallback = multiple ? [] : void 0;
      if ((0, import_shared79.isArray)(rawModelValue)) {
        return multiple ? rawModelValue : fallback;
      }
      return multiple ? fallback : rawModelValue;
    });
    const API = useSelect2((0, import_vue480.reactive)({
      ...(0, import_vue480.toRefs)(props),
      modelValue
    }), emit);
    (0, import_vue480.provide)(selectV2InjectionKey, {
      props: (0, import_vue480.reactive)({
        ...(0, import_vue480.toRefs)(props),
        height: API.popupHeight,
        modelValue
      }),
      popper: API.popper,
      onSelect: API.onSelect,
      onHover: API.onHover,
      onKeyboardNavigate: API.onKeyboardNavigate,
      onKeyboardSelect: API.onKeyboardSelect
    });
    return {
      ...API,
      modelValue
    };
  }
});
var _hoisted_170 = { key: 0 };
var _hoisted_242 = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
var _hoisted_321 = ["textContent"];
var _hoisted_410 = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
var _hoisted_57 = ["textContent"];
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = (0, import_vue480.resolveComponent)("el-tag");
  const _component_el_tooltip = (0, import_vue480.resolveComponent)("el-tooltip");
  const _component_el_icon = (0, import_vue480.resolveComponent)("el-icon");
  const _component_el_select_menu = (0, import_vue480.resolveComponent)("el-select-menu");
  const _directive_model_text = (0, import_vue480.resolveDirective)("model-text");
  const _directive_click_outside = (0, import_vue480.resolveDirective)("click-outside");
  return (0, import_vue480.withDirectives)(((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("div", {
    ref: "selectRef",
    class: (0, import_vue480.normalizeClass)([_ctx.nsSelectV2.b(), _ctx.nsSelectV2.m(_ctx.selectSize)]),
    onClick: _cache[25] || (_cache[25] = (0, import_vue480.withModifiers)((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
    onMouseenter: _cache[26] || (_cache[26] = ($event) => _ctx.states.comboBoxHovering = true),
    onMouseleave: _cache[27] || (_cache[27] = ($event) => _ctx.states.comboBoxHovering = false)
  }, [
    (0, import_vue480.createVNode)(_component_el_tooltip, {
      ref: "popper",
      visible: _ctx.dropdownMenuVisible,
      teleported: _ctx.teleported,
      "popper-class": [_ctx.nsSelectV2.e("popper"), _ctx.popperClass],
      "gpu-acceleration": false,
      "stop-popper-mouse-event": false,
      "popper-options": _ctx.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: _ctx.effect,
      placement: _ctx.placement,
      pure: "",
      transition: `${_ctx.nsSelectV2.namespace.value}-zoom-in-top`,
      trigger: "click",
      persistent: _ctx.persistent,
      onBeforeShow: _ctx.handleMenuEnter,
      onHide: _cache[24] || (_cache[24] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
    }, {
      default: (0, import_vue480.withCtx)(() => {
        var _a2;
        return [
          (0, import_vue480.createElementVNode)("div", {
            ref: "selectionRef",
            class: (0, import_vue480.normalizeClass)([
              _ctx.nsSelectV2.e("wrapper"),
              _ctx.nsSelectV2.is("focused", _ctx.states.isComposing || _ctx.expanded),
              _ctx.nsSelectV2.is("hovering", _ctx.states.comboBoxHovering),
              _ctx.nsSelectV2.is("filterable", _ctx.filterable),
              _ctx.nsSelectV2.is("disabled", _ctx.selectDisabled)
            ])
          }, [
            _ctx.$slots.prefix ? ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("div", _hoisted_170, [
              (0, import_vue480.renderSlot)(_ctx.$slots, "prefix")
            ])) : (0, import_vue480.createCommentVNode)("v-if", true),
            _ctx.multiple ? ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("div", {
              key: 1,
              class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("selection"))
            }, [
              _ctx.collapseTags && _ctx.modelValue.length > 0 ? ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("div", {
                key: 0,
                class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("selected-item"))
              }, [
                (0, import_vue480.createVNode)(_component_el_tag, {
                  closable: !_ctx.selectDisabled && !((_a2 = _ctx.states.cachedOptions[0]) == null ? void 0 : _a2.disable),
                  size: _ctx.collapseTagSize,
                  type: "info",
                  "disable-transitions": "",
                  onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.states.cachedOptions[0]))
                }, {
                  default: (0, import_vue480.withCtx)(() => {
                    var _a22;
                    return [
                      (0, import_vue480.createElementVNode)("span", {
                        class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("tags-text")),
                        style: (0, import_vue480.normalizeStyle)({
                          maxWidth: `${_ctx.tagMaxWidth}px`
                        })
                      }, (0, import_vue480.toDisplayString)((_a22 = _ctx.states.cachedOptions[0]) == null ? void 0 : _a22.label), 7)
                    ];
                  }),
                  _: 1
                }, 8, ["closable", "size"]),
                _ctx.modelValue.length > 1 ? ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_tag, {
                  key: 0,
                  closable: false,
                  size: _ctx.collapseTagSize,
                  type: "info",
                  "disable-transitions": ""
                }, {
                  default: (0, import_vue480.withCtx)(() => [
                    _ctx.collapseTagsTooltip ? ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_tooltip, {
                      key: 0,
                      disabled: _ctx.dropdownMenuVisible,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      effect: _ctx.effect,
                      placement: "bottom",
                      teleported: false
                    }, {
                      default: (0, import_vue480.withCtx)(() => [
                        (0, import_vue480.createElementVNode)("span", {
                          class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("tags-text")),
                          style: (0, import_vue480.normalizeStyle)({
                            maxWidth: `${_ctx.tagMaxWidth}px`
                          })
                        }, "+ " + (0, import_vue480.toDisplayString)(_ctx.modelValue.length - 1), 7)
                      ]),
                      content: (0, import_vue480.withCtx)(() => [
                        (0, import_vue480.createElementVNode)("div", {
                          class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("selection"))
                        }, [
                          ((0, import_vue480.openBlock)(true), (0, import_vue480.createElementBlock)(import_vue480.Fragment, null, (0, import_vue480.renderList)(_ctx.states.cachedOptions.slice(1), (selected, idx) => {
                            return (0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("div", {
                              key: idx,
                              class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("selected-item"))
                            }, [
                              ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_tag, {
                                key: _ctx.getValueKey(selected),
                                closable: !_ctx.selectDisabled && !selected.disabled,
                                size: _ctx.collapseTagSize,
                                class: "in-tooltip",
                                type: "info",
                                "disable-transitions": "",
                                onClose: ($event) => _ctx.deleteTag($event, selected)
                              }, {
                                default: (0, import_vue480.withCtx)(() => [
                                  (0, import_vue480.createElementVNode)("span", {
                                    class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("tags-text")),
                                    style: (0, import_vue480.normalizeStyle)({
                                      maxWidth: `${_ctx.tagMaxWidth}px`
                                    })
                                  }, (0, import_vue480.toDisplayString)(_ctx.getLabel(selected)), 7)
                                ]),
                                _: 2
                              }, 1032, ["closable", "size", "onClose"]))
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 1
                    }, 8, ["disabled", "effect"])) : ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("span", {
                      key: 1,
                      class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("tags-text")),
                      style: (0, import_vue480.normalizeStyle)({
                        maxWidth: `${_ctx.tagMaxWidth}px`
                      })
                    }, "+ " + (0, import_vue480.toDisplayString)(_ctx.modelValue.length - 1), 7))
                  ]),
                  _: 1
                }, 8, ["size"])) : (0, import_vue480.createCommentVNode)("v-if", true)
              ], 2)) : ((0, import_vue480.openBlock)(true), (0, import_vue480.createElementBlock)(import_vue480.Fragment, { key: 1 }, (0, import_vue480.renderList)(_ctx.states.cachedOptions, (selected, idx) => {
                return (0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("div", {
                  key: idx,
                  class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("selected-item"))
                }, [
                  ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_tag, {
                    key: _ctx.getValueKey(selected),
                    closable: !_ctx.selectDisabled && !selected.disabled,
                    size: _ctx.collapseTagSize,
                    type: "info",
                    "disable-transitions": "",
                    onClose: ($event) => _ctx.deleteTag($event, selected)
                  }, {
                    default: (0, import_vue480.withCtx)(() => [
                      (0, import_vue480.createElementVNode)("span", {
                        class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("tags-text")),
                        style: (0, import_vue480.normalizeStyle)({
                          maxWidth: `${_ctx.tagMaxWidth}px`
                        })
                      }, (0, import_vue480.toDisplayString)(_ctx.getLabel(selected)), 7)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "onClose"]))
                ], 2);
              }), 128)),
              (0, import_vue480.createElementVNode)("div", {
                class: (0, import_vue480.normalizeClass)([
                  _ctx.nsSelectV2.e("selected-item"),
                  _ctx.nsSelectV2.e("input-wrapper")
                ]),
                style: (0, import_vue480.normalizeStyle)(_ctx.inputWrapperStyle)
              }, [
                (0, import_vue480.withDirectives)((0, import_vue480.createElementVNode)("input", {
                  id: _ctx.id,
                  ref: "inputRef",
                  autocomplete: _ctx.autocomplete,
                  "aria-autocomplete": "list",
                  "aria-haspopup": "listbox",
                  autocapitalize: "off",
                  "aria-expanded": _ctx.expanded,
                  "aria-labelledby": _ctx.label,
                  class: (0, import_vue480.normalizeClass)([
                    _ctx.nsSelectV2.is(_ctx.selectSize),
                    _ctx.nsSelectV2.e("combobox-input")
                  ]),
                  disabled: _ctx.disabled,
                  role: "combobox",
                  readonly: !_ctx.filterable,
                  spellcheck: "false",
                  type: "text",
                  name: _ctx.name,
                  unselectable: _ctx.expanded ? "on" : void 0,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                  onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onInput: _cache[4] || (_cache[4] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                  onCompositionstart: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                  onCompositionupdate: _cache[6] || (_cache[6] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                  onCompositionend: _cache[7] || (_cache[7] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                  onKeydown: [
                    _cache[8] || (_cache[8] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                    _cache[9] || (_cache[9] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                    _cache[10] || (_cache[10] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                    _cache[11] || (_cache[11] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                    _cache[12] || (_cache[12] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                  ]
                }, null, 42, _hoisted_242), [
                  [_directive_model_text, _ctx.states.displayInputValue]
                ]),
                _ctx.filterable ? ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("input-calculator")),
                  textContent: (0, import_vue480.toDisplayString)(_ctx.states.displayInputValue)
                }, null, 10, _hoisted_321)) : (0, import_vue480.createCommentVNode)("v-if", true)
              ], 6)
            ], 2)) : ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)(import_vue480.Fragment, { key: 2 }, [
              (0, import_vue480.createElementVNode)("div", {
                class: (0, import_vue480.normalizeClass)([
                  _ctx.nsSelectV2.e("selected-item"),
                  _ctx.nsSelectV2.e("input-wrapper")
                ])
              }, [
                (0, import_vue480.withDirectives)((0, import_vue480.createElementVNode)("input", {
                  id: _ctx.id,
                  ref: "inputRef",
                  "aria-autocomplete": "list",
                  "aria-haspopup": "listbox",
                  "aria-labelledby": _ctx.label,
                  "aria-expanded": _ctx.expanded,
                  autocapitalize: "off",
                  autocomplete: _ctx.autocomplete,
                  class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("combobox-input")),
                  disabled: _ctx.disabled,
                  name: _ctx.name,
                  role: "combobox",
                  readonly: !_ctx.filterable,
                  spellcheck: "false",
                  type: "text",
                  unselectable: _ctx.expanded ? "on" : void 0,
                  onCompositionstart: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                  onCompositionupdate: _cache[14] || (_cache[14] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                  onCompositionend: _cache[15] || (_cache[15] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                  onFocus: _cache[16] || (_cache[16] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  onBlur: _cache[17] || (_cache[17] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onInput: _cache[18] || (_cache[18] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                  onKeydown: [
                    _cache[19] || (_cache[19] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                    _cache[20] || (_cache[20] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                    _cache[21] || (_cache[21] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                    _cache[22] || (_cache[22] = (0, import_vue480.withKeys)((0, import_vue480.withModifiers)((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"]))
                  ],
                  "onUpdate:modelValue": _cache[23] || (_cache[23] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
                }, null, 42, _hoisted_410), [
                  [_directive_model_text, _ctx.states.displayInputValue]
                ])
              ], 2),
              _ctx.filterable ? ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: (0, import_vue480.normalizeClass)([
                  _ctx.nsSelectV2.e("selected-item"),
                  _ctx.nsSelectV2.e("input-calculator")
                ]),
                textContent: (0, import_vue480.toDisplayString)(_ctx.states.displayInputValue)
              }, null, 10, _hoisted_57)) : (0, import_vue480.createCommentVNode)("v-if", true)
            ], 64)),
            _ctx.shouldShowPlaceholder ? ((0, import_vue480.openBlock)(), (0, import_vue480.createElementBlock)("span", {
              key: 3,
              class: (0, import_vue480.normalizeClass)([
                _ctx.nsSelectV2.e("placeholder"),
                _ctx.nsSelectV2.is("transparent", _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue)
              ])
            }, (0, import_vue480.toDisplayString)(_ctx.currentPlaceholder), 3)) : (0, import_vue480.createCommentVNode)("v-if", true),
            (0, import_vue480.createElementVNode)("span", {
              class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("suffix"))
            }, [
              _ctx.iconComponent ? (0, import_vue480.withDirectives)(((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_icon, {
                key: 0,
                class: (0, import_vue480.normalizeClass)([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon"), _ctx.iconReverse])
              }, {
                default: (0, import_vue480.withCtx)(() => [
                  ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)((0, import_vue480.resolveDynamicComponent)(_ctx.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])), [
                [import_vue480.vShow, !_ctx.showClearBtn]
              ]) : (0, import_vue480.createCommentVNode)("v-if", true),
              _ctx.showClearBtn && _ctx.clearIcon ? ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_icon, {
                key: 1,
                class: (0, import_vue480.normalizeClass)([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon")]),
                onClick: (0, import_vue480.withModifiers)(_ctx.handleClear, ["prevent", "stop"])
              }, {
                default: (0, import_vue480.withCtx)(() => [
                  ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)((0, import_vue480.resolveDynamicComponent)(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (0, import_vue480.createCommentVNode)("v-if", true),
              _ctx.validateState && _ctx.validateIcon ? ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)(_component_el_icon, {
                key: 2,
                class: (0, import_vue480.normalizeClass)([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
              }, {
                default: (0, import_vue480.withCtx)(() => [
                  ((0, import_vue480.openBlock)(), (0, import_vue480.createBlock)((0, import_vue480.resolveDynamicComponent)(_ctx.validateIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : (0, import_vue480.createCommentVNode)("v-if", true)
            ], 2)
          ], 2)
        ];
      }),
      content: (0, import_vue480.withCtx)(() => [
        (0, import_vue480.createVNode)(_component_el_select_menu, {
          ref: "menuRef",
          data: _ctx.filteredOptions,
          width: _ctx.popperSize,
          "hovering-index": _ctx.states.hoveringIndex,
          "scrollbar-always-on": _ctx.scrollbarAlwaysOn
        }, {
          default: (0, import_vue480.withCtx)((scope) => [
            (0, import_vue480.renderSlot)(_ctx.$slots, "default", (0, import_vue480.normalizeProps)((0, import_vue480.guardReactiveProps)(scope)))
          ]),
          empty: (0, import_vue480.withCtx)(() => [
            (0, import_vue480.renderSlot)(_ctx.$slots, "empty", {}, () => [
              (0, import_vue480.createElementVNode)("p", {
                class: (0, import_vue480.normalizeClass)(_ctx.nsSelectV2.e("empty"))
              }, (0, import_vue480.toDisplayString)(_ctx.emptyText ? _ctx.emptyText : ""), 3)
            ])
          ]),
          _: 3
        }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
  ]);
}
var Select2 = /* @__PURE__ */ _export_sfc(_sfc_main110, [["render", _sfc_render37], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/select-v2/index.mjs
Select2.install = (app) => {
  app.component(Select2.name, Select2);
};
var _Select = Select2;
var ElSelectV2 = _Select;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/src/skeleton2.mjs
var import_vue482 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/src/skeleton.mjs
var skeletonProps = buildProps({
  animated: {
    type: Boolean,
    default: false
  },
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: true
  },
  throttle: {
    type: Number
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/src/skeleton-item2.mjs
var import_vue481 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/src/skeleton-item.mjs
var skeletonItemProps = buildProps({
  variant: {
    type: String,
    values: [
      "circle",
      "rect",
      "h1",
      "h3",
      "text",
      "caption",
      "p",
      "image",
      "button"
    ],
    default: "text"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/src/skeleton-item2.mjs
var __default__72 = (0, import_vue481.defineComponent)({
  name: "ElSkeletonItem"
});
var _sfc_main111 = /* @__PURE__ */ (0, import_vue481.defineComponent)({
  ...__default__72,
  props: skeletonItemProps,
  setup(__props) {
    const ns2 = useNamespace("skeleton");
    return (_ctx, _cache) => {
      return (0, import_vue481.openBlock)(), (0, import_vue481.createElementBlock)("div", {
        class: (0, import_vue481.normalizeClass)([(0, import_vue481.unref)(ns2).e("item"), (0, import_vue481.unref)(ns2).e(_ctx.variant)])
      }, [
        _ctx.variant === "image" ? ((0, import_vue481.openBlock)(), (0, import_vue481.createBlock)((0, import_vue481.unref)(picture_filled_default), { key: 0 })) : (0, import_vue481.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var SkeletonItem = /* @__PURE__ */ _export_sfc(_sfc_main111, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/src/skeleton2.mjs
var __default__73 = (0, import_vue482.defineComponent)({
  name: "ElSkeleton"
});
var _sfc_main112 = /* @__PURE__ */ (0, import_vue482.defineComponent)({
  ...__default__73,
  props: skeletonProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("skeleton");
    const uiLoading = useThrottleRender((0, import_vue482.toRef)(props, "loading"), props.throttle);
    expose({
      uiLoading
    });
    return (_ctx, _cache) => {
      return (0, import_vue482.unref)(uiLoading) ? ((0, import_vue482.openBlock)(), (0, import_vue482.createElementBlock)("div", (0, import_vue482.mergeProps)({
        key: 0,
        class: [(0, import_vue482.unref)(ns2).b(), (0, import_vue482.unref)(ns2).is("animated", _ctx.animated)]
      }, _ctx.$attrs), [
        ((0, import_vue482.openBlock)(true), (0, import_vue482.createElementBlock)(import_vue482.Fragment, null, (0, import_vue482.renderList)(_ctx.count, (i) => {
          return (0, import_vue482.openBlock)(), (0, import_vue482.createElementBlock)(import_vue482.Fragment, { key: i }, [
            _ctx.loading ? (0, import_vue482.renderSlot)(_ctx.$slots, "template", { key: i }, () => [
              (0, import_vue482.createVNode)(SkeletonItem, {
                class: (0, import_vue482.normalizeClass)((0, import_vue482.unref)(ns2).is("first")),
                variant: "p"
              }, null, 8, ["class"]),
              ((0, import_vue482.openBlock)(true), (0, import_vue482.createElementBlock)(import_vue482.Fragment, null, (0, import_vue482.renderList)(_ctx.rows, (item) => {
                return (0, import_vue482.openBlock)(), (0, import_vue482.createBlock)(SkeletonItem, {
                  key: item,
                  class: (0, import_vue482.normalizeClass)([
                    (0, import_vue482.unref)(ns2).e("paragraph"),
                    (0, import_vue482.unref)(ns2).is("last", item === _ctx.rows && _ctx.rows > 1)
                  ]),
                  variant: "p"
                }, null, 8, ["class"]);
              }), 128))
            ]) : (0, import_vue482.createCommentVNode)("v-if", true)
          ], 64);
        }), 128))
      ], 16)) : (0, import_vue482.renderSlot)(_ctx.$slots, "default", (0, import_vue482.normalizeProps)((0, import_vue482.mergeProps)({ key: 1 }, _ctx.$attrs)));
    };
  }
});
var Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main112, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/skeleton/index.mjs
var ElSkeleton = withInstall(Skeleton, {
  SkeletonItem
});
var ElSkeletonItem = withNoopInstall(SkeletonItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/slider2.mjs
var import_vue491 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/slider.mjs
var import_shared80 = require("@vue/shared");
var sliderProps = buildProps({
  modelValue: {
    type: definePropType([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: true
  },
  size: useSizeProp,
  inputSize: useSizeProp,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: true
  },
  formatTooltip: {
    type: definePropType(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: definePropType(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Ee,
    default: "top"
  },
  marks: {
    type: definePropType(Object)
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var isValidValue = (value) => isNumber(value) || (0, import_shared80.isArray)(value) && value.every(isNumber);
var sliderEmits = {
  [UPDATE_MODEL_EVENT]: isValidValue,
  [INPUT_EVENT]: isValidValue,
  [CHANGE_EVENT]: isValidValue
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/button2.mjs
var import_vue489 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/composables/use-lifecycle.mjs
var import_vue483 = require("vue");
var useLifecycle = (props, initData, resetSize) => {
  const sliderWrapper = (0, import_vue483.ref)();
  (0, import_vue483.onMounted)(async () => {
    if (props.range) {
      if (Array.isArray(props.modelValue)) {
        initData.firstValue = Math.max(props.min, props.modelValue[0]);
        initData.secondValue = Math.min(props.max, props.modelValue[1]);
      } else {
        initData.firstValue = props.min;
        initData.secondValue = props.max;
      }
      initData.oldValue = [initData.firstValue, initData.secondValue];
    } else {
      if (typeof props.modelValue !== "number" || Number.isNaN(props.modelValue)) {
        initData.firstValue = props.min;
      } else {
        initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
      }
      initData.oldValue = initData.firstValue;
    }
    useEventListener(window, "resize", resetSize);
    await (0, import_vue483.nextTick)();
    resetSize();
  });
  return {
    sliderWrapper
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/composables/use-marks.mjs
var import_vue484 = require("vue");
var useMarks = (props) => {
  return (0, import_vue484.computed)(() => {
    if (!props.marks) {
      return [];
    }
    const marksKeys = Object.keys(props.marks);
    return marksKeys.map(Number.parseFloat).sort((a3, b3) => a3 - b3).filter((point) => point <= props.max && point >= props.min).map((point) => ({
      point,
      position: (point - props.min) * 100 / (props.max - props.min),
      mark: props.marks[point]
    }));
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/composables/use-slide.mjs
var import_vue485 = require("vue");
var useSlide = (props, initData, emit) => {
  const { form: elForm, formItem: elFormItem } = useFormItem();
  const slider = (0, import_vue485.shallowRef)();
  const firstButton = (0, import_vue485.ref)();
  const secondButton = (0, import_vue485.ref)();
  const buttonRefs = {
    firstButton,
    secondButton
  };
  const sliderDisabled = (0, import_vue485.computed)(() => {
    return props.disabled || (elForm == null ? void 0 : elForm.disabled) || false;
  });
  const minValue = (0, import_vue485.computed)(() => {
    return Math.min(initData.firstValue, initData.secondValue);
  });
  const maxValue = (0, import_vue485.computed)(() => {
    return Math.max(initData.firstValue, initData.secondValue);
  });
  const barSize = (0, import_vue485.computed)(() => {
    return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
  });
  const barStart = (0, import_vue485.computed)(() => {
    return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
  });
  const runwayStyle = (0, import_vue485.computed)(() => {
    return props.vertical ? { height: props.height } : {};
  });
  const barStyle = (0, import_vue485.computed)(() => {
    return props.vertical ? {
      height: barSize.value,
      bottom: barStart.value
    } : {
      width: barSize.value,
      left: barStart.value
    };
  });
  const resetSize = () => {
    if (slider.value) {
      initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
    }
  };
  const getButtonRefByPercent = (percent) => {
    const targetValue = props.min + percent * (props.max - props.min) / 100;
    if (!props.range) {
      return firstButton;
    }
    let buttonRefName;
    if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
      buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
    } else {
      buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
    }
    return buttonRefs[buttonRefName];
  };
  const setPosition = (percent) => {
    const buttonRef = getButtonRefByPercent(percent);
    buttonRef.value.setPosition(percent);
    return buttonRef;
  };
  const setFirstValue = (firstValue) => {
    initData.firstValue = firstValue;
    _emit(props.range ? [minValue.value, maxValue.value] : firstValue);
  };
  const setSecondValue = (secondValue) => {
    initData.secondValue = secondValue;
    if (props.range) {
      _emit([minValue.value, maxValue.value]);
    }
  };
  const _emit = (val) => {
    emit(UPDATE_MODEL_EVENT, val);
    emit(INPUT_EVENT, val);
  };
  const emitChange = async () => {
    await (0, import_vue485.nextTick)();
    emit(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);
  };
  const handleSliderPointerEvent = (event) => {
    var _a2, _b, _c, _d, _e, _f;
    if (sliderDisabled.value || initData.dragging)
      return;
    resetSize();
    let newPercent = 0;
    if (props.vertical) {
      const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
      const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
      newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
    } else {
      const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
      const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
      newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
    }
    if (newPercent < 0 || newPercent > 100)
      return;
    return setPosition(newPercent);
  };
  const onSliderWrapperPrevent = (event) => {
    var _a2, _b;
    if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
      event.preventDefault();
    }
  };
  const onSliderDown = async (event) => {
    const buttonRef = handleSliderPointerEvent(event);
    if (buttonRef) {
      await (0, import_vue485.nextTick)();
      buttonRef.value.onButtonDown(event);
    }
  };
  const onSliderClick = (event) => {
    const buttonRef = handleSliderPointerEvent(event);
    if (buttonRef) {
      emitChange();
    }
  };
  return {
    elFormItem,
    slider,
    firstButton,
    secondButton,
    sliderDisabled,
    minValue,
    maxValue,
    runwayStyle,
    barStyle,
    resetSize,
    setPosition,
    emitChange,
    onSliderWrapperPrevent,
    onSliderClick,
    onSliderDown,
    setFirstValue,
    setSecondValue
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/composables/use-slider-button.mjs
var import_vue486 = require("vue");
var { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
var useTooltip = (props, formatTooltip, showTooltip) => {
  const tooltip = (0, import_vue486.ref)();
  const tooltipVisible = (0, import_vue486.ref)(false);
  const enableFormat = (0, import_vue486.computed)(() => {
    return formatTooltip.value instanceof Function;
  });
  const formatValue = (0, import_vue486.computed)(() => {
    return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
  });
  const displayTooltip = debounce_default(() => {
    showTooltip.value && (tooltipVisible.value = true);
  }, 50);
  const hideTooltip = debounce_default(() => {
    showTooltip.value && (tooltipVisible.value = false);
  }, 50);
  return {
    tooltip,
    tooltipVisible,
    formatValue,
    displayTooltip,
    hideTooltip
  };
};
var useSliderButton = (props, initData, emit) => {
  const {
    disabled,
    min: min4,
    max: max4,
    step,
    showTooltip,
    precision,
    sliderSize,
    formatTooltip,
    emitChange,
    resetSize,
    updateDragging
  } = (0, import_vue486.inject)(sliderContextKey);
  const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props, formatTooltip, showTooltip);
  const button = (0, import_vue486.ref)();
  const currentPosition = (0, import_vue486.computed)(() => {
    return `${(props.modelValue - min4.value) / (max4.value - min4.value) * 100}%`;
  });
  const wrapperStyle = (0, import_vue486.computed)(() => {
    return props.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
  });
  const handleMouseEnter = () => {
    initData.hovering = true;
    displayTooltip();
  };
  const handleMouseLeave = () => {
    initData.hovering = false;
    if (!initData.dragging) {
      hideTooltip();
    }
  };
  const onButtonDown = (event) => {
    if (disabled.value)
      return;
    event.preventDefault();
    onDragStart(event);
    window.addEventListener("mousemove", onDragging);
    window.addEventListener("touchmove", onDragging);
    window.addEventListener("mouseup", onDragEnd);
    window.addEventListener("touchend", onDragEnd);
    window.addEventListener("contextmenu", onDragEnd);
    button.value.focus();
  };
  const incrementPosition = (amount) => {
    if (disabled.value)
      return;
    initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max4.value - min4.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const onLeftKeyDown = () => {
    incrementPosition(-step.value);
  };
  const onRightKeyDown = () => {
    incrementPosition(step.value);
  };
  const onPageDownKeyDown = () => {
    incrementPosition(-step.value * 4);
  };
  const onPageUpKeyDown = () => {
    incrementPosition(step.value * 4);
  };
  const onHomeKeyDown = () => {
    if (disabled.value)
      return;
    setPosition(0);
    emitChange();
  };
  const onEndKeyDown = () => {
    if (disabled.value)
      return;
    setPosition(100);
    emitChange();
  };
  const onKeyDown = (event) => {
    let isPreventDefault = true;
    if ([left, down].includes(event.key)) {
      onLeftKeyDown();
    } else if ([right, up].includes(event.key)) {
      onRightKeyDown();
    } else if (event.key === home) {
      onHomeKeyDown();
    } else if (event.key === end) {
      onEndKeyDown();
    } else if (event.key === pageDown) {
      onPageDownKeyDown();
    } else if (event.key === pageUp) {
      onPageUpKeyDown();
    } else {
      isPreventDefault = false;
    }
    isPreventDefault && event.preventDefault();
  };
  const getClientXY2 = (event) => {
    let clientX;
    let clientY;
    if (event.type.startsWith("touch")) {
      clientY = event.touches[0].clientY;
      clientX = event.touches[0].clientX;
    } else {
      clientY = event.clientY;
      clientX = event.clientX;
    }
    return {
      clientX,
      clientY
    };
  };
  const onDragStart = (event) => {
    initData.dragging = true;
    initData.isClick = true;
    const { clientX, clientY } = getClientXY2(event);
    if (props.vertical) {
      initData.startY = clientY;
    } else {
      initData.startX = clientX;
    }
    initData.startPosition = Number.parseFloat(currentPosition.value);
    initData.newPosition = initData.startPosition;
  };
  const onDragging = (event) => {
    if (initData.dragging) {
      initData.isClick = false;
      displayTooltip();
      resetSize();
      let diff;
      const { clientX, clientY } = getClientXY2(event);
      if (props.vertical) {
        initData.currentY = clientY;
        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
      } else {
        initData.currentX = clientX;
        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
      }
      initData.newPosition = initData.startPosition + diff;
      setPosition(initData.newPosition);
    }
  };
  const onDragEnd = () => {
    if (initData.dragging) {
      setTimeout(() => {
        initData.dragging = false;
        if (!initData.hovering) {
          hideTooltip();
        }
        if (!initData.isClick) {
          setPosition(initData.newPosition);
        }
        emitChange();
      }, 0);
      window.removeEventListener("mousemove", onDragging);
      window.removeEventListener("touchmove", onDragging);
      window.removeEventListener("mouseup", onDragEnd);
      window.removeEventListener("touchend", onDragEnd);
      window.removeEventListener("contextmenu", onDragEnd);
    }
  };
  const setPosition = async (newPosition) => {
    if (newPosition === null || Number.isNaN(+newPosition))
      return;
    if (newPosition < 0) {
      newPosition = 0;
    } else if (newPosition > 100) {
      newPosition = 100;
    }
    const lengthPerStep = 100 / ((max4.value - min4.value) / step.value);
    const steps = Math.round(newPosition / lengthPerStep);
    let value = steps * lengthPerStep * (max4.value - min4.value) * 0.01 + min4.value;
    value = Number.parseFloat(value.toFixed(precision.value));
    if (value !== props.modelValue) {
      emit(UPDATE_MODEL_EVENT, value);
    }
    if (!initData.dragging && props.modelValue !== initData.oldValue) {
      initData.oldValue = props.modelValue;
    }
    await (0, import_vue486.nextTick)();
    initData.dragging && displayTooltip();
    tooltip.value.updatePopper();
  };
  (0, import_vue486.watch)(() => initData.dragging, (val) => {
    updateDragging(val);
  });
  return {
    disabled,
    button,
    tooltip,
    tooltipVisible,
    showTooltip,
    wrapperStyle,
    formatValue,
    handleMouseEnter,
    handleMouseLeave,
    onButtonDown,
    onKeyDown,
    setPosition
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/composables/use-stops.mjs
var import_vue487 = require("vue");
var useStops = (props, initData, minValue, maxValue) => {
  const stops = (0, import_vue487.computed)(() => {
    if (!props.showStops || props.min > props.max)
      return [];
    if (props.step === 0) {
      debugWarn("ElSlider", "step should not be 0.");
      return [];
    }
    const stopCount = (props.max - props.min) / props.step;
    const stepWidth = 100 * props.step / (props.max - props.min);
    const result = Array.from({ length: stopCount - 1 }).map((_2, index2) => (index2 + 1) * stepWidth);
    if (props.range) {
      return result.filter((step) => {
        return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
      });
    } else {
      return result.filter((step) => step > 100 * (initData.firstValue - props.min) / (props.max - props.min));
    }
  });
  const getStopStyle = (position) => {
    return props.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
  };
  return {
    stops,
    getStopStyle
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/composables/use-watch.mjs
var import_vue488 = require("vue");
var useWatch = (props, initData, minValue, maxValue, emit, elFormItem) => {
  const _emit = (val) => {
    emit(UPDATE_MODEL_EVENT, val);
    emit(INPUT_EVENT, val);
  };
  const valueChanged = () => {
    if (props.range) {
      return ![minValue.value, maxValue.value].every((item, index2) => item === initData.oldValue[index2]);
    } else {
      return props.modelValue !== initData.oldValue;
    }
  };
  const setValues = () => {
    var _a2, _b;
    if (props.min > props.max) {
      throwError("Slider", "min should not be greater than max.");
      return;
    }
    const val = props.modelValue;
    if (props.range && Array.isArray(val)) {
      if (val[1] < props.min) {
        _emit([props.min, props.min]);
      } else if (val[0] > props.max) {
        _emit([props.max, props.max]);
      } else if (val[0] < props.min) {
        _emit([props.min, val[1]]);
      } else if (val[1] > props.max) {
        _emit([val[0], props.max]);
      } else {
        initData.firstValue = val[0];
        initData.secondValue = val[1];
        if (valueChanged()) {
          if (props.validateEvent) {
            (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn(err));
          }
          initData.oldValue = val.slice();
        }
      }
    } else if (!props.range && typeof val === "number" && !Number.isNaN(val)) {
      if (val < props.min) {
        _emit(props.min);
      } else if (val > props.max) {
        _emit(props.max);
      } else {
        initData.firstValue = val;
        if (valueChanged()) {
          if (props.validateEvent) {
            (_b = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "change").catch((err) => debugWarn(err));
          }
          initData.oldValue = val;
        }
      }
    }
  };
  setValues();
  (0, import_vue488.watch)(() => initData.dragging, (val) => {
    if (!val) {
      setValues();
    }
  });
  (0, import_vue488.watch)(() => props.modelValue, (val, oldVal) => {
    if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index2) => item === oldVal[index2]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
      return;
    }
    setValues();
  }, {
    deep: true
  });
  (0, import_vue488.watch)(() => [props.min, props.max], () => {
    setValues();
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/button.mjs
var sliderButtonProps = buildProps({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Ee,
    default: "top"
  }
});
var sliderButtonEmits = {
  [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/button2.mjs
var _hoisted_171 = ["tabindex"];
var __default__74 = (0, import_vue489.defineComponent)({
  name: "ElSliderButton"
});
var _sfc_main113 = /* @__PURE__ */ (0, import_vue489.defineComponent)({
  ...__default__74,
  props: sliderButtonProps,
  emits: sliderButtonEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("slider");
    const initData = (0, import_vue489.reactive)({
      hovering: false,
      dragging: false,
      isClick: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: props.modelValue
    });
    const {
      disabled,
      button,
      tooltip,
      showTooltip,
      tooltipVisible,
      wrapperStyle,
      formatValue,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onKeyDown,
      setPosition
    } = useSliderButton(props, initData, emit);
    const { hovering, dragging } = (0, import_vue489.toRefs)(initData);
    expose({
      onButtonDown,
      onKeyDown,
      setPosition,
      hovering,
      dragging
    });
    return (_ctx, _cache) => {
      return (0, import_vue489.openBlock)(), (0, import_vue489.createElementBlock)("div", {
        ref_key: "button",
        ref: button,
        class: (0, import_vue489.normalizeClass)([(0, import_vue489.unref)(ns2).e("button-wrapper"), { hover: (0, import_vue489.unref)(hovering), dragging: (0, import_vue489.unref)(dragging) }]),
        style: (0, import_vue489.normalizeStyle)((0, import_vue489.unref)(wrapperStyle)),
        tabindex: (0, import_vue489.unref)(disabled) ? -1 : 0,
        onMouseenter: _cache[0] || (_cache[0] = (...args) => (0, import_vue489.unref)(handleMouseEnter) && (0, import_vue489.unref)(handleMouseEnter)(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => (0, import_vue489.unref)(handleMouseLeave) && (0, import_vue489.unref)(handleMouseLeave)(...args)),
        onMousedown: _cache[2] || (_cache[2] = (...args) => (0, import_vue489.unref)(onButtonDown) && (0, import_vue489.unref)(onButtonDown)(...args)),
        onTouchstart: _cache[3] || (_cache[3] = (...args) => (0, import_vue489.unref)(onButtonDown) && (0, import_vue489.unref)(onButtonDown)(...args)),
        onFocus: _cache[4] || (_cache[4] = (...args) => (0, import_vue489.unref)(handleMouseEnter) && (0, import_vue489.unref)(handleMouseEnter)(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => (0, import_vue489.unref)(handleMouseLeave) && (0, import_vue489.unref)(handleMouseLeave)(...args)),
        onKeydown: _cache[6] || (_cache[6] = (...args) => (0, import_vue489.unref)(onKeyDown) && (0, import_vue489.unref)(onKeyDown)(...args))
      }, [
        (0, import_vue489.createVNode)((0, import_vue489.unref)(ElTooltip), {
          ref_key: "tooltip",
          ref: tooltip,
          visible: (0, import_vue489.unref)(tooltipVisible),
          placement: _ctx.placement,
          "fallback-placements": ["top", "bottom", "right", "left"],
          "stop-popper-mouse-event": false,
          "popper-class": _ctx.tooltipClass,
          disabled: !(0, import_vue489.unref)(showTooltip),
          persistent: ""
        }, {
          content: (0, import_vue489.withCtx)(() => [
            (0, import_vue489.createElementVNode)("span", null, (0, import_vue489.toDisplayString)((0, import_vue489.unref)(formatValue)), 1)
          ]),
          default: (0, import_vue489.withCtx)(() => [
            (0, import_vue489.createElementVNode)("div", {
              class: (0, import_vue489.normalizeClass)([(0, import_vue489.unref)(ns2).e("button"), { hover: (0, import_vue489.unref)(hovering), dragging: (0, import_vue489.unref)(dragging) }])
            }, null, 2)
          ]),
          _: 1
        }, 8, ["visible", "placement", "popper-class", "disabled"])
      ], 46, _hoisted_171);
    };
  }
});
var SliderButton = /* @__PURE__ */ _export_sfc(_sfc_main113, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/marker.mjs
var import_vue490 = require("vue");
var import_shared81 = require("@vue/shared");
var sliderMarkerProps = buildProps({
  mark: {
    type: definePropType([String, Object]),
    default: void 0
  }
});
var SliderMarker = (0, import_vue490.defineComponent)({
  name: "ElSliderMarker",
  props: sliderMarkerProps,
  setup(props) {
    const ns2 = useNamespace("slider");
    const label = (0, import_vue490.computed)(() => {
      return (0, import_shared81.isString)(props.mark) ? props.mark : props.mark.label;
    });
    const style = (0, import_vue490.computed)(() => (0, import_shared81.isString)(props.mark) ? void 0 : props.mark.style);
    return () => (0, import_vue490.h)("div", {
      class: ns2.e("marks-text"),
      style: style.value
    }, label.value);
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/src/slider2.mjs
var _hoisted_175 = ["id", "role", "aria-label", "aria-labelledby"];
var _hoisted_244 = { key: 1 };
var __default__75 = (0, import_vue491.defineComponent)({
  name: "ElSlider"
});
var _sfc_main114 = /* @__PURE__ */ (0, import_vue491.defineComponent)({
  ...__default__75,
  props: sliderProps,
  emits: sliderEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("slider");
    const { t } = useLocale();
    const initData = (0, import_vue491.reactive)({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: false,
      sliderSize: 1
    });
    const {
      elFormItem,
      slider,
      firstButton,
      secondButton,
      sliderDisabled,
      minValue,
      maxValue,
      runwayStyle,
      barStyle,
      resetSize,
      emitChange,
      onSliderWrapperPrevent,
      onSliderClick,
      onSliderDown,
      setFirstValue,
      setSecondValue
    } = useSlide(props, initData, emit);
    const { stops, getStopStyle } = useStops(props, initData, minValue, maxValue);
    const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
      formItemContext: elFormItem
    });
    const sliderWrapperSize = useSize();
    const sliderInputSize = (0, import_vue491.computed)(() => props.inputSize || sliderWrapperSize.value);
    const groupLabel = (0, import_vue491.computed)(() => {
      return props.label || t("el.slider.defaultLabel", {
        min: props.min,
        max: props.max
      });
    });
    const firstButtonLabel = (0, import_vue491.computed)(() => {
      if (props.range) {
        return props.rangeStartLabel || t("el.slider.defaultRangeStartLabel");
      } else {
        return groupLabel.value;
      }
    });
    const firstValueText = (0, import_vue491.computed)(() => {
      return props.formatValueText ? props.formatValueText(firstValue.value) : `${firstValue.value}`;
    });
    const secondButtonLabel = (0, import_vue491.computed)(() => {
      return props.rangeEndLabel || t("el.slider.defaultRangeEndLabel");
    });
    const secondValueText = (0, import_vue491.computed)(() => {
      return props.formatValueText ? props.formatValueText(secondValue.value) : `${secondValue.value}`;
    });
    const sliderKls = (0, import_vue491.computed)(() => [
      ns2.b(),
      ns2.m(sliderWrapperSize.value),
      ns2.is("vertical", props.vertical),
      { [ns2.m("with-input")]: props.showInput }
    ]);
    const markList = useMarks(props);
    useWatch(props, initData, minValue, maxValue, emit, elFormItem);
    const precision = (0, import_vue491.computed)(() => {
      const precisions = [props.min, props.max, props.step].map((item) => {
        const decimal = `${item}`.split(".")[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    });
    const { sliderWrapper } = useLifecycle(props, initData, resetSize);
    const { firstValue, secondValue, sliderSize } = (0, import_vue491.toRefs)(initData);
    const updateDragging = (val) => {
      initData.dragging = val;
    };
    (0, import_vue491.provide)(sliderContextKey, {
      ...(0, import_vue491.toRefs)(props),
      sliderSize,
      disabled: sliderDisabled,
      precision,
      emitChange,
      resetSize,
      updateDragging
    });
    expose({
      onSliderClick
    });
    return (_ctx, _cache) => {
      var _a2, _b;
      return (0, import_vue491.openBlock)(), (0, import_vue491.createElementBlock)("div", {
        id: _ctx.range ? (0, import_vue491.unref)(inputId) : void 0,
        ref_key: "sliderWrapper",
        ref: sliderWrapper,
        class: (0, import_vue491.normalizeClass)((0, import_vue491.unref)(sliderKls)),
        role: _ctx.range ? "group" : void 0,
        "aria-label": _ctx.range && !(0, import_vue491.unref)(isLabeledByFormItem) ? (0, import_vue491.unref)(groupLabel) : void 0,
        "aria-labelledby": _ctx.range && (0, import_vue491.unref)(isLabeledByFormItem) ? (_a2 = (0, import_vue491.unref)(elFormItem)) == null ? void 0 : _a2.labelId : void 0,
        onTouchstart: _cache[2] || (_cache[2] = (...args) => (0, import_vue491.unref)(onSliderWrapperPrevent) && (0, import_vue491.unref)(onSliderWrapperPrevent)(...args)),
        onTouchmove: _cache[3] || (_cache[3] = (...args) => (0, import_vue491.unref)(onSliderWrapperPrevent) && (0, import_vue491.unref)(onSliderWrapperPrevent)(...args))
      }, [
        (0, import_vue491.createElementVNode)("div", {
          ref_key: "slider",
          ref: slider,
          class: (0, import_vue491.normalizeClass)([
            (0, import_vue491.unref)(ns2).e("runway"),
            { "show-input": _ctx.showInput && !_ctx.range },
            (0, import_vue491.unref)(ns2).is("disabled", (0, import_vue491.unref)(sliderDisabled))
          ]),
          style: (0, import_vue491.normalizeStyle)((0, import_vue491.unref)(runwayStyle)),
          onMousedown: _cache[0] || (_cache[0] = (...args) => (0, import_vue491.unref)(onSliderDown) && (0, import_vue491.unref)(onSliderDown)(...args)),
          onTouchstart: _cache[1] || (_cache[1] = (...args) => (0, import_vue491.unref)(onSliderDown) && (0, import_vue491.unref)(onSliderDown)(...args))
        }, [
          (0, import_vue491.createElementVNode)("div", {
            class: (0, import_vue491.normalizeClass)((0, import_vue491.unref)(ns2).e("bar")),
            style: (0, import_vue491.normalizeStyle)((0, import_vue491.unref)(barStyle))
          }, null, 6),
          (0, import_vue491.createVNode)(SliderButton, {
            id: !_ctx.range ? (0, import_vue491.unref)(inputId) : void 0,
            ref_key: "firstButton",
            ref: firstButton,
            "model-value": (0, import_vue491.unref)(firstValue),
            vertical: _ctx.vertical,
            "tooltip-class": _ctx.tooltipClass,
            placement: _ctx.placement,
            role: "slider",
            "aria-label": _ctx.range || !(0, import_vue491.unref)(isLabeledByFormItem) ? (0, import_vue491.unref)(firstButtonLabel) : void 0,
            "aria-labelledby": !_ctx.range && (0, import_vue491.unref)(isLabeledByFormItem) ? (_b = (0, import_vue491.unref)(elFormItem)) == null ? void 0 : _b.labelId : void 0,
            "aria-valuemin": _ctx.min,
            "aria-valuemax": _ctx.range ? (0, import_vue491.unref)(secondValue) : _ctx.max,
            "aria-valuenow": (0, import_vue491.unref)(firstValue),
            "aria-valuetext": (0, import_vue491.unref)(firstValueText),
            "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
            "aria-disabled": (0, import_vue491.unref)(sliderDisabled),
            "onUpdate:modelValue": (0, import_vue491.unref)(setFirstValue)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          _ctx.range ? ((0, import_vue491.openBlock)(), (0, import_vue491.createBlock)(SliderButton, {
            key: 0,
            ref_key: "secondButton",
            ref: secondButton,
            "model-value": (0, import_vue491.unref)(secondValue),
            vertical: _ctx.vertical,
            "tooltip-class": _ctx.tooltipClass,
            placement: _ctx.placement,
            role: "slider",
            "aria-label": (0, import_vue491.unref)(secondButtonLabel),
            "aria-valuemin": (0, import_vue491.unref)(firstValue),
            "aria-valuemax": _ctx.max,
            "aria-valuenow": (0, import_vue491.unref)(secondValue),
            "aria-valuetext": (0, import_vue491.unref)(secondValueText),
            "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
            "aria-disabled": (0, import_vue491.unref)(sliderDisabled),
            "onUpdate:modelValue": (0, import_vue491.unref)(setSecondValue)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : (0, import_vue491.createCommentVNode)("v-if", true),
          _ctx.showStops ? ((0, import_vue491.openBlock)(), (0, import_vue491.createElementBlock)("div", _hoisted_244, [
            ((0, import_vue491.openBlock)(true), (0, import_vue491.createElementBlock)(import_vue491.Fragment, null, (0, import_vue491.renderList)((0, import_vue491.unref)(stops), (item, key) => {
              return (0, import_vue491.openBlock)(), (0, import_vue491.createElementBlock)("div", {
                key,
                class: (0, import_vue491.normalizeClass)((0, import_vue491.unref)(ns2).e("stop")),
                style: (0, import_vue491.normalizeStyle)((0, import_vue491.unref)(getStopStyle)(item))
              }, null, 6);
            }), 128))
          ])) : (0, import_vue491.createCommentVNode)("v-if", true),
          (0, import_vue491.unref)(markList).length > 0 ? ((0, import_vue491.openBlock)(), (0, import_vue491.createElementBlock)(import_vue491.Fragment, { key: 2 }, [
            (0, import_vue491.createElementVNode)("div", null, [
              ((0, import_vue491.openBlock)(true), (0, import_vue491.createElementBlock)(import_vue491.Fragment, null, (0, import_vue491.renderList)((0, import_vue491.unref)(markList), (item, key) => {
                return (0, import_vue491.openBlock)(), (0, import_vue491.createElementBlock)("div", {
                  key,
                  style: (0, import_vue491.normalizeStyle)((0, import_vue491.unref)(getStopStyle)(item.position)),
                  class: (0, import_vue491.normalizeClass)([(0, import_vue491.unref)(ns2).e("stop"), (0, import_vue491.unref)(ns2).e("marks-stop")])
                }, null, 6);
              }), 128))
            ]),
            (0, import_vue491.createElementVNode)("div", {
              class: (0, import_vue491.normalizeClass)((0, import_vue491.unref)(ns2).e("marks"))
            }, [
              ((0, import_vue491.openBlock)(true), (0, import_vue491.createElementBlock)(import_vue491.Fragment, null, (0, import_vue491.renderList)((0, import_vue491.unref)(markList), (item, key) => {
                return (0, import_vue491.openBlock)(), (0, import_vue491.createBlock)((0, import_vue491.unref)(SliderMarker), {
                  key,
                  mark: item.mark,
                  style: (0, import_vue491.normalizeStyle)((0, import_vue491.unref)(getStopStyle)(item.position))
                }, null, 8, ["mark", "style"]);
              }), 128))
            ], 2)
          ], 64)) : (0, import_vue491.createCommentVNode)("v-if", true)
        ], 38),
        _ctx.showInput && !_ctx.range ? ((0, import_vue491.openBlock)(), (0, import_vue491.createBlock)((0, import_vue491.unref)(ElInputNumber), {
          key: 0,
          ref: "input",
          "model-value": (0, import_vue491.unref)(firstValue),
          class: (0, import_vue491.normalizeClass)((0, import_vue491.unref)(ns2).e("input")),
          step: _ctx.step,
          disabled: (0, import_vue491.unref)(sliderDisabled),
          controls: _ctx.showInputControls,
          min: _ctx.min,
          max: _ctx.max,
          debounce: _ctx.debounce,
          size: (0, import_vue491.unref)(sliderInputSize),
          "onUpdate:modelValue": (0, import_vue491.unref)(setFirstValue),
          onChange: (0, import_vue491.unref)(emitChange)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : (0, import_vue491.createCommentVNode)("v-if", true)
      ], 42, _hoisted_175);
    };
  }
});
var Slider = /* @__PURE__ */ _export_sfc(_sfc_main114, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/slider/index.mjs
var ElSlider = withInstall(Slider);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/space/src/space.mjs
var import_vue494 = require("vue");
var import_shared83 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/space/src/item.mjs
var import_vue492 = require("vue");
var spaceItemProps = buildProps({
  prefixCls: {
    type: String
  }
});
var SpaceItem = (0, import_vue492.defineComponent)({
  name: "ElSpaceItem",
  props: spaceItemProps,
  setup(props, { slots }) {
    const ns2 = useNamespace("space");
    const classes = (0, import_vue492.computed)(() => `${props.prefixCls || ns2.b()}__item`);
    return () => (0, import_vue492.h)("div", { class: classes.value }, (0, import_vue492.renderSlot)(slots, "default"));
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/space/src/use-space.mjs
var import_vue493 = require("vue");
var import_shared82 = require("@vue/shared");
var SIZE_MAP = {
  small: 8,
  default: 12,
  large: 16
};
function useSpace(props) {
  const ns2 = useNamespace("space");
  const classes = (0, import_vue493.computed)(() => [ns2.b(), ns2.m(props.direction), props.class]);
  const horizontalSize = (0, import_vue493.ref)(0);
  const verticalSize = (0, import_vue493.ref)(0);
  const containerStyle = (0, import_vue493.computed)(() => {
    const wrapKls = props.wrap || props.fill ? { flexWrap: "wrap", marginBottom: `-${verticalSize.value}px` } : {};
    const alignment = {
      alignItems: props.alignment
    };
    return [wrapKls, alignment, props.style];
  });
  const itemStyle = (0, import_vue493.computed)(() => {
    const itemBaseStyle = {
      paddingBottom: `${verticalSize.value}px`,
      marginRight: `${horizontalSize.value}px`
    };
    const fillStyle = props.fill ? { flexGrow: 1, minWidth: `${props.fillRatio}%` } : {};
    return [itemBaseStyle, fillStyle];
  });
  (0, import_vue493.watchEffect)(() => {
    const { size: size2 = "small", wrap, direction: dir, fill } = props;
    if ((0, import_shared82.isArray)(size2)) {
      const [h29 = 0, v3 = 0] = size2;
      horizontalSize.value = h29;
      verticalSize.value = v3;
    } else {
      let val;
      if (isNumber(size2)) {
        val = size2;
      } else {
        val = SIZE_MAP[size2 || "small"] || SIZE_MAP.small;
      }
      if ((wrap || fill) && dir === "horizontal") {
        horizontalSize.value = verticalSize.value = val;
      } else {
        if (dir === "horizontal") {
          horizontalSize.value = val;
          verticalSize.value = 0;
        } else {
          verticalSize.value = val;
          horizontalSize.value = 0;
        }
      }
    }
  });
  return {
    classes,
    containerStyle,
    itemStyle
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/space/src/space.mjs
var spaceProps = buildProps({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: definePropType([
      String,
      Object,
      Array
    ]),
    default: ""
  },
  style: {
    type: definePropType([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: definePropType(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: definePropType([Object, String, Number, Array]),
    default: null,
    validator: (val) => (0, import_vue494.isVNode)(val) || isNumber(val) || (0, import_shared83.isString)(val)
  },
  wrap: Boolean,
  fill: Boolean,
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: componentSizes,
    validator: (val) => {
      return isNumber(val) || (0, import_shared83.isArray)(val) && val.length === 2 && val.every(isNumber);
    }
  }
});
var Space = (0, import_vue494.defineComponent)({
  name: "ElSpace",
  props: spaceProps,
  setup(props, { slots }) {
    const { classes, containerStyle, itemStyle } = useSpace(props);
    function extractChildren(children, parentKey = "", extractedChildren = []) {
      const { prefixCls } = props;
      children.forEach((child, loopKey) => {
        if (isFragment(child)) {
          if ((0, import_shared83.isArray)(child.children)) {
            child.children.forEach((nested, key) => {
              if (isFragment(nested) && (0, import_shared83.isArray)(nested.children)) {
                extractChildren(nested.children, `${parentKey + key}-`, extractedChildren);
              } else {
                extractedChildren.push((0, import_vue494.createVNode)(SpaceItem, {
                  style: itemStyle.value,
                  prefixCls,
                  key: `nested-${parentKey + key}`
                }, {
                  default: () => [nested]
                }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
              }
            });
          }
        } else if (isValidElementNode(child)) {
          extractedChildren.push((0, import_vue494.createVNode)(SpaceItem, {
            style: itemStyle.value,
            prefixCls,
            key: `LoopKey${parentKey + loopKey}`
          }, {
            default: () => [child]
          }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
        }
      });
      return extractedChildren;
    }
    return () => {
      var _a2;
      const { spacer, direction: direction2 } = props;
      const children = (0, import_vue494.renderSlot)(slots, "default", { key: 0 }, () => []);
      if (((_a2 = children.children) != null ? _a2 : []).length === 0)
        return null;
      if ((0, import_shared83.isArray)(children.children)) {
        let extractedChildren = extractChildren(children.children);
        if (spacer) {
          const len = extractedChildren.length - 1;
          extractedChildren = extractedChildren.reduce((acc, child, idx) => {
            const children2 = [...acc, child];
            if (idx !== len) {
              children2.push((0, import_vue494.createVNode)("span", {
                style: [
                  itemStyle.value,
                  direction2 === "vertical" ? "width: 100%" : null
                ],
                key: idx
              }, [
                (0, import_vue494.isVNode)(spacer) ? spacer : (0, import_vue494.createTextVNode)(spacer, PatchFlags.TEXT)
              ], PatchFlags.STYLE));
            }
            return children2;
          }, []);
        }
        return (0, import_vue494.createVNode)("div", {
          class: classes.value,
          style: containerStyle.value
        }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
      }
      return children.children;
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/space/index.mjs
var ElSpace = withInstall(Space);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/statistic/src/statistic2.mjs
var import_vue495 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/statistic/src/statistic.mjs
var statisticProps = buildProps({
  decimalSeparator: {
    type: String,
    default: "."
  },
  groupSeparator: {
    type: String,
    default: ","
  },
  precision: {
    type: Number,
    default: 0
  },
  formatter: Function,
  value: {
    type: definePropType([Number, Object]),
    default: 0
  },
  prefix: String,
  suffix: String,
  title: String,
  valueStyle: {
    type: definePropType([String, Object, Array])
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/statistic/src/statistic2.mjs
var import_shared84 = require("@vue/shared");
var __default__76 = (0, import_vue495.defineComponent)({
  name: "ElStatistic"
});
var _sfc_main115 = /* @__PURE__ */ (0, import_vue495.defineComponent)({
  ...__default__76,
  props: statisticProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("statistic");
    const displayValue = (0, import_vue495.computed)(() => {
      const { value, formatter: formatter2, precision, decimalSeparator, groupSeparator } = props;
      if ((0, import_shared84.isFunction)(formatter2))
        return formatter2(value);
      if (!isNumber(value))
        return value;
      let [integer4, decimal = ""] = String(value).split(".");
      decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
      integer4 = integer4.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
      return [integer4, decimal].join(decimal ? decimalSeparator : "");
    });
    expose({
      displayValue
    });
    return (_ctx, _cache) => {
      return (0, import_vue495.openBlock)(), (0, import_vue495.createElementBlock)("div", {
        class: (0, import_vue495.normalizeClass)((0, import_vue495.unref)(ns2).b())
      }, [
        _ctx.$slots.title || _ctx.title ? ((0, import_vue495.openBlock)(), (0, import_vue495.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue495.normalizeClass)((0, import_vue495.unref)(ns2).e("head"))
        }, [
          (0, import_vue495.renderSlot)(_ctx.$slots, "title", {}, () => [
            (0, import_vue495.createTextVNode)((0, import_vue495.toDisplayString)(_ctx.title), 1)
          ])
        ], 2)) : (0, import_vue495.createCommentVNode)("v-if", true),
        (0, import_vue495.createElementVNode)("div", {
          class: (0, import_vue495.normalizeClass)((0, import_vue495.unref)(ns2).e("content"))
        }, [
          _ctx.$slots.prefix || _ctx.prefix ? ((0, import_vue495.openBlock)(), (0, import_vue495.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue495.normalizeClass)((0, import_vue495.unref)(ns2).e("prefix"))
          }, [
            (0, import_vue495.renderSlot)(_ctx.$slots, "prefix", {}, () => [
              (0, import_vue495.createElementVNode)("span", null, (0, import_vue495.toDisplayString)(_ctx.prefix), 1)
            ])
          ], 2)) : (0, import_vue495.createCommentVNode)("v-if", true),
          (0, import_vue495.createElementVNode)("span", {
            class: (0, import_vue495.normalizeClass)((0, import_vue495.unref)(ns2).e("number")),
            style: (0, import_vue495.normalizeStyle)(_ctx.valueStyle)
          }, (0, import_vue495.toDisplayString)((0, import_vue495.unref)(displayValue)), 7),
          _ctx.$slots.suffix || _ctx.suffix ? ((0, import_vue495.openBlock)(), (0, import_vue495.createElementBlock)("div", {
            key: 1,
            class: (0, import_vue495.normalizeClass)((0, import_vue495.unref)(ns2).e("suffix"))
          }, [
            (0, import_vue495.renderSlot)(_ctx.$slots, "suffix", {}, () => [
              (0, import_vue495.createElementVNode)("span", null, (0, import_vue495.toDisplayString)(_ctx.suffix), 1)
            ])
          ], 2)) : (0, import_vue495.createCommentVNode)("v-if", true)
        ], 2)
      ], 2);
    };
  }
});
var Statistic = /* @__PURE__ */ _export_sfc(_sfc_main115, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/statistic/index.mjs
var ElStatistic = withInstall(Statistic);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/countdown/src/countdown2.mjs
var import_vue496 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/countdown/src/countdown.mjs
var countdownProps = buildProps({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: definePropType([Number, Object]),
    default: 0
  },
  valueStyle: {
    type: definePropType([String, Object, Array])
  }
});
var countdownEmits = {
  finish: () => true,
  [CHANGE_EVENT]: (value) => isNumber(value)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/countdown/src/utils.mjs
var timeUnits2 = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
];
var getTime = (value) => {
  return isNumber(value) ? new Date(value).getTime() : value.valueOf();
};
var formatTime = (timestamp2, format2) => {
  let timeLeft = timestamp2;
  const escapeRegex = /\[([^\]]*)]/g;
  const replacedText = timeUnits2.reduce((current, [name, unit3]) => {
    const replaceRegex = new RegExp(`${name}+(?![^\\[\\]]*\\])`, "g");
    if (replaceRegex.test(current)) {
      const value = Math.floor(timeLeft / unit3);
      timeLeft -= value * unit3;
      return current.replace(replaceRegex, (match) => String(value).padStart(match.length, "0"));
    }
    return current;
  }, format2);
  return replacedText.replace(escapeRegex, "$1");
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/countdown/src/countdown2.mjs
var __default__77 = (0, import_vue496.defineComponent)({
  name: "ElCountdown"
});
var _sfc_main116 = /* @__PURE__ */ (0, import_vue496.defineComponent)({
  ...__default__77,
  props: countdownProps,
  emits: countdownEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    let timer;
    const rawValue = (0, import_vue496.ref)(getTime(props.value) - Date.now());
    const displayValue = (0, import_vue496.computed)(() => formatTime(rawValue.value, props.format));
    const formatter2 = (val) => formatTime(val, props.format);
    const stopTimer = () => {
      if (timer) {
        cAF(timer);
        timer = void 0;
      }
    };
    const startTimer = () => {
      const timestamp2 = getTime(props.value);
      const frameFunc = () => {
        let diff = timestamp2 - Date.now();
        emit("change", diff);
        if (diff <= 0) {
          diff = 0;
          stopTimer();
          emit("finish");
        } else {
          timer = rAF(frameFunc);
        }
        rawValue.value = diff;
      };
      timer = rAF(frameFunc);
    };
    (0, import_vue496.watch)(() => [props.value, props.format], () => {
      stopTimer();
      startTimer();
    }, {
      immediate: true
    });
    (0, import_vue496.onBeforeUnmount)(() => {
      stopTimer();
    });
    expose({
      displayValue
    });
    return (_ctx, _cache) => {
      return (0, import_vue496.openBlock)(), (0, import_vue496.createBlock)((0, import_vue496.unref)(ElStatistic), {
        value: rawValue.value,
        title: _ctx.title,
        prefix: _ctx.prefix,
        suffix: _ctx.suffix,
        "value-style": _ctx.valueStyle,
        formatter: formatter2
      }, (0, import_vue496.createSlots)({ _: 2 }, [
        (0, import_vue496.renderList)(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: (0, import_vue496.withCtx)(() => [
              (0, import_vue496.renderSlot)(_ctx.$slots, name)
            ])
          };
        })
      ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]);
    };
  }
});
var Countdown = /* @__PURE__ */ _export_sfc(_sfc_main116, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/countdown/src/countdown.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/countdown/index.mjs
var ElCountdown = withInstall(Countdown);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/src/steps2.mjs
var import_vue497 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/src/steps.mjs
var stepsProps = buildProps({
  space: {
    type: [Number, String],
    default: ""
  },
  active: {
    type: Number,
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  alignCenter: {
    type: Boolean
  },
  simple: {
    type: Boolean
  },
  finishStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "finish"
  },
  processStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "process"
  }
});
var stepsEmits = {
  [CHANGE_EVENT]: (newVal, oldVal) => [newVal, oldVal].every(isNumber)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/src/steps2.mjs
var __default__78 = (0, import_vue497.defineComponent)({
  name: "ElSteps"
});
var _sfc_main117 = /* @__PURE__ */ (0, import_vue497.defineComponent)({
  ...__default__78,
  props: stepsProps,
  emits: stepsEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("steps");
    const steps = (0, import_vue497.ref)([]);
    (0, import_vue497.watch)(steps, () => {
      steps.value.forEach((instance, index2) => {
        instance.setIndex(index2);
      });
    });
    (0, import_vue497.provide)("ElSteps", { props, steps });
    (0, import_vue497.watch)(() => props.active, (newVal, oldVal) => {
      emit(CHANGE_EVENT, newVal, oldVal);
    });
    return (_ctx, _cache) => {
      return (0, import_vue497.openBlock)(), (0, import_vue497.createElementBlock)("div", {
        class: (0, import_vue497.normalizeClass)([(0, import_vue497.unref)(ns2).b(), (0, import_vue497.unref)(ns2).m(_ctx.simple ? "simple" : _ctx.direction)])
      }, [
        (0, import_vue497.renderSlot)(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Steps = /* @__PURE__ */ _export_sfc(_sfc_main117, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/src/item2.mjs
var import_vue498 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/src/item.mjs
var stepProps = buildProps({
  title: {
    type: String,
    default: ""
  },
  icon: {
    type: iconPropType
  },
  description: {
    type: String,
    default: ""
  },
  status: {
    type: String,
    values: ["", "wait", "process", "finish", "error", "success"],
    default: ""
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/src/item2.mjs
var __default__79 = (0, import_vue498.defineComponent)({
  name: "ElStep"
});
var _sfc_main118 = (0, import_vue498.defineComponent)({
  ...__default__79,
  props: stepProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("step");
    const index2 = (0, import_vue498.ref)(-1);
    const lineStyle = (0, import_vue498.ref)({});
    const internalStatus = (0, import_vue498.ref)("");
    const parent = (0, import_vue498.inject)("ElSteps");
    const currentInstance = (0, import_vue498.getCurrentInstance)();
    (0, import_vue498.onMounted)(() => {
      (0, import_vue498.watch)([
        () => parent.props.active,
        () => parent.props.processStatus,
        () => parent.props.finishStatus
      ], ([active]) => {
        updateStatus(active);
      }, { immediate: true });
    });
    (0, import_vue498.onBeforeUnmount)(() => {
      parent.steps.value = parent.steps.value.filter((instance) => instance.uid !== (currentInstance == null ? void 0 : currentInstance.uid));
    });
    const currentStatus = (0, import_vue498.computed)(() => {
      return props.status || internalStatus.value;
    });
    const prevStatus = (0, import_vue498.computed)(() => {
      const prevStep = parent.steps.value[index2.value - 1];
      return prevStep ? prevStep.currentStatus : "wait";
    });
    const isCenter = (0, import_vue498.computed)(() => {
      return parent.props.alignCenter;
    });
    const isVertical = (0, import_vue498.computed)(() => {
      return parent.props.direction === "vertical";
    });
    const isSimple = (0, import_vue498.computed)(() => {
      return parent.props.simple;
    });
    const stepsCount = (0, import_vue498.computed)(() => {
      return parent.steps.value.length;
    });
    const isLast = (0, import_vue498.computed)(() => {
      var _a2;
      return ((_a2 = parent.steps.value[stepsCount.value - 1]) == null ? void 0 : _a2.uid) === (currentInstance == null ? void 0 : currentInstance.uid);
    });
    const space = (0, import_vue498.computed)(() => {
      return isSimple.value ? "" : parent.props.space;
    });
    const style = (0, import_vue498.computed)(() => {
      const style2 = {
        flexBasis: typeof space.value === "number" ? `${space.value}px` : space.value ? space.value : `${100 / (stepsCount.value - (isCenter.value ? 0 : 1))}%`
      };
      if (isVertical.value)
        return style2;
      if (isLast.value) {
        style2.maxWidth = `${100 / stepsCount.value}%`;
      }
      return style2;
    });
    const setIndex = (val) => {
      index2.value = val;
    };
    const calcProgress = (status) => {
      let step = 100;
      const style2 = {};
      style2.transitionDelay = `${150 * index2.value}ms`;
      if (status === parent.props.processStatus) {
        step = 0;
      } else if (status === "wait") {
        step = 0;
        style2.transitionDelay = `${-150 * index2.value}ms`;
      }
      style2.borderWidth = step && !isSimple.value ? "1px" : 0;
      style2[parent.props.direction === "vertical" ? "height" : "width"] = `${step}%`;
      lineStyle.value = style2;
    };
    const updateStatus = (activeIndex) => {
      if (activeIndex > index2.value) {
        internalStatus.value = parent.props.finishStatus;
      } else if (activeIndex === index2.value && prevStatus.value !== "error") {
        internalStatus.value = parent.props.processStatus;
      } else {
        internalStatus.value = "wait";
      }
      const prevChild = parent.steps.value[index2.value - 1];
      if (prevChild)
        prevChild.calcProgress(internalStatus.value);
    };
    const stepItemState = (0, import_vue498.reactive)({
      uid: (0, import_vue498.computed)(() => currentInstance == null ? void 0 : currentInstance.uid),
      currentStatus,
      setIndex,
      calcProgress
    });
    parent.steps.value = [...parent.steps.value, stepItemState];
    return (_ctx, _cache) => {
      return (0, import_vue498.openBlock)(), (0, import_vue498.createElementBlock)("div", {
        style: (0, import_vue498.normalizeStyle)((0, import_vue498.unref)(style)),
        class: (0, import_vue498.normalizeClass)([
          (0, import_vue498.unref)(ns2).b(),
          (0, import_vue498.unref)(ns2).is((0, import_vue498.unref)(isSimple) ? "simple" : (0, import_vue498.unref)(parent).props.direction),
          (0, import_vue498.unref)(ns2).is("flex", (0, import_vue498.unref)(isLast) && !(0, import_vue498.unref)(space) && !(0, import_vue498.unref)(isCenter)),
          (0, import_vue498.unref)(ns2).is("center", (0, import_vue498.unref)(isCenter) && !(0, import_vue498.unref)(isVertical) && !(0, import_vue498.unref)(isSimple))
        ])
      }, [
        (0, import_vue498.createCommentVNode)(" icon & line "),
        (0, import_vue498.createElementVNode)("div", {
          class: (0, import_vue498.normalizeClass)([(0, import_vue498.unref)(ns2).e("head"), (0, import_vue498.unref)(ns2).is((0, import_vue498.unref)(currentStatus))])
        }, [
          !(0, import_vue498.unref)(isSimple) ? ((0, import_vue498.openBlock)(), (0, import_vue498.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue498.normalizeClass)((0, import_vue498.unref)(ns2).e("line"))
          }, [
            (0, import_vue498.createElementVNode)("i", {
              class: (0, import_vue498.normalizeClass)((0, import_vue498.unref)(ns2).e("line-inner")),
              style: (0, import_vue498.normalizeStyle)(lineStyle.value)
            }, null, 6)
          ], 2)) : (0, import_vue498.createCommentVNode)("v-if", true),
          (0, import_vue498.createElementVNode)("div", {
            class: (0, import_vue498.normalizeClass)([(0, import_vue498.unref)(ns2).e("icon"), (0, import_vue498.unref)(ns2).is(_ctx.icon || _ctx.$slots.icon ? "icon" : "text")])
          }, [
            (0, import_vue498.renderSlot)(_ctx.$slots, "icon", {}, () => [
              _ctx.icon ? ((0, import_vue498.openBlock)(), (0, import_vue498.createBlock)((0, import_vue498.unref)(ElIcon), {
                key: 0,
                class: (0, import_vue498.normalizeClass)((0, import_vue498.unref)(ns2).e("icon-inner"))
              }, {
                default: (0, import_vue498.withCtx)(() => [
                  ((0, import_vue498.openBlock)(), (0, import_vue498.createBlock)((0, import_vue498.resolveDynamicComponent)(_ctx.icon)))
                ]),
                _: 1
              }, 8, ["class"])) : (0, import_vue498.unref)(currentStatus) === "success" ? ((0, import_vue498.openBlock)(), (0, import_vue498.createBlock)((0, import_vue498.unref)(ElIcon), {
                key: 1,
                class: (0, import_vue498.normalizeClass)([(0, import_vue498.unref)(ns2).e("icon-inner"), (0, import_vue498.unref)(ns2).is("status")])
              }, {
                default: (0, import_vue498.withCtx)(() => [
                  (0, import_vue498.createVNode)((0, import_vue498.unref)(check_default))
                ]),
                _: 1
              }, 8, ["class"])) : (0, import_vue498.unref)(currentStatus) === "error" ? ((0, import_vue498.openBlock)(), (0, import_vue498.createBlock)((0, import_vue498.unref)(ElIcon), {
                key: 2,
                class: (0, import_vue498.normalizeClass)([(0, import_vue498.unref)(ns2).e("icon-inner"), (0, import_vue498.unref)(ns2).is("status")])
              }, {
                default: (0, import_vue498.withCtx)(() => [
                  (0, import_vue498.createVNode)((0, import_vue498.unref)(close_default))
                ]),
                _: 1
              }, 8, ["class"])) : !(0, import_vue498.unref)(isSimple) ? ((0, import_vue498.openBlock)(), (0, import_vue498.createElementBlock)("div", {
                key: 3,
                class: (0, import_vue498.normalizeClass)((0, import_vue498.unref)(ns2).e("icon-inner"))
              }, (0, import_vue498.toDisplayString)(index2.value + 1), 3)) : (0, import_vue498.createCommentVNode)("v-if", true)
            ])
          ], 2)
        ], 2),
        (0, import_vue498.createCommentVNode)(" title & description "),
        (0, import_vue498.createElementVNode)("div", {
          class: (0, import_vue498.normalizeClass)((0, import_vue498.unref)(ns2).e("main"))
        }, [
          (0, import_vue498.createElementVNode)("div", {
            class: (0, import_vue498.normalizeClass)([(0, import_vue498.unref)(ns2).e("title"), (0, import_vue498.unref)(ns2).is((0, import_vue498.unref)(currentStatus))])
          }, [
            (0, import_vue498.renderSlot)(_ctx.$slots, "title", {}, () => [
              (0, import_vue498.createTextVNode)((0, import_vue498.toDisplayString)(_ctx.title), 1)
            ])
          ], 2),
          (0, import_vue498.unref)(isSimple) ? ((0, import_vue498.openBlock)(), (0, import_vue498.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue498.normalizeClass)((0, import_vue498.unref)(ns2).e("arrow"))
          }, null, 2)) : ((0, import_vue498.openBlock)(), (0, import_vue498.createElementBlock)("div", {
            key: 1,
            class: (0, import_vue498.normalizeClass)([(0, import_vue498.unref)(ns2).e("description"), (0, import_vue498.unref)(ns2).is((0, import_vue498.unref)(currentStatus))])
          }, [
            (0, import_vue498.renderSlot)(_ctx.$slots, "description", {}, () => [
              (0, import_vue498.createTextVNode)((0, import_vue498.toDisplayString)(_ctx.description), 1)
            ])
          ], 2))
        ], 2)
      ], 6);
    };
  }
});
var Step = /* @__PURE__ */ _export_sfc(_sfc_main118, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/steps/index.mjs
var ElSteps = withInstall(Steps, {
  Step
});
var ElStep = withNoopInstall(Step);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/switch/src/switch2.mjs
var import_vue499 = require("vue");
var import_shared86 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/switch/src/switch.mjs
var import_shared85 = require("@vue/shared");
var switchProps = buildProps({
  modelValue: {
    type: [Boolean, String, Number],
    default: false
  },
  value: {
    type: [Boolean, String, Number],
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: false
  },
  activeIcon: {
    type: iconPropType
  },
  inactiveIcon: {
    type: iconPropType
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: true
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: false
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  id: String,
  loading: {
    type: Boolean,
    default: false
  },
  beforeChange: {
    type: definePropType(Function)
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  tabindex: {
    type: [String, Number]
  }
});
var switchEmits = {
  [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || (0, import_shared85.isString)(val) || isNumber(val),
  [CHANGE_EVENT]: (val) => isBoolean(val) || (0, import_shared85.isString)(val) || isNumber(val),
  [INPUT_EVENT]: (val) => isBoolean(val) || (0, import_shared85.isString)(val) || isNumber(val)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/switch/src/switch2.mjs
var _hoisted_176 = ["onClick"];
var _hoisted_245 = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
var _hoisted_322 = ["aria-hidden"];
var _hoisted_411 = ["aria-hidden"];
var _hoisted_58 = ["aria-hidden"];
var COMPONENT_NAME16 = "ElSwitch";
var __default__80 = (0, import_vue499.defineComponent)({
  name: COMPONENT_NAME16
});
var _sfc_main119 = /* @__PURE__ */ (0, import_vue499.defineComponent)({
  ...__default__80,
  props: switchProps,
  emits: switchEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const vm = (0, import_vue499.getCurrentInstance)();
    const { formItem } = useFormItem();
    const switchSize = useSize();
    const ns2 = useNamespace("switch");
    useDeprecated({
      from: '"value"',
      replacement: '"model-value" or "v-model"',
      scope: COMPONENT_NAME16,
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/switch.html#attributes",
      type: "Attribute"
    }, (0, import_vue499.computed)(() => {
      var _a2;
      return !!((_a2 = vm.vnode.props) == null ? void 0 : _a2.value);
    }));
    const { inputId } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const switchDisabled = useDisabled((0, import_vue499.computed)(() => props.loading));
    const isControlled = (0, import_vue499.ref)(props.modelValue !== false);
    const input = (0, import_vue499.ref)();
    const core = (0, import_vue499.ref)();
    const switchKls = (0, import_vue499.computed)(() => [
      ns2.b(),
      ns2.m(switchSize.value),
      ns2.is("disabled", switchDisabled.value),
      ns2.is("checked", checked.value)
    ]);
    const coreStyle = (0, import_vue499.computed)(() => ({
      width: addUnit(props.width)
    }));
    (0, import_vue499.watch)(() => props.modelValue, () => {
      isControlled.value = true;
    });
    (0, import_vue499.watch)(() => props.value, () => {
      isControlled.value = false;
    });
    const actualValue = (0, import_vue499.computed)(() => {
      return isControlled.value ? props.modelValue : props.value;
    });
    const checked = (0, import_vue499.computed)(() => actualValue.value === props.activeValue);
    if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
      emit(UPDATE_MODEL_EVENT, props.inactiveValue);
      emit(CHANGE_EVENT, props.inactiveValue);
      emit(INPUT_EVENT, props.inactiveValue);
    }
    (0, import_vue499.watch)(checked, (val) => {
      var _a2;
      input.value.checked = val;
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn(err));
      }
    });
    const handleChange = () => {
      const val = checked.value ? props.inactiveValue : props.activeValue;
      emit(UPDATE_MODEL_EVENT, val);
      emit(CHANGE_EVENT, val);
      emit(INPUT_EVENT, val);
      (0, import_vue499.nextTick)(() => {
        input.value.checked = checked.value;
      });
    };
    const switchValue = () => {
      if (switchDisabled.value)
        return;
      const { beforeChange } = props;
      if (!beforeChange) {
        handleChange();
        return;
      }
      const shouldChange = beforeChange();
      const isPromiseOrBool = [
        (0, import_shared86.isPromise)(shouldChange),
        isBoolean(shouldChange)
      ].includes(true);
      if (!isPromiseOrBool) {
        throwError(COMPONENT_NAME16, "beforeChange must return type `Promise<boolean>` or `boolean`");
      }
      if ((0, import_shared86.isPromise)(shouldChange)) {
        shouldChange.then((result) => {
          if (result) {
            handleChange();
          }
        }).catch((e) => {
          debugWarn(COMPONENT_NAME16, `some error occurred: ${e}`);
        });
      } else if (shouldChange) {
        handleChange();
      }
    };
    const styles = (0, import_vue499.computed)(() => {
      return ns2.cssVarBlock({
        ...props.activeColor ? { "on-color": props.activeColor } : null,
        ...props.inactiveColor ? { "off-color": props.inactiveColor } : null,
        ...props.borderColor ? { "border-color": props.borderColor } : null
      });
    });
    const focus = () => {
      var _a2, _b;
      (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    };
    (0, import_vue499.onMounted)(() => {
      input.value.checked = checked.value;
    });
    expose({
      focus,
      checked
    });
    return (_ctx, _cache) => {
      return (0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("div", {
        class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(switchKls)),
        style: (0, import_vue499.normalizeStyle)((0, import_vue499.unref)(styles)),
        onClick: (0, import_vue499.withModifiers)(switchValue, ["prevent"])
      }, [
        (0, import_vue499.createElementVNode)("input", {
          id: (0, import_vue499.unref)(inputId),
          ref_key: "input",
          ref: input,
          class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).e("input")),
          type: "checkbox",
          role: "switch",
          "aria-checked": (0, import_vue499.unref)(checked),
          "aria-disabled": (0, import_vue499.unref)(switchDisabled),
          name: _ctx.name,
          "true-value": _ctx.activeValue,
          "false-value": _ctx.inactiveValue,
          disabled: (0, import_vue499.unref)(switchDisabled),
          tabindex: _ctx.tabindex,
          onChange: handleChange,
          onKeydown: (0, import_vue499.withKeys)(switchValue, ["enter"])
        }, null, 42, _hoisted_245),
        !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? ((0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("span", {
          key: 0,
          class: (0, import_vue499.normalizeClass)([
            (0, import_vue499.unref)(ns2).e("label"),
            (0, import_vue499.unref)(ns2).em("label", "left"),
            (0, import_vue499.unref)(ns2).is("active", !(0, import_vue499.unref)(checked))
          ])
        }, [
          _ctx.inactiveIcon ? ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.unref)(ElIcon), { key: 0 }, {
            default: (0, import_vue499.withCtx)(() => [
              ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.resolveDynamicComponent)(_ctx.inactiveIcon)))
            ]),
            _: 1
          })) : (0, import_vue499.createCommentVNode)("v-if", true),
          !_ctx.inactiveIcon && _ctx.inactiveText ? ((0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("span", {
            key: 1,
            "aria-hidden": (0, import_vue499.unref)(checked)
          }, (0, import_vue499.toDisplayString)(_ctx.inactiveText), 9, _hoisted_322)) : (0, import_vue499.createCommentVNode)("v-if", true)
        ], 2)) : (0, import_vue499.createCommentVNode)("v-if", true),
        (0, import_vue499.createElementVNode)("span", {
          ref_key: "core",
          ref: core,
          class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).e("core")),
          style: (0, import_vue499.normalizeStyle)((0, import_vue499.unref)(coreStyle))
        }, [
          _ctx.inlinePrompt ? ((0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).e("inner"))
          }, [
            _ctx.activeIcon || _ctx.inactiveIcon ? ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.unref)(ElIcon), {
              key: 0,
              class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).is("icon"))
            }, {
              default: (0, import_vue499.withCtx)(() => [
                ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.resolveDynamicComponent)((0, import_vue499.unref)(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? ((0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("span", {
              key: 1,
              class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).is("text")),
              "aria-hidden": !(0, import_vue499.unref)(checked)
            }, (0, import_vue499.toDisplayString)((0, import_vue499.unref)(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_411)) : (0, import_vue499.createCommentVNode)("v-if", true)
          ], 2)) : (0, import_vue499.createCommentVNode)("v-if", true),
          (0, import_vue499.createElementVNode)("div", {
            class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).e("action"))
          }, [
            _ctx.loading ? ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.unref)(ElIcon), {
              key: 0,
              class: (0, import_vue499.normalizeClass)((0, import_vue499.unref)(ns2).is("loading"))
            }, {
              default: (0, import_vue499.withCtx)(() => [
                (0, import_vue499.createVNode)((0, import_vue499.unref)(loading_default))
              ]),
              _: 1
            }, 8, ["class"])) : (0, import_vue499.createCommentVNode)("v-if", true)
          ], 2)
        ], 6),
        !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? ((0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("span", {
          key: 1,
          class: (0, import_vue499.normalizeClass)([
            (0, import_vue499.unref)(ns2).e("label"),
            (0, import_vue499.unref)(ns2).em("label", "right"),
            (0, import_vue499.unref)(ns2).is("active", (0, import_vue499.unref)(checked))
          ])
        }, [
          _ctx.activeIcon ? ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.unref)(ElIcon), { key: 0 }, {
            default: (0, import_vue499.withCtx)(() => [
              ((0, import_vue499.openBlock)(), (0, import_vue499.createBlock)((0, import_vue499.resolveDynamicComponent)(_ctx.activeIcon)))
            ]),
            _: 1
          })) : (0, import_vue499.createCommentVNode)("v-if", true),
          !_ctx.activeIcon && _ctx.activeText ? ((0, import_vue499.openBlock)(), (0, import_vue499.createElementBlock)("span", {
            key: 1,
            "aria-hidden": !(0, import_vue499.unref)(checked)
          }, (0, import_vue499.toDisplayString)(_ctx.activeText), 9, _hoisted_58)) : (0, import_vue499.createCommentVNode)("v-if", true)
        ], 2)) : (0, import_vue499.createCommentVNode)("v-if", true)
      ], 14, _hoisted_176);
    };
  }
});
var Switch = /* @__PURE__ */ _export_sfc(_sfc_main119, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/switch/index.mjs
var ElSwitch = withInstall(Switch);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table.mjs
var import_vue522 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/helper.mjs
var import_vue505 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/index.mjs
var import_vue504 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/watcher.mjs
var import_vue503 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/util.mjs
var import_escape_html = __toESM(require_escape_html(), 1);
var import_shared87 = require("@vue/shared");
var getCell = function(event) {
  var _a2;
  return (_a2 = event.target) == null ? void 0 : _a2.closest("td");
};
var orderBy = function(array4, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array4;
  }
  if (typeof reverse === "string") {
    reverse = reverse === "descending" ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }
  const getKey = sortMethod ? null : function(value, index2) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }
      return sortBy.map((by) => {
        if (typeof by === "string") {
          return get_default(value, by);
        } else {
          return by(value, index2, array4);
        }
      });
    }
    if (sortKey !== "$key") {
      if ((0, import_shared87.isObject)(value) && "$value" in value)
        value = value.$value;
    }
    return [(0, import_shared87.isObject)(value) ? get_default(value, sortKey) : value];
  };
  const compare = function(a3, b3) {
    if (sortMethod) {
      return sortMethod(a3.value, b3.value);
    }
    for (let i = 0, len = a3.key.length; i < len; i++) {
      if (a3.key[i] < b3.key[i]) {
        return -1;
      }
      if (a3.key[i] > b3.key[i]) {
        return 1;
      }
    }
    return 0;
  };
  return array4.map((value, index2) => {
    return {
      value,
      index: index2,
      key: getKey ? getKey(value, index2) : null
    };
  }).sort((a3, b3) => {
    let order = compare(a3, b3);
    if (!order) {
      order = a3.index - b3.index;
    }
    return order * +reverse;
  }).map((item) => item.value);
};
var getColumnById = function(table, columnId) {
  let column2 = null;
  table.columns.forEach((item) => {
    if (item.id === columnId) {
      column2 = item;
    }
  });
  return column2;
};
var getColumnByKey = function(table, columnKey) {
  let column2 = null;
  for (let i = 0; i < table.columns.length; i++) {
    const item = table.columns[i];
    if (item.columnKey === columnKey) {
      column2 = item;
      break;
    }
  }
  if (!column2)
    throwError("ElTable", `No column matching with column-key: ${columnKey}`);
  return column2;
};
var getColumnByCell = function(table, cell, namespace) {
  const matches2 = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
  if (matches2) {
    return getColumnById(table, matches2[0]);
  }
  return null;
};
var getRowIdentity = (row, rowKey2) => {
  if (!row)
    throw new Error("Row is required when get row identity");
  if (typeof rowKey2 === "string") {
    if (!rowKey2.includes(".")) {
      return `${row[rowKey2]}`;
    }
    const key = rowKey2.split(".");
    let current = row;
    for (const element of key) {
      current = current[element];
    }
    return `${current}`;
  } else if (typeof rowKey2 === "function") {
    return rowKey2.call(null, row);
  }
};
var getKeysMap = function(array4, rowKey2) {
  const arrayMap2 = {};
  (array4 || []).forEach((row, index2) => {
    arrayMap2[getRowIdentity(row, rowKey2)] = { row, index: index2 };
  });
  return arrayMap2;
};
function mergeOptions(defaults2, config) {
  const options = {};
  let key;
  for (key in defaults2) {
    options[key] = defaults2[key];
  }
  for (key in config) {
    if ((0, import_shared87.hasOwn)(config, key)) {
      const value = config[key];
      if (typeof value !== "undefined") {
        options[key] = value;
      }
    }
  }
  return options;
}
function parseWidth(width) {
  if (width === "")
    return width;
  if (width !== void 0) {
    width = Number.parseInt(width, 10);
    if (Number.isNaN(width)) {
      width = "";
    }
  }
  return width;
}
function parseMinWidth(minWidth) {
  if (minWidth === "")
    return minWidth;
  if (minWidth !== void 0) {
    minWidth = parseWidth(minWidth);
    if (Number.isNaN(minWidth)) {
      minWidth = 80;
    }
  }
  return minWidth;
}
function parseHeight(height) {
  if (typeof height === "number") {
    return height;
  }
  if (typeof height === "string") {
    if (/^\d+(?:px)?$/.test(height)) {
      return Number.parseInt(height, 10);
    } else {
      return height;
    }
  }
  return null;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a3, b3) => (...args) => a3(b3(...args)));
}
function toggleRowStatus(statusArr, row, newVal) {
  let changed = false;
  const index2 = statusArr.indexOf(row);
  const included = index2 !== -1;
  const toggleStatus = (type4) => {
    if (type4 === "add") {
      statusArr.push(row);
    } else {
      statusArr.splice(index2, 1);
    }
    changed = true;
    if ((0, import_shared87.isArray)(row.children)) {
      row.children.forEach((item) => {
        toggleRowStatus(statusArr, item, newVal != null ? newVal : !included);
      });
    }
  };
  if (isBoolean(newVal)) {
    if (newVal && !included) {
      toggleStatus("add");
    } else if (!newVal && included) {
      toggleStatus("remove");
    }
  } else {
    included ? toggleStatus("remove") : toggleStatus("add");
  }
  return changed;
}
function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
  const isNil2 = (array4) => !(Array.isArray(array4) && array4.length);
  function _walker(parent, children, level) {
    cb(parent, children, level);
    children.forEach((item) => {
      if (item[lazyKey]) {
        cb(item, null, level + 1);
        return;
      }
      const children2 = item[childrenKey];
      if (!isNil2(children2)) {
        _walker(item, children2, level + 1);
      }
    });
  }
  root2.forEach((item) => {
    if (item[lazyKey]) {
      cb(item, null, 0);
      return;
    }
    const children = item[childrenKey];
    if (!isNil2(children)) {
      _walker(item, children, 0);
    }
  });
}
var removePopper;
function createTablePopper(parentNode, trigger, popperContent, tooltipOptions) {
  tooltipOptions = merge_default({
    enterable: true,
    showArrow: true
  }, tooltipOptions);
  const { nextZIndex } = useZIndex();
  const ns2 = parentNode == null ? void 0 : parentNode.dataset.prefix;
  const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns2}-scrollbar__wrap`);
  function renderContent() {
    const isLight = tooltipOptions.effect === "light";
    const content2 = document.createElement("div");
    content2.className = [
      `${ns2}-popper`,
      isLight ? "is-light" : "is-dark",
      tooltipOptions.popperClass || ""
    ].join(" ");
    popperContent = (0, import_escape_html.default)(popperContent);
    content2.innerHTML = popperContent;
    content2.style.zIndex = String(nextZIndex());
    parentNode == null ? void 0 : parentNode.appendChild(content2);
    return content2;
  }
  function renderArrow() {
    const arrow2 = document.createElement("div");
    arrow2.className = `${ns2}-popper__arrow`;
    return arrow2;
  }
  function showPopper() {
    popperInstance && popperInstance.update();
  }
  removePopper == null ? void 0 : removePopper();
  removePopper = () => {
    try {
      popperInstance && popperInstance.destroy();
      content && (parentNode == null ? void 0 : parentNode.removeChild(content));
      trigger.removeEventListener("mouseenter", onOpen);
      trigger.removeEventListener("mouseleave", onClose);
      scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
      removePopper = void 0;
    } catch (e) {
    }
  };
  let popperInstance = null;
  let onOpen = showPopper;
  let onClose = removePopper;
  if (tooltipOptions.enterable) {
    ;
    ({ onOpen, onClose } = useDelayedToggle({
      showAfter: tooltipOptions.showAfter,
      hideAfter: tooltipOptions.hideAfter,
      open: showPopper,
      close: removePopper
    }));
  }
  const content = renderContent();
  content.onmouseenter = onOpen;
  content.onmouseleave = onClose;
  const modifiers = [];
  if (tooltipOptions.offset) {
    modifiers.push({
      name: "offset",
      options: {
        offset: [0, tooltipOptions.offset]
      }
    });
  }
  if (tooltipOptions.showArrow) {
    const arrow2 = content.appendChild(renderArrow());
    modifiers.push({
      name: "arrow",
      options: {
        element: arrow2,
        padding: 10
      }
    });
  }
  const popperOptions = tooltipOptions.popperOptions || {};
  popperInstance = yn(trigger, content, {
    placement: tooltipOptions.placement || "top",
    strategy: "fixed",
    ...popperOptions,
    modifiers: popperOptions.modifiers ? modifiers.concat(popperOptions.modifiers) : modifiers
  });
  trigger.addEventListener("mouseenter", onOpen);
  trigger.addEventListener("mouseleave", onClose);
  scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
  return popperInstance;
}
function getCurrentColumns(column2) {
  if (column2.children) {
    return flatMap_default(column2.children, getCurrentColumns);
  } else {
    return [column2];
  }
}
function getColSpan(colSpan, column2) {
  return colSpan + column2.colSpan;
}
var isFixedColumn = (index2, fixed, store, realColumns) => {
  let start = 0;
  let after = index2;
  const columns2 = store.states.columns.value;
  if (realColumns) {
    const curColumns = getCurrentColumns(realColumns[index2]);
    const preColumns = columns2.slice(0, columns2.indexOf(curColumns[0]));
    start = preColumns.reduce(getColSpan, 0);
    after = start + curColumns.reduce(getColSpan, 0) - 1;
  } else {
    start = index2;
  }
  let fixedLayout;
  switch (fixed) {
    case "left":
      if (after < store.states.fixedLeafColumnsLength.value) {
        fixedLayout = "left";
      }
      break;
    case "right":
      if (start >= columns2.length - store.states.rightFixedLeafColumnsLength.value) {
        fixedLayout = "right";
      }
      break;
    default:
      if (after < store.states.fixedLeafColumnsLength.value) {
        fixedLayout = "left";
      } else if (start >= columns2.length - store.states.rightFixedLeafColumnsLength.value) {
        fixedLayout = "right";
      }
  }
  return fixedLayout ? {
    direction: fixedLayout,
    start,
    after
  } : {};
};
var getFixedColumnsClass = (namespace, index2, fixed, store, realColumns, offset2 = 0) => {
  const classes = [];
  const { direction: direction2, start, after } = isFixedColumn(index2, fixed, store, realColumns);
  if (direction2) {
    const isLeft = direction2 === "left";
    classes.push(`${namespace}-fixed-column--${direction2}`);
    if (isLeft && after + offset2 === store.states.fixedLeafColumnsLength.value - 1) {
      classes.push("is-last-column");
    } else if (!isLeft && start - offset2 === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
      classes.push("is-first-column");
    }
  }
  return classes;
};
function getOffset2(offset2, column2) {
  return offset2 + (column2.realWidth === null || Number.isNaN(column2.realWidth) ? Number(column2.width) : column2.realWidth);
}
var getFixedColumnOffset = (index2, fixed, store, realColumns) => {
  const {
    direction: direction2,
    start = 0,
    after = 0
  } = isFixedColumn(index2, fixed, store, realColumns);
  if (!direction2) {
    return;
  }
  const styles = {};
  const isLeft = direction2 === "left";
  const columns2 = store.states.columns.value;
  if (isLeft) {
    styles.left = columns2.slice(0, start).reduce(getOffset2, 0);
  } else {
    styles.right = columns2.slice(after + 1).reverse().reduce(getOffset2, 0);
  }
  return styles;
};
var ensurePosition = (style, key) => {
  if (!style)
    return;
  if (!Number.isNaN(style[key])) {
    style[key] = `${style[key]}px`;
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/expand.mjs
var import_vue500 = require("vue");
function useExpand(watcherData) {
  const instance = (0, import_vue500.getCurrentInstance)();
  const defaultExpandAll = (0, import_vue500.ref)(false);
  const expandRows = (0, import_vue500.ref)([]);
  const updateExpandRows = () => {
    const data = watcherData.data.value || [];
    const rowKey2 = watcherData.rowKey.value;
    if (defaultExpandAll.value) {
      expandRows.value = data.slice();
    } else if (rowKey2) {
      const expandRowsMap = getKeysMap(expandRows.value, rowKey2);
      expandRows.value = data.reduce((prev, row) => {
        const rowId = getRowIdentity(row, rowKey2);
        const rowInfo = expandRowsMap[rowId];
        if (rowInfo) {
          prev.push(row);
        }
        return prev;
      }, []);
    } else {
      expandRows.value = [];
    }
  };
  const toggleRowExpansion = (row, expanded) => {
    const changed = toggleRowStatus(expandRows.value, row, expanded);
    if (changed) {
      instance.emit("expand-change", row, expandRows.value.slice());
    }
  };
  const setExpandRowKeys = (rowKeys) => {
    instance.store.assertRowKey();
    const data = watcherData.data.value || [];
    const rowKey2 = watcherData.rowKey.value;
    const keysMap = getKeysMap(data, rowKey2);
    expandRows.value = rowKeys.reduce((prev, cur) => {
      const info = keysMap[cur];
      if (info) {
        prev.push(info.row);
      }
      return prev;
    }, []);
  };
  const isRowExpanded = (row) => {
    const rowKey2 = watcherData.rowKey.value;
    if (rowKey2) {
      const expandMap = getKeysMap(expandRows.value, rowKey2);
      return !!expandMap[getRowIdentity(row, rowKey2)];
    }
    return expandRows.value.includes(row);
  };
  return {
    updateExpandRows,
    toggleRowExpansion,
    setExpandRowKeys,
    isRowExpanded,
    states: {
      expandRows,
      defaultExpandAll
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/current.mjs
var import_vue501 = require("vue");
function useCurrent(watcherData) {
  const instance = (0, import_vue501.getCurrentInstance)();
  const _currentRowKey = (0, import_vue501.ref)(null);
  const currentRow = (0, import_vue501.ref)(null);
  const setCurrentRowKey = (key) => {
    instance.store.assertRowKey();
    _currentRowKey.value = key;
    setCurrentRowByKey(key);
  };
  const restoreCurrentRowKey = () => {
    _currentRowKey.value = null;
  };
  const setCurrentRowByKey = (key) => {
    const { data, rowKey: rowKey2 } = watcherData;
    let _currentRow = null;
    if (rowKey2.value) {
      _currentRow = ((0, import_vue501.unref)(data) || []).find((item) => getRowIdentity(item, rowKey2.value) === key);
    }
    currentRow.value = _currentRow;
    instance.emit("current-change", currentRow.value, null);
  };
  const updateCurrentRow = (_currentRow) => {
    const oldCurrentRow = currentRow.value;
    if (_currentRow && _currentRow !== oldCurrentRow) {
      currentRow.value = _currentRow;
      instance.emit("current-change", currentRow.value, oldCurrentRow);
      return;
    }
    if (!_currentRow && oldCurrentRow) {
      currentRow.value = null;
      instance.emit("current-change", null, oldCurrentRow);
    }
  };
  const updateCurrentRowData = () => {
    const rowKey2 = watcherData.rowKey.value;
    const data = watcherData.data.value || [];
    const oldCurrentRow = currentRow.value;
    if (!data.includes(oldCurrentRow) && oldCurrentRow) {
      if (rowKey2) {
        const currentRowKey = getRowIdentity(oldCurrentRow, rowKey2);
        setCurrentRowByKey(currentRowKey);
      } else {
        currentRow.value = null;
      }
      if (currentRow.value === null) {
        instance.emit("current-change", null, oldCurrentRow);
      }
    } else if (_currentRowKey.value) {
      setCurrentRowByKey(_currentRowKey.value);
      restoreCurrentRowKey();
    }
  };
  return {
    setCurrentRowKey,
    restoreCurrentRowKey,
    setCurrentRowByKey,
    updateCurrentRow,
    updateCurrentRowData,
    states: {
      _currentRowKey,
      currentRow
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/tree.mjs
var import_vue502 = require("vue");
function useTree(watcherData) {
  const expandRowKeys = (0, import_vue502.ref)([]);
  const treeData = (0, import_vue502.ref)({});
  const indent = (0, import_vue502.ref)(16);
  const lazy = (0, import_vue502.ref)(false);
  const lazyTreeNodeMap = (0, import_vue502.ref)({});
  const lazyColumnIdentifier = (0, import_vue502.ref)("hasChildren");
  const childrenColumnName = (0, import_vue502.ref)("children");
  const instance = (0, import_vue502.getCurrentInstance)();
  const normalizedData = (0, import_vue502.computed)(() => {
    if (!watcherData.rowKey.value)
      return {};
    const data = watcherData.data.value || [];
    return normalize(data);
  });
  const normalizedLazyNode = (0, import_vue502.computed)(() => {
    const rowKey2 = watcherData.rowKey.value;
    const keys2 = Object.keys(lazyTreeNodeMap.value);
    const res = {};
    if (!keys2.length)
      return res;
    keys2.forEach((key) => {
      if (lazyTreeNodeMap.value[key].length) {
        const item = { children: [] };
        lazyTreeNodeMap.value[key].forEach((row) => {
          const currentRowKey = getRowIdentity(row, rowKey2);
          item.children.push(currentRowKey);
          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
            res[currentRowKey] = { children: [] };
          }
        });
        res[key] = item;
      }
    });
    return res;
  });
  const normalize = (data) => {
    const rowKey2 = watcherData.rowKey.value;
    const res = {};
    walkTreeNode(data, (parent, children, level) => {
      const parentId = getRowIdentity(parent, rowKey2);
      if (Array.isArray(children)) {
        res[parentId] = {
          children: children.map((row) => getRowIdentity(row, rowKey2)),
          level
        };
      } else if (lazy.value) {
        res[parentId] = {
          children: [],
          lazy: true,
          level
        };
      }
    }, childrenColumnName.value, lazyColumnIdentifier.value);
    return res;
  };
  const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
    var _a2;
    const nested = normalizedData.value;
    const normalizedLazyNode_ = normalizedLazyNode.value;
    const keys2 = Object.keys(nested);
    const newTreeData = {};
    if (keys2.length) {
      const oldTreeData = (0, import_vue502.unref)(treeData);
      const rootLazyRowKeys = [];
      const getExpanded = (oldValue, key) => {
        if (ifChangeExpandRowKeys) {
          if (expandRowKeys.value) {
            return ifExpandAll || expandRowKeys.value.includes(key);
          } else {
            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
          }
        } else {
          const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
        }
      };
      keys2.forEach((key) => {
        const oldValue = oldTreeData[key];
        const newValue = { ...nested[key] };
        newValue.expanded = getExpanded(oldValue, key);
        if (newValue.lazy) {
          const { loaded = false, loading = false } = oldValue || {};
          newValue.loaded = !!loaded;
          newValue.loading = !!loading;
          rootLazyRowKeys.push(key);
        }
        newTreeData[key] = newValue;
      });
      const lazyKeys = Object.keys(normalizedLazyNode_);
      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
        lazyKeys.forEach((key) => {
          const oldValue = oldTreeData[key];
          const lazyNodeChildren = normalizedLazyNode_[key].children;
          if (rootLazyRowKeys.includes(key)) {
            if (newTreeData[key].children.length !== 0) {
              throw new Error("[ElTable]children must be an empty array.");
            }
            newTreeData[key].children = lazyNodeChildren;
          } else {
            const { loaded = false, loading = false } = oldValue || {};
            newTreeData[key] = {
              lazy: true,
              loaded: !!loaded,
              loading: !!loading,
              expanded: getExpanded(oldValue, key),
              children: lazyNodeChildren,
              level: ""
            };
          }
        });
      }
    }
    treeData.value = newTreeData;
    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
  };
  (0, import_vue502.watch)(() => expandRowKeys.value, () => {
    updateTreeData(true);
  });
  (0, import_vue502.watch)(() => normalizedData.value, () => {
    updateTreeData();
  });
  (0, import_vue502.watch)(() => normalizedLazyNode.value, () => {
    updateTreeData();
  });
  const updateTreeExpandKeys = (value) => {
    expandRowKeys.value = value;
    updateTreeData();
  };
  const toggleTreeExpansion = (row, expanded) => {
    instance.store.assertRowKey();
    const rowKey2 = watcherData.rowKey.value;
    const id2 = getRowIdentity(row, rowKey2);
    const data = id2 && treeData.value[id2];
    if (id2 && data && "expanded" in data) {
      const oldExpanded = data.expanded;
      expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
      treeData.value[id2].expanded = expanded;
      if (oldExpanded !== expanded) {
        instance.emit("expand-change", row, expanded);
      }
      instance.store.updateTableScrollY();
    }
  };
  const loadOrToggle = (row) => {
    instance.store.assertRowKey();
    const rowKey2 = watcherData.rowKey.value;
    const id2 = getRowIdentity(row, rowKey2);
    const data = treeData.value[id2];
    if (lazy.value && data && "loaded" in data && !data.loaded) {
      loadData(row, id2, data);
    } else {
      toggleTreeExpansion(row, void 0);
    }
  };
  const loadData = (row, key, treeNode) => {
    const { load } = instance.props;
    if (load && !treeData.value[key].loaded) {
      treeData.value[key].loading = true;
      load(row, treeNode, (data) => {
        if (!Array.isArray(data)) {
          throw new TypeError("[ElTable] data must be an array");
        }
        treeData.value[key].loading = false;
        treeData.value[key].loaded = true;
        treeData.value[key].expanded = true;
        if (data.length) {
          lazyTreeNodeMap.value[key] = data;
        }
        instance.emit("expand-change", row, true);
      });
    }
  };
  return {
    loadData,
    loadOrToggle,
    toggleTreeExpansion,
    updateTreeExpandKeys,
    updateTreeData,
    normalize,
    states: {
      expandRowKeys,
      treeData,
      indent,
      lazy,
      lazyTreeNodeMap,
      lazyColumnIdentifier,
      childrenColumnName
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/watcher.mjs
var import_shared88 = require("@vue/shared");
var sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;
  if (!sortingColumn || typeof sortingColumn.sortable === "string") {
    return data;
  }
  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};
var doFlattenColumns = (columns2) => {
  const result = [];
  columns2.forEach((column2) => {
    if (column2.children) {
      result.push.apply(result, doFlattenColumns(column2.children));
    } else {
      result.push(column2);
    }
  });
  return result;
};
function useWatcher() {
  var _a2;
  const instance = (0, import_vue503.getCurrentInstance)();
  const { size: tableSize } = (0, import_vue503.toRefs)((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
  const rowKey2 = (0, import_vue503.ref)(null);
  const data = (0, import_vue503.ref)([]);
  const _data = (0, import_vue503.ref)([]);
  const isComplex = (0, import_vue503.ref)(false);
  const _columns = (0, import_vue503.ref)([]);
  const originColumns = (0, import_vue503.ref)([]);
  const columns2 = (0, import_vue503.ref)([]);
  const fixedColumns = (0, import_vue503.ref)([]);
  const rightFixedColumns = (0, import_vue503.ref)([]);
  const leafColumns = (0, import_vue503.ref)([]);
  const fixedLeafColumns = (0, import_vue503.ref)([]);
  const rightFixedLeafColumns = (0, import_vue503.ref)([]);
  const leafColumnsLength = (0, import_vue503.ref)(0);
  const fixedLeafColumnsLength = (0, import_vue503.ref)(0);
  const rightFixedLeafColumnsLength = (0, import_vue503.ref)(0);
  const isAllSelected = (0, import_vue503.ref)(false);
  const selection = (0, import_vue503.ref)([]);
  const reserveSelection = (0, import_vue503.ref)(false);
  const selectOnIndeterminate = (0, import_vue503.ref)(false);
  const selectable = (0, import_vue503.ref)(null);
  const filters = (0, import_vue503.ref)({});
  const filteredData = (0, import_vue503.ref)(null);
  const sortingColumn = (0, import_vue503.ref)(null);
  const sortProp = (0, import_vue503.ref)(null);
  const sortOrder = (0, import_vue503.ref)(null);
  const hoverRow = (0, import_vue503.ref)(null);
  (0, import_vue503.watch)(data, () => instance.state && scheduleLayout(false), {
    deep: true
  });
  const assertRowKey = () => {
    if (!rowKey2.value)
      throw new Error("[ElTable] prop row-key is required");
  };
  const updateChildFixed = (column2) => {
    var _a22;
    (_a22 = column2.children) == null ? void 0 : _a22.forEach((childColumn) => {
      childColumn.fixed = column2.fixed;
      updateChildFixed(childColumn);
    });
  };
  const updateColumns = () => {
    _columns.value.forEach((column2) => {
      updateChildFixed(column2);
    });
    fixedColumns.value = _columns.value.filter((column2) => column2.fixed === true || column2.fixed === "left");
    rightFixedColumns.value = _columns.value.filter((column2) => column2.fixed === "right");
    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
      _columns.value[0].fixed = true;
      fixedColumns.value.unshift(_columns.value[0]);
    }
    const notFixedColumns = _columns.value.filter((column2) => !column2.fixed);
    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
    const leafColumns2 = doFlattenColumns(notFixedColumns);
    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
    leafColumnsLength.value = leafColumns2.length;
    fixedLeafColumnsLength.value = fixedLeafColumns2.length;
    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
    columns2.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
  };
  const scheduleLayout = (needUpdateColumns, immediate = false) => {
    if (needUpdateColumns) {
      updateColumns();
    }
    if (immediate) {
      instance.state.doLayout();
    } else {
      instance.state.debouncedUpdateLayout();
    }
  };
  const isSelected = (row) => {
    return selection.value.includes(row);
  };
  const clearSelection = () => {
    isAllSelected.value = false;
    const oldSelection = selection.value;
    if (oldSelection.length) {
      selection.value = [];
      instance.emit("selection-change", []);
    }
  };
  const cleanSelection = () => {
    let deleted;
    if (rowKey2.value) {
      deleted = [];
      const selectedMap = getKeysMap(selection.value, rowKey2.value);
      const dataMap = getKeysMap(data.value, rowKey2.value);
      for (const key in selectedMap) {
        if ((0, import_shared88.hasOwn)(selectedMap, key) && !dataMap[key]) {
          deleted.push(selectedMap[key].row);
        }
      }
    } else {
      deleted = selection.value.filter((item) => !data.value.includes(item));
    }
    if (deleted.length) {
      const newSelection = selection.value.filter((item) => !deleted.includes(item));
      selection.value = newSelection;
      instance.emit("selection-change", newSelection.slice());
    }
  };
  const getSelectionRows = () => {
    return (selection.value || []).slice();
  };
  const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
    const changed = toggleRowStatus(selection.value, row, selected);
    if (changed) {
      const newSelection = (selection.value || []).slice();
      if (emitChange) {
        instance.emit("select", newSelection, row);
      }
      instance.emit("selection-change", newSelection);
    }
  };
  const _toggleAllSelection = () => {
    var _a22, _b;
    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
    isAllSelected.value = value;
    let selectionChanged = false;
    let childrenCount = 0;
    const rowKey22 = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.rowKey.value;
    data.value.forEach((row, index2) => {
      const rowIndex = index2 + childrenCount;
      if (selectable.value) {
        if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      }
      childrenCount += getChildrenCount(getRowIdentity(row, rowKey22));
    });
    if (selectionChanged) {
      instance.emit("selection-change", selection.value ? selection.value.slice() : []);
    }
    instance.emit("select-all", selection.value);
  };
  const updateSelectionByRowKey = () => {
    const selectedMap = getKeysMap(selection.value, rowKey2.value);
    data.value.forEach((row) => {
      const rowId = getRowIdentity(row, rowKey2.value);
      const rowInfo = selectedMap[rowId];
      if (rowInfo) {
        selection.value[rowInfo.index] = row;
      }
    });
  };
  const updateAllSelected = () => {
    var _a22, _b, _c;
    if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
      isAllSelected.value = false;
      return;
    }
    let selectedMap;
    if (rowKey2.value) {
      selectedMap = getKeysMap(selection.value, rowKey2.value);
    }
    const isSelected2 = function(row) {
      if (selectedMap) {
        return !!selectedMap[getRowIdentity(row, rowKey2.value)];
      } else {
        return selection.value.includes(row);
      }
    };
    let isAllSelected_ = true;
    let selectedCount = 0;
    let childrenCount = 0;
    for (let i = 0, j = (data.value || []).length; i < j; i++) {
      const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
      const rowIndex = i + childrenCount;
      const item = data.value[i];
      const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
      if (!isSelected2(item)) {
        if (!selectable.value || isRowSelectable) {
          isAllSelected_ = false;
          break;
        }
      } else {
        selectedCount++;
      }
      childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
    }
    if (selectedCount === 0)
      isAllSelected_ = false;
    isAllSelected.value = isAllSelected_;
  };
  const getChildrenCount = (rowKey22) => {
    var _a22;
    if (!instance || !instance.store)
      return 0;
    const { treeData } = instance.store.states;
    let count = 0;
    const children = (_a22 = treeData.value[rowKey22]) == null ? void 0 : _a22.children;
    if (children) {
      count += children.length;
      children.forEach((childKey) => {
        count += getChildrenCount(childKey);
      });
    }
    return count;
  };
  const updateFilters = (columns22, values) => {
    if (!Array.isArray(columns22)) {
      columns22 = [columns22];
    }
    const filters_ = {};
    columns22.forEach((col) => {
      filters.value[col.id] = values;
      filters_[col.columnKey || col.id] = values;
    });
    return filters_;
  };
  const updateSort = (column2, prop, order) => {
    if (sortingColumn.value && sortingColumn.value !== column2) {
      sortingColumn.value.order = null;
    }
    sortingColumn.value = column2;
    sortProp.value = prop;
    sortOrder.value = order;
  };
  const execFilter = () => {
    let sourceData = (0, import_vue503.unref)(_data);
    Object.keys(filters.value).forEach((columnId) => {
      const values = filters.value[columnId];
      if (!values || values.length === 0)
        return;
      const column2 = getColumnById({
        columns: columns2.value
      }, columnId);
      if (column2 && column2.filterMethod) {
        sourceData = sourceData.filter((row) => {
          return values.some((value) => column2.filterMethod.call(null, value, row, column2));
        });
      }
    });
    filteredData.value = sourceData;
  };
  const execSort = () => {
    data.value = sortData(filteredData.value, {
      sortingColumn: sortingColumn.value,
      sortProp: sortProp.value,
      sortOrder: sortOrder.value
    });
  };
  const execQuery = (ignore = void 0) => {
    if (!(ignore && ignore.filter)) {
      execFilter();
    }
    execSort();
  };
  const clearFilter = (columnKeys) => {
    const { tableHeaderRef } = instance.refs;
    if (!tableHeaderRef)
      return;
    const panels = Object.assign({}, tableHeaderRef.filterPanels);
    const keys2 = Object.keys(panels);
    if (!keys2.length)
      return;
    if (typeof columnKeys === "string") {
      columnKeys = [columnKeys];
    }
    if (Array.isArray(columnKeys)) {
      const columns_ = columnKeys.map((key) => getColumnByKey({
        columns: columns2.value
      }, key));
      keys2.forEach((key) => {
        const column2 = columns_.find((col) => col.id === key);
        if (column2) {
          column2.filteredValue = [];
        }
      });
      instance.store.commit("filterChange", {
        column: columns_,
        values: [],
        silent: true,
        multi: true
      });
    } else {
      keys2.forEach((key) => {
        const column2 = columns2.value.find((col) => col.id === key);
        if (column2) {
          column2.filteredValue = [];
        }
      });
      filters.value = {};
      instance.store.commit("filterChange", {
        column: {},
        values: [],
        silent: true
      });
    }
  };
  const clearSort = () => {
    if (!sortingColumn.value)
      return;
    updateSort(null, null, null);
    instance.store.commit("changeSortCondition", {
      silent: true
    });
  };
  const {
    setExpandRowKeys,
    toggleRowExpansion,
    updateExpandRows,
    states: expandStates,
    isRowExpanded
  } = useExpand({
    data,
    rowKey: rowKey2
  });
  const {
    updateTreeExpandKeys,
    toggleTreeExpansion,
    updateTreeData,
    loadOrToggle,
    states: treeStates
  } = useTree({
    data,
    rowKey: rowKey2
  });
  const {
    updateCurrentRowData,
    updateCurrentRow,
    setCurrentRowKey,
    states: currentData
  } = useCurrent({
    data,
    rowKey: rowKey2
  });
  const setExpandRowKeysAdapter = (val) => {
    setExpandRowKeys(val);
    updateTreeExpandKeys(val);
  };
  const toggleRowExpansionAdapter = (row, expanded) => {
    const hasExpandColumn = columns2.value.some(({ type: type4 }) => type4 === "expand");
    if (hasExpandColumn) {
      toggleRowExpansion(row, expanded);
    } else {
      toggleTreeExpansion(row, expanded);
    }
  };
  return {
    assertRowKey,
    updateColumns,
    scheduleLayout,
    isSelected,
    clearSelection,
    cleanSelection,
    getSelectionRows,
    toggleRowSelection,
    _toggleAllSelection,
    toggleAllSelection: null,
    updateSelectionByRowKey,
    updateAllSelected,
    updateFilters,
    updateCurrentRow,
    updateSort,
    execFilter,
    execSort,
    execQuery,
    clearFilter,
    clearSort,
    toggleRowExpansion,
    setExpandRowKeysAdapter,
    setCurrentRowKey,
    toggleRowExpansionAdapter,
    isRowExpanded,
    updateExpandRows,
    updateCurrentRowData,
    loadOrToggle,
    updateTreeData,
    states: {
      tableSize,
      rowKey: rowKey2,
      data,
      _data,
      isComplex,
      _columns,
      originColumns,
      columns: columns2,
      fixedColumns,
      rightFixedColumns,
      leafColumns,
      fixedLeafColumns,
      rightFixedLeafColumns,
      leafColumnsLength,
      fixedLeafColumnsLength,
      rightFixedLeafColumnsLength,
      isAllSelected,
      selection,
      reserveSelection,
      selectOnIndeterminate,
      selectable,
      filters,
      filteredData,
      sortingColumn,
      sortProp,
      sortOrder,
      hoverRow,
      ...expandStates,
      ...treeStates,
      ...currentData
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/index.mjs
function replaceColumn(array4, column2) {
  return array4.map((item) => {
    var _a2;
    if (item.id === column2.id) {
      return column2;
    } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
      item.children = replaceColumn(item.children, column2);
    }
    return item;
  });
}
function sortColumn(array4) {
  array4.forEach((item) => {
    var _a2, _b;
    item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
    if ((_b = item.children) == null ? void 0 : _b.length) {
      sortColumn(item.children);
    }
  });
  array4.sort((cur, pre) => cur.no - pre.no);
}
function useStore() {
  const instance = (0, import_vue504.getCurrentInstance)();
  const watcher = useWatcher();
  const ns2 = useNamespace("table");
  const mutations = {
    setData(states, data) {
      const dataInstanceChanged = (0, import_vue504.unref)(states._data) !== data;
      states.data.value = data;
      states._data.value = data;
      instance.store.execQuery();
      instance.store.updateCurrentRowData();
      instance.store.updateExpandRows();
      instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
      if ((0, import_vue504.unref)(states.reserveSelection)) {
        instance.store.assertRowKey();
        instance.store.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          instance.store.clearSelection();
        } else {
          instance.store.cleanSelection();
        }
      }
      instance.store.updateAllSelected();
      if (instance.$ready) {
        instance.store.scheduleLayout();
      }
    },
    insertColumn(states, column2, parent) {
      const array4 = (0, import_vue504.unref)(states._columns);
      let newColumns = [];
      if (!parent) {
        array4.push(column2);
        newColumns = array4;
      } else {
        if (parent && !parent.children) {
          parent.children = [];
        }
        parent.children.push(column2);
        newColumns = replaceColumn(array4, parent);
      }
      sortColumn(newColumns);
      states._columns.value = newColumns;
      if (column2.type === "selection") {
        states.selectable.value = column2.selectable;
        states.reserveSelection.value = column2.reserveSelection;
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    removeColumn(states, column2, parent) {
      const array4 = (0, import_vue504.unref)(states._columns) || [];
      if (parent) {
        parent.children.splice(parent.children.findIndex((item) => item.id === column2.id), 1);
        (0, import_vue504.nextTick)(() => {
          var _a2;
          if (((_a2 = parent.children) == null ? void 0 : _a2.length) === 0) {
            delete parent.children;
          }
        });
        states._columns.value = replaceColumn(array4, parent);
      } else {
        const index2 = array4.indexOf(column2);
        if (index2 > -1) {
          array4.splice(index2, 1);
          states._columns.value = array4;
        }
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    sort(states, options) {
      const { prop, order, init } = options;
      if (prop) {
        const column2 = (0, import_vue504.unref)(states.columns).find((column22) => column22.property === prop);
        if (column2) {
          column2.order = order;
          instance.store.updateSort(column2, prop, order);
          instance.store.commit("changeSortCondition", { init });
        }
      }
    },
    changeSortCondition(states, options) {
      const { sortingColumn, sortProp, sortOrder } = states;
      const columnValue = (0, import_vue504.unref)(sortingColumn), propValue = (0, import_vue504.unref)(sortProp), orderValue = (0, import_vue504.unref)(sortOrder);
      if (orderValue === null) {
        states.sortingColumn.value = null;
        states.sortProp.value = null;
      }
      const ignore = { filter: true };
      instance.store.execQuery(ignore);
      if (!options || !(options.silent || options.init)) {
        instance.emit("sort-change", {
          column: columnValue,
          prop: propValue,
          order: orderValue
        });
      }
      instance.store.updateTableScrollY();
    },
    filterChange(_states, options) {
      const { column: column2, values, silent } = options;
      const newFilters = instance.store.updateFilters(column2, values);
      instance.store.execQuery();
      if (!silent) {
        instance.emit("filter-change", newFilters);
      }
      instance.store.updateTableScrollY();
    },
    toggleAllSelection() {
      instance.store.toggleAllSelection();
    },
    rowSelectedChanged(_states, row) {
      instance.store.toggleRowSelection(row);
      instance.store.updateAllSelected();
    },
    setHoverRow(states, row) {
      states.hoverRow.value = row;
    },
    setCurrentRow(_states, row) {
      instance.store.updateCurrentRow(row);
    }
  };
  const commit = function(name, ...args) {
    const mutations2 = instance.store.mutations;
    if (mutations2[name]) {
      mutations2[name].apply(instance, [instance.store.states].concat(args));
    } else {
      throw new Error(`Action not found: ${name}`);
    }
  };
  const updateTableScrollY = function() {
    (0, import_vue504.nextTick)(() => instance.layout.updateScrollY.apply(instance.layout));
  };
  return {
    ns: ns2,
    ...watcher,
    mutations,
    commit,
    updateTableScrollY
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/store/helper.mjs
var InitialStateMap = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function createStore(table, props) {
  if (!table) {
    throw new Error("Table is required.");
  }
  const store = useStore();
  store.toggleAllSelection = debounce_default(store._toggleAllSelection, 10);
  Object.keys(InitialStateMap).forEach((key) => {
    handleValue(getArrKeysValue(props, key), key, store);
  });
  proxyTableProps(store, props);
  return store;
}
function proxyTableProps(store, props) {
  Object.keys(InitialStateMap).forEach((key) => {
    (0, import_vue505.watch)(() => getArrKeysValue(props, key), (value) => {
      handleValue(value, key, store);
    });
  });
}
function handleValue(value, propsKey, store) {
  let newVal = value;
  let storeKey = InitialStateMap[propsKey];
  if (typeof InitialStateMap[propsKey] === "object") {
    storeKey = storeKey.key;
    newVal = newVal || InitialStateMap[propsKey].default;
  }
  store.states[storeKey].value = newVal;
}
function getArrKeysValue(props, keys2) {
  if (keys2.includes(".")) {
    const keyList = keys2.split(".");
    let value = props;
    keyList.forEach((key) => {
      value = value[key];
    });
    return value;
  } else {
    return props[keys2];
  }
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-layout.mjs
var import_vue506 = require("vue");
var import_shared89 = require("@vue/shared");
var TableLayout = class {
  constructor(options) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = [];
    this.fit = true;
    this.showHeader = true;
    this.height = (0, import_vue506.ref)(null);
    this.scrollX = (0, import_vue506.ref)(false);
    this.scrollY = (0, import_vue506.ref)(false);
    this.bodyWidth = (0, import_vue506.ref)(null);
    this.fixedWidth = (0, import_vue506.ref)(null);
    this.rightFixedWidth = (0, import_vue506.ref)(null);
    this.gutterWidth = 0;
    for (const name in options) {
      if ((0, import_shared89.hasOwn)(options, name)) {
        if ((0, import_vue506.isRef)(this[name])) {
          this[name].value = options[name];
        } else {
          this[name] = options[name];
        }
      }
    }
    if (!this.table) {
      throw new Error("Table is required for Table Layout");
    }
    if (!this.store) {
      throw new Error("Store is required for Table Layout");
    }
  }
  updateScrollY() {
    const height = this.height.value;
    if (height === null)
      return false;
    const scrollBarRef = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && scrollBarRef) {
      let scrollY = true;
      const prevScrollY = this.scrollY.value;
      scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
      this.scrollY.value = scrollY;
      return prevScrollY !== scrollY;
    }
    return false;
  }
  setHeight(value, prop = "height") {
    if (!isClient)
      return;
    const el = this.table.vnode.el;
    value = parseHeight(value);
    this.height.value = Number(value);
    if (!el && (value || value === 0))
      return (0, import_vue506.nextTick)(() => this.setHeight(value, prop));
    if (typeof value === "number") {
      el.style[prop] = `${value}px`;
      this.updateElsHeight();
    } else if (typeof value === "string") {
      el.style[prop] = value;
      this.updateElsHeight();
    }
  }
  setMaxHeight(value) {
    this.setHeight(value, "max-height");
  }
  getFlattenColumns() {
    const flattenColumns = [];
    const columns2 = this.table.store.states.columns.value;
    columns2.forEach((column2) => {
      if (column2.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column2.columns);
      } else {
        flattenColumns.push(column2);
      }
    });
    return flattenColumns;
  }
  updateElsHeight() {
    this.updateScrollY();
    this.notifyObservers("scrollable");
  }
  headerDisplayNone(elm) {
    if (!elm)
      return true;
    let headerChild = elm;
    while (headerChild.tagName !== "DIV") {
      if (getComputedStyle(headerChild).display === "none") {
        return true;
      }
      headerChild = headerChild.parentElement;
    }
    return false;
  }
  updateColumnsWidth() {
    if (!isClient)
      return;
    const fit = this.fit;
    const bodyWidth = this.table.vnode.el.clientWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    const flexColumns = flattenColumns.filter((column2) => typeof column2.width !== "number");
    flattenColumns.forEach((column2) => {
      if (typeof column2.width === "number" && column2.realWidth)
        column2.realWidth = null;
    });
    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach((column2) => {
        bodyMinWidth += Number(column2.width || column2.minWidth || 80);
      });
      if (bodyMinWidth <= bodyWidth) {
        this.scrollX.value = false;
        const totalFlexWidth = bodyWidth - bodyMinWidth;
        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          const allColumnsWidth = flexColumns.reduce((prev, column2) => prev + Number(column2.minWidth || 80), 0);
          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
          let noneFirstWidth = 0;
          flexColumns.forEach((column2, index2) => {
            if (index2 === 0)
              return;
            const flexWidth = Math.floor(Number(column2.minWidth || 80) * flexWidthPerPixel);
            noneFirstWidth += flexWidth;
            column2.realWidth = Number(column2.minWidth || 80) + flexWidth;
          });
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
        }
      } else {
        this.scrollX.value = true;
        flexColumns.forEach((column2) => {
          column2.realWidth = Number(column2.minWidth);
        });
      }
      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
      this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else {
      flattenColumns.forEach((column2) => {
        if (!column2.width && !column2.minWidth) {
          column2.realWidth = 80;
        } else {
          column2.realWidth = Number(column2.width || column2.minWidth);
        }
        bodyMinWidth += column2.realWidth;
      });
      this.scrollX.value = bodyMinWidth > bodyWidth;
      this.bodyWidth.value = bodyMinWidth;
    }
    const fixedColumns = this.store.states.fixedColumns.value;
    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach((column2) => {
        fixedWidth += Number(column2.realWidth || column2.width);
      });
      this.fixedWidth.value = fixedWidth;
    }
    const rightFixedColumns = this.store.states.rightFixedColumns.value;
    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach((column2) => {
        rightFixedWidth += Number(column2.realWidth || column2.width);
      });
      this.rightFixedWidth.value = rightFixedWidth;
    }
    this.notifyObservers("columns");
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    const index2 = this.observers.indexOf(observer);
    if (index2 !== -1) {
      this.observers.splice(index2, 1);
    }
  }
  notifyObservers(event) {
    const observers = this.observers;
    observers.forEach((observer) => {
      var _a2, _b;
      switch (event) {
        case "columns":
          (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
          break;
        case "scrollable":
          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${event}.`);
      }
    });
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-header/index.mjs
var import_vue512 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/filter-panel.mjs
var import_vue507 = require("vue");
var { CheckboxGroup: ElCheckboxGroup2 } = ElCheckbox;
var _sfc_main120 = (0, import_vue507.defineComponent)({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox,
    ElCheckboxGroup: ElCheckboxGroup2,
    ElScrollbar,
    ElTooltip,
    ElIcon,
    ArrowDown: arrow_down_default,
    ArrowUp: arrow_up_default
  },
  directives: { ClickOutside },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(props) {
    const instance = (0, import_vue507.getCurrentInstance)();
    const { t } = useLocale();
    const ns2 = useNamespace("table-filter");
    const parent = instance == null ? void 0 : instance.parent;
    if (!parent.filterPanels.value[props.column.id]) {
      parent.filterPanels.value[props.column.id] = instance;
    }
    const tooltipVisible = (0, import_vue507.ref)(false);
    const tooltip = (0, import_vue507.ref)(null);
    const filters = (0, import_vue507.computed)(() => {
      return props.column && props.column.filters;
    });
    const filterValue = (0, import_vue507.computed)({
      get: () => {
        var _a2;
        return (((_a2 = props.column) == null ? void 0 : _a2.filteredValue) || [])[0];
      },
      set: (value) => {
        if (filteredValue.value) {
          if (typeof value !== "undefined" && value !== null) {
            filteredValue.value.splice(0, 1, value);
          } else {
            filteredValue.value.splice(0, 1);
          }
        }
      }
    });
    const filteredValue = (0, import_vue507.computed)({
      get() {
        if (props.column) {
          return props.column.filteredValue || [];
        }
        return [];
      },
      set(value) {
        if (props.column) {
          props.upDataColumn("filteredValue", value);
        }
      }
    });
    const multiple = (0, import_vue507.computed)(() => {
      if (props.column) {
        return props.column.filterMultiple;
      }
      return true;
    });
    const isActive = (filter) => {
      return filter.value === filterValue.value;
    };
    const hidden = () => {
      tooltipVisible.value = false;
    };
    const showFilterPanel = (e) => {
      e.stopPropagation();
      tooltipVisible.value = !tooltipVisible.value;
    };
    const hideFilterPanel = () => {
      tooltipVisible.value = false;
    };
    const handleConfirm = () => {
      confirmFilter(filteredValue.value);
      hidden();
    };
    const handleReset = () => {
      filteredValue.value = [];
      confirmFilter(filteredValue.value);
      hidden();
    };
    const handleSelect = (_filterValue) => {
      filterValue.value = _filterValue;
      if (typeof _filterValue !== "undefined" && _filterValue !== null) {
        confirmFilter(filteredValue.value);
      } else {
        confirmFilter([]);
      }
      hidden();
    };
    const confirmFilter = (filteredValue2) => {
      props.store.commit("filterChange", {
        column: props.column,
        values: filteredValue2
      });
      props.store.updateAllSelected();
    };
    (0, import_vue507.watch)(tooltipVisible, (value) => {
      if (props.column) {
        props.upDataColumn("filterOpened", value);
      }
    }, {
      immediate: true
    });
    const popperPaneRef = (0, import_vue507.computed)(() => {
      var _a2, _b;
      return (_b = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
    });
    return {
      tooltipVisible,
      multiple,
      filteredValue,
      filterValue,
      filters,
      handleConfirm,
      handleReset,
      handleSelect,
      isActive,
      t,
      ns: ns2,
      showFilterPanel,
      hideFilterPanel,
      popperPaneRef,
      tooltip
    };
  }
});
var _hoisted_177 = { key: 0 };
var _hoisted_246 = ["disabled"];
var _hoisted_323 = ["label", "onClick"];
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = (0, import_vue507.resolveComponent)("el-checkbox");
  const _component_el_checkbox_group = (0, import_vue507.resolveComponent)("el-checkbox-group");
  const _component_el_scrollbar = (0, import_vue507.resolveComponent)("el-scrollbar");
  const _component_arrow_up = (0, import_vue507.resolveComponent)("arrow-up");
  const _component_arrow_down = (0, import_vue507.resolveComponent)("arrow-down");
  const _component_el_icon = (0, import_vue507.resolveComponent)("el-icon");
  const _component_el_tooltip = (0, import_vue507.resolveComponent)("el-tooltip");
  const _directive_click_outside = (0, import_vue507.resolveDirective)("click-outside");
  return (0, import_vue507.openBlock)(), (0, import_vue507.createBlock)(_component_el_tooltip, {
    ref: "tooltip",
    visible: _ctx.tooltipVisible,
    offset: 0,
    placement: _ctx.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": _ctx.ns.b(),
    persistent: ""
  }, {
    content: (0, import_vue507.withCtx)(() => [
      _ctx.multiple ? ((0, import_vue507.openBlock)(), (0, import_vue507.createElementBlock)("div", _hoisted_177, [
        (0, import_vue507.createElementVNode)("div", {
          class: (0, import_vue507.normalizeClass)(_ctx.ns.e("content"))
        }, [
          (0, import_vue507.createVNode)(_component_el_scrollbar, {
            "wrap-class": _ctx.ns.e("wrap")
          }, {
            default: (0, import_vue507.withCtx)(() => [
              (0, import_vue507.createVNode)(_component_el_checkbox_group, {
                modelValue: _ctx.filteredValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                class: (0, import_vue507.normalizeClass)(_ctx.ns.e("checkbox-group"))
              }, {
                default: (0, import_vue507.withCtx)(() => [
                  ((0, import_vue507.openBlock)(true), (0, import_vue507.createElementBlock)(import_vue507.Fragment, null, (0, import_vue507.renderList)(_ctx.filters, (filter) => {
                    return (0, import_vue507.openBlock)(), (0, import_vue507.createBlock)(_component_el_checkbox, {
                      key: filter.value,
                      label: filter.value
                    }, {
                      default: (0, import_vue507.withCtx)(() => [
                        (0, import_vue507.createTextVNode)((0, import_vue507.toDisplayString)(filter.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        (0, import_vue507.createElementVNode)("div", {
          class: (0, import_vue507.normalizeClass)(_ctx.ns.e("bottom"))
        }, [
          (0, import_vue507.createElementVNode)("button", {
            class: (0, import_vue507.normalizeClass)({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
            disabled: _ctx.filteredValue.length === 0,
            type: "button",
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
          }, (0, import_vue507.toDisplayString)(_ctx.t("el.table.confirmFilter")), 11, _hoisted_246),
          (0, import_vue507.createElementVNode)("button", {
            type: "button",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
          }, (0, import_vue507.toDisplayString)(_ctx.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : ((0, import_vue507.openBlock)(), (0, import_vue507.createElementBlock)("ul", {
        key: 1,
        class: (0, import_vue507.normalizeClass)(_ctx.ns.e("list"))
      }, [
        (0, import_vue507.createElementVNode)("li", {
          class: (0, import_vue507.normalizeClass)([
            _ctx.ns.e("list-item"),
            {
              [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
            }
          ]),
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
        }, (0, import_vue507.toDisplayString)(_ctx.t("el.table.clearFilter")), 3),
        ((0, import_vue507.openBlock)(true), (0, import_vue507.createElementBlock)(import_vue507.Fragment, null, (0, import_vue507.renderList)(_ctx.filters, (filter) => {
          return (0, import_vue507.openBlock)(), (0, import_vue507.createElementBlock)("li", {
            key: filter.value,
            class: (0, import_vue507.normalizeClass)([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
            label: filter.value,
            onClick: ($event) => _ctx.handleSelect(filter.value)
          }, (0, import_vue507.toDisplayString)(filter.text), 11, _hoisted_323);
        }), 128))
      ], 2))
    ]),
    default: (0, import_vue507.withCtx)(() => [
      (0, import_vue507.withDirectives)(((0, import_vue507.openBlock)(), (0, import_vue507.createElementBlock)("span", {
        class: (0, import_vue507.normalizeClass)([
          `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
          `${_ctx.ns.namespace.value}-none-outline`
        ]),
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
      }, [
        (0, import_vue507.createVNode)(_component_el_icon, null, {
          default: (0, import_vue507.withCtx)(() => [
            _ctx.column.filterOpened ? ((0, import_vue507.openBlock)(), (0, import_vue507.createBlock)(_component_arrow_up, { key: 0 })) : ((0, import_vue507.openBlock)(), (0, import_vue507.createBlock)(_component_arrow_down, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var FilterPanel = /* @__PURE__ */ _export_sfc(_sfc_main120, [["render", _sfc_render38], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/layout-observer.mjs
var import_vue508 = require("vue");
function useLayoutObserver(root2) {
  const instance = (0, import_vue508.getCurrentInstance)();
  (0, import_vue508.onBeforeMount)(() => {
    tableLayout.value.addObserver(instance);
  });
  (0, import_vue508.onMounted)(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  (0, import_vue508.onUpdated)(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  (0, import_vue508.onUnmounted)(() => {
    tableLayout.value.removeObserver(instance);
  });
  const tableLayout = (0, import_vue508.computed)(() => {
    const layout2 = root2.layout;
    if (!layout2) {
      throw new Error("Can not find table layout.");
    }
    return layout2;
  });
  const onColumnsChange = (layout2) => {
    var _a2;
    const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
    if (!cols.length)
      return;
    const flattenColumns = layout2.getFlattenColumns();
    const columnsMap = {};
    flattenColumns.forEach((column2) => {
      columnsMap[column2.id] = column2;
    });
    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      const name = col.getAttribute("name");
      const column2 = columnsMap[name];
      if (column2) {
        col.setAttribute("width", column2.realWidth || column2.width);
      }
    }
  };
  const onScrollableChange = (layout2) => {
    var _a2, _b;
    const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      col.setAttribute("width", layout2.scrollY.value ? layout2.gutterWidth : "0");
    }
    const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
    for (let i = 0, j = ths.length; i < j; i++) {
      const th = ths[i];
      th.style.width = layout2.scrollY.value ? `${layout2.gutterWidth}px` : "0";
      th.style.display = layout2.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: tableLayout.value,
    onColumnsChange,
    onScrollableChange
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/tokens.mjs
var TABLE_INJECTION_KEY = Symbol("ElTable");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-header/event-helper.mjs
var import_vue509 = require("vue");
function useEvent(props, emit) {
  const instance = (0, import_vue509.getCurrentInstance)();
  const parent = (0, import_vue509.inject)(TABLE_INJECTION_KEY);
  const handleFilterClick = (event) => {
    event.stopPropagation();
    return;
  };
  const handleHeaderClick = (event, column2) => {
    if (!column2.filters && column2.sortable) {
      handleSortClick(event, column2, false);
    } else if (column2.filterable && !column2.sortable) {
      handleFilterClick(event);
    }
    parent == null ? void 0 : parent.emit("header-click", column2, event);
  };
  const handleHeaderContextMenu = (event, column2) => {
    parent == null ? void 0 : parent.emit("header-contextmenu", column2, event);
  };
  const draggingColumn = (0, import_vue509.ref)(null);
  const dragging = (0, import_vue509.ref)(false);
  const dragState = (0, import_vue509.ref)({});
  const handleMouseDown = (event, column2) => {
    if (!isClient)
      return;
    if (column2.children && column2.children.length > 0)
      return;
    if (draggingColumn.value && props.border) {
      dragging.value = true;
      const table = parent;
      emit("set-drag-visible", true);
      const tableEl = table == null ? void 0 : table.vnode.el;
      const tableLeft = tableEl.getBoundingClientRect().left;
      const columnEl = instance.vnode.el.querySelector(`th.${column2.id}`);
      const columnRect = columnEl.getBoundingClientRect();
      const minLeft = columnRect.left - tableLeft + 30;
      addClass(columnEl, "noclick");
      dragState.value = {
        startMouseLeft: event.clientX,
        startLeft: columnRect.right - tableLeft,
        startColumnLeft: columnRect.left - tableLeft,
        tableLeft
      };
      const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
      resizeProxy.style.left = `${dragState.value.startLeft}px`;
      document.onselectstart = function() {
        return false;
      };
      document.ondragstart = function() {
        return false;
      };
      const handleMouseMove2 = (event2) => {
        const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
        const proxyLeft = dragState.value.startLeft + deltaLeft;
        resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
      };
      const handleMouseUp = () => {
        if (dragging.value) {
          const { startColumnLeft, startLeft } = dragState.value;
          const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
          const columnWidth = finalLeft - startColumnLeft;
          column2.width = column2.realWidth = columnWidth;
          table == null ? void 0 : table.emit("header-dragend", column2.width, startLeft - startColumnLeft, column2, event);
          requestAnimationFrame(() => {
            props.store.scheduleLayout(false, true);
          });
          document.body.style.cursor = "";
          dragging.value = false;
          draggingColumn.value = null;
          dragState.value = {};
          emit("set-drag-visible", false);
        }
        document.removeEventListener("mousemove", handleMouseMove2);
        document.removeEventListener("mouseup", handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        setTimeout(() => {
          removeClass(columnEl, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", handleMouseMove2);
      document.addEventListener("mouseup", handleMouseUp);
    }
  };
  const handleMouseMove = (event, column2) => {
    var _a2;
    if (column2.children && column2.children.length > 0)
      return;
    const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
    if (!column2 || !column2.resizable)
      return;
    if (!dragging.value && props.border) {
      const rect = target.getBoundingClientRect();
      const bodyStyle = document.body.style;
      if (rect.width > 12 && rect.right - event.pageX < 8) {
        bodyStyle.cursor = "col-resize";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "col-resize";
        }
        draggingColumn.value = column2;
      } else if (!dragging.value) {
        bodyStyle.cursor = "";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "pointer";
        }
        draggingColumn.value = null;
      }
    }
  };
  const handleMouseOut = () => {
    if (!isClient)
      return;
    document.body.style.cursor = "";
  };
  const toggleOrder = ({ order, sortOrders }) => {
    if (order === "")
      return sortOrders[0];
    const index2 = sortOrders.indexOf(order || null);
    return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
  };
  const handleSortClick = (event, column2, givenOrder) => {
    var _a2;
    event.stopPropagation();
    const order = column2.order === givenOrder ? null : givenOrder || toggleOrder(column2);
    const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
    if (target) {
      if (hasClass(target, "noclick")) {
        removeClass(target, "noclick");
        return;
      }
    }
    if (!column2.sortable)
      return;
    const states = props.store.states;
    let sortProp = states.sortProp.value;
    let sortOrder;
    const sortingColumn = states.sortingColumn.value;
    if (sortingColumn !== column2 || sortingColumn === column2 && sortingColumn.order === null) {
      if (sortingColumn) {
        sortingColumn.order = null;
      }
      states.sortingColumn.value = column2;
      sortProp = column2.property;
    }
    if (!order) {
      sortOrder = column2.order = null;
    } else {
      sortOrder = column2.order = order;
    }
    states.sortProp.value = sortProp;
    states.sortOrder.value = sortOrder;
    parent == null ? void 0 : parent.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick,
    handleHeaderContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseOut,
    handleSortClick,
    handleFilterClick
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-header/style.helper.mjs
var import_vue510 = require("vue");
function useStyle(props) {
  const parent = (0, import_vue510.inject)(TABLE_INJECTION_KEY);
  const ns2 = useNamespace("table");
  const getHeaderRowStyle = (rowIndex) => {
    const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
    if (typeof headerRowStyle === "function") {
      return headerRowStyle.call(null, { rowIndex });
    }
    return headerRowStyle;
  };
  const getHeaderRowClass = (rowIndex) => {
    const classes = [];
    const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
    if (typeof headerRowClassName === "string") {
      classes.push(headerRowClassName);
    } else if (typeof headerRowClassName === "function") {
      classes.push(headerRowClassName.call(null, { rowIndex }));
    }
    return classes.join(" ");
  };
  const getHeaderCellStyle = (rowIndex, columnIndex, row, column2) => {
    var _a2;
    let headerCellStyles = (_a2 = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a2 : {};
    if (typeof headerCellStyles === "function") {
      headerCellStyles = headerCellStyles.call(null, {
        rowIndex,
        columnIndex,
        row,
        column: column2
      });
    }
    const fixedStyle = getFixedColumnOffset(columnIndex, column2.fixed, props.store, row);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return Object.assign({}, headerCellStyles, fixedStyle);
  };
  const getHeaderCellClass = (rowIndex, columnIndex, row, column2) => {
    const fixedClasses = getFixedColumnsClass(ns2.b(), columnIndex, column2.fixed, props.store, row);
    const classes = [
      column2.id,
      column2.order,
      column2.headerAlign,
      column2.className,
      column2.labelClassName,
      ...fixedClasses
    ];
    if (!column2.children) {
      classes.push("is-leaf");
    }
    if (column2.sortable) {
      classes.push("is-sortable");
    }
    const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
    if (typeof headerCellClassName === "string") {
      classes.push(headerCellClassName);
    } else if (typeof headerCellClassName === "function") {
      classes.push(headerCellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column: column2
      }));
    }
    classes.push(ns2.e("cell"));
    return classes.filter((className) => Boolean(className)).join(" ");
  };
  return {
    getHeaderRowStyle,
    getHeaderRowClass,
    getHeaderCellStyle,
    getHeaderCellClass
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-header/utils-helper.mjs
var import_vue511 = require("vue");
var getAllColumns = (columns2) => {
  const result = [];
  columns2.forEach((column2) => {
    if (column2.children) {
      result.push(column2);
      result.push.apply(result, getAllColumns(column2.children));
    } else {
      result.push(column2);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column2, parent) => {
    if (parent) {
      column2.level = parent.level + 1;
      if (maxLevel < column2.level) {
        maxLevel = column2.level;
      }
    }
    if (column2.children) {
      let colSpan = 0;
      column2.children.forEach((subColumn) => {
        traverse(subColumn, column2);
        colSpan += subColumn.colSpan;
      });
      column2.colSpan = colSpan;
    } else {
      column2.colSpan = 1;
    }
  };
  originColumns.forEach((column2) => {
    column2.level = 1;
    traverse(column2, void 0);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllColumns(originColumns);
  allColumns.forEach((column2) => {
    if (!column2.children) {
      column2.rowSpan = maxLevel - column2.level + 1;
    } else {
      column2.rowSpan = 1;
      column2.children.forEach((col) => col.isSubColumn = true);
    }
    rows[column2.level - 1].push(column2);
  });
  return rows;
};
function useUtils(props) {
  const parent = (0, import_vue511.inject)(TABLE_INJECTION_KEY);
  const columnRows = (0, import_vue511.computed)(() => {
    return convertToRows(props.store.states.originColumns.value);
  });
  const isGroup = (0, import_vue511.computed)(() => {
    const result = columnRows.value.length > 1;
    if (result && parent) {
      parent.state.isGroup.value = true;
    }
    return result;
  });
  const toggleAllSelection = (event) => {
    event.stopPropagation();
    parent == null ? void 0 : parent.store.commit("toggleAllSelection");
  };
  return {
    isGroup,
    toggleAllSelection,
    columnRows
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-header/index.mjs
var TableHeader = (0, import_vue512.defineComponent)({
  name: "ElTableHeader",
  components: {
    ElCheckbox
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props, { emit }) {
    const instance = (0, import_vue512.getCurrentInstance)();
    const parent = (0, import_vue512.inject)(TABLE_INJECTION_KEY);
    const ns2 = useNamespace("table");
    const filterPanels = (0, import_vue512.ref)({});
    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
    (0, import_vue512.onMounted)(async () => {
      await (0, import_vue512.nextTick)();
      await (0, import_vue512.nextTick)();
      const { prop, order } = props.defaultSort;
      parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
    });
    const {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    } = useEvent(props, emit);
    const {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    } = useStyle(props);
    const { isGroup, toggleAllSelection, columnRows } = useUtils(props);
    instance.state = {
      onColumnsChange,
      onScrollableChange
    };
    instance.filterPanels = filterPanels;
    return {
      ns: ns2,
      filterPanels,
      onColumnsChange,
      onScrollableChange,
      columnRows,
      getHeaderRowClass,
      getHeaderRowStyle,
      getHeaderCellClass,
      getHeaderCellStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
      isGroup,
      toggleAllSelection
    };
  },
  render() {
    const {
      ns: ns2,
      isGroup,
      columnRows,
      getHeaderCellStyle,
      getHeaderCellClass,
      getHeaderRowClass,
      getHeaderRowStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleSortClick,
      handleMouseOut,
      store,
      $parent
    } = this;
    let rowSpan = 1;
    return (0, import_vue512.h)("thead", {
      class: { [ns2.is("group")]: isGroup }
    }, columnRows.map((subColumns, rowIndex) => (0, import_vue512.h)("tr", {
      class: getHeaderRowClass(rowIndex),
      key: rowIndex,
      style: getHeaderRowStyle(rowIndex)
    }, subColumns.map((column2, cellIndex) => {
      if (column2.rowSpan > rowSpan) {
        rowSpan = column2.rowSpan;
      }
      return (0, import_vue512.h)("th", {
        class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column2),
        colspan: column2.colSpan,
        key: `${column2.id}-thead`,
        rowspan: column2.rowSpan,
        style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column2),
        onClick: ($event) => handleHeaderClick($event, column2),
        onContextmenu: ($event) => handleHeaderContextMenu($event, column2),
        onMousedown: ($event) => handleMouseDown($event, column2),
        onMousemove: ($event) => handleMouseMove($event, column2),
        onMouseout: handleMouseOut
      }, [
        (0, import_vue512.h)("div", {
          class: [
            "cell",
            column2.filteredValue && column2.filteredValue.length > 0 ? "highlight" : ""
          ]
        }, [
          column2.renderHeader ? column2.renderHeader({
            column: column2,
            $index: cellIndex,
            store,
            _self: $parent
          }) : column2.label,
          column2.sortable && (0, import_vue512.h)("span", {
            onClick: ($event) => handleSortClick($event, column2),
            class: "caret-wrapper"
          }, [
            (0, import_vue512.h)("i", {
              onClick: ($event) => handleSortClick($event, column2, "ascending"),
              class: "sort-caret ascending"
            }),
            (0, import_vue512.h)("i", {
              onClick: ($event) => handleSortClick($event, column2, "descending"),
              class: "sort-caret descending"
            })
          ]),
          column2.filterable && (0, import_vue512.h)(FilterPanel, {
            store,
            placement: column2.filterPlacement || "bottom-start",
            column: column2,
            upDataColumn: (key, value) => {
              column2[key] = value;
            }
          })
        ])
      ]);
    }))));
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/index.mjs
var import_vue516 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/render-helper.mjs
var import_vue515 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/events-helper.mjs
var import_vue513 = require("vue");
function useEvents(props) {
  const parent = (0, import_vue513.inject)(TABLE_INJECTION_KEY);
  const tooltipContent = (0, import_vue513.ref)("");
  const tooltipTrigger = (0, import_vue513.ref)((0, import_vue513.h)("div"));
  const handleEvent2 = (event, row, name) => {
    var _a2;
    const table = parent;
    const cell = getCell(event);
    let column2;
    const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
    if (cell) {
      column2 = getColumnByCell({
        columns: props.store.states.columns.value
      }, cell, namespace);
      if (column2) {
        table == null ? void 0 : table.emit(`cell-${name}`, row, column2, cell, event);
      }
    }
    table == null ? void 0 : table.emit(`row-${name}`, row, column2, event);
  };
  const handleDoubleClick = (event, row) => {
    handleEvent2(event, row, "dblclick");
  };
  const handleClick = (event, row) => {
    props.store.commit("setCurrentRow", row);
    handleEvent2(event, row, "click");
  };
  const handleContextMenu = (event, row) => {
    handleEvent2(event, row, "contextmenu");
  };
  const handleMouseEnter = debounce_default((index2) => {
    props.store.commit("setHoverRow", index2);
  }, 30);
  const handleMouseLeave = debounce_default(() => {
    props.store.commit("setHoverRow", null);
  }, 30);
  const handleCellMouseEnter = (event, row, tooltipOptions) => {
    var _a2;
    const table = parent;
    const cell = getCell(event);
    const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
    if (cell) {
      const column2 = getColumnByCell({
        columns: props.store.states.columns.value
      }, cell, namespace);
      const hoverState = table.hoverState = { cell, column: column2, row };
      table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
    }
    if (!tooltipOptions) {
      return;
    }
    const cellChild = event.target.querySelector(".cell");
    if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
      return;
    }
    const range3 = document.createRange();
    range3.setStart(cellChild, 0);
    range3.setEnd(cellChild, cellChild.childNodes.length);
    const rangeWidth = Math.round(range3.getBoundingClientRect().width);
    const padding = (Number.parseInt(getStyle(cellChild, "paddingLeft"), 10) || 0) + (Number.parseInt(getStyle(cellChild, "paddingRight"), 10) || 0);
    if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
      createTablePopper(parent == null ? void 0 : parent.refs.tableWrapper, cell, cell.innerText || cell.textContent, tooltipOptions);
    }
  };
  const handleCellMouseLeave = (event) => {
    const cell = getCell(event);
    if (!cell)
      return;
    const oldHoverState = parent == null ? void 0 : parent.hoverState;
    parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
  };
  return {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/styles-helper.mjs
var import_vue514 = require("vue");
function useStyles(props) {
  const parent = (0, import_vue514.inject)(TABLE_INJECTION_KEY);
  const ns2 = useNamespace("table");
  const getRowStyle = (row, rowIndex) => {
    const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
    if (typeof rowStyle === "function") {
      return rowStyle.call(null, {
        row,
        rowIndex
      });
    }
    return rowStyle || null;
  };
  const getRowClass = (row, rowIndex) => {
    const classes = [ns2.e("row")];
    if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
      classes.push("current-row");
    }
    if (props.stripe && rowIndex % 2 === 1) {
      classes.push(ns2.em("row", "striped"));
    }
    const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
    if (typeof rowClassName === "string") {
      classes.push(rowClassName);
    } else if (typeof rowClassName === "function") {
      classes.push(rowClassName.call(null, {
        row,
        rowIndex
      }));
    }
    return classes;
  };
  const getCellStyle = (rowIndex, columnIndex, row, column2) => {
    const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
    let cellStyles = cellStyle != null ? cellStyle : {};
    if (typeof cellStyle === "function") {
      cellStyles = cellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column: column2
      });
    }
    const fixedStyle = getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return Object.assign({}, cellStyles, fixedStyle);
  };
  const getCellClass = (rowIndex, columnIndex, row, column2, offset2) => {
    const fixedClasses = getFixedColumnsClass(ns2.b(), columnIndex, props == null ? void 0 : props.fixed, props.store, void 0, offset2);
    const classes = [column2.id, column2.align, column2.className, ...fixedClasses];
    const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
    if (typeof cellClassName === "string") {
      classes.push(cellClassName);
    } else if (typeof cellClassName === "function") {
      classes.push(cellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column: column2
      }));
    }
    classes.push(ns2.e("cell"));
    return classes.filter((className) => Boolean(className)).join(" ");
  };
  const getSpan = (row, column2, rowIndex, columnIndex) => {
    let rowspan = 1;
    let colspan = 1;
    const fn2 = parent == null ? void 0 : parent.props.spanMethod;
    if (typeof fn2 === "function") {
      const result = fn2({
        row,
        column: column2,
        rowIndex,
        columnIndex
      });
      if (Array.isArray(result)) {
        rowspan = result[0];
        colspan = result[1];
      } else if (typeof result === "object") {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }
    return { rowspan, colspan };
  };
  const getColspanRealWidth = (columns2, colspan, index2) => {
    if (colspan < 1) {
      return columns2[index2].realWidth;
    }
    const widthArr = columns2.map(({ realWidth, width }) => realWidth || width).slice(index2, index2 + colspan);
    return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
  };
  return {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/render-helper.mjs
function useRender(props) {
  const parent = (0, import_vue515.inject)(TABLE_INJECTION_KEY);
  const ns2 = useNamespace("table");
  const {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  } = useEvents(props);
  const {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  } = useStyles(props);
  const firstDefaultColumnIndex = (0, import_vue515.computed)(() => {
    return props.store.states.columns.value.findIndex(({ type: type4 }) => type4 === "default");
  });
  const getKeyOfRow = (row, index2) => {
    const rowKey2 = parent.props.rowKey;
    if (rowKey2) {
      return getRowIdentity(row, rowKey2);
    }
    return index2;
  };
  const rowRender = (row, $index, treeRowData, expanded = false) => {
    const { tooltipEffect, tooltipOptions, store } = props;
    const { indent, columns: columns2 } = store.states;
    const rowClasses = getRowClass(row, $index);
    let display = true;
    if (treeRowData) {
      rowClasses.push(ns2.em("row", `level-${treeRowData.level}`));
      display = treeRowData.display;
    }
    const displayStyle = display ? null : {
      display: "none"
    };
    return (0, import_vue515.h)("tr", {
      style: [displayStyle, getRowStyle(row, $index)],
      class: rowClasses,
      key: getKeyOfRow(row, $index),
      onDblclick: ($event) => handleDoubleClick($event, row),
      onClick: ($event) => handleClick($event, row),
      onContextmenu: ($event) => handleContextMenu($event, row),
      onMouseenter: () => handleMouseEnter($index),
      onMouseleave: handleMouseLeave
    }, columns2.value.map((column2, cellIndex) => {
      const { rowspan, colspan } = getSpan(row, column2, $index, cellIndex);
      if (!rowspan || !colspan) {
        return null;
      }
      const columnData = { ...column2 };
      columnData.realWidth = getColspanRealWidth(columns2.value, colspan, cellIndex);
      const data = {
        store: props.store,
        _self: props.context || parent,
        column: columnData,
        row,
        $index,
        cellIndex,
        expanded
      };
      if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
        data.treeNode = {
          indent: treeRowData.level * indent.value,
          level: treeRowData.level
        };
        if (typeof treeRowData.expanded === "boolean") {
          data.treeNode.expanded = treeRowData.expanded;
          if ("loading" in treeRowData) {
            data.treeNode.loading = treeRowData.loading;
          }
          if ("noLazyChildren" in treeRowData) {
            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
          }
        }
      }
      const baseKey = `${$index},${cellIndex}`;
      const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
      const tdChildren = cellChildren(cellIndex, column2, data);
      const mergedTooltipOptions = column2.showOverflowTooltip && merge_default({
        effect: tooltipEffect
      }, tooltipOptions, column2.showOverflowTooltip);
      return (0, import_vue515.h)("td", {
        style: getCellStyle($index, cellIndex, row, column2),
        class: getCellClass($index, cellIndex, row, column2, colspan - 1),
        key: `${patchKey}${baseKey}`,
        rowspan,
        colspan,
        onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
        onMouseleave: handleCellMouseLeave
      }, [tdChildren]);
    }));
  };
  const cellChildren = (cellIndex, column2, data) => {
    return column2.renderCell(data);
  };
  const wrappedRowRender = (row, $index) => {
    const store = props.store;
    const { isRowExpanded, assertRowKey } = store;
    const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey: rowKey2 } = store.states;
    const columns2 = store.states.columns.value;
    const hasExpandColumn = columns2.some(({ type: type4 }) => type4 === "expand");
    if (hasExpandColumn) {
      const expanded = isRowExpanded(row);
      const tr = rowRender(row, $index, void 0, expanded);
      const renderExpanded = parent.renderExpanded;
      if (expanded) {
        if (!renderExpanded) {
          console.error("[Element Error]renderExpanded is required.");
          return tr;
        }
        return [
          [
            tr,
            (0, import_vue515.h)("tr", {
              key: `expanded-row__${tr.key}`
            }, [
              (0, import_vue515.h)("td", {
                colspan: columns2.length,
                class: `${ns2.e("cell")} ${ns2.e("expanded-cell")}`
              }, [renderExpanded({ row, $index, store, expanded })])
            ])
          ]
        ];
      } else {
        return [[tr]];
      }
    } else if (Object.keys(treeData.value).length) {
      assertRowKey();
      const key = getRowIdentity(row, rowKey2.value);
      let cur = treeData.value[key];
      let treeRowData = null;
      if (cur) {
        treeRowData = {
          expanded: cur.expanded,
          level: cur.level,
          display: true
        };
        if (typeof cur.lazy === "boolean") {
          if (typeof cur.loaded === "boolean" && cur.loaded) {
            treeRowData.noLazyChildren = !(cur.children && cur.children.length);
          }
          treeRowData.loading = cur.loading;
        }
      }
      const tmp = [rowRender(row, $index, treeRowData)];
      if (cur) {
        let i = 0;
        const traverse = (children, parent2) => {
          if (!(children && children.length && parent2))
            return;
          children.forEach((node) => {
            const innerTreeRowData = {
              display: parent2.display && parent2.expanded,
              level: parent2.level + 1,
              expanded: false,
              noLazyChildren: false,
              loading: false
            };
            const childKey = getRowIdentity(node, rowKey2.value);
            if (childKey === void 0 || childKey === null) {
              throw new Error("For nested data item, row-key is required.");
            }
            cur = { ...treeData.value[childKey] };
            if (cur) {
              innerTreeRowData.expanded = cur.expanded;
              cur.level = cur.level || innerTreeRowData.level;
              cur.display = !!(cur.expanded && innerTreeRowData.display);
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                innerTreeRowData.loading = cur.loading;
              }
            }
            i++;
            tmp.push(rowRender(node, $index + i, innerTreeRowData));
            if (cur) {
              const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
              traverse(nodes2, cur);
            }
          });
        };
        cur.display = true;
        const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
        traverse(nodes, cur);
      }
      return tmp;
    } else {
      return rowRender(row, $index, void 0);
    }
  };
  return {
    wrappedRowRender,
    tooltipContent,
    tooltipTrigger
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/defaults.mjs
var defaultProps = {
  store: {
    required: true,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-body/index.mjs
var TableBody = (0, import_vue516.defineComponent)({
  name: "ElTableBody",
  props: defaultProps,
  setup(props) {
    const instance = (0, import_vue516.getCurrentInstance)();
    const parent = (0, import_vue516.inject)(TABLE_INJECTION_KEY);
    const ns2 = useNamespace("table");
    const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender(props);
    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
    (0, import_vue516.watch)(props.store.states.hoverRow, (newVal, oldVal) => {
      if (!props.store.states.isComplex.value || !isClient)
        return;
      let raf = window.requestAnimationFrame;
      if (!raf) {
        raf = (fn2) => window.setTimeout(fn2, 16);
      }
      raf(() => {
        const el = instance == null ? void 0 : instance.vnode.el;
        const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns2.e("row")}`));
        const oldRow = rows[oldVal];
        const newRow = rows[newVal];
        if (oldRow) {
          removeClass(oldRow, "hover-row");
        }
        if (newRow) {
          addClass(newRow, "hover-row");
        }
      });
    });
    (0, import_vue516.onUnmounted)(() => {
      var _a2;
      (_a2 = removePopper) == null ? void 0 : _a2();
    });
    return {
      ns: ns2,
      onColumnsChange,
      onScrollableChange,
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    };
  },
  render() {
    const { wrappedRowRender, store } = this;
    const data = store.states.data.value || [];
    return (0, import_vue516.h)("tbody", {}, [
      data.reduce((acc, row) => {
        return acc.concat(wrappedRowRender(row, acc.length));
      }, [])
    ]);
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-footer/index.mjs
var import_vue519 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/h-helper.mjs
var import_vue517 = require("vue");
function hColgroup(props) {
  const isAuto = props.tableLayout === "auto";
  let columns2 = props.columns || [];
  if (isAuto) {
    if (columns2.every((column2) => column2.width === void 0)) {
      columns2 = [];
    }
  }
  const getPropsData = (column2) => {
    const propsData = {
      key: `${props.tableLayout}_${column2.id}`,
      style: {},
      name: void 0
    };
    if (isAuto) {
      propsData.style = {
        width: `${column2.width}px`
      };
    } else {
      propsData.name = column2.id;
    }
    return propsData;
  };
  return (0, import_vue517.h)("colgroup", {}, columns2.map((column2) => (0, import_vue517.h)("col", getPropsData(column2))));
}
hColgroup.props = ["columns", "tableLayout"];

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-footer/mapState-helper.mjs
var import_vue518 = require("vue");
function useMapState() {
  const table = (0, import_vue518.inject)(TABLE_INJECTION_KEY);
  const store = table == null ? void 0 : table.store;
  const leftFixedLeafCount = (0, import_vue518.computed)(() => {
    return store.states.fixedLeafColumnsLength.value;
  });
  const rightFixedLeafCount = (0, import_vue518.computed)(() => {
    return store.states.rightFixedColumns.value.length;
  });
  const columnsCount = (0, import_vue518.computed)(() => {
    return store.states.columns.value.length;
  });
  const leftFixedCount = (0, import_vue518.computed)(() => {
    return store.states.fixedColumns.value.length;
  });
  const rightFixedCount = (0, import_vue518.computed)(() => {
    return store.states.rightFixedColumns.value.length;
  });
  return {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns: store.states.columns
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-footer/style-helper.mjs
function useStyle2(props) {
  const { columns: columns2 } = useMapState();
  const ns2 = useNamespace("table");
  const getCellClasses = (columns22, cellIndex) => {
    const column2 = columns22[cellIndex];
    const classes = [
      ns2.e("cell"),
      column2.id,
      column2.align,
      column2.labelClassName,
      ...getFixedColumnsClass(ns2.b(), cellIndex, column2.fixed, props.store)
    ];
    if (column2.className) {
      classes.push(column2.className);
    }
    if (!column2.children) {
      classes.push(ns2.is("leaf"));
    }
    return classes;
  };
  const getCellStyles = (column2, cellIndex) => {
    const fixedStyle = getFixedColumnOffset(cellIndex, column2.fixed, props.store);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return fixedStyle;
  };
  return {
    getCellClasses,
    getCellStyles,
    columns: columns2
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-footer/index.mjs
var TableFooter = (0, import_vue519.defineComponent)({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props) {
    const { getCellClasses, getCellStyles, columns: columns2 } = useStyle2(props);
    const ns2 = useNamespace("table");
    return {
      ns: ns2,
      getCellClasses,
      getCellStyles,
      columns: columns2
    };
  },
  render() {
    const {
      columns: columns2,
      getCellStyles,
      getCellClasses,
      summaryMethod,
      sumText,
      ns: ns2
    } = this;
    const data = this.store.states.data.value;
    let sums = [];
    if (summaryMethod) {
      sums = summaryMethod({
        columns: columns2,
        data
      });
    } else {
      columns2.forEach((column2, index2) => {
        if (index2 === 0) {
          sums[index2] = sumText;
          return;
        }
        const values = data.map((item) => Number(item[column2.property]));
        const precisions = [];
        let notNumber = true;
        values.forEach((value) => {
          if (!Number.isNaN(+value)) {
            notNumber = false;
            const decimal = `${value}`.split(".")[1];
            precisions.push(decimal ? decimal.length : 0);
          }
        });
        const precision = Math.max.apply(null, precisions);
        if (!notNumber) {
          sums[index2] = values.reduce((prev, curr) => {
            const value = Number(curr);
            if (!Number.isNaN(+value)) {
              return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
            } else {
              return prev;
            }
          }, 0);
        } else {
          sums[index2] = "";
        }
      });
    }
    return (0, import_vue519.h)("table", {
      class: ns2.e("footer"),
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      hColgroup({
        columns: columns2
      }),
      (0, import_vue519.h)("tbody", [
        (0, import_vue519.h)("tr", {}, [
          ...columns2.map((column2, cellIndex) => (0, import_vue519.h)("td", {
            key: cellIndex,
            colspan: column2.colSpan,
            rowspan: column2.rowSpan,
            class: getCellClasses(columns2, cellIndex),
            style: getCellStyles(column2, cellIndex)
          }, [
            (0, import_vue519.h)("div", {
              class: ["cell", column2.labelClassName]
            }, [sums[cellIndex]])
          ]))
        ])
      ])
    ]);
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table/utils-helper.mjs
function useUtils2(store) {
  const setCurrentRow = (row) => {
    store.commit("setCurrentRow", row);
  };
  const getSelectionRows = () => {
    return store.getSelectionRows();
  };
  const toggleRowSelection = (row, selected) => {
    store.toggleRowSelection(row, selected, false);
    store.updateAllSelected();
  };
  const clearSelection = () => {
    store.clearSelection();
  };
  const clearFilter = (columnKeys) => {
    store.clearFilter(columnKeys);
  };
  const toggleAllSelection = () => {
    store.commit("toggleAllSelection");
  };
  const toggleRowExpansion = (row, expanded) => {
    store.toggleRowExpansionAdapter(row, expanded);
  };
  const clearSort = () => {
    store.clearSort();
  };
  const sort2 = (prop, order) => {
    store.commit("sort", { prop, order });
  };
  return {
    setCurrentRow,
    getSelectionRows,
    toggleRowSelection,
    clearSelection,
    clearFilter,
    toggleAllSelection,
    toggleRowExpansion,
    clearSort,
    sort: sort2
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table/style-helper.mjs
var import_vue520 = require("vue");
function useStyle3(props, layout2, store, table) {
  const isHidden2 = (0, import_vue520.ref)(false);
  const renderExpanded = (0, import_vue520.ref)(null);
  const resizeProxyVisible = (0, import_vue520.ref)(false);
  const setDragVisible = (visible) => {
    resizeProxyVisible.value = visible;
  };
  const resizeState = (0, import_vue520.ref)({
    width: null,
    height: null,
    headerHeight: null
  });
  const isGroup = (0, import_vue520.ref)(false);
  const scrollbarViewStyle = {
    display: "inline-block",
    verticalAlign: "middle"
  };
  const tableWidth = (0, import_vue520.ref)();
  const tableScrollHeight = (0, import_vue520.ref)(0);
  const bodyScrollHeight = (0, import_vue520.ref)(0);
  const headerScrollHeight = (0, import_vue520.ref)(0);
  const footerScrollHeight = (0, import_vue520.ref)(0);
  (0, import_vue520.watchEffect)(() => {
    layout2.setHeight(props.height);
  });
  (0, import_vue520.watchEffect)(() => {
    layout2.setMaxHeight(props.maxHeight);
  });
  (0, import_vue520.watch)(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey2]) => {
    if (!(0, import_vue520.unref)(rowKey2) || !(0, import_vue520.unref)(currentRowKey))
      return;
    store.setCurrentRowKey(`${currentRowKey}`);
  }, {
    immediate: true
  });
  (0, import_vue520.watch)(() => props.data, (data) => {
    table.store.commit("setData", data);
  }, {
    immediate: true,
    deep: true
  });
  (0, import_vue520.watchEffect)(() => {
    if (props.expandRowKeys) {
      store.setExpandRowKeysAdapter(props.expandRowKeys);
    }
  });
  const handleMouseLeave = () => {
    table.store.commit("setHoverRow", null);
    if (table.hoverState)
      table.hoverState = null;
  };
  const handleHeaderFooterMousewheel = (event, data) => {
    const { pixelX, pixelY } = data;
    if (Math.abs(pixelX) >= Math.abs(pixelY)) {
      table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    }
  };
  const shouldUpdateHeight = (0, import_vue520.computed)(() => {
    return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
  });
  const tableBodyStyles = (0, import_vue520.computed)(() => {
    return {
      width: layout2.bodyWidth.value ? `${layout2.bodyWidth.value}px` : ""
    };
  });
  const doLayout = () => {
    if (shouldUpdateHeight.value) {
      layout2.updateElsHeight();
    }
    layout2.updateColumnsWidth();
    requestAnimationFrame(syncPosition);
  };
  (0, import_vue520.onMounted)(async () => {
    await (0, import_vue520.nextTick)();
    store.updateColumns();
    bindEvents();
    requestAnimationFrame(doLayout);
    const el = table.vnode.el;
    const tableHeader = table.refs.headerWrapper;
    if (props.flexible && el && el.parentElement) {
      el.parentElement.style.minWidth = "0";
    }
    resizeState.value = {
      width: tableWidth.value = el.offsetWidth,
      height: el.offsetHeight,
      headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
    };
    store.states.columns.value.forEach((column2) => {
      if (column2.filteredValue && column2.filteredValue.length) {
        table.store.commit("filterChange", {
          column: column2,
          values: column2.filteredValue,
          silent: true
        });
      }
    });
    table.$ready = true;
  });
  const setScrollClassByEl = (el, className) => {
    if (!el)
      return;
    const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
    classList.push(layout2.scrollX.value ? className : "is-scrolling-none");
    el.className = classList.join(" ");
  };
  const setScrollClass = (className) => {
    const { tableWrapper } = table.refs;
    setScrollClassByEl(tableWrapper, className);
  };
  const hasScrollClass = (className) => {
    const { tableWrapper } = table.refs;
    return !!(tableWrapper && tableWrapper.classList.contains(className));
  };
  const syncPosition = function() {
    if (!table.refs.scrollBarRef)
      return;
    if (!layout2.scrollX.value) {
      const scrollingNoneClass = "is-scrolling-none";
      if (!hasScrollClass(scrollingNoneClass)) {
        setScrollClass(scrollingNoneClass);
      }
      return;
    }
    const scrollContainer = table.refs.scrollBarRef.wrapRef;
    if (!scrollContainer)
      return;
    const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
    const { headerWrapper, footerWrapper } = table.refs;
    if (headerWrapper)
      headerWrapper.scrollLeft = scrollLeft;
    if (footerWrapper)
      footerWrapper.scrollLeft = scrollLeft;
    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
    if (scrollLeft >= maxScrollLeftPosition) {
      setScrollClass("is-scrolling-right");
    } else if (scrollLeft === 0) {
      setScrollClass("is-scrolling-left");
    } else {
      setScrollClass("is-scrolling-middle");
    }
  };
  const bindEvents = () => {
    if (!table.refs.scrollBarRef)
      return;
    if (table.refs.scrollBarRef.wrapRef) {
      useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
        passive: true
      });
    }
    if (props.fit) {
      useResizeObserver(table.vnode.el, resizeListener);
    } else {
      useEventListener(window, "resize", resizeListener);
    }
    useResizeObserver(table.refs.bodyWrapper, () => {
      var _a2, _b;
      resizeListener();
      (_b = (_a2 = table.refs) == null ? void 0 : _a2.scrollBarRef) == null ? void 0 : _b.update();
    });
  };
  const resizeListener = () => {
    var _a2, _b, _c;
    const el = table.vnode.el;
    if (!table.$ready || !el)
      return;
    let shouldUpdateLayout = false;
    const {
      width: oldWidth,
      height: oldHeight,
      headerHeight: oldHeaderHeight
    } = resizeState.value;
    const width = tableWidth.value = el.offsetWidth;
    if (oldWidth !== width) {
      shouldUpdateLayout = true;
    }
    const height = el.offsetHeight;
    if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
      shouldUpdateLayout = true;
    }
    const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a2 = table.refs.tableHeaderRef) == null ? void 0 : _a2.$el;
    if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
      shouldUpdateLayout = true;
    }
    tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
    headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
    footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
    bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value;
    if (shouldUpdateLayout) {
      resizeState.value = {
        width,
        height,
        headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
      };
      doLayout();
    }
  };
  const tableSize = useSize();
  const bodyWidth = (0, import_vue520.computed)(() => {
    const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout2;
    return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
  });
  const tableLayout = (0, import_vue520.computed)(() => {
    if (props.maxHeight)
      return "fixed";
    return props.tableLayout;
  });
  const emptyBlockStyle = (0, import_vue520.computed)(() => {
    if (props.data && props.data.length)
      return null;
    let height = "100%";
    if (props.height && bodyScrollHeight.value) {
      height = `${bodyScrollHeight.value}px`;
    }
    const width = tableWidth.value;
    return {
      width: width ? `${width}px` : "",
      height
    };
  });
  const tableInnerStyle = (0, import_vue520.computed)(() => {
    if (props.height) {
      return {
        height: !Number.isNaN(Number(props.height)) ? `${props.height}px` : props.height
      };
    }
    if (props.maxHeight) {
      return {
        maxHeight: !Number.isNaN(Number(props.maxHeight)) ? `${props.maxHeight}px` : props.maxHeight
      };
    }
    return {};
  });
  const scrollbarStyle = (0, import_vue520.computed)(() => {
    if (props.height) {
      return {
        height: "100%"
      };
    }
    if (props.maxHeight) {
      if (!Number.isNaN(Number(props.maxHeight))) {
        const maxHeight = props.maxHeight;
        const reachMaxHeight = tableScrollHeight.value >= Number(maxHeight);
        if (reachMaxHeight) {
          return {
            maxHeight: `${tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value}px`
          };
        }
      } else {
        return {
          maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
        };
      }
    }
    return {};
  });
  const handleFixedMousewheel = (event, data) => {
    const bodyWrapper = table.refs.bodyWrapper;
    if (Math.abs(data.spinY) > 0) {
      const currentScrollTop = bodyWrapper.scrollTop;
      if (data.pixelY < 0 && currentScrollTop !== 0) {
        event.preventDefault();
      }
      if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
        event.preventDefault();
      }
      bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
    } else {
      bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    }
  };
  return {
    isHidden: isHidden2,
    renderExpanded,
    setDragVisible,
    isGroup,
    handleMouseLeave,
    handleHeaderFooterMousewheel,
    tableSize,
    emptyBlockStyle,
    handleFixedMousewheel,
    resizeProxyVisible,
    bodyWidth,
    resizeState,
    doLayout,
    tableBodyStyles,
    tableLayout,
    scrollbarViewStyle,
    tableInnerStyle,
    scrollbarStyle
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table/defaults.mjs
var defaultProps2 = {
  data: {
    type: Array,
    default: () => []
  },
  size: String,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: true
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: true
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: true
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => {
      return {
        hasChildren: "hasChildren",
        children: "children"
      };
    }
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  },
  flexible: Boolean
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/composables/use-scrollbar.mjs
var import_vue521 = require("vue");
var useScrollbar = () => {
  const scrollBarRef = (0, import_vue521.ref)();
  const scrollTo = (options, yCoord) => {
    const scrollbar = scrollBarRef.value;
    if (scrollbar) {
      scrollbar.scrollTo(options, yCoord);
    }
  };
  const setScrollPosition = (position, offset2) => {
    const scrollbar = scrollBarRef.value;
    if (scrollbar && isNumber(offset2) && ["Top", "Left"].includes(position)) {
      scrollbar[`setScroll${position}`](offset2);
    }
  };
  const setScrollTop = (top) => setScrollPosition("Top", top);
  const setScrollLeft = (left2) => setScrollPosition("Left", left2);
  return {
    scrollBarRef,
    scrollTo,
    setScrollTop,
    setScrollLeft
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table.mjs
var tableIdSeed = 1;
var _sfc_main121 = (0, import_vue522.defineComponent)({
  name: "ElTable",
  directives: {
    Mousewheel
  },
  components: {
    TableHeader,
    TableBody,
    TableFooter,
    ElScrollbar,
    hColgroup
  },
  props: defaultProps2,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(props) {
    const { t } = useLocale();
    const ns2 = useNamespace("table");
    const table = (0, import_vue522.getCurrentInstance)();
    (0, import_vue522.provide)(TABLE_INJECTION_KEY, table);
    const store = createStore(table, props);
    table.store = store;
    const layout2 = new TableLayout({
      store: table.store,
      table,
      fit: props.fit,
      showHeader: props.showHeader
    });
    table.layout = layout2;
    const isEmpty2 = (0, import_vue522.computed)(() => (store.states.data.value || []).length === 0);
    const {
      setCurrentRow,
      getSelectionRows,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort: sort2
    } = useUtils2(store);
    const {
      isHidden: isHidden2,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      emptyBlockStyle,
      handleFixedMousewheel,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout,
      tableBodyStyles,
      tableLayout,
      scrollbarViewStyle,
      tableInnerStyle,
      scrollbarStyle
    } = useStyle3(props, layout2, store, table);
    const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
    const debouncedUpdateLayout = debounce_default(doLayout, 50);
    const tableId = `${ns2.namespace.value}-table_${tableIdSeed++}`;
    table.tableId = tableId;
    table.state = {
      isGroup,
      resizeState,
      doLayout,
      debouncedUpdateLayout
    };
    const computedSumText = (0, import_vue522.computed)(() => props.sumText || t("el.table.sumText"));
    const computedEmptyText = (0, import_vue522.computed)(() => {
      return props.emptyText || t("el.table.emptyText");
    });
    return {
      ns: ns2,
      layout: layout2,
      store,
      handleHeaderFooterMousewheel,
      handleMouseLeave,
      tableId,
      tableSize,
      isHidden: isHidden2,
      isEmpty: isEmpty2,
      renderExpanded,
      resizeProxyVisible,
      resizeState,
      isGroup,
      bodyWidth,
      tableBodyStyles,
      emptyBlockStyle,
      debouncedUpdateLayout,
      handleFixedMousewheel,
      setCurrentRow,
      getSelectionRows,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort: sort2,
      t,
      setDragVisible,
      context: table,
      computedSumText,
      computedEmptyText,
      tableLayout,
      scrollbarViewStyle,
      tableInnerStyle,
      scrollbarStyle,
      scrollBarRef,
      scrollTo,
      setScrollLeft,
      setScrollTop
    };
  }
});
var _hoisted_178 = ["data-prefix"];
var _hoisted_247 = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hColgroup = (0, import_vue522.resolveComponent)("hColgroup");
  const _component_table_header = (0, import_vue522.resolveComponent)("table-header");
  const _component_table_body = (0, import_vue522.resolveComponent)("table-body");
  const _component_el_scrollbar = (0, import_vue522.resolveComponent)("el-scrollbar");
  const _component_table_footer = (0, import_vue522.resolveComponent)("table-footer");
  const _directive_mousewheel = (0, import_vue522.resolveDirective)("mousewheel");
  return (0, import_vue522.openBlock)(), (0, import_vue522.createElementBlock)("div", {
    ref: "tableWrapper",
    class: (0, import_vue522.normalizeClass)([
      {
        [_ctx.ns.m("fit")]: _ctx.fit,
        [_ctx.ns.m("striped")]: _ctx.stripe,
        [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
        [_ctx.ns.m("hidden")]: _ctx.isHidden,
        [_ctx.ns.m("group")]: _ctx.isGroup,
        [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
        [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
        [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
        [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
        [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
        "has-footer": _ctx.showSummary
      },
      _ctx.ns.m(_ctx.tableSize),
      _ctx.className,
      _ctx.ns.b(),
      _ctx.ns.m(`layout-${_ctx.tableLayout}`)
    ]),
    style: (0, import_vue522.normalizeStyle)(_ctx.style),
    "data-prefix": _ctx.ns.namespace.value,
    onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseLeave())
  }, [
    (0, import_vue522.createElementVNode)("div", {
      class: (0, import_vue522.normalizeClass)(_ctx.ns.e("inner-wrapper")),
      style: (0, import_vue522.normalizeStyle)(_ctx.tableInnerStyle)
    }, [
      (0, import_vue522.createElementVNode)("div", _hoisted_247, [
        (0, import_vue522.renderSlot)(_ctx.$slots, "default")
      ], 512),
      _ctx.showHeader && _ctx.tableLayout === "fixed" ? (0, import_vue522.withDirectives)(((0, import_vue522.openBlock)(), (0, import_vue522.createElementBlock)("div", {
        key: 0,
        ref: "headerWrapper",
        class: (0, import_vue522.normalizeClass)(_ctx.ns.e("header-wrapper"))
      }, [
        (0, import_vue522.createElementVNode)("table", {
          ref: "tableHeader",
          class: (0, import_vue522.normalizeClass)(_ctx.ns.e("header")),
          style: (0, import_vue522.normalizeStyle)(_ctx.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          (0, import_vue522.createVNode)(_component_hColgroup, {
            columns: _ctx.store.states.columns.value,
            "table-layout": _ctx.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          (0, import_vue522.createVNode)(_component_table_header, {
            ref: "tableHeaderRef",
            border: _ctx.border,
            "default-sort": _ctx.defaultSort,
            store: _ctx.store,
            onSetDragVisible: _ctx.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
      ]) : (0, import_vue522.createCommentVNode)("v-if", true),
      (0, import_vue522.createElementVNode)("div", {
        ref: "bodyWrapper",
        class: (0, import_vue522.normalizeClass)(_ctx.ns.e("body-wrapper"))
      }, [
        (0, import_vue522.createVNode)(_component_el_scrollbar, {
          ref: "scrollBarRef",
          "view-style": _ctx.scrollbarViewStyle,
          "wrap-style": _ctx.scrollbarStyle,
          always: _ctx.scrollbarAlwaysOn
        }, {
          default: (0, import_vue522.withCtx)(() => [
            (0, import_vue522.createElementVNode)("table", {
              ref: "tableBody",
              class: (0, import_vue522.normalizeClass)(_ctx.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: (0, import_vue522.normalizeStyle)({
                width: _ctx.bodyWidth,
                tableLayout: _ctx.tableLayout
              })
            }, [
              (0, import_vue522.createVNode)(_component_hColgroup, {
                columns: _ctx.store.states.columns.value,
                "table-layout": _ctx.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              _ctx.showHeader && _ctx.tableLayout === "auto" ? ((0, import_vue522.openBlock)(), (0, import_vue522.createBlock)(_component_table_header, {
                key: 0,
                ref: "tableHeaderRef",
                border: _ctx.border,
                "default-sort": _ctx.defaultSort,
                store: _ctx.store,
                onSetDragVisible: _ctx.setDragVisible
              }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : (0, import_vue522.createCommentVNode)("v-if", true),
              (0, import_vue522.createVNode)(_component_table_body, {
                context: _ctx.context,
                highlight: _ctx.highlightCurrentRow,
                "row-class-name": _ctx.rowClassName,
                "tooltip-effect": _ctx.tooltipEffect,
                "tooltip-options": _ctx.tooltipOptions,
                "row-style": _ctx.rowStyle,
                store: _ctx.store,
                stripe: _ctx.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"])
            ], 6),
            _ctx.isEmpty ? ((0, import_vue522.openBlock)(), (0, import_vue522.createElementBlock)("div", {
              key: 0,
              ref: "emptyBlock",
              style: (0, import_vue522.normalizeStyle)(_ctx.emptyBlockStyle),
              class: (0, import_vue522.normalizeClass)(_ctx.ns.e("empty-block"))
            }, [
              (0, import_vue522.createElementVNode)("span", {
                class: (0, import_vue522.normalizeClass)(_ctx.ns.e("empty-text"))
              }, [
                (0, import_vue522.renderSlot)(_ctx.$slots, "empty", {}, () => [
                  (0, import_vue522.createTextVNode)((0, import_vue522.toDisplayString)(_ctx.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : (0, import_vue522.createCommentVNode)("v-if", true),
            _ctx.$slots.append ? ((0, import_vue522.openBlock)(), (0, import_vue522.createElementBlock)("div", {
              key: 1,
              ref: "appendWrapper",
              class: (0, import_vue522.normalizeClass)(_ctx.ns.e("append-wrapper"))
            }, [
              (0, import_vue522.renderSlot)(_ctx.$slots, "append")
            ], 2)) : (0, import_vue522.createCommentVNode)("v-if", true)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      _ctx.showSummary ? (0, import_vue522.withDirectives)(((0, import_vue522.openBlock)(), (0, import_vue522.createElementBlock)("div", {
        key: 1,
        ref: "footerWrapper",
        class: (0, import_vue522.normalizeClass)(_ctx.ns.e("footer-wrapper"))
      }, [
        (0, import_vue522.createVNode)(_component_table_footer, {
          border: _ctx.border,
          "default-sort": _ctx.defaultSort,
          store: _ctx.store,
          style: (0, import_vue522.normalizeStyle)(_ctx.tableBodyStyles),
          "sum-text": _ctx.computedSumText,
          "summary-method": _ctx.summaryMethod
        }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
      ], 2)), [
        [import_vue522.vShow, !_ctx.isEmpty],
        [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
      ]) : (0, import_vue522.createCommentVNode)("v-if", true),
      _ctx.border || _ctx.isGroup ? ((0, import_vue522.openBlock)(), (0, import_vue522.createElementBlock)("div", {
        key: 2,
        class: (0, import_vue522.normalizeClass)(_ctx.ns.e("border-left-patch"))
      }, null, 2)) : (0, import_vue522.createCommentVNode)("v-if", true)
    ], 6),
    (0, import_vue522.withDirectives)((0, import_vue522.createElementVNode)("div", {
      ref: "resizeProxy",
      class: (0, import_vue522.normalizeClass)(_ctx.ns.e("column-resize-proxy"))
    }, null, 2), [
      [import_vue522.vShow, _ctx.resizeProxyVisible]
    ])
  ], 46, _hoisted_178);
}
var Table = /* @__PURE__ */ _export_sfc(_sfc_main121, [["render", _sfc_render39], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-column/index.mjs
var import_vue526 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/config.mjs
var import_vue523 = require("vue");
var defaultClassNames = {
  selection: "table-column--selection",
  expand: "table__expand-column"
};
var cellStarts = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
};
var getDefaultClassName = (type4) => {
  return defaultClassNames[type4] || "";
};
var cellForced = {
  selection: {
    renderHeader({ store }) {
      function isDisabled() {
        return store.states.data.value && store.states.data.value.length === 0;
      }
      return (0, import_vue523.h)(ElCheckbox, {
        disabled: isDisabled(),
        size: store.states.tableSize.value,
        indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
        "onUpdate:modelValue": store.toggleAllSelection,
        modelValue: store.states.isAllSelected.value
      });
    },
    renderCell({
      row,
      column: column2,
      store,
      $index
    }) {
      return (0, import_vue523.h)(ElCheckbox, {
        disabled: column2.selectable ? !column2.selectable.call(null, row, $index) : false,
        size: store.states.tableSize.value,
        onChange: () => {
          store.commit("rowSelectedChanged", row);
        },
        onClick: (event) => event.stopPropagation(),
        modelValue: store.isSelected(row)
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader({ column: column2 }) {
      return column2.label || "#";
    },
    renderCell({
      column: column2,
      $index
    }) {
      let i = $index + 1;
      const index2 = column2.index;
      if (typeof index2 === "number") {
        i = $index + index2;
      } else if (typeof index2 === "function") {
        i = index2($index);
      }
      return (0, import_vue523.h)("div", {}, [i]);
    },
    sortable: false
  },
  expand: {
    renderHeader({ column: column2 }) {
      return column2.label || "";
    },
    renderCell({
      row,
      store,
      expanded
    }) {
      const { ns: ns2 } = store;
      const classes = [ns2.e("expand-icon")];
      if (expanded) {
        classes.push(ns2.em("expand-icon", "expanded"));
      }
      const callback = function(e) {
        e.stopPropagation();
        store.toggleRowExpansion(row);
      };
      return (0, import_vue523.h)("div", {
        class: classes,
        onClick: callback
      }, {
        default: () => {
          return [
            (0, import_vue523.h)(ElIcon, null, {
              default: () => {
                return [(0, import_vue523.h)(arrow_right_default)];
              }
            })
          ];
        }
      });
    },
    sortable: false,
    resizable: false
  }
};
function defaultRenderCell({
  row,
  column: column2,
  $index
}) {
  var _a2;
  const property2 = column2.property;
  const value = property2 && getProp(row, property2).value;
  if (column2 && column2.formatter) {
    return column2.formatter(row, column2, value, $index);
  }
  return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
}
function treeCellPrefix({
  row,
  treeNode,
  store
}, createPlacehoder = false) {
  const { ns: ns2 } = store;
  if (!treeNode) {
    if (createPlacehoder) {
      return [
        (0, import_vue523.h)("span", {
          class: ns2.e("placeholder")
        })
      ];
    }
    return null;
  }
  const ele = [];
  const callback = function(e) {
    e.stopPropagation();
    if (treeNode.loading) {
      return;
    }
    store.loadOrToggle(row);
  };
  if (treeNode.indent) {
    ele.push((0, import_vue523.h)("span", {
      class: ns2.e("indent"),
      style: { "padding-left": `${treeNode.indent}px` }
    }));
  }
  if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
    const expandClasses = [
      ns2.e("expand-icon"),
      treeNode.expanded ? ns2.em("expand-icon", "expanded") : ""
    ];
    let icon = arrow_right_default;
    if (treeNode.loading) {
      icon = loading_default;
    }
    ele.push((0, import_vue523.h)("div", {
      class: expandClasses,
      onClick: callback
    }, {
      default: () => {
        return [
          (0, import_vue523.h)(ElIcon, { class: { [ns2.is("loading")]: treeNode.loading } }, {
            default: () => [(0, import_vue523.h)(icon)]
          })
        ];
      }
    }));
  } else {
    ele.push((0, import_vue523.h)("span", {
      class: ns2.e("placeholder")
    }));
  }
  return ele;
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-column/watcher-helper.mjs
var import_vue524 = require("vue");
var import_shared90 = require("@vue/shared");
function getAllAliases(props, aliases) {
  return props.reduce((prev, cur) => {
    prev[cur] = cur;
    return prev;
  }, aliases);
}
function useWatcher2(owner, props_) {
  const instance = (0, import_vue524.getCurrentInstance)();
  const registerComplexWatchers = () => {
    const props = ["fixed"];
    const aliases = {
      realWidth: "width",
      realMinWidth: "minWidth"
    };
    const allAliases = getAllAliases(props, aliases);
    Object.keys(allAliases).forEach((key) => {
      const columnKey = aliases[key];
      if ((0, import_shared90.hasOwn)(props_, columnKey)) {
        (0, import_vue524.watch)(() => props_[columnKey], (newVal) => {
          let value = newVal;
          if (columnKey === "width" && key === "realWidth") {
            value = parseWidth(newVal);
          }
          if (columnKey === "minWidth" && key === "realMinWidth") {
            value = parseMinWidth(newVal);
          }
          instance.columnConfig.value[columnKey] = value;
          instance.columnConfig.value[key] = value;
          const updateColumns = columnKey === "fixed";
          owner.value.store.scheduleLayout(updateColumns);
        });
      }
    });
  };
  const registerNormalWatchers = () => {
    const props = [
      "label",
      "filters",
      "filterMultiple",
      "sortable",
      "index",
      "formatter",
      "className",
      "labelClassName",
      "showOverflowTooltip"
    ];
    const aliases = {
      property: "prop",
      align: "realAlign",
      headerAlign: "realHeaderAlign"
    };
    const allAliases = getAllAliases(props, aliases);
    Object.keys(allAliases).forEach((key) => {
      const columnKey = aliases[key];
      if ((0, import_shared90.hasOwn)(props_, columnKey)) {
        (0, import_vue524.watch)(() => props_[columnKey], (newVal) => {
          instance.columnConfig.value[key] = newVal;
        });
      }
    });
  };
  return {
    registerComplexWatchers,
    registerNormalWatchers
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-column/render-helper.mjs
var import_vue525 = require("vue");
function useRender2(props, slots, owner) {
  const instance = (0, import_vue525.getCurrentInstance)();
  const columnId = (0, import_vue525.ref)("");
  const isSubColumn = (0, import_vue525.ref)(false);
  const realAlign = (0, import_vue525.ref)();
  const realHeaderAlign = (0, import_vue525.ref)();
  const ns2 = useNamespace("table");
  (0, import_vue525.watchEffect)(() => {
    realAlign.value = props.align ? `is-${props.align}` : null;
    realAlign.value;
  });
  (0, import_vue525.watchEffect)(() => {
    realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
    realHeaderAlign.value;
  });
  const columnOrTableParent = (0, import_vue525.computed)(() => {
    let parent = instance.vnode.vParent || instance.parent;
    while (parent && !parent.tableId && !parent.columnId) {
      parent = parent.vnode.vParent || parent.parent;
    }
    return parent;
  });
  const hasTreeColumn = (0, import_vue525.computed)(() => {
    const { store } = instance.parent;
    if (!store)
      return false;
    const { treeData } = store.states;
    const treeDataValue = treeData.value;
    return treeDataValue && Object.keys(treeDataValue).length > 0;
  });
  const realWidth = (0, import_vue525.ref)(parseWidth(props.width));
  const realMinWidth = (0, import_vue525.ref)(parseMinWidth(props.minWidth));
  const setColumnWidth = (column2) => {
    if (realWidth.value)
      column2.width = realWidth.value;
    if (realMinWidth.value) {
      column2.minWidth = realMinWidth.value;
    }
    if (!realWidth.value && realMinWidth.value) {
      column2.width = void 0;
    }
    if (!column2.minWidth) {
      column2.minWidth = 80;
    }
    column2.realWidth = Number(column2.width === void 0 ? column2.minWidth : column2.width);
    return column2;
  };
  const setColumnForcedProps = (column2) => {
    const type4 = column2.type;
    const source = cellForced[type4] || {};
    Object.keys(source).forEach((prop) => {
      const value = source[prop];
      if (prop !== "className" && value !== void 0) {
        column2[prop] = value;
      }
    });
    const className = getDefaultClassName(type4);
    if (className) {
      const forceClass = `${(0, import_vue525.unref)(ns2.namespace)}-${className}`;
      column2.className = column2.className ? `${column2.className} ${forceClass}` : forceClass;
    }
    return column2;
  };
  const checkSubColumn = (children) => {
    if (Array.isArray(children)) {
      children.forEach((child) => check(child));
    } else {
      check(children);
    }
    function check(item) {
      var _a2;
      if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
        item.vParent = instance;
      }
    }
  };
  const setColumnRenders = (column2) => {
    if (props.renderHeader) {
      debugWarn("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.");
    } else if (column2.type !== "selection") {
      column2.renderHeader = (scope) => {
        instance.columnConfig.value["label"];
        const renderHeader = slots.header;
        return renderHeader ? renderHeader(scope) : column2.label;
      };
    }
    let originRenderCell = column2.renderCell;
    if (column2.type === "expand") {
      column2.renderCell = (data) => (0, import_vue525.h)("div", {
        class: "cell"
      }, [originRenderCell(data)]);
      owner.value.renderExpanded = (data) => {
        return slots.default ? slots.default(data) : slots.default;
      };
    } else {
      originRenderCell = originRenderCell || defaultRenderCell;
      column2.renderCell = (data) => {
        let children = null;
        if (slots.default) {
          const vnodes = slots.default(data);
          children = vnodes.some((v3) => v3.type !== import_vue525.Comment) ? vnodes : originRenderCell(data);
        } else {
          children = originRenderCell(data);
        }
        const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === 0 && data.column.type !== "selection";
        const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
        const props2 = {
          class: "cell",
          style: {}
        };
        if (column2.showOverflowTooltip) {
          props2.class = `${props2.class} ${(0, import_vue525.unref)(ns2.namespace)}-tooltip`;
          props2.style = {
            width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
          };
        }
        checkSubColumn(children);
        return (0, import_vue525.h)("div", props2, [prefix, children]);
      };
    }
    return column2;
  };
  const getPropsData = (...propsKey) => {
    return propsKey.reduce((prev, cur) => {
      if (Array.isArray(cur)) {
        cur.forEach((key) => {
          prev[key] = props[key];
        });
      }
      return prev;
    }, {});
  };
  const getColumnElIndex = (children, child) => {
    return Array.prototype.indexOf.call(children, child);
  };
  return {
    columnId,
    realAlign,
    isSubColumn,
    realHeaderAlign,
    columnOrTableParent,
    setColumnWidth,
    setColumnForcedProps,
    setColumnRenders,
    getPropsData,
    getColumnElIndex
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-column/defaults.mjs
var defaultProps3 = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: false
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: true
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: [Boolean, Object],
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: true
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => {
      return ["ascending", "descending", null];
    },
    validator: (val) => {
      return val.every((order) => ["ascending", "descending", null].includes(order));
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/src/table-column/index.mjs
var import_shared91 = require("@vue/shared");
var columnIdSeed = 1;
var ElTableColumn = (0, import_vue526.defineComponent)({
  name: "ElTableColumn",
  components: {
    ElCheckbox
  },
  props: defaultProps3,
  setup(props, { slots }) {
    const instance = (0, import_vue526.getCurrentInstance)();
    const columnConfig = (0, import_vue526.ref)({});
    const owner = (0, import_vue526.computed)(() => {
      let parent2 = instance.parent;
      while (parent2 && !parent2.tableId) {
        parent2 = parent2.parent;
      }
      return parent2;
    });
    const { registerNormalWatchers, registerComplexWatchers } = useWatcher2(owner, props);
    const {
      columnId,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
      realAlign
    } = useRender2(props, slots, owner);
    const parent = columnOrTableParent.value;
    columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
    (0, import_vue526.onBeforeMount)(() => {
      isSubColumn.value = owner.value !== parent;
      const type4 = props.type || "default";
      const sortable = props.sortable === "" ? true : props.sortable;
      const defaults2 = {
        ...cellStarts[type4],
        id: columnId.value,
        type: type4,
        property: props.prop || props.property,
        align: realAlign,
        headerAlign: realHeaderAlign,
        showOverflowTooltip: props.showOverflowTooltip,
        filterable: props.filters || props.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: false,
        isSubColumn: false,
        filterOpened: false,
        sortable,
        index: props.index,
        rawColumnKey: instance.vnode.key
      };
      const basicProps = [
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ];
      const sortProps = ["sortMethod", "sortBy", "sortOrders"];
      const selectProps = ["selectable", "reserveSelection"];
      const filterProps = [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ];
      let column2 = getPropsData(basicProps, sortProps, selectProps, filterProps);
      column2 = mergeOptions(defaults2, column2);
      const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
      column2 = chains(column2);
      columnConfig.value = column2;
      registerNormalWatchers();
      registerComplexWatchers();
    });
    (0, import_vue526.onMounted)(() => {
      var _a2;
      const parent2 = columnOrTableParent.value;
      const children = isSubColumn.value ? parent2.vnode.el.children : (_a2 = parent2.refs.hiddenColumns) == null ? void 0 : _a2.children;
      const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
      columnConfig.value.getColumnIndex = getColumnIndex;
      const columnIndex = getColumnIndex();
      columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
    });
    (0, import_vue526.onBeforeUnmount)(() => {
      owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null);
    });
    instance.columnId = columnId.value;
    instance.columnConfig = columnConfig;
    return;
  },
  render() {
    var _a2, _b, _c;
    try {
      const renderDefault = (_b = (_a2 = this.$slots).default) == null ? void 0 : _b.call(_a2, {
        row: {},
        column: {},
        $index: -1
      });
      const children = [];
      if (Array.isArray(renderDefault)) {
        for (const childNode of renderDefault) {
          if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
            children.push(childNode);
          } else if (childNode.type === import_vue526.Fragment && Array.isArray(childNode.children)) {
            childNode.children.forEach((vnode2) => {
              if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !(0, import_shared91.isString)(vnode2 == null ? void 0 : vnode2.children)) {
                children.push(vnode2);
              }
            });
          }
        }
      }
      const vnode = (0, import_vue526.h)("div", children);
      return vnode;
    } catch (e) {
      return (0, import_vue526.h)("div", []);
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table/index.mjs
var ElTable = withInstall(Table, {
  TableColumn: ElTableColumn
});
var ElTableColumn2 = withNoopInstall(ElTableColumn);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/table-v2.mjs
var import_vue553 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/use-table.mjs
var import_vue534 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-columns.mjs
var import_vue527 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/constants.mjs
var SortOrder = /* @__PURE__ */ ((SortOrder2) => {
  SortOrder2["ASC"] = "asc";
  SortOrder2["DESC"] = "desc";
  return SortOrder2;
})(SortOrder || {});
var Alignment = /* @__PURE__ */ ((Alignment2) => {
  Alignment2["CENTER"] = "center";
  Alignment2["RIGHT"] = "right";
  return Alignment2;
})(Alignment || {});
var FixedDir = /* @__PURE__ */ ((FixedDir2) => {
  FixedDir2["LEFT"] = "left";
  FixedDir2["RIGHT"] = "right";
  return FixedDir2;
})(FixedDir || {});
var oppositeOrderMap = {
  [
    "asc"
    /* ASC */
  ]: "desc",
  [
    "desc"
    /* DESC */
  ]: "asc"
  /* ASC */
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/private.mjs
var placeholderSign = Symbol("placeholder");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/utils.mjs
var calcColumnStyle = (column2, fixedColumn, fixed) => {
  var _a2;
  const flex = {
    flexGrow: 0,
    flexShrink: 0,
    ...fixed ? {} : {
      flexGrow: column2.flexGrow || 0,
      flexShrink: column2.flexShrink || 1
    }
  };
  if (!fixed) {
    flex.flexShrink = 1;
  }
  const style = {
    ...(_a2 = column2.style) != null ? _a2 : {},
    ...flex,
    flexBasis: "auto",
    width: column2.width
  };
  if (!fixedColumn) {
    if (column2.maxWidth)
      style.maxWidth = column2.maxWidth;
    if (column2.minWidth)
      style.minWidth = column2.minWidth;
  }
  return style;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-columns.mjs
var import_shared92 = require("@vue/shared");
function useColumns(props, columns2, fixed) {
  const visibleColumns = (0, import_vue527.computed)(() => {
    return (0, import_vue527.unref)(columns2).filter((column2) => !column2.hidden);
  });
  const fixedColumnsOnLeft = (0, import_vue527.computed)(() => (0, import_vue527.unref)(visibleColumns).filter((column2) => column2.fixed === "left" || column2.fixed === true));
  const fixedColumnsOnRight = (0, import_vue527.computed)(() => (0, import_vue527.unref)(visibleColumns).filter((column2) => column2.fixed === "right"));
  const normalColumns = (0, import_vue527.computed)(() => (0, import_vue527.unref)(visibleColumns).filter((column2) => !column2.fixed));
  const mainColumns = (0, import_vue527.computed)(() => {
    const ret = [];
    (0, import_vue527.unref)(fixedColumnsOnLeft).forEach((column2) => {
      ret.push({
        ...column2,
        placeholderSign
      });
    });
    (0, import_vue527.unref)(normalColumns).forEach((column2) => {
      ret.push(column2);
    });
    (0, import_vue527.unref)(fixedColumnsOnRight).forEach((column2) => {
      ret.push({
        ...column2,
        placeholderSign
      });
    });
    return ret;
  });
  const hasFixedColumns = (0, import_vue527.computed)(() => {
    return (0, import_vue527.unref)(fixedColumnsOnLeft).length || (0, import_vue527.unref)(fixedColumnsOnRight).length;
  });
  const columnsStyles = (0, import_vue527.computed)(() => {
    const _columns = (0, import_vue527.unref)(columns2);
    return _columns.reduce((style, column2) => {
      style[column2.key] = calcColumnStyle(column2, (0, import_vue527.unref)(fixed), props.fixed);
      return style;
    }, {});
  });
  const columnsTotalWidth = (0, import_vue527.computed)(() => {
    return (0, import_vue527.unref)(visibleColumns).reduce((width, column2) => width + column2.width, 0);
  });
  const getColumn = (key) => {
    return (0, import_vue527.unref)(columns2).find((column2) => column2.key === key);
  };
  const getColumnStyle = (key) => {
    return (0, import_vue527.unref)(columnsStyles)[key];
  };
  const updateColumnWidth = (column2, width) => {
    column2.width = width;
  };
  function onColumnSorted(e) {
    var _a2;
    const { key } = e.currentTarget.dataset;
    if (!key)
      return;
    const { sortState, sortBy } = props;
    let order = SortOrder.ASC;
    if ((0, import_shared92.isObject)(sortState)) {
      order = oppositeOrderMap[sortState[key]];
    } else {
      order = oppositeOrderMap[sortBy.order];
    }
    (_a2 = props.onColumnSort) == null ? void 0 : _a2.call(props, { column: getColumn(key), key, order });
  }
  return {
    columns: columns2,
    columnsStyles,
    columnsTotalWidth,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    hasFixedColumns,
    mainColumns,
    normalColumns,
    visibleColumns,
    getColumn,
    getColumnStyle,
    updateColumnWidth,
    onColumnSorted
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-scrollbar.mjs
var import_vue528 = require("vue");
var useScrollbar2 = (props, {
  mainTableRef,
  leftTableRef,
  rightTableRef,
  onMaybeEndReached
}) => {
  const scrollPos = (0, import_vue528.ref)({ scrollLeft: 0, scrollTop: 0 });
  function doScroll(params) {
    var _a2, _b, _c;
    const { scrollTop } = params;
    (_a2 = mainTableRef.value) == null ? void 0 : _a2.scrollTo(params);
    (_b = leftTableRef.value) == null ? void 0 : _b.scrollToTop(scrollTop);
    (_c = rightTableRef.value) == null ? void 0 : _c.scrollToTop(scrollTop);
  }
  function scrollTo(params) {
    scrollPos.value = params;
    doScroll(params);
  }
  function scrollToTop(scrollTop) {
    scrollPos.value.scrollTop = scrollTop;
    doScroll((0, import_vue528.unref)(scrollPos));
  }
  function scrollToLeft(scrollLeft) {
    var _a2, _b;
    scrollPos.value.scrollLeft = scrollLeft;
    (_b = (_a2 = mainTableRef.value) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, (0, import_vue528.unref)(scrollPos));
  }
  function onScroll(params) {
    var _a2;
    scrollTo(params);
    (_a2 = props.onScroll) == null ? void 0 : _a2.call(props, params);
  }
  function onVerticalScroll({ scrollTop }) {
    const { scrollTop: currentScrollTop } = (0, import_vue528.unref)(scrollPos);
    if (scrollTop !== currentScrollTop)
      scrollToTop(scrollTop);
  }
  function scrollToRow(row, strategy = "auto") {
    var _a2;
    (_a2 = mainTableRef.value) == null ? void 0 : _a2.scrollToRow(row, strategy);
  }
  (0, import_vue528.watch)(() => (0, import_vue528.unref)(scrollPos).scrollTop, (cur, prev) => {
    if (cur > prev)
      onMaybeEndReached();
  });
  return {
    scrollPos,
    scrollTo,
    scrollToLeft,
    scrollToTop,
    scrollToRow,
    onScroll,
    onVerticalScroll
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-row.mjs
var import_vue529 = require("vue");
var useRow = (props, { mainTableRef, leftTableRef, rightTableRef, onMaybeEndReached }) => {
  const vm = (0, import_vue529.getCurrentInstance)();
  const { emit } = vm;
  const isResetting = (0, import_vue529.shallowRef)(false);
  const hoveringRowKey = (0, import_vue529.shallowRef)(null);
  const expandedRowKeys = (0, import_vue529.ref)(props.defaultExpandedRowKeys || []);
  const lastRenderedRowIndex = (0, import_vue529.ref)(-1);
  const resetIndex = (0, import_vue529.shallowRef)(null);
  const rowHeights = (0, import_vue529.ref)({});
  const pendingRowHeights = (0, import_vue529.ref)({});
  const leftTableHeights = (0, import_vue529.shallowRef)({});
  const mainTableHeights = (0, import_vue529.shallowRef)({});
  const rightTableHeights = (0, import_vue529.shallowRef)({});
  const isDynamic = (0, import_vue529.computed)(() => isNumber(props.estimatedRowHeight));
  function onRowsRendered(params) {
    var _a2;
    (_a2 = props.onRowsRendered) == null ? void 0 : _a2.call(props, params);
    if (params.rowCacheEnd > (0, import_vue529.unref)(lastRenderedRowIndex)) {
      lastRenderedRowIndex.value = params.rowCacheEnd;
    }
  }
  function onRowHovered({ hovered, rowKey: rowKey2 }) {
    hoveringRowKey.value = hovered ? rowKey2 : null;
  }
  function onRowExpanded({
    expanded,
    rowData,
    rowIndex,
    rowKey: rowKey2
  }) {
    var _a2, _b;
    const _expandedRowKeys = [...(0, import_vue529.unref)(expandedRowKeys)];
    const currentKeyIndex = _expandedRowKeys.indexOf(rowKey2);
    if (expanded) {
      if (currentKeyIndex === -1)
        _expandedRowKeys.push(rowKey2);
    } else {
      if (currentKeyIndex > -1)
        _expandedRowKeys.splice(currentKeyIndex, 1);
    }
    expandedRowKeys.value = _expandedRowKeys;
    emit("update:expandedRowKeys", _expandedRowKeys);
    (_a2 = props.onRowExpand) == null ? void 0 : _a2.call(props, {
      expanded,
      rowData,
      rowIndex,
      rowKey: rowKey2
    });
    (_b = props.onExpandedRowsChange) == null ? void 0 : _b.call(props, _expandedRowKeys);
  }
  const flushingRowHeights = debounce_default(() => {
    var _a2, _b, _c, _d;
    isResetting.value = true;
    rowHeights.value = { ...(0, import_vue529.unref)(rowHeights), ...(0, import_vue529.unref)(pendingRowHeights) };
    resetAfterIndex((0, import_vue529.unref)(resetIndex), false);
    pendingRowHeights.value = {};
    resetIndex.value = null;
    (_a2 = mainTableRef.value) == null ? void 0 : _a2.forceUpdate();
    (_b = leftTableRef.value) == null ? void 0 : _b.forceUpdate();
    (_c = rightTableRef.value) == null ? void 0 : _c.forceUpdate();
    (_d = vm.proxy) == null ? void 0 : _d.$forceUpdate();
    isResetting.value = false;
  }, 0);
  function resetAfterIndex(index2, forceUpdate = false) {
    if (!(0, import_vue529.unref)(isDynamic))
      return;
    [mainTableRef, leftTableRef, rightTableRef].forEach((tableRef) => {
      const table = (0, import_vue529.unref)(tableRef);
      if (table)
        table.resetAfterRowIndex(index2, forceUpdate);
    });
  }
  function resetHeights(rowKey2, height, rowIdx) {
    const resetIdx = (0, import_vue529.unref)(resetIndex);
    if (resetIdx === null) {
      resetIndex.value = rowIdx;
    } else {
      if (resetIdx > rowIdx) {
        resetIndex.value = rowIdx;
      }
    }
    pendingRowHeights.value[rowKey2] = height;
  }
  function onRowHeightChange({ rowKey: rowKey2, height, rowIndex }, fixedDir) {
    if (!fixedDir) {
      mainTableHeights.value[rowKey2] = height;
    } else {
      if (fixedDir === FixedDir.RIGHT) {
        rightTableHeights.value[rowKey2] = height;
      } else {
        leftTableHeights.value[rowKey2] = height;
      }
    }
    const maximumHeight = Math.max(...[leftTableHeights, rightTableHeights, mainTableHeights].map((records) => records.value[rowKey2] || 0));
    if ((0, import_vue529.unref)(rowHeights)[rowKey2] !== maximumHeight) {
      resetHeights(rowKey2, maximumHeight, rowIndex);
      flushingRowHeights();
    }
  }
  (0, import_vue529.watch)(lastRenderedRowIndex, () => onMaybeEndReached());
  return {
    hoveringRowKey,
    expandedRowKeys,
    lastRenderedRowIndex,
    isDynamic,
    isResetting,
    rowHeights,
    resetAfterIndex,
    onRowExpanded,
    onRowHovered,
    onRowsRendered,
    onRowHeightChange
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-data.mjs
var import_vue530 = require("vue");
var useData = (props, { expandedRowKeys, lastRenderedRowIndex, resetAfterIndex }) => {
  const depthMap = (0, import_vue530.ref)({});
  const flattenedData = (0, import_vue530.computed)(() => {
    const depths = {};
    const { data: data2, rowKey: rowKey2 } = props;
    const _expandedRowKeys = (0, import_vue530.unref)(expandedRowKeys);
    if (!_expandedRowKeys || !_expandedRowKeys.length)
      return data2;
    const array4 = [];
    const keysSet = /* @__PURE__ */ new Set();
    _expandedRowKeys.forEach((x3) => keysSet.add(x3));
    let copy = data2.slice();
    copy.forEach((x3) => depths[x3[rowKey2]] = 0);
    while (copy.length > 0) {
      const item = copy.shift();
      array4.push(item);
      if (keysSet.has(item[rowKey2]) && Array.isArray(item.children) && item.children.length > 0) {
        copy = [...item.children, ...copy];
        item.children.forEach((child) => depths[child[rowKey2]] = depths[item[rowKey2]] + 1);
      }
    }
    depthMap.value = depths;
    return array4;
  });
  const data = (0, import_vue530.computed)(() => {
    const { data: data2, expandColumnKey: expandColumnKey2 } = props;
    return expandColumnKey2 ? (0, import_vue530.unref)(flattenedData) : data2;
  });
  (0, import_vue530.watch)(data, (val, prev) => {
    if (val !== prev) {
      lastRenderedRowIndex.value = -1;
      resetAfterIndex(0, true);
    }
  });
  return {
    data,
    depthMap
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-styles.mjs
var import_vue532 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/utils.mjs
var import_vue531 = require("vue");
var import_shared93 = require("@vue/shared");
var sumReducer = (sum2, num) => sum2 + num;
var sum = (listLike) => {
  return (0, import_shared93.isArray)(listLike) ? listLike.reduce(sumReducer, 0) : listLike;
};
var tryCall = (fLike, params, defaultRet = {}) => {
  return (0, import_shared93.isFunction)(fLike) ? fLike(params) : fLike != null ? fLike : defaultRet;
};
var enforceUnit = (style) => {
  ;
  ["width", "maxWidth", "minWidth", "height"].forEach((key) => {
    style[key] = addUnit(style[key]);
  });
  return style;
};
var componentToSlot = (ComponentLike) => (0, import_vue531.isVNode)(ComponentLike) ? (props) => (0, import_vue531.h)(ComponentLike, props) : ComponentLike;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-styles.mjs
var useStyles2 = (props, {
  columnsTotalWidth,
  data,
  fixedColumnsOnLeft,
  fixedColumnsOnRight
}) => {
  const bodyWidth = (0, import_vue532.computed)(() => {
    const { fixed, width, vScrollbarSize } = props;
    const ret = width - vScrollbarSize;
    return fixed ? Math.max(Math.round((0, import_vue532.unref)(columnsTotalWidth)), ret) : ret;
  });
  const headerWidth = (0, import_vue532.computed)(() => (0, import_vue532.unref)(bodyWidth) + (props.fixed ? props.vScrollbarSize : 0));
  const mainTableHeight = (0, import_vue532.computed)(() => {
    const { height = 0, maxHeight = 0, footerHeight: footerHeight2, hScrollbarSize } = props;
    if (maxHeight > 0) {
      const _fixedRowsHeight = (0, import_vue532.unref)(fixedRowsHeight);
      const _rowsHeight = (0, import_vue532.unref)(rowsHeight);
      const _headerHeight = (0, import_vue532.unref)(headerHeight);
      const total2 = _headerHeight + _fixedRowsHeight + _rowsHeight + hScrollbarSize;
      return Math.min(total2, maxHeight - footerHeight2);
    }
    return height - footerHeight2;
  });
  const rowsHeight = (0, import_vue532.computed)(() => {
    const { rowHeight, estimatedRowHeight } = props;
    const _data = (0, import_vue532.unref)(data);
    if (isNumber(estimatedRowHeight)) {
      return _data.length * estimatedRowHeight;
    }
    return _data.length * rowHeight;
  });
  const fixedTableHeight = (0, import_vue532.computed)(() => {
    const { maxHeight } = props;
    const tableHeight = (0, import_vue532.unref)(mainTableHeight);
    if (isNumber(maxHeight) && maxHeight > 0)
      return tableHeight;
    const totalHeight = (0, import_vue532.unref)(rowsHeight) + (0, import_vue532.unref)(headerHeight) + (0, import_vue532.unref)(fixedRowsHeight);
    return Math.min(tableHeight, totalHeight);
  });
  const mapColumn = (column2) => column2.width;
  const leftTableWidth = (0, import_vue532.computed)(() => sum((0, import_vue532.unref)(fixedColumnsOnLeft).map(mapColumn)));
  const rightTableWidth = (0, import_vue532.computed)(() => sum((0, import_vue532.unref)(fixedColumnsOnRight).map(mapColumn)));
  const headerHeight = (0, import_vue532.computed)(() => sum(props.headerHeight));
  const fixedRowsHeight = (0, import_vue532.computed)(() => {
    var _a2;
    return (((_a2 = props.fixedData) == null ? void 0 : _a2.length) || 0) * props.rowHeight;
  });
  const windowHeight = (0, import_vue532.computed)(() => {
    return (0, import_vue532.unref)(mainTableHeight) - (0, import_vue532.unref)(headerHeight) - (0, import_vue532.unref)(fixedRowsHeight);
  });
  const rootStyle = (0, import_vue532.computed)(() => {
    const { style = {}, height, width } = props;
    return enforceUnit({
      ...style,
      height,
      width
    });
  });
  const footerHeight = (0, import_vue532.computed)(() => enforceUnit({ height: props.footerHeight }));
  const emptyStyle = (0, import_vue532.computed)(() => ({
    top: addUnit((0, import_vue532.unref)(headerHeight)),
    bottom: addUnit(props.footerHeight),
    width: addUnit(props.width)
  }));
  return {
    bodyWidth,
    fixedTableHeight,
    mainTableHeight,
    leftTableWidth,
    rightTableWidth,
    headerWidth,
    rowsHeight,
    windowHeight,
    footerHeight,
    emptyStyle,
    rootStyle,
    headerHeight
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/composables/use-auto-resize.mjs
var import_vue533 = require("vue");
var useAutoResize = (props) => {
  const sizer = (0, import_vue533.ref)();
  const width$ = (0, import_vue533.ref)(0);
  const height$ = (0, import_vue533.ref)(0);
  let resizerStopper;
  (0, import_vue533.onMounted)(() => {
    resizerStopper = useResizeObserver(sizer, ([entry]) => {
      const { width, height } = entry.contentRect;
      const { paddingLeft, paddingRight, paddingTop, paddingBottom } = getComputedStyle(entry.target);
      const left2 = Number.parseInt(paddingLeft) || 0;
      const right2 = Number.parseInt(paddingRight) || 0;
      const top = Number.parseInt(paddingTop) || 0;
      const bottom = Number.parseInt(paddingBottom) || 0;
      width$.value = width - left2 - right2;
      height$.value = height - top - bottom;
    }).stop;
  });
  (0, import_vue533.onBeforeUnmount)(() => {
    resizerStopper == null ? void 0 : resizerStopper();
  });
  (0, import_vue533.watch)([width$, height$], ([width, height]) => {
    var _a2;
    (_a2 = props.onResize) == null ? void 0 : _a2.call(props, {
      width,
      height
    });
  });
  return {
    sizer,
    width: width$,
    height: height$
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/use-table.mjs
var import_shared94 = require("@vue/shared");
function useTable(props) {
  const mainTableRef = (0, import_vue534.ref)();
  const leftTableRef = (0, import_vue534.ref)();
  const rightTableRef = (0, import_vue534.ref)();
  const {
    columns: columns2,
    columnsStyles,
    columnsTotalWidth,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    hasFixedColumns,
    mainColumns,
    onColumnSorted
  } = useColumns(props, (0, import_vue534.toRef)(props, "columns"), (0, import_vue534.toRef)(props, "fixed"));
  const {
    scrollTo,
    scrollToLeft,
    scrollToTop,
    scrollToRow,
    onScroll,
    onVerticalScroll,
    scrollPos
  } = useScrollbar2(props, {
    mainTableRef,
    leftTableRef,
    rightTableRef,
    onMaybeEndReached
  });
  const {
    expandedRowKeys,
    hoveringRowKey,
    lastRenderedRowIndex,
    isDynamic,
    isResetting,
    rowHeights,
    resetAfterIndex,
    onRowExpanded,
    onRowHeightChange,
    onRowHovered,
    onRowsRendered
  } = useRow(props, {
    mainTableRef,
    leftTableRef,
    rightTableRef,
    onMaybeEndReached
  });
  const { data, depthMap } = useData(props, {
    expandedRowKeys,
    lastRenderedRowIndex,
    resetAfterIndex
  });
  const {
    bodyWidth,
    fixedTableHeight,
    mainTableHeight,
    leftTableWidth,
    rightTableWidth,
    headerWidth,
    rowsHeight,
    windowHeight,
    footerHeight,
    emptyStyle,
    rootStyle,
    headerHeight
  } = useStyles2(props, {
    columnsTotalWidth,
    data,
    fixedColumnsOnLeft,
    fixedColumnsOnRight
  });
  const isScrolling = (0, import_vue534.shallowRef)(false);
  const containerRef = (0, import_vue534.ref)();
  const showEmpty = (0, import_vue534.computed)(() => {
    const noData = (0, import_vue534.unref)(data).length === 0;
    return (0, import_shared94.isArray)(props.fixedData) ? props.fixedData.length === 0 && noData : noData;
  });
  function getRowHeight(rowIndex) {
    const { estimatedRowHeight, rowHeight, rowKey: rowKey2 } = props;
    if (!estimatedRowHeight)
      return rowHeight;
    return (0, import_vue534.unref)(rowHeights)[(0, import_vue534.unref)(data)[rowIndex][rowKey2]] || estimatedRowHeight;
  }
  function onMaybeEndReached() {
    const { onEndReached } = props;
    if (!onEndReached)
      return;
    const { scrollTop } = (0, import_vue534.unref)(scrollPos);
    const _totalHeight = (0, import_vue534.unref)(rowsHeight);
    const clientHeight = (0, import_vue534.unref)(windowHeight);
    const heightUntilEnd = _totalHeight - (scrollTop + clientHeight) + props.hScrollbarSize;
    if ((0, import_vue534.unref)(lastRenderedRowIndex) >= 0 && _totalHeight === scrollTop + (0, import_vue534.unref)(mainTableHeight) - (0, import_vue534.unref)(headerHeight)) {
      onEndReached(heightUntilEnd);
    }
  }
  (0, import_vue534.watch)(() => props.expandedRowKeys, (val) => expandedRowKeys.value = val, {
    deep: true
  });
  return {
    columns: columns2,
    containerRef,
    mainTableRef,
    leftTableRef,
    rightTableRef,
    isDynamic,
    isResetting,
    isScrolling,
    hoveringRowKey,
    hasFixedColumns,
    columnsStyles,
    columnsTotalWidth,
    data,
    expandedRowKeys,
    depthMap,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    mainColumns,
    bodyWidth,
    emptyStyle,
    rootStyle,
    headerWidth,
    footerHeight,
    mainTableHeight,
    fixedTableHeight,
    leftTableWidth,
    rightTableWidth,
    showEmpty,
    getRowHeight,
    onColumnSorted,
    onRowHovered,
    onRowExpanded,
    onRowsRendered,
    onRowHeightChange,
    scrollTo,
    scrollToLeft,
    scrollToTop,
    scrollToRow,
    onScroll,
    onVerticalScroll
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/tokens.mjs
var TableV2InjectionKey = Symbol("tableV2");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/common.mjs
var classType = String;
var columns = {
  type: definePropType(Array),
  required: true
};
var column = {
  type: definePropType(Object)
};
var fixedDataType = {
  type: definePropType(Array)
};
var dataType = {
  ...fixedDataType,
  required: true
};
var expandColumnKey = String;
var expandKeys = {
  type: definePropType(Array),
  default: () => mutable([])
};
var requiredNumber = {
  type: Number,
  required: true
};
var rowKey = {
  type: definePropType([String, Number, Symbol]),
  default: "id"
};
var styleType = {
  type: definePropType(Object)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/row.mjs
var tableV2RowProps = buildProps({
  class: String,
  columns,
  columnsStyles: {
    type: definePropType(Object),
    required: true
  },
  depth: Number,
  expandColumnKey,
  estimatedRowHeight: {
    ...virtualizedGridProps.estimatedRowHeight,
    default: void 0
  },
  isScrolling: Boolean,
  onRowExpand: {
    type: definePropType(Function)
  },
  onRowHover: {
    type: definePropType(Function)
  },
  onRowHeightChange: {
    type: definePropType(Function)
  },
  rowData: {
    type: definePropType(Object),
    required: true
  },
  rowEventHandlers: {
    type: definePropType(Object)
  },
  rowIndex: {
    type: Number,
    required: true
  },
  rowKey,
  style: {
    type: definePropType(Object)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/header.mjs
var requiredNumberType = {
  type: Number,
  required: true
};
var tableV2HeaderProps = buildProps({
  class: String,
  columns,
  fixedHeaderData: {
    type: definePropType(Array)
  },
  headerData: {
    type: definePropType(Array),
    required: true
  },
  headerHeight: {
    type: definePropType([Number, Array]),
    default: 50
  },
  rowWidth: requiredNumberType,
  rowHeight: {
    type: Number,
    default: 50
  },
  height: requiredNumberType,
  width: requiredNumberType
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/grid.mjs
var tableV2GridProps = buildProps({
  columns,
  data: dataType,
  fixedData: fixedDataType,
  estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
  width: requiredNumber,
  height: requiredNumber,
  headerWidth: requiredNumber,
  headerHeight: tableV2HeaderProps.headerHeight,
  bodyWidth: requiredNumber,
  rowHeight: requiredNumber,
  cache: virtualizedListProps.cache,
  useIsScrolling: Boolean,
  scrollbarAlwaysOn: virtualizedGridProps.scrollbarAlwaysOn,
  scrollbarStartGap: virtualizedGridProps.scrollbarStartGap,
  scrollbarEndGap: virtualizedGridProps.scrollbarEndGap,
  class: classType,
  style: styleType,
  containerStyle: styleType,
  getRowHeight: {
    type: definePropType(Function),
    required: true
  },
  rowKey: tableV2RowProps.rowKey,
  onRowsRendered: {
    type: definePropType(Function)
  },
  onScroll: {
    type: definePropType(Function)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/table.mjs
var tableV2Props = buildProps({
  cache: tableV2GridProps.cache,
  estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
  rowKey,
  headerClass: {
    type: definePropType([
      String,
      Function
    ])
  },
  headerProps: {
    type: definePropType([
      Object,
      Function
    ])
  },
  headerCellProps: {
    type: definePropType([
      Object,
      Function
    ])
  },
  headerHeight: tableV2HeaderProps.headerHeight,
  footerHeight: {
    type: Number,
    default: 0
  },
  rowClass: {
    type: definePropType([String, Function])
  },
  rowProps: {
    type: definePropType([Object, Function])
  },
  rowHeight: {
    type: Number,
    default: 50
  },
  cellProps: {
    type: definePropType([
      Object,
      Function
    ])
  },
  columns,
  data: dataType,
  dataGetter: {
    type: definePropType(Function)
  },
  fixedData: fixedDataType,
  expandColumnKey: tableV2RowProps.expandColumnKey,
  expandedRowKeys: expandKeys,
  defaultExpandedRowKeys: expandKeys,
  class: classType,
  fixed: Boolean,
  style: {
    type: definePropType(Object)
  },
  width: requiredNumber,
  height: requiredNumber,
  maxHeight: Number,
  useIsScrolling: Boolean,
  indentSize: {
    type: Number,
    default: 12
  },
  iconSize: {
    type: Number,
    default: 12
  },
  hScrollbarSize: virtualizedGridProps.hScrollbarSize,
  vScrollbarSize: virtualizedGridProps.vScrollbarSize,
  scrollbarAlwaysOn: virtualizedScrollbarProps.alwaysOn,
  sortBy: {
    type: definePropType(Object),
    default: () => ({})
  },
  sortState: {
    type: definePropType(Object),
    default: void 0
  },
  onColumnSort: {
    type: definePropType(Function)
  },
  onExpandedRowsChange: {
    type: definePropType(Function)
  },
  onEndReached: {
    type: definePropType(Function)
  },
  onRowExpand: tableV2RowProps.onRowExpand,
  onScroll: tableV2GridProps.onScroll,
  onRowsRendered: tableV2GridProps.onRowsRendered,
  rowEventHandlers: tableV2RowProps.rowEventHandlers
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/main-table.mjs
var import_vue543 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/table-grid.mjs
var import_vue542 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/cell.mjs
var import_vue535 = require("vue");
var TableV2Cell = (props, {
  slots
}) => {
  var _a2;
  const {
    cellData,
    style
  } = props;
  const displayText = ((_a2 = cellData == null ? void 0 : cellData.toString) == null ? void 0 : _a2.call(cellData)) || "";
  return (0, import_vue535.createVNode)("div", {
    "class": props.class,
    "title": displayText,
    "style": style
  }, [slots.default ? slots.default(props) : displayText]);
};
TableV2Cell.displayName = "ElTableV2Cell";
TableV2Cell.inheritAttrs = false;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/header-cell.mjs
var import_vue536 = require("vue");
var HeaderCell = (props, {
  slots
}) => {
  var _a2, _b;
  return slots.default ? slots.default(props) : (0, import_vue536.createVNode)("div", {
    "class": props.class,
    "title": (_a2 = props.column) == null ? void 0 : _a2.title
  }, [(_b = props.column) == null ? void 0 : _b.title]);
};
HeaderCell.displayName = "ElTableV2HeaderCell";
HeaderCell.inheritAttrs = false;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/header-row.mjs
var import_vue537 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/header-row.mjs
var tableV2HeaderRowProps = buildProps({
  class: String,
  columns,
  columnsStyles: {
    type: definePropType(Object),
    required: true
  },
  headerIndex: Number,
  style: { type: definePropType(Object) }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/header-row.mjs
var import_shared95 = require("@vue/shared");
var TableV2HeaderRow = (0, import_vue537.defineComponent)({
  name: "ElTableV2HeaderRow",
  props: tableV2HeaderRowProps,
  setup(props, {
    slots
  }) {
    return () => {
      const {
        columns: columns2,
        columnsStyles,
        headerIndex,
        style
      } = props;
      let Cells = columns2.map((column2, columnIndex) => {
        return slots.cell({
          columns: columns2,
          column: column2,
          columnIndex,
          headerIndex,
          style: columnsStyles[column2.key]
        });
      });
      if (slots.header) {
        Cells = slots.header({
          cells: Cells.map((node) => {
            if ((0, import_shared95.isArray)(node) && node.length === 1) {
              return node[0];
            }
            return node;
          }),
          columns: columns2,
          headerIndex
        });
      }
      return (0, import_vue537.createVNode)("div", {
        "class": props.class,
        "style": style
      }, [Cells]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/header.mjs
var import_vue538 = require("vue");
var COMPONENT_NAME17 = "ElTableV2Header";
var TableV2Header = (0, import_vue538.defineComponent)({
  name: COMPONENT_NAME17,
  props: tableV2HeaderProps,
  setup(props, {
    slots,
    expose
  }) {
    const ns2 = useNamespace("table-v2");
    const headerRef = (0, import_vue538.ref)();
    const headerStyle = (0, import_vue538.computed)(() => enforceUnit({
      width: props.width,
      height: props.height
    }));
    const rowStyle = (0, import_vue538.computed)(() => enforceUnit({
      width: props.rowWidth,
      height: props.height
    }));
    const headerHeights = (0, import_vue538.computed)(() => castArray_default((0, import_vue538.unref)(props.headerHeight)));
    const scrollToLeft = (left2) => {
      const headerEl = (0, import_vue538.unref)(headerRef);
      (0, import_vue538.nextTick)(() => {
        (headerEl == null ? void 0 : headerEl.scroll) && headerEl.scroll({
          left: left2
        });
      });
    };
    const renderFixedRows = () => {
      const fixedRowClassName = ns2.e("fixed-header-row");
      const {
        columns: columns2,
        fixedHeaderData,
        rowHeight
      } = props;
      return fixedHeaderData == null ? void 0 : fixedHeaderData.map((fixedRowData, fixedRowIndex) => {
        var _a2;
        const style = enforceUnit({
          height: rowHeight,
          width: "100%"
        });
        return (_a2 = slots.fixed) == null ? void 0 : _a2.call(slots, {
          class: fixedRowClassName,
          columns: columns2,
          rowData: fixedRowData,
          rowIndex: -(fixedRowIndex + 1),
          style
        });
      });
    };
    const renderDynamicRows = () => {
      const dynamicRowClassName = ns2.e("dynamic-header-row");
      const {
        columns: columns2
      } = props;
      return (0, import_vue538.unref)(headerHeights).map((rowHeight, rowIndex) => {
        var _a2;
        const style = enforceUnit({
          width: "100%",
          height: rowHeight
        });
        return (_a2 = slots.dynamic) == null ? void 0 : _a2.call(slots, {
          class: dynamicRowClassName,
          columns: columns2,
          headerIndex: rowIndex,
          style
        });
      });
    };
    expose({
      scrollToLeft
    });
    return () => {
      if (props.height <= 0)
        return;
      return (0, import_vue538.createVNode)("div", {
        "ref": headerRef,
        "class": props.class,
        "style": (0, import_vue538.unref)(headerStyle)
      }, [(0, import_vue538.createVNode)("div", {
        "style": (0, import_vue538.unref)(rowStyle),
        "class": ns2.e("header")
      }, [renderDynamicRows(), renderFixedRows()])]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/row.mjs
var import_vue539 = require("vue");
var import_shared96 = require("@vue/shared");
var useTableRow = (props) => {
  const {
    isScrolling
  } = (0, import_vue539.inject)(TableV2InjectionKey);
  const measured = (0, import_vue539.ref)(false);
  const rowRef = (0, import_vue539.ref)();
  const measurable = (0, import_vue539.computed)(() => {
    return isNumber(props.estimatedRowHeight) && props.rowIndex >= 0;
  });
  const doMeasure = (isInit = false) => {
    const $rowRef = (0, import_vue539.unref)(rowRef);
    if (!$rowRef)
      return;
    const {
      columns: columns2,
      onRowHeightChange,
      rowKey: rowKey2,
      rowIndex,
      style
    } = props;
    const {
      height
    } = $rowRef.getBoundingClientRect();
    measured.value = true;
    (0, import_vue539.nextTick)(() => {
      if (isInit || height !== Number.parseInt(style.height)) {
        const firstColumn = columns2[0];
        const isPlaceholder = (firstColumn == null ? void 0 : firstColumn.placeholderSign) === placeholderSign;
        onRowHeightChange == null ? void 0 : onRowHeightChange({
          rowKey: rowKey2,
          height,
          rowIndex
        }, firstColumn && !isPlaceholder && firstColumn.fixed);
      }
    });
  };
  const eventHandlers = (0, import_vue539.computed)(() => {
    const {
      rowData,
      rowIndex,
      rowKey: rowKey2,
      onRowHover
    } = props;
    const handlers2 = props.rowEventHandlers || {};
    const eventHandlers2 = {};
    Object.entries(handlers2).forEach(([eventName, handler]) => {
      if ((0, import_shared96.isFunction)(handler)) {
        eventHandlers2[eventName] = (event) => {
          handler({
            event,
            rowData,
            rowIndex,
            rowKey: rowKey2
          });
        };
      }
    });
    if (onRowHover) {
      ;
      [{
        name: "onMouseleave",
        hovered: false
      }, {
        name: "onMouseenter",
        hovered: true
      }].forEach(({
        name,
        hovered
      }) => {
        const existedHandler = eventHandlers2[name];
        eventHandlers2[name] = (event) => {
          onRowHover({
            event,
            hovered,
            rowData,
            rowIndex,
            rowKey: rowKey2
          });
          existedHandler == null ? void 0 : existedHandler(event);
        };
      });
    }
    return eventHandlers2;
  });
  const onExpand = (expanded) => {
    const {
      onRowExpand,
      rowData,
      rowIndex,
      rowKey: rowKey2
    } = props;
    onRowExpand == null ? void 0 : onRowExpand({
      expanded,
      rowData,
      rowIndex,
      rowKey: rowKey2
    });
  };
  (0, import_vue539.onMounted)(() => {
    if ((0, import_vue539.unref)(measurable)) {
      doMeasure(true);
    }
  });
  return {
    isScrolling,
    measurable,
    measured,
    rowRef,
    eventHandlers,
    onExpand
  };
};
var COMPONENT_NAME18 = "ElTableV2TableRow";
var TableV2Row = (0, import_vue539.defineComponent)({
  name: COMPONENT_NAME18,
  props: tableV2RowProps,
  setup(props, {
    expose,
    slots,
    attrs
  }) {
    const {
      eventHandlers,
      isScrolling,
      measurable,
      measured,
      rowRef,
      onExpand
    } = useTableRow(props);
    expose({
      onExpand
    });
    return () => {
      const {
        columns: columns2,
        columnsStyles,
        expandColumnKey: expandColumnKey2,
        depth,
        rowData,
        rowIndex,
        style
      } = props;
      let ColumnCells = columns2.map((column2, columnIndex) => {
        const expandable = (0, import_shared96.isArray)(rowData.children) && rowData.children.length > 0 && column2.key === expandColumnKey2;
        return slots.cell({
          column: column2,
          columns: columns2,
          columnIndex,
          depth,
          style: columnsStyles[column2.key],
          rowData,
          rowIndex,
          isScrolling: (0, import_vue539.unref)(isScrolling),
          expandIconProps: expandable ? {
            rowData,
            rowIndex,
            onExpand
          } : void 0
        });
      });
      if (slots.row) {
        ColumnCells = slots.row({
          cells: ColumnCells.map((node) => {
            if ((0, import_shared96.isArray)(node) && node.length === 1) {
              return node[0];
            }
            return node;
          }),
          style,
          columns: columns2,
          depth,
          rowData,
          rowIndex,
          isScrolling: (0, import_vue539.unref)(isScrolling)
        });
      }
      if ((0, import_vue539.unref)(measurable)) {
        const {
          height,
          ...exceptHeightStyle
        } = style || {};
        const _measured = (0, import_vue539.unref)(measured);
        return (0, import_vue539.createVNode)("div", (0, import_vue539.mergeProps)({
          "ref": rowRef,
          "class": props.class,
          "style": _measured ? style : exceptHeightStyle
        }, attrs, (0, import_vue539.unref)(eventHandlers)), [ColumnCells]);
      }
      return (0, import_vue539.createVNode)("div", (0, import_vue539.mergeProps)(attrs, {
        "ref": rowRef,
        "class": props.class,
        "style": style
      }, (0, import_vue539.unref)(eventHandlers)), [ColumnCells]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/sort-icon.mjs
var import_vue540 = require("vue");
var SortIcon = (props) => {
  const {
    sortOrder
  } = props;
  return (0, import_vue540.createVNode)(ElIcon, {
    "size": 14,
    "class": props.class
  }, {
    default: () => [sortOrder === SortOrder.ASC ? (0, import_vue540.createVNode)(sort_up_default, null, null) : (0, import_vue540.createVNode)(sort_down_default, null, null)]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/expand-icon.mjs
var import_vue541 = require("vue");
var ExpandIcon = (props) => {
  const {
    expanded,
    expandable,
    onExpand,
    style,
    size: size2
  } = props;
  const expandIconProps = {
    onClick: expandable ? () => onExpand(!expanded) : void 0,
    class: props.class
  };
  return (0, import_vue541.createVNode)(ElIcon, (0, import_vue541.mergeProps)(expandIconProps, {
    "size": size2,
    "style": style
  }), {
    default: () => [(0, import_vue541.createVNode)(arrow_right_default, null, null)]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/table-grid.mjs
var import_shared97 = require("@vue/shared");
var COMPONENT_NAME19 = "ElTableV2Grid";
var useTableGrid = (props) => {
  const headerRef = (0, import_vue542.ref)();
  const bodyRef = (0, import_vue542.ref)();
  const totalHeight = (0, import_vue542.computed)(() => {
    const {
      data,
      rowHeight,
      estimatedRowHeight
    } = props;
    if (estimatedRowHeight) {
      return;
    }
    return data.length * rowHeight;
  });
  const fixedRowHeight = (0, import_vue542.computed)(() => {
    const {
      fixedData,
      rowHeight
    } = props;
    return ((fixedData == null ? void 0 : fixedData.length) || 0) * rowHeight;
  });
  const headerHeight = (0, import_vue542.computed)(() => sum(props.headerHeight));
  const gridHeight = (0, import_vue542.computed)(() => {
    const {
      height
    } = props;
    return Math.max(0, height - (0, import_vue542.unref)(headerHeight) - (0, import_vue542.unref)(fixedRowHeight));
  });
  const hasHeader = (0, import_vue542.computed)(() => {
    return (0, import_vue542.unref)(headerHeight) + (0, import_vue542.unref)(fixedRowHeight) > 0;
  });
  const itemKey = ({
    data,
    rowIndex
  }) => data[rowIndex][props.rowKey];
  function onItemRendered({
    rowCacheStart,
    rowCacheEnd,
    rowVisibleStart,
    rowVisibleEnd
  }) {
    var _a2;
    (_a2 = props.onRowsRendered) == null ? void 0 : _a2.call(props, {
      rowCacheStart,
      rowCacheEnd,
      rowVisibleStart,
      rowVisibleEnd
    });
  }
  function resetAfterRowIndex(index2, forceUpdate2) {
    var _a2;
    (_a2 = bodyRef.value) == null ? void 0 : _a2.resetAfterRowIndex(index2, forceUpdate2);
  }
  function scrollTo(leftOrOptions, top) {
    const header$ = (0, import_vue542.unref)(headerRef);
    const body$ = (0, import_vue542.unref)(bodyRef);
    if (!header$ || !body$)
      return;
    if ((0, import_shared97.isObject)(leftOrOptions)) {
      header$.scrollToLeft(leftOrOptions.scrollLeft);
      body$.scrollTo(leftOrOptions);
    } else {
      header$.scrollToLeft(leftOrOptions);
      body$.scrollTo({
        scrollLeft: leftOrOptions,
        scrollTop: top
      });
    }
  }
  function scrollToTop(scrollTop) {
    var _a2;
    (_a2 = (0, import_vue542.unref)(bodyRef)) == null ? void 0 : _a2.scrollTo({
      scrollTop
    });
  }
  function scrollToRow(row, strategy) {
    var _a2;
    (_a2 = (0, import_vue542.unref)(bodyRef)) == null ? void 0 : _a2.scrollToItem(row, 1, strategy);
  }
  function forceUpdate() {
    var _a2, _b;
    (_a2 = (0, import_vue542.unref)(bodyRef)) == null ? void 0 : _a2.$forceUpdate();
    (_b = (0, import_vue542.unref)(headerRef)) == null ? void 0 : _b.$forceUpdate();
  }
  return {
    bodyRef,
    forceUpdate,
    fixedRowHeight,
    gridHeight,
    hasHeader,
    headerHeight,
    headerRef,
    totalHeight,
    itemKey,
    onItemRendered,
    resetAfterRowIndex,
    scrollTo,
    scrollToTop,
    scrollToRow
  };
};
var TableGrid = (0, import_vue542.defineComponent)({
  name: COMPONENT_NAME19,
  props: tableV2GridProps,
  setup(props, {
    slots,
    expose
  }) {
    const {
      ns: ns2
    } = (0, import_vue542.inject)(TableV2InjectionKey);
    const {
      bodyRef,
      fixedRowHeight,
      gridHeight,
      hasHeader,
      headerRef,
      headerHeight,
      totalHeight,
      forceUpdate,
      itemKey,
      onItemRendered,
      resetAfterRowIndex,
      scrollTo,
      scrollToTop,
      scrollToRow
    } = useTableGrid(props);
    expose({
      forceUpdate,
      totalHeight,
      scrollTo,
      scrollToTop,
      scrollToRow,
      resetAfterRowIndex
    });
    const getColumnWidth = () => props.bodyWidth;
    return () => {
      const {
        cache: cache2,
        columns: columns2,
        data,
        fixedData,
        useIsScrolling,
        scrollbarAlwaysOn,
        scrollbarEndGap,
        scrollbarStartGap,
        style,
        rowHeight,
        bodyWidth,
        estimatedRowHeight,
        headerWidth,
        height,
        width,
        getRowHeight,
        onScroll
      } = props;
      const isDynamicRowEnabled = isNumber(estimatedRowHeight);
      const Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid;
      const _headerHeight = (0, import_vue542.unref)(headerHeight);
      return (0, import_vue542.createVNode)("div", {
        "role": "table",
        "class": [ns2.e("table"), props.class],
        "style": style
      }, [(0, import_vue542.createVNode)(Grid, {
        "ref": bodyRef,
        "data": data,
        "useIsScrolling": useIsScrolling,
        "itemKey": itemKey,
        "columnCache": 0,
        "columnWidth": isDynamicRowEnabled ? getColumnWidth : bodyWidth,
        "totalColumn": 1,
        "totalRow": data.length,
        "rowCache": cache2,
        "rowHeight": isDynamicRowEnabled ? getRowHeight : rowHeight,
        "width": width,
        "height": (0, import_vue542.unref)(gridHeight),
        "class": ns2.e("body"),
        "scrollbarStartGap": scrollbarStartGap,
        "scrollbarEndGap": scrollbarEndGap,
        "scrollbarAlwaysOn": scrollbarAlwaysOn,
        "onScroll": onScroll,
        "onItemRendered": onItemRendered,
        "perfMode": false
      }, {
        default: (params) => {
          var _a2;
          const rowData = data[params.rowIndex];
          return (_a2 = slots.row) == null ? void 0 : _a2.call(slots, {
            ...params,
            columns: columns2,
            rowData
          });
        }
      }), (0, import_vue542.unref)(hasHeader) && (0, import_vue542.createVNode)(TableV2Header, {
        "ref": headerRef,
        "class": ns2.e("header-wrapper"),
        "columns": columns2,
        "headerData": data,
        "headerHeight": props.headerHeight,
        "fixedHeaderData": fixedData,
        "rowWidth": headerWidth,
        "rowHeight": rowHeight,
        "width": width,
        "height": Math.min(_headerHeight + (0, import_vue542.unref)(fixedRowHeight), height)
      }, {
        dynamic: slots.header,
        fixed: slots.row
      })]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/main-table.mjs
function _isSlot(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !(0, import_vue543.isVNode)(s2);
}
var MainTable = (props, {
  slots
}) => {
  const {
    mainTableRef,
    ...rest
  } = props;
  return (0, import_vue543.createVNode)(TableGrid, (0, import_vue543.mergeProps)({
    "ref": mainTableRef
  }, rest), _isSlot(slots) ? slots : {
    default: () => [slots]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/left-table.mjs
var import_vue544 = require("vue");
function _isSlot2(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !(0, import_vue544.isVNode)(s2);
}
var LeftTable = (props, {
  slots
}) => {
  if (!props.columns.length)
    return;
  const {
    leftTableRef,
    ...rest
  } = props;
  return (0, import_vue544.createVNode)(TableGrid, (0, import_vue544.mergeProps)({
    "ref": leftTableRef
  }, rest), _isSlot2(slots) ? slots : {
    default: () => [slots]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/right-table.mjs
var import_vue545 = require("vue");
function _isSlot3(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !(0, import_vue545.isVNode)(s2);
}
var LeftTable2 = (props, {
  slots
}) => {
  if (!props.columns.length)
    return;
  const {
    rightTableRef,
    ...rest
  } = props;
  return (0, import_vue545.createVNode)(TableGrid, (0, import_vue545.mergeProps)({
    "ref": rightTableRef
  }, rest), _isSlot3(slots) ? slots : {
    default: () => [slots]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/row.mjs
var import_vue546 = require("vue");
function _isSlot4(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !(0, import_vue546.isVNode)(s2);
}
var RowRenderer = (props, {
  slots
}) => {
  const {
    columns: columns2,
    columnsStyles,
    depthMap,
    expandColumnKey: expandColumnKey2,
    expandedRowKeys,
    estimatedRowHeight,
    hasFixedColumns,
    hoveringRowKey,
    rowData,
    rowIndex,
    style,
    isScrolling,
    rowProps: rowProps2,
    rowClass,
    rowKey: rowKey2,
    rowEventHandlers,
    ns: ns2,
    onRowHovered,
    onRowExpanded
  } = props;
  const rowKls = tryCall(rowClass, {
    columns: columns2,
    rowData,
    rowIndex
  }, "");
  const additionalProps = tryCall(rowProps2, {
    columns: columns2,
    rowData,
    rowIndex
  });
  const _rowKey = rowData[rowKey2];
  const depth = depthMap[_rowKey] || 0;
  const canExpand = Boolean(expandColumnKey2);
  const isFixedRow = rowIndex < 0;
  const kls = [ns2.e("row"), rowKls, {
    [ns2.e(`row-depth-${depth}`)]: canExpand && rowIndex >= 0,
    [ns2.is("expanded")]: canExpand && expandedRowKeys.includes(_rowKey),
    [ns2.is("hovered")]: !isScrolling && _rowKey === hoveringRowKey,
    [ns2.is("fixed")]: !depth && isFixedRow,
    [ns2.is("customized")]: Boolean(slots.row)
  }];
  const onRowHover = hasFixedColumns ? onRowHovered : void 0;
  const _rowProps = {
    ...additionalProps,
    columns: columns2,
    columnsStyles,
    class: kls,
    depth,
    expandColumnKey: expandColumnKey2,
    estimatedRowHeight: isFixedRow ? void 0 : estimatedRowHeight,
    isScrolling,
    rowIndex,
    rowData,
    rowKey: _rowKey,
    rowEventHandlers,
    style
  };
  return (0, import_vue546.createVNode)(TableV2Row, (0, import_vue546.mergeProps)(_rowProps, {
    "onRowHover": onRowHover,
    "onRowExpand": onRowExpanded
  }), _isSlot4(slots) ? slots : {
    default: () => [slots]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/cell.mjs
var import_vue547 = require("vue");
var import_shared98 = require("@vue/shared");
var CellRenderer = ({
  columns: columns2,
  column: column2,
  columnIndex,
  depth,
  expandIconProps,
  isScrolling,
  rowData,
  rowIndex,
  style,
  expandedRowKeys,
  ns: ns2,
  cellProps: _cellProps,
  expandColumnKey: expandColumnKey2,
  indentSize,
  iconSize,
  rowKey: rowKey2
}, {
  slots
}) => {
  const cellStyle = enforceUnit(style);
  if (column2.placeholderSign === placeholderSign) {
    return (0, import_vue547.createVNode)("div", {
      "class": ns2.em("row-cell", "placeholder"),
      "style": cellStyle
    }, null);
  }
  const {
    cellRenderer,
    dataKey,
    dataGetter
  } = column2;
  const columnCellRenderer = componentToSlot(cellRenderer);
  const CellComponent = columnCellRenderer || slots.default || ((props) => (0, import_vue547.createVNode)(TableV2Cell, props, null));
  const cellData = (0, import_shared98.isFunction)(dataGetter) ? dataGetter({
    columns: columns2,
    column: column2,
    columnIndex,
    rowData,
    rowIndex
  }) : get_default(rowData, dataKey != null ? dataKey : "");
  const extraCellProps = tryCall(_cellProps, {
    cellData,
    columns: columns2,
    column: column2,
    columnIndex,
    rowIndex,
    rowData
  });
  const cellProps = {
    class: ns2.e("cell-text"),
    columns: columns2,
    column: column2,
    columnIndex,
    cellData,
    isScrolling,
    rowData,
    rowIndex
  };
  const Cell = CellComponent(cellProps);
  const kls = [ns2.e("row-cell"), column2.align === Alignment.CENTER && ns2.is("align-center"), column2.align === Alignment.RIGHT && ns2.is("align-right")];
  const expandable = rowIndex >= 0 && column2.key === expandColumnKey2;
  const expanded = rowIndex >= 0 && expandedRowKeys.includes(rowData[rowKey2]);
  let IconOrPlaceholder;
  const iconStyle = `margin-inline-start: ${depth * indentSize}px;`;
  if (expandable) {
    if ((0, import_shared98.isObject)(expandIconProps)) {
      IconOrPlaceholder = (0, import_vue547.createVNode)(ExpandIcon, (0, import_vue547.mergeProps)(expandIconProps, {
        "class": [ns2.e("expand-icon"), ns2.is("expanded", expanded)],
        "size": iconSize,
        "expanded": expanded,
        "style": iconStyle,
        "expandable": true
      }), null);
    } else {
      IconOrPlaceholder = (0, import_vue547.createVNode)("div", {
        "style": [iconStyle, `width: ${iconSize}px; height: ${iconSize}px;`].join(" ")
      }, null);
    }
  }
  return (0, import_vue547.createVNode)("div", (0, import_vue547.mergeProps)({
    "class": kls,
    "style": cellStyle
  }, extraCellProps), [IconOrPlaceholder, Cell]);
};
CellRenderer.inheritAttrs = false;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/header.mjs
var import_vue548 = require("vue");
function _isSlot5(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !(0, import_vue548.isVNode)(s2);
}
var HeaderRenderer = ({
  columns: columns2,
  columnsStyles,
  headerIndex,
  style,
  headerClass,
  headerProps,
  ns: ns2
}, {
  slots
}) => {
  const param = {
    columns: columns2,
    headerIndex
  };
  const kls = [ns2.e("header-row"), tryCall(headerClass, param, ""), {
    [ns2.is("customized")]: Boolean(slots.header)
  }];
  const extraProps = {
    ...tryCall(headerProps, param),
    columnsStyles,
    class: kls,
    columns: columns2,
    headerIndex,
    style
  };
  return (0, import_vue548.createVNode)(TableV2HeaderRow, extraProps, _isSlot5(slots) ? slots : {
    default: () => [slots]
  });
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/header-cell.mjs
var import_vue549 = require("vue");
var HeaderCellRenderer = (props, {
  slots
}) => {
  const {
    column: column2,
    ns: ns2,
    style,
    onColumnSorted
  } = props;
  const cellStyle = enforceUnit(style);
  if (column2.placeholderSign === placeholderSign) {
    return (0, import_vue549.createVNode)("div", {
      "class": ns2.em("header-row-cell", "placeholder"),
      "style": cellStyle
    }, null);
  }
  const {
    headerCellRenderer,
    headerClass,
    sortable
  } = column2;
  const cellProps = {
    ...props,
    class: ns2.e("header-cell-text")
  };
  const cellRenderer = componentToSlot(headerCellRenderer) || slots.default || ((props2) => (0, import_vue549.createVNode)(HeaderCell, props2, null));
  const Cell = cellRenderer(cellProps);
  const {
    sortBy,
    sortState,
    headerCellProps
  } = props;
  let sorting, sortOrder;
  if (sortState) {
    const order = sortState[column2.key];
    sorting = Boolean(oppositeOrderMap[order]);
    sortOrder = sorting ? order : SortOrder.ASC;
  } else {
    sorting = column2.key === sortBy.key;
    sortOrder = sorting ? sortBy.order : SortOrder.ASC;
  }
  const cellKls = [ns2.e("header-cell"), tryCall(headerClass, props, ""), column2.align === Alignment.CENTER && ns2.is("align-center"), column2.align === Alignment.RIGHT && ns2.is("align-right"), sortable && ns2.is("sortable")];
  const cellWrapperProps = {
    ...tryCall(headerCellProps, props),
    onClick: column2.sortable ? onColumnSorted : void 0,
    class: cellKls,
    style: cellStyle,
    ["data-key"]: column2.key
  };
  return (0, import_vue549.createVNode)("div", cellWrapperProps, [Cell, sortable && (0, import_vue549.createVNode)(SortIcon, {
    "class": [ns2.e("sort-icon"), sorting && ns2.is("sorting")],
    "sortOrder": sortOrder
  }, null)]);
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/footer.mjs
var import_vue550 = require("vue");
var Footer2 = (props, {
  slots
}) => {
  var _a2;
  return (0, import_vue550.createVNode)("div", {
    "class": props.class,
    "style": props.style
  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
};
Footer2.displayName = "ElTableV2Footer";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/empty.mjs
var import_vue551 = require("vue");
var Footer3 = (props, {
  slots
}) => {
  return (0, import_vue551.createVNode)("div", {
    "class": props.class,
    "style": props.style
  }, [slots.default ? slots.default() : (0, import_vue551.createVNode)(ElEmpty, null, null)]);
};
Footer3.displayName = "ElTableV2Empty";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/renderers/overlay.mjs
var import_vue552 = require("vue");
var Overlay2 = (props, {
  slots
}) => {
  var _a2;
  return (0, import_vue552.createVNode)("div", {
    "class": props.class,
    "style": props.style
  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
};
Overlay2.displayName = "ElTableV2Overlay";

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/table-v2.mjs
function _isSlot6(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !(0, import_vue553.isVNode)(s2);
}
var COMPONENT_NAME20 = "ElTableV2";
var TableV2 = (0, import_vue553.defineComponent)({
  name: COMPONENT_NAME20,
  props: tableV2Props,
  setup(props, {
    slots,
    expose
  }) {
    const ns2 = useNamespace("table-v2");
    const {
      columnsStyles,
      fixedColumnsOnLeft,
      fixedColumnsOnRight,
      mainColumns,
      mainTableHeight,
      fixedTableHeight,
      leftTableWidth,
      rightTableWidth,
      data,
      depthMap,
      expandedRowKeys,
      hasFixedColumns,
      hoveringRowKey,
      mainTableRef,
      leftTableRef,
      rightTableRef,
      isDynamic,
      isResetting,
      isScrolling,
      bodyWidth,
      emptyStyle,
      rootStyle,
      headerWidth,
      footerHeight,
      showEmpty,
      scrollTo,
      scrollToLeft,
      scrollToTop,
      scrollToRow,
      getRowHeight,
      onColumnSorted,
      onRowHeightChange,
      onRowHovered,
      onRowExpanded,
      onRowsRendered,
      onScroll,
      onVerticalScroll
    } = useTable(props);
    expose({
      scrollTo,
      scrollToLeft,
      scrollToTop,
      scrollToRow
    });
    (0, import_vue553.provide)(TableV2InjectionKey, {
      ns: ns2,
      isResetting,
      hoveringRowKey,
      isScrolling
    });
    return () => {
      const {
        cache: cache2,
        cellProps,
        estimatedRowHeight,
        expandColumnKey: expandColumnKey2,
        fixedData,
        headerHeight,
        headerClass,
        headerProps,
        headerCellProps,
        sortBy,
        sortState,
        rowHeight,
        rowClass,
        rowEventHandlers,
        rowKey: rowKey2,
        rowProps: rowProps2,
        scrollbarAlwaysOn,
        indentSize,
        iconSize,
        useIsScrolling,
        vScrollbarSize,
        width
      } = props;
      const _data = (0, import_vue553.unref)(data);
      const mainTableProps = {
        cache: cache2,
        class: ns2.e("main"),
        columns: (0, import_vue553.unref)(mainColumns),
        data: _data,
        fixedData,
        estimatedRowHeight,
        bodyWidth: (0, import_vue553.unref)(bodyWidth),
        headerHeight,
        headerWidth: (0, import_vue553.unref)(headerWidth),
        height: (0, import_vue553.unref)(mainTableHeight),
        mainTableRef,
        rowKey: rowKey2,
        rowHeight,
        scrollbarAlwaysOn,
        scrollbarStartGap: 2,
        scrollbarEndGap: vScrollbarSize,
        useIsScrolling,
        width,
        getRowHeight,
        onRowsRendered,
        onScroll
      };
      const leftColumnsWidth = (0, import_vue553.unref)(leftTableWidth);
      const _fixedTableHeight = (0, import_vue553.unref)(fixedTableHeight);
      const leftTableProps = {
        cache: cache2,
        class: ns2.e("left"),
        columns: (0, import_vue553.unref)(fixedColumnsOnLeft),
        data: _data,
        estimatedRowHeight,
        leftTableRef,
        rowHeight,
        bodyWidth: leftColumnsWidth,
        headerWidth: leftColumnsWidth,
        headerHeight,
        height: _fixedTableHeight,
        rowKey: rowKey2,
        scrollbarAlwaysOn,
        scrollbarStartGap: 2,
        scrollbarEndGap: vScrollbarSize,
        useIsScrolling,
        width: leftColumnsWidth,
        getRowHeight,
        onScroll: onVerticalScroll
      };
      const rightColumnsWidth = (0, import_vue553.unref)(rightTableWidth);
      const rightColumnsWidthWithScrollbar = rightColumnsWidth + vScrollbarSize;
      const rightTableProps = {
        cache: cache2,
        class: ns2.e("right"),
        columns: (0, import_vue553.unref)(fixedColumnsOnRight),
        data: _data,
        estimatedRowHeight,
        rightTableRef,
        rowHeight,
        bodyWidth: rightColumnsWidthWithScrollbar,
        headerWidth: rightColumnsWidthWithScrollbar,
        headerHeight,
        height: _fixedTableHeight,
        rowKey: rowKey2,
        scrollbarAlwaysOn,
        scrollbarStartGap: 2,
        scrollbarEndGap: vScrollbarSize,
        width: rightColumnsWidthWithScrollbar,
        style: `--${(0, import_vue553.unref)(ns2.namespace)}-table-scrollbar-size: ${vScrollbarSize}px`,
        useIsScrolling,
        getRowHeight,
        onScroll: onVerticalScroll
      };
      const _columnsStyles = (0, import_vue553.unref)(columnsStyles);
      const tableRowProps = {
        ns: ns2,
        depthMap: (0, import_vue553.unref)(depthMap),
        columnsStyles: _columnsStyles,
        expandColumnKey: expandColumnKey2,
        expandedRowKeys: (0, import_vue553.unref)(expandedRowKeys),
        estimatedRowHeight,
        hasFixedColumns: (0, import_vue553.unref)(hasFixedColumns),
        hoveringRowKey: (0, import_vue553.unref)(hoveringRowKey),
        rowProps: rowProps2,
        rowClass,
        rowKey: rowKey2,
        rowEventHandlers,
        onRowHovered,
        onRowExpanded,
        onRowHeightChange
      };
      const tableCellProps = {
        cellProps,
        expandColumnKey: expandColumnKey2,
        indentSize,
        iconSize,
        rowKey: rowKey2,
        expandedRowKeys: (0, import_vue553.unref)(expandedRowKeys),
        ns: ns2
      };
      const tableHeaderProps = {
        ns: ns2,
        headerClass,
        headerProps,
        columnsStyles: _columnsStyles
      };
      const tableHeaderCellProps = {
        ns: ns2,
        sortBy,
        sortState,
        headerCellProps,
        onColumnSorted
      };
      const tableSlots = {
        row: (props2) => (0, import_vue553.createVNode)(RowRenderer, (0, import_vue553.mergeProps)(props2, tableRowProps), {
          row: slots.row,
          cell: (props3) => {
            let _slot;
            return slots.cell ? (0, import_vue553.createVNode)(CellRenderer, (0, import_vue553.mergeProps)(props3, tableCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), _isSlot6(_slot = slots.cell(props3)) ? _slot : {
              default: () => [_slot]
            }) : (0, import_vue553.createVNode)(CellRenderer, (0, import_vue553.mergeProps)(props3, tableCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), null);
          }
        }),
        header: (props2) => (0, import_vue553.createVNode)(HeaderRenderer, (0, import_vue553.mergeProps)(props2, tableHeaderProps), {
          header: slots.header,
          cell: (props3) => {
            let _slot2;
            return slots["header-cell"] ? (0, import_vue553.createVNode)(HeaderCellRenderer, (0, import_vue553.mergeProps)(props3, tableHeaderCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), _isSlot6(_slot2 = slots["header-cell"](props3)) ? _slot2 : {
              default: () => [_slot2]
            }) : (0, import_vue553.createVNode)(HeaderCellRenderer, (0, import_vue553.mergeProps)(props3, tableHeaderCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), null);
          }
        })
      };
      const rootKls = [props.class, ns2.b(), ns2.e("root"), {
        [ns2.is("dynamic")]: (0, import_vue553.unref)(isDynamic)
      }];
      const footerProps = {
        class: ns2.e("footer"),
        style: (0, import_vue553.unref)(footerHeight)
      };
      return (0, import_vue553.createVNode)("div", {
        "class": rootKls,
        "style": (0, import_vue553.unref)(rootStyle)
      }, [(0, import_vue553.createVNode)(MainTable, mainTableProps, _isSlot6(tableSlots) ? tableSlots : {
        default: () => [tableSlots]
      }), (0, import_vue553.createVNode)(LeftTable, leftTableProps, _isSlot6(tableSlots) ? tableSlots : {
        default: () => [tableSlots]
      }), (0, import_vue553.createVNode)(LeftTable2, rightTableProps, _isSlot6(tableSlots) ? tableSlots : {
        default: () => [tableSlots]
      }), slots.footer && (0, import_vue553.createVNode)(Footer2, footerProps, {
        default: slots.footer
      }), (0, import_vue553.unref)(showEmpty) && (0, import_vue553.createVNode)(Footer3, {
        "class": ns2.e("empty"),
        "style": (0, import_vue553.unref)(emptyStyle)
      }, {
        default: slots.empty
      }), slots.overlay && (0, import_vue553.createVNode)(Overlay2, {
        "class": ns2.e("overlay")
      }, {
        default: slots.overlay
      })]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/auto-resizer.mjs
var import_vue554 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/auto-resizer.mjs
var autoResizerProps = buildProps({
  disableWidth: Boolean,
  disableHeight: Boolean,
  onResize: {
    type: definePropType(Function)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/src/components/auto-resizer.mjs
var AutoResizer = (0, import_vue554.defineComponent)({
  name: "ElAutoResizer",
  props: autoResizerProps,
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("auto-resizer");
    const {
      height,
      width,
      sizer
    } = useAutoResize(props);
    const style = {
      width: "100%",
      height: "100%"
    };
    return () => {
      var _a2;
      return (0, import_vue554.createVNode)("div", {
        "ref": sizer,
        "class": ns2.b(),
        "style": style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
        height: height.value,
        width: width.value
      })]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/table-v2/index.mjs
var ElTableV2 = withInstall(TableV2);
var ElAutoResizer = withInstall(AutoResizer);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tabs.mjs
var import_vue557 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-nav.mjs
var import_vue556 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-bar2.mjs
var import_vue555 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-bar.mjs
var tabBarProps = buildProps({
  tabs: {
    type: definePropType(Array),
    default: () => mutable([])
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-bar2.mjs
var COMPONENT_NAME21 = "ElTabBar";
var __default__81 = (0, import_vue555.defineComponent)({
  name: COMPONENT_NAME21
});
var _sfc_main122 = /* @__PURE__ */ (0, import_vue555.defineComponent)({
  ...__default__81,
  props: tabBarProps,
  setup(__props, { expose }) {
    const props = __props;
    const instance = (0, import_vue555.getCurrentInstance)();
    const rootTabs = (0, import_vue555.inject)(tabsRootContextKey);
    if (!rootTabs)
      throwError(COMPONENT_NAME21, "<el-tabs><el-tab-bar /></el-tabs>");
    const ns2 = useNamespace("tabs");
    const barRef = (0, import_vue555.ref)();
    const barStyle = (0, import_vue555.ref)();
    const getBarStyle = () => {
      let offset2 = 0;
      let tabSize = 0;
      const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
      const sizeDir = sizeName === "width" ? "x" : "y";
      const position = sizeDir === "x" ? "left" : "top";
      props.tabs.every((tab) => {
        var _a2, _b;
        const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
        if (!$el)
          return false;
        if (!tab.active) {
          return true;
        }
        offset2 = $el[`offset${capitalize(position)}`];
        tabSize = $el[`client${capitalize(sizeName)}`];
        const tabStyles = window.getComputedStyle($el);
        if (sizeName === "width") {
          if (props.tabs.length > 1) {
            tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
          }
          offset2 += Number.parseFloat(tabStyles.paddingLeft);
        }
        return false;
      });
      return {
        [sizeName]: `${tabSize}px`,
        transform: `translate${capitalize(sizeDir)}(${offset2}px)`
      };
    };
    const update = () => barStyle.value = getBarStyle();
    (0, import_vue555.watch)(() => props.tabs, async () => {
      await (0, import_vue555.nextTick)();
      update();
    }, { immediate: true });
    useResizeObserver(barRef, () => update());
    expose({
      ref: barRef,
      update
    });
    return (_ctx, _cache) => {
      return (0, import_vue555.openBlock)(), (0, import_vue555.createElementBlock)("div", {
        ref_key: "barRef",
        ref: barRef,
        class: (0, import_vue555.normalizeClass)([(0, import_vue555.unref)(ns2).e("active-bar"), (0, import_vue555.unref)(ns2).is((0, import_vue555.unref)(rootTabs).props.tabPosition)]),
        style: (0, import_vue555.normalizeStyle)(barStyle.value)
      }, null, 6);
    };
  }
});
var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main122, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-nav.mjs
var tabNavProps = buildProps({
  panes: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
});
var tabNavEmits = {
  tabClick: (tab, tabName, ev) => ev instanceof Event,
  tabRemove: (tab, ev) => ev instanceof Event
};
var COMPONENT_NAME22 = "ElTabNav";
var TabNav = (0, import_vue556.defineComponent)({
  name: COMPONENT_NAME22,
  props: tabNavProps,
  emits: tabNavEmits,
  setup(props, {
    expose,
    emit
  }) {
    const vm = (0, import_vue556.getCurrentInstance)();
    const rootTabs = (0, import_vue556.inject)(tabsRootContextKey);
    if (!rootTabs)
      throwError(COMPONENT_NAME22, `<el-tabs><tab-nav /></el-tabs>`);
    const ns2 = useNamespace("tabs");
    const visibility = useDocumentVisibility();
    const focused = useWindowFocus();
    const navScroll$ = (0, import_vue556.ref)();
    const nav$ = (0, import_vue556.ref)();
    const el$ = (0, import_vue556.ref)();
    const scrollable = (0, import_vue556.ref)(false);
    const navOffset = (0, import_vue556.ref)(0);
    const isFocus = (0, import_vue556.ref)(false);
    const focusable = (0, import_vue556.ref)(true);
    const sizeName = (0, import_vue556.computed)(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
    const navStyle = (0, import_vue556.computed)(() => {
      const dir = sizeName.value === "width" ? "X" : "Y";
      return {
        transform: `translate${dir}(-${navOffset.value}px)`
      };
    });
    const scrollPrev = () => {
      if (!navScroll$.value)
        return;
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (!currentOffset)
        return;
      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
      navOffset.value = newOffset;
    };
    const scrollNext = () => {
      if (!navScroll$.value || !nav$.value)
        return;
      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (navSize - currentOffset <= containerSize)
        return;
      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
      navOffset.value = newOffset;
    };
    const scrollToActiveTab = async () => {
      const nav = nav$.value;
      if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
        return;
      await (0, import_vue556.nextTick)();
      const activeTab = el$.value.querySelector(".is-active");
      if (!activeTab)
        return;
      const navScroll = navScroll$.value;
      const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
      const activeTabBounding = activeTab.getBoundingClientRect();
      const navScrollBounding = navScroll.getBoundingClientRect();
      const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
      const currentOffset = navOffset.value;
      let newOffset = currentOffset;
      if (isHorizontal2) {
        if (activeTabBounding.left < navScrollBounding.left) {
          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
        }
        if (activeTabBounding.right > navScrollBounding.right) {
          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
        }
      } else {
        if (activeTabBounding.top < navScrollBounding.top) {
          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
        }
        if (activeTabBounding.bottom > navScrollBounding.bottom) {
          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
        }
      }
      newOffset = Math.max(newOffset, 0);
      navOffset.value = Math.min(newOffset, maxOffset);
    };
    const update = () => {
      if (!nav$.value || !navScroll$.value)
        return;
      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (containerSize < navSize) {
        const currentOffset2 = navOffset.value;
        scrollable.value = scrollable.value || {};
        scrollable.value.prev = currentOffset2;
        scrollable.value.next = currentOffset2 + containerSize < navSize;
        if (navSize - currentOffset2 < containerSize) {
          navOffset.value = navSize - containerSize;
        }
      } else {
        scrollable.value = false;
        if (currentOffset > 0) {
          navOffset.value = 0;
        }
      }
    };
    const changeTab = (e) => {
      const code = e.code;
      const {
        up: up2,
        down: down2,
        left: left2,
        right: right2
      } = EVENT_CODE;
      if (![up2, down2, left2, right2].includes(code))
        return;
      const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
      const currentIndex = tabList.indexOf(e.target);
      let nextIndex;
      if (code === left2 || code === up2) {
        if (currentIndex === 0) {
          nextIndex = tabList.length - 1;
        } else {
          nextIndex = currentIndex - 1;
        }
      } else {
        if (currentIndex < tabList.length - 1) {
          nextIndex = currentIndex + 1;
        } else {
          nextIndex = 0;
        }
      }
      tabList[nextIndex].focus({
        preventScroll: true
      });
      tabList[nextIndex].click();
      setFocus();
    };
    const setFocus = () => {
      if (focusable.value)
        isFocus.value = true;
    };
    const removeFocus = () => isFocus.value = false;
    (0, import_vue556.watch)(visibility, (visibility2) => {
      if (visibility2 === "hidden") {
        focusable.value = false;
      } else if (visibility2 === "visible") {
        setTimeout(() => focusable.value = true, 50);
      }
    });
    (0, import_vue556.watch)(focused, (focused2) => {
      if (focused2) {
        setTimeout(() => focusable.value = true, 50);
      } else {
        focusable.value = false;
      }
    });
    useResizeObserver(el$, update);
    (0, import_vue556.onMounted)(() => setTimeout(() => scrollToActiveTab(), 0));
    (0, import_vue556.onUpdated)(() => update());
    expose({
      scrollToActiveTab,
      removeFocus
    });
    (0, import_vue556.watch)(() => props.panes, () => vm.update(), {
      flush: "post"
    });
    return () => {
      const scrollBtn = scrollable.value ? [(0, import_vue556.createVNode)("span", {
        "class": [ns2.e("nav-prev"), ns2.is("disabled", !scrollable.value.prev)],
        "onClick": scrollPrev
      }, [(0, import_vue556.createVNode)(ElIcon, null, {
        default: () => [(0, import_vue556.createVNode)(arrow_left_default, null, null)]
      })]), (0, import_vue556.createVNode)("span", {
        "class": [ns2.e("nav-next"), ns2.is("disabled", !scrollable.value.next)],
        "onClick": scrollNext
      }, [(0, import_vue556.createVNode)(ElIcon, null, {
        default: () => [(0, import_vue556.createVNode)(arrow_right_default, null, null)]
      })])] : null;
      const tabs = props.panes.map((pane, index2) => {
        var _a2, _b, _c, _d;
        const uid2 = pane.uid;
        const disabled = pane.props.disabled;
        const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index2}`;
        const closable = !disabled && (pane.isClosable || props.editable);
        pane.index = `${index2}`;
        const btnClose = closable ? (0, import_vue556.createVNode)(ElIcon, {
          "class": "is-icon-close",
          "onClick": (ev) => emit("tabRemove", pane, ev)
        }, {
          default: () => [(0, import_vue556.createVNode)(close_default, null, null)]
        }) : null;
        const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
        const tabindex = !disabled && pane.active ? 0 : -1;
        return (0, import_vue556.createVNode)("div", {
          "ref": `tab-${uid2}`,
          "class": [ns2.e("item"), ns2.is(rootTabs.props.tabPosition), ns2.is("active", pane.active), ns2.is("disabled", disabled), ns2.is("closable", closable), ns2.is("focus", isFocus.value)],
          "id": `tab-${tabName}`,
          "key": `tab-${uid2}`,
          "aria-controls": `pane-${tabName}`,
          "role": "tab",
          "aria-selected": pane.active,
          "tabindex": tabindex,
          "onFocus": () => setFocus(),
          "onBlur": () => removeFocus(),
          "onClick": (ev) => {
            removeFocus();
            emit("tabClick", pane, tabName, ev);
          },
          "onKeydown": (ev) => {
            if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
              emit("tabRemove", pane, ev);
            }
          }
        }, [...[tabLabelContent, btnClose]]);
      });
      return (0, import_vue556.createVNode)("div", {
        "ref": el$,
        "class": [ns2.e("nav-wrap"), ns2.is("scrollable", !!scrollable.value), ns2.is(rootTabs.props.tabPosition)]
      }, [scrollBtn, (0, import_vue556.createVNode)("div", {
        "class": ns2.e("nav-scroll"),
        "ref": navScroll$
      }, [(0, import_vue556.createVNode)("div", {
        "class": [ns2.e("nav"), ns2.is(rootTabs.props.tabPosition), ns2.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
        "ref": nav$,
        "style": navStyle.value,
        "role": "tablist",
        "onKeydown": changeTab
      }, [...[!props.type ? (0, import_vue556.createVNode)(TabBar, {
        "tabs": [...props.panes]
      }, null) : null, tabs]])])]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tabs.mjs
var import_shared99 = require("@vue/shared");
var tabsProps = buildProps({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  activeName: {
    type: [String, Number]
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: definePropType(Function),
    default: () => true
  },
  stretch: Boolean
});
var isPaneName = (value) => (0, import_shared99.isString)(value) || isNumber(value);
var tabsEmits = {
  [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
  tabClick: (pane, ev) => ev instanceof Event,
  tabChange: (name) => isPaneName(name),
  edit: (paneName, action) => ["remove", "add"].includes(action),
  tabRemove: (name) => isPaneName(name),
  tabAdd: () => true
};
var Tabs = (0, import_vue557.defineComponent)({
  name: "ElTabs",
  props: tabsProps,
  emits: tabsEmits,
  setup(props, {
    emit,
    slots,
    expose
  }) {
    var _a2, _b;
    const ns2 = useNamespace("tabs");
    const {
      children: panes,
      addChild: registerPane,
      removeChild: unregisterPane
    } = useOrderedChildren((0, import_vue557.getCurrentInstance)(), "ElTabPane");
    const nav$ = (0, import_vue557.ref)();
    const currentName = (0, import_vue557.ref)((_b = (_a2 = props.modelValue) != null ? _a2 : props.activeName) != null ? _b : "0");
    const changeCurrentName = (value) => {
      currentName.value = value;
      emit(UPDATE_MODEL_EVENT, value);
      emit("tabChange", value);
    };
    const setCurrentName = async (value) => {
      var _a22, _b2, _c;
      if (currentName.value === value || isUndefined(value))
        return;
      try {
        const canLeave = await ((_a22 = props.beforeLeave) == null ? void 0 : _a22.call(props, value, currentName.value));
        if (canLeave !== false) {
          changeCurrentName(value);
          (_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null ? void 0 : _c.call(_b2);
        }
      } catch (e) {
      }
    };
    const handleTabClick = (tab, tabName, event) => {
      if (tab.props.disabled)
        return;
      setCurrentName(tabName);
      emit("tabClick", tab, event);
    };
    const handleTabRemove = (pane, ev) => {
      if (pane.props.disabled || isUndefined(pane.props.name))
        return;
      ev.stopPropagation();
      emit("edit", pane.props.name, "remove");
      emit("tabRemove", pane.props.name);
    };
    const handleTabAdd = () => {
      emit("edit", void 0, "add");
      emit("tabAdd");
    };
    useDeprecated({
      from: '"activeName"',
      replacement: '"model-value" or "v-model"',
      scope: "ElTabs",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
      type: "Attribute"
    }, (0, import_vue557.computed)(() => !!props.activeName));
    (0, import_vue557.watch)(() => props.activeName, (modelValue) => setCurrentName(modelValue));
    (0, import_vue557.watch)(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
    (0, import_vue557.watch)(currentName, async () => {
      var _a22;
      await (0, import_vue557.nextTick)();
      (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
    });
    (0, import_vue557.provide)(tabsRootContextKey, {
      props,
      currentName,
      registerPane,
      unregisterPane
    });
    expose({
      currentName
    });
    return () => {
      const newButton = props.editable || props.addable ? (0, import_vue557.createVNode)("span", {
        "class": ns2.e("new-tab"),
        "tabindex": "0",
        "onClick": handleTabAdd,
        "onKeydown": (ev) => {
          if (ev.code === EVENT_CODE.enter)
            handleTabAdd();
        }
      }, [(0, import_vue557.createVNode)(ElIcon, {
        "class": ns2.is("icon-plus")
      }, {
        default: () => [(0, import_vue557.createVNode)(plus_default, null, null)]
      })]) : null;
      const header = (0, import_vue557.createVNode)("div", {
        "class": [ns2.e("header"), ns2.is(props.tabPosition)]
      }, [newButton, (0, import_vue557.createVNode)(TabNav, {
        "ref": nav$,
        "currentName": currentName.value,
        "editable": props.editable,
        "type": props.type,
        "panes": panes.value,
        "stretch": props.stretch,
        "onTabClick": handleTabClick,
        "onTabRemove": handleTabRemove
      }, null)]);
      const panels = (0, import_vue557.createVNode)("div", {
        "class": ns2.e("content")
      }, [(0, import_vue557.renderSlot)(slots, "default")]);
      return (0, import_vue557.createVNode)("div", {
        "class": [ns2.b(), ns2.m(props.tabPosition), {
          [ns2.m("card")]: props.type === "card",
          [ns2.m("border-card")]: props.type === "border-card"
        }]
      }, [...props.tabPosition !== "bottom" ? [header, panels] : [panels, header]]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-pane2.mjs
var import_vue558 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-pane.mjs
var tabPaneProps = buildProps({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/src/tab-pane2.mjs
var _hoisted_179 = ["id", "aria-hidden", "aria-labelledby"];
var COMPONENT_NAME23 = "ElTabPane";
var __default__82 = (0, import_vue558.defineComponent)({
  name: COMPONENT_NAME23
});
var _sfc_main123 = /* @__PURE__ */ (0, import_vue558.defineComponent)({
  ...__default__82,
  props: tabPaneProps,
  setup(__props) {
    const props = __props;
    const instance = (0, import_vue558.getCurrentInstance)();
    const slots = (0, import_vue558.useSlots)();
    const tabsRoot = (0, import_vue558.inject)(tabsRootContextKey);
    if (!tabsRoot)
      throwError(COMPONENT_NAME23, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const ns2 = useNamespace("tab-pane");
    const index2 = (0, import_vue558.ref)();
    const isClosable = (0, import_vue558.computed)(() => props.closable || tabsRoot.props.closable);
    const active = computedEager(() => {
      var _a2;
      return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index2.value);
    });
    const loaded = (0, import_vue558.ref)(active.value);
    const paneName = (0, import_vue558.computed)(() => {
      var _a2;
      return (_a2 = props.name) != null ? _a2 : index2.value;
    });
    const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
    (0, import_vue558.watch)(active, (val) => {
      if (val)
        loaded.value = true;
    });
    const pane = (0, import_vue558.reactive)({
      uid: instance.uid,
      slots,
      props,
      paneName,
      active,
      index: index2,
      isClosable
    });
    (0, import_vue558.onMounted)(() => {
      tabsRoot.registerPane(pane);
    });
    (0, import_vue558.onUnmounted)(() => {
      tabsRoot.unregisterPane(pane.uid);
    });
    return (_ctx, _cache) => {
      return (0, import_vue558.unref)(shouldBeRender) ? (0, import_vue558.withDirectives)(((0, import_vue558.openBlock)(), (0, import_vue558.createElementBlock)("div", {
        key: 0,
        id: `pane-${(0, import_vue558.unref)(paneName)}`,
        class: (0, import_vue558.normalizeClass)((0, import_vue558.unref)(ns2).b()),
        role: "tabpanel",
        "aria-hidden": !(0, import_vue558.unref)(active),
        "aria-labelledby": `tab-${(0, import_vue558.unref)(paneName)}`
      }, [
        (0, import_vue558.renderSlot)(_ctx.$slots, "default")
      ], 10, _hoisted_179)), [
        [import_vue558.vShow, (0, import_vue558.unref)(active)]
      ]) : (0, import_vue558.createCommentVNode)("v-if", true);
    };
  }
});
var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main123, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tabs/index.mjs
var ElTabs = withInstall(Tabs, {
  TabPane
});
var ElTabPane = withNoopInstall(TabPane);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-select/src/time-select2.mjs
var import_vue559 = require("vue");
var import_dayjs16 = __toESM(require_dayjs_min(), 1);
var import_customParseFormat3 = __toESM(require_customParseFormat(), 1);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-select/src/time-select.mjs
var timeSelectProps = buildProps({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: String,
  disabled: Boolean,
  editable: {
    type: Boolean,
    default: true
  },
  effect: {
    type: String,
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: true
  },
  size: useSizeProp,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: String,
  maxTime: String,
  name: String,
  prefixIcon: {
    type: definePropType([String, Object]),
    default: () => clock_default
  },
  clearIcon: {
    type: definePropType([String, Object]),
    default: () => circle_close_default
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-select/src/utils.mjs
var parseTime = (time) => {
  const values = (time || "").split(":");
  if (values.length >= 2) {
    let hours = Number.parseInt(values[0], 10);
    const minutes = Number.parseInt(values[1], 10);
    const timeUpper = time.toUpperCase();
    if (timeUpper.includes("AM") && hours === 12) {
      hours = 0;
    } else if (timeUpper.includes("PM") && hours !== 12) {
      hours += 12;
    }
    return {
      hours,
      minutes
    };
  }
  return null;
};
var compareTime = (time1, time2) => {
  const value1 = parseTime(time1);
  if (!value1)
    return -1;
  const value2 = parseTime(time2);
  if (!value2)
    return -1;
  const minutes1 = value1.minutes + value1.hours * 60;
  const minutes2 = value2.minutes + value2.hours * 60;
  if (minutes1 === minutes2) {
    return 0;
  }
  return minutes1 > minutes2 ? 1 : -1;
};
var padTime = (time) => {
  return `${time}`.padStart(2, "0");
};
var formatTime2 = (time) => {
  return `${padTime(time.hours)}:${padTime(time.minutes)}`;
};
var nextTime = (time, step) => {
  const timeValue = parseTime(time);
  if (!timeValue)
    return "";
  const stepValue = parseTime(step);
  if (!stepValue)
    return "";
  const next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes
  };
  next.minutes += stepValue.minutes;
  next.hours += stepValue.hours;
  next.hours += Math.floor(next.minutes / 60);
  next.minutes = next.minutes % 60;
  return formatTime2(next);
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-select/src/time-select2.mjs
var __default__83 = (0, import_vue559.defineComponent)({
  name: "ElTimeSelect"
});
var _sfc_main124 = /* @__PURE__ */ (0, import_vue559.defineComponent)({
  ...__default__83,
  props: timeSelectProps,
  emits: ["change", "blur", "focus", "update:modelValue"],
  setup(__props, { expose }) {
    const props = __props;
    import_dayjs16.default.extend(import_customParseFormat3.default);
    const { Option: ElOption2 } = ElSelect;
    const nsInput = useNamespace("input");
    const select = (0, import_vue559.ref)();
    const _disabled = useDisabled();
    const value = (0, import_vue559.computed)(() => props.modelValue);
    const start = (0, import_vue559.computed)(() => {
      const time = parseTime(props.start);
      return time ? formatTime2(time) : null;
    });
    const end2 = (0, import_vue559.computed)(() => {
      const time = parseTime(props.end);
      return time ? formatTime2(time) : null;
    });
    const step = (0, import_vue559.computed)(() => {
      const time = parseTime(props.step);
      return time ? formatTime2(time) : null;
    });
    const minTime = (0, import_vue559.computed)(() => {
      const time = parseTime(props.minTime || "");
      return time ? formatTime2(time) : null;
    });
    const maxTime = (0, import_vue559.computed)(() => {
      const time = parseTime(props.maxTime || "");
      return time ? formatTime2(time) : null;
    });
    const items = (0, import_vue559.computed)(() => {
      const result = [];
      if (props.start && props.end && props.step) {
        let current = start.value;
        let currentTime;
        while (current && end2.value && compareTime(current, end2.value) <= 0) {
          currentTime = (0, import_dayjs16.default)(current, "HH:mm").format(props.format);
          result.push({
            value: currentTime,
            disabled: compareTime(current, minTime.value || "-1:-1") <= 0 || compareTime(current, maxTime.value || "100:100") >= 0
          });
          current = nextTime(current, step.value);
        }
      }
      return result;
    });
    const blur = () => {
      var _a2, _b;
      (_b = (_a2 = select.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
    };
    const focus = () => {
      var _a2, _b;
      (_b = (_a2 = select.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
    };
    expose({
      blur,
      focus
    });
    return (_ctx, _cache) => {
      return (0, import_vue559.openBlock)(), (0, import_vue559.createBlock)((0, import_vue559.unref)(ElSelect), {
        ref_key: "select",
        ref: select,
        "model-value": (0, import_vue559.unref)(value),
        disabled: (0, import_vue559.unref)(_disabled),
        clearable: _ctx.clearable,
        "clear-icon": _ctx.clearIcon,
        size: _ctx.size,
        effect: _ctx.effect,
        placeholder: _ctx.placeholder,
        "default-first-option": "",
        filterable: _ctx.editable,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (event) => _ctx.$emit("update:modelValue", event)),
        onChange: _cache[1] || (_cache[1] = (event) => _ctx.$emit("change", event)),
        onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
        onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event))
      }, {
        prefix: (0, import_vue559.withCtx)(() => [
          _ctx.prefixIcon ? ((0, import_vue559.openBlock)(), (0, import_vue559.createBlock)((0, import_vue559.unref)(ElIcon), {
            key: 0,
            class: (0, import_vue559.normalizeClass)((0, import_vue559.unref)(nsInput).e("prefix-icon"))
          }, {
            default: (0, import_vue559.withCtx)(() => [
              ((0, import_vue559.openBlock)(), (0, import_vue559.createBlock)((0, import_vue559.resolveDynamicComponent)(_ctx.prefixIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : (0, import_vue559.createCommentVNode)("v-if", true)
        ]),
        default: (0, import_vue559.withCtx)(() => [
          ((0, import_vue559.openBlock)(true), (0, import_vue559.createElementBlock)(import_vue559.Fragment, null, (0, import_vue559.renderList)((0, import_vue559.unref)(items), (item) => {
            return (0, import_vue559.openBlock)(), (0, import_vue559.createBlock)((0, import_vue559.unref)(ElOption2), {
              key: item.value,
              label: item.value,
              value: item.value,
              disabled: item.disabled
            }, null, 8, ["label", "value", "disabled"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"]);
    };
  }
});
var TimeSelect = /* @__PURE__ */ _export_sfc(_sfc_main124, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/time-select/index.mjs
TimeSelect.install = (app) => {
  app.component(TimeSelect.name, TimeSelect);
};
var _TimeSelect = TimeSelect;
var ElTimeSelect = _TimeSelect;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/timeline/src/timeline.mjs
var import_vue560 = require("vue");
var Timeline = (0, import_vue560.defineComponent)({
  name: "ElTimeline",
  setup(_2, { slots }) {
    const ns2 = useNamespace("timeline");
    (0, import_vue560.provide)("timeline", slots);
    return () => {
      return (0, import_vue560.h)("ul", { class: [ns2.b()] }, [(0, import_vue560.renderSlot)(slots, "default")]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/timeline/src/timeline-item2.mjs
var import_vue561 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/timeline/src/timeline-item.mjs
var timelineItemProps = buildProps({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: {
    type: Boolean,
    default: false
  },
  center: {
    type: Boolean,
    default: false
  },
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: iconPropType
  },
  hollow: {
    type: Boolean,
    default: false
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/timeline/src/timeline-item2.mjs
var __default__84 = (0, import_vue561.defineComponent)({
  name: "ElTimelineItem"
});
var _sfc_main125 = /* @__PURE__ */ (0, import_vue561.defineComponent)({
  ...__default__84,
  props: timelineItemProps,
  setup(__props) {
    const ns2 = useNamespace("timeline-item");
    return (_ctx, _cache) => {
      return (0, import_vue561.openBlock)(), (0, import_vue561.createElementBlock)("li", {
        class: (0, import_vue561.normalizeClass)([(0, import_vue561.unref)(ns2).b(), { [(0, import_vue561.unref)(ns2).e("center")]: _ctx.center }])
      }, [
        (0, import_vue561.createElementVNode)("div", {
          class: (0, import_vue561.normalizeClass)((0, import_vue561.unref)(ns2).e("tail"))
        }, null, 2),
        !_ctx.$slots.dot ? ((0, import_vue561.openBlock)(), (0, import_vue561.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue561.normalizeClass)([
            (0, import_vue561.unref)(ns2).e("node"),
            (0, import_vue561.unref)(ns2).em("node", _ctx.size || ""),
            (0, import_vue561.unref)(ns2).em("node", _ctx.type || ""),
            (0, import_vue561.unref)(ns2).is("hollow", _ctx.hollow)
          ]),
          style: (0, import_vue561.normalizeStyle)({
            backgroundColor: _ctx.color
          })
        }, [
          _ctx.icon ? ((0, import_vue561.openBlock)(), (0, import_vue561.createBlock)((0, import_vue561.unref)(ElIcon), {
            key: 0,
            class: (0, import_vue561.normalizeClass)((0, import_vue561.unref)(ns2).e("icon"))
          }, {
            default: (0, import_vue561.withCtx)(() => [
              ((0, import_vue561.openBlock)(), (0, import_vue561.createBlock)((0, import_vue561.resolveDynamicComponent)(_ctx.icon)))
            ]),
            _: 1
          }, 8, ["class"])) : (0, import_vue561.createCommentVNode)("v-if", true)
        ], 6)) : (0, import_vue561.createCommentVNode)("v-if", true),
        _ctx.$slots.dot ? ((0, import_vue561.openBlock)(), (0, import_vue561.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue561.normalizeClass)((0, import_vue561.unref)(ns2).e("dot"))
        }, [
          (0, import_vue561.renderSlot)(_ctx.$slots, "dot")
        ], 2)) : (0, import_vue561.createCommentVNode)("v-if", true),
        (0, import_vue561.createElementVNode)("div", {
          class: (0, import_vue561.normalizeClass)((0, import_vue561.unref)(ns2).e("wrapper"))
        }, [
          !_ctx.hideTimestamp && _ctx.placement === "top" ? ((0, import_vue561.openBlock)(), (0, import_vue561.createElementBlock)("div", {
            key: 0,
            class: (0, import_vue561.normalizeClass)([(0, import_vue561.unref)(ns2).e("timestamp"), (0, import_vue561.unref)(ns2).is("top")])
          }, (0, import_vue561.toDisplayString)(_ctx.timestamp), 3)) : (0, import_vue561.createCommentVNode)("v-if", true),
          (0, import_vue561.createElementVNode)("div", {
            class: (0, import_vue561.normalizeClass)((0, import_vue561.unref)(ns2).e("content"))
          }, [
            (0, import_vue561.renderSlot)(_ctx.$slots, "default")
          ], 2),
          !_ctx.hideTimestamp && _ctx.placement === "bottom" ? ((0, import_vue561.openBlock)(), (0, import_vue561.createElementBlock)("div", {
            key: 1,
            class: (0, import_vue561.normalizeClass)([(0, import_vue561.unref)(ns2).e("timestamp"), (0, import_vue561.unref)(ns2).is("bottom")])
          }, (0, import_vue561.toDisplayString)(_ctx.timestamp), 3)) : (0, import_vue561.createCommentVNode)("v-if", true)
        ], 2)
      ], 2);
    };
  }
});
var TimelineItem = /* @__PURE__ */ _export_sfc(_sfc_main125, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/timeline/index.mjs
var ElTimeline = withInstall(Timeline, {
  TimelineItem
});
var ElTimelineItem = withNoopInstall(TimelineItem);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/tooltip2.mjs
var import_vue568 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/common.mjs
var tooltipV2CommonProps = buildProps({
  nowrap: Boolean
});
var TooltipV2Sides = /* @__PURE__ */ ((TooltipV2Sides2) => {
  TooltipV2Sides2["top"] = "top";
  TooltipV2Sides2["bottom"] = "bottom";
  TooltipV2Sides2["left"] = "left";
  TooltipV2Sides2["right"] = "right";
  return TooltipV2Sides2;
})(TooltipV2Sides || {});
var tooltipV2Sides = Object.values(TooltipV2Sides);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/arrow.mjs
var tooltipV2ArrowProps = buildProps({
  width: {
    type: Number,
    default: 10
  },
  height: {
    type: Number,
    default: 10
  },
  style: {
    type: definePropType(Object),
    default: null
  }
});
var tooltipV2ArrowSpecialProps = buildProps({
  side: {
    type: definePropType(String),
    values: tooltipV2Sides,
    required: true
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/content.mjs
var tooltipV2Strategies = ["absolute", "fixed"];
var tooltipV2Placements = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
];
var tooltipV2ContentProps = buildProps({
  ariaLabel: String,
  arrowPadding: {
    type: definePropType(Number),
    default: 5
  },
  effect: {
    type: String,
    default: ""
  },
  contentClass: String,
  placement: {
    type: definePropType(String),
    values: tooltipV2Placements,
    default: "bottom"
  },
  reference: {
    type: definePropType(Object),
    default: null
  },
  offset: {
    type: Number,
    default: 8
  },
  strategy: {
    type: definePropType(String),
    values: tooltipV2Strategies,
    default: "absolute"
  },
  showArrow: {
    type: Boolean,
    default: false
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/root.mjs
var tooltipV2RootProps = buildProps({
  delayDuration: {
    type: Number,
    default: 300
  },
  defaultOpen: Boolean,
  open: {
    type: Boolean,
    default: void 0
  },
  onOpenChange: {
    type: definePropType(Function)
  },
  "onUpdate:open": {
    type: definePropType(Function)
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/trigger.mjs
var EventHandler = {
  type: definePropType(Function)
};
var tooltipV2TriggerProps = buildProps({
  onBlur: EventHandler,
  onClick: EventHandler,
  onFocus: EventHandler,
  onMouseDown: EventHandler,
  onMouseEnter: EventHandler,
  onMouseLeave: EventHandler
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/tooltip.mjs
var tooltipV2Props = buildProps({
  ...tooltipV2RootProps,
  ...tooltipV2ArrowProps,
  ...tooltipV2TriggerProps,
  ...tooltipV2ContentProps,
  alwaysOn: Boolean,
  fullTransition: Boolean,
  transitionProps: {
    type: definePropType(Object),
    default: null
  },
  teleported: Boolean,
  to: {
    type: definePropType(String),
    default: "body"
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/root2.mjs
var import_vue562 = require("vue");
var __default__85 = (0, import_vue562.defineComponent)({
  name: "ElTooltipV2Root"
});
var _sfc_main126 = /* @__PURE__ */ (0, import_vue562.defineComponent)({
  ...__default__85,
  props: tooltipV2RootProps,
  setup(__props, { expose }) {
    const props = __props;
    const _open = (0, import_vue562.ref)(props.defaultOpen);
    const triggerRef2 = (0, import_vue562.ref)(null);
    const open = (0, import_vue562.computed)({
      get: () => isPropAbsent(props.open) ? _open.value : props.open,
      set: (open2) => {
        var _a2;
        _open.value = open2;
        (_a2 = props["onUpdate:open"]) == null ? void 0 : _a2.call(props, open2);
      }
    });
    const isOpenDelayed = (0, import_vue562.computed)(() => isNumber(props.delayDuration) && props.delayDuration > 0);
    const { start: onDelayedOpen, stop: clearTimer } = useTimeoutFn(() => {
      open.value = true;
    }, (0, import_vue562.computed)(() => props.delayDuration), {
      immediate: false
    });
    const ns2 = useNamespace("tooltip-v2");
    const contentId = useId();
    const onNormalOpen = () => {
      clearTimer();
      open.value = true;
    };
    const onDelayOpen = () => {
      (0, import_vue562.unref)(isOpenDelayed) ? onDelayedOpen() : onNormalOpen();
    };
    const onOpen = onNormalOpen;
    const onClose = () => {
      clearTimer();
      open.value = false;
    };
    const onChange = (open2) => {
      var _a2;
      if (open2) {
        document.dispatchEvent(new CustomEvent(TOOLTIP_V2_OPEN));
        onOpen();
      }
      (_a2 = props.onOpenChange) == null ? void 0 : _a2.call(props, open2);
    };
    (0, import_vue562.watch)(open, onChange);
    (0, import_vue562.onMounted)(() => {
      document.addEventListener(TOOLTIP_V2_OPEN, onClose);
    });
    (0, import_vue562.onBeforeUnmount)(() => {
      clearTimer();
      document.removeEventListener(TOOLTIP_V2_OPEN, onClose);
    });
    (0, import_vue562.provide)(tooltipV2RootKey, {
      contentId,
      triggerRef: triggerRef2,
      ns: ns2,
      onClose,
      onDelayOpen,
      onOpen
    });
    expose({
      onOpen,
      onClose
    });
    return (_ctx, _cache) => {
      return (0, import_vue562.renderSlot)(_ctx.$slots, "default", { open: (0, import_vue562.unref)(open) });
    };
  }
});
var TooltipV2Root = /* @__PURE__ */ _export_sfc(_sfc_main126, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/arrow2.mjs
var import_vue563 = require("vue");
var __default__86 = (0, import_vue563.defineComponent)({
  name: "ElTooltipV2Arrow"
});
var _sfc_main127 = /* @__PURE__ */ (0, import_vue563.defineComponent)({
  ...__default__86,
  props: {
    ...tooltipV2ArrowProps,
    ...tooltipV2ArrowSpecialProps
  },
  setup(__props) {
    const props = __props;
    const { ns: ns2 } = (0, import_vue563.inject)(tooltipV2RootKey);
    const { arrowRef } = (0, import_vue563.inject)(tooltipV2ContentKey);
    const arrowStyle = (0, import_vue563.computed)(() => {
      const { style, width, height } = props;
      const namespace = ns2.namespace.value;
      return {
        [`--${namespace}-tooltip-v2-arrow-width`]: `${width}px`,
        [`--${namespace}-tooltip-v2-arrow-height`]: `${height}px`,
        [`--${namespace}-tooltip-v2-arrow-border-width`]: `${width / 2}px`,
        [`--${namespace}-tooltip-v2-arrow-cover-width`]: width / 2 - 1,
        ...style || {}
      };
    });
    return (_ctx, _cache) => {
      return (0, import_vue563.openBlock)(), (0, import_vue563.createElementBlock)("span", {
        ref_key: "arrowRef",
        ref: arrowRef,
        style: (0, import_vue563.normalizeStyle)((0, import_vue563.unref)(arrowStyle)),
        class: (0, import_vue563.normalizeClass)((0, import_vue563.unref)(ns2).e("arrow"))
      }, null, 6);
    };
  }
});
var TooltipV2Arrow = /* @__PURE__ */ _export_sfc(_sfc_main127, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/content2.mjs
var import_vue565 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/visual-hidden/src/visual-hidden2.mjs
var import_vue564 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/visual-hidden/src/visual-hidden.mjs
var visualHiddenProps = buildProps({
  style: {
    type: definePropType([String, Object, Array]),
    default: () => ({})
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/visual-hidden/src/visual-hidden2.mjs
var __default__87 = (0, import_vue564.defineComponent)({
  name: "ElVisuallyHidden"
});
var _sfc_main128 = /* @__PURE__ */ (0, import_vue564.defineComponent)({
  ...__default__87,
  props: visualHiddenProps,
  setup(__props) {
    const props = __props;
    const computedStyle = (0, import_vue564.computed)(() => {
      return [
        props.style,
        {
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }
      ];
    });
    return (_ctx, _cache) => {
      return (0, import_vue564.openBlock)(), (0, import_vue564.createElementBlock)("span", (0, import_vue564.mergeProps)(_ctx.$attrs, { style: (0, import_vue564.unref)(computedStyle) }), [
        (0, import_vue564.renderSlot)(_ctx.$slots, "default")
      ], 16);
    };
  }
});
var ElVisuallyHidden = /* @__PURE__ */ _export_sfc(_sfc_main128, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/content2.mjs
var _hoisted_181 = ["data-side"];
var __default__88 = (0, import_vue565.defineComponent)({
  name: "ElTooltipV2Content"
});
var _sfc_main129 = /* @__PURE__ */ (0, import_vue565.defineComponent)({
  ...__default__88,
  props: { ...tooltipV2ContentProps, ...tooltipV2CommonProps },
  setup(__props) {
    const props = __props;
    const { triggerRef: triggerRef2, contentId } = (0, import_vue565.inject)(tooltipV2RootKey);
    const placement = (0, import_vue565.ref)(props.placement);
    const strategy = (0, import_vue565.ref)(props.strategy);
    const arrowRef = (0, import_vue565.ref)(null);
    const { referenceRef, contentRef, middlewareData, x: x3, y: y2, update } = useFloating({
      placement,
      strategy,
      middleware: (0, import_vue565.computed)(() => {
        const middleware = [offset(props.offset)];
        if (props.showArrow) {
          middleware.push(arrowMiddleware({
            arrowRef
          }));
        }
        return middleware;
      })
    });
    const zIndex2 = useZIndex().nextZIndex();
    const ns2 = useNamespace("tooltip-v2");
    const side = (0, import_vue565.computed)(() => {
      return placement.value.split("-")[0];
    });
    const contentStyle = (0, import_vue565.computed)(() => {
      return {
        position: (0, import_vue565.unref)(strategy),
        top: `${(0, import_vue565.unref)(y2) || 0}px`,
        left: `${(0, import_vue565.unref)(x3) || 0}px`,
        zIndex: zIndex2
      };
    });
    const arrowStyle = (0, import_vue565.computed)(() => {
      if (!props.showArrow)
        return {};
      const { arrow: arrow2 } = (0, import_vue565.unref)(middlewareData);
      return {
        [`--${ns2.namespace.value}-tooltip-v2-arrow-x`]: `${arrow2 == null ? void 0 : arrow2.x}px` || "",
        [`--${ns2.namespace.value}-tooltip-v2-arrow-y`]: `${arrow2 == null ? void 0 : arrow2.y}px` || ""
      };
    });
    const contentClass = (0, import_vue565.computed)(() => [
      ns2.e("content"),
      ns2.is("dark", props.effect === "dark"),
      ns2.is((0, import_vue565.unref)(strategy)),
      props.contentClass
    ]);
    (0, import_vue565.watch)(arrowRef, () => update());
    (0, import_vue565.watch)(() => props.placement, (val) => placement.value = val);
    (0, import_vue565.onMounted)(() => {
      (0, import_vue565.watch)(() => props.reference || triggerRef2.value, (el) => {
        referenceRef.value = el || void 0;
      }, {
        immediate: true
      });
    });
    (0, import_vue565.provide)(tooltipV2ContentKey, { arrowRef });
    return (_ctx, _cache) => {
      return (0, import_vue565.openBlock)(), (0, import_vue565.createElementBlock)("div", {
        ref_key: "contentRef",
        ref: contentRef,
        style: (0, import_vue565.normalizeStyle)((0, import_vue565.unref)(contentStyle)),
        "data-tooltip-v2-root": ""
      }, [
        !_ctx.nowrap ? ((0, import_vue565.openBlock)(), (0, import_vue565.createElementBlock)("div", {
          key: 0,
          "data-side": (0, import_vue565.unref)(side),
          class: (0, import_vue565.normalizeClass)((0, import_vue565.unref)(contentClass))
        }, [
          (0, import_vue565.renderSlot)(_ctx.$slots, "default", {
            contentStyle: (0, import_vue565.unref)(contentStyle),
            contentClass: (0, import_vue565.unref)(contentClass)
          }),
          (0, import_vue565.createVNode)((0, import_vue565.unref)(ElVisuallyHidden), {
            id: (0, import_vue565.unref)(contentId),
            role: "tooltip"
          }, {
            default: (0, import_vue565.withCtx)(() => [
              _ctx.ariaLabel ? ((0, import_vue565.openBlock)(), (0, import_vue565.createElementBlock)(import_vue565.Fragment, { key: 0 }, [
                (0, import_vue565.createTextVNode)((0, import_vue565.toDisplayString)(_ctx.ariaLabel), 1)
              ], 64)) : (0, import_vue565.renderSlot)(_ctx.$slots, "default", { key: 1 })
            ]),
            _: 3
          }, 8, ["id"]),
          (0, import_vue565.renderSlot)(_ctx.$slots, "arrow", {
            style: (0, import_vue565.normalizeStyle)((0, import_vue565.unref)(arrowStyle)),
            side: (0, import_vue565.unref)(side)
          })
        ], 10, _hoisted_181)) : (0, import_vue565.createCommentVNode)("v-if", true)
      ], 4);
    };
  }
});
var TooltipV2Content = /* @__PURE__ */ _export_sfc(_sfc_main129, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/trigger2.mjs
var import_vue567 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/forward-ref.mjs
var import_vue566 = require("vue");
var forwardRefProps = buildProps({
  setRef: {
    type: definePropType(Function),
    required: true
  },
  onlyChild: Boolean
});
var ForwardRef = (0, import_vue566.defineComponent)({
  props: forwardRefProps,
  setup(props, {
    slots
  }) {
    const fragmentRef = (0, import_vue566.ref)();
    const setRef = composeRefs(fragmentRef, (el) => {
      if (el) {
        props.setRef(el.nextElementSibling);
      } else {
        props.setRef(null);
      }
    });
    return () => {
      var _a2;
      const [firstChild] = ((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) || [];
      const child = props.onlyChild ? ensureOnlyChild(firstChild.children) : firstChild.children;
      return (0, import_vue566.createVNode)(import_vue566.Fragment, {
        "ref": setRef
      }, [child]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/trigger2.mjs
var __default__89 = (0, import_vue567.defineComponent)({
  name: "ElTooltipV2Trigger"
});
var _sfc_main130 = /* @__PURE__ */ (0, import_vue567.defineComponent)({
  ...__default__89,
  props: {
    ...tooltipV2CommonProps,
    ...tooltipV2TriggerProps
  },
  setup(__props) {
    const props = __props;
    const { onClose, onOpen, onDelayOpen, triggerRef: triggerRef2, contentId } = (0, import_vue567.inject)(tooltipV2RootKey);
    let isMousedown = false;
    const setTriggerRef = (el) => {
      triggerRef2.value = el;
    };
    const onMouseup = () => {
      isMousedown = false;
    };
    const onMouseenter = composeEventHandlers(props.onMouseEnter, onDelayOpen);
    const onMouseleave = composeEventHandlers(props.onMouseLeave, onClose);
    const onMousedown = composeEventHandlers(props.onMouseDown, () => {
      onClose();
      isMousedown = true;
      document.addEventListener("mouseup", onMouseup, { once: true });
    });
    const onFocus = composeEventHandlers(props.onFocus, () => {
      if (!isMousedown)
        onOpen();
    });
    const onBlur = composeEventHandlers(props.onBlur, onClose);
    const onClick = composeEventHandlers(props.onClick, (e) => {
      if (e.detail === 0)
        onClose();
    });
    const events = {
      blur: onBlur,
      click: onClick,
      focus: onFocus,
      mousedown: onMousedown,
      mouseenter: onMouseenter,
      mouseleave: onMouseleave
    };
    const setEvents = (el, events2, type4) => {
      if (el) {
        Object.entries(events2).forEach(([name, handler]) => {
          el[type4](name, handler);
        });
      }
    };
    (0, import_vue567.watch)(triggerRef2, (triggerEl, previousTriggerEl) => {
      setEvents(triggerEl, events, "addEventListener");
      setEvents(previousTriggerEl, events, "removeEventListener");
      if (triggerEl) {
        triggerEl.setAttribute("aria-describedby", contentId.value);
      }
    });
    (0, import_vue567.onBeforeUnmount)(() => {
      setEvents(triggerRef2.value, events, "removeEventListener");
      document.removeEventListener("mouseup", onMouseup);
    });
    return (_ctx, _cache) => {
      return _ctx.nowrap ? ((0, import_vue567.openBlock)(), (0, import_vue567.createBlock)((0, import_vue567.unref)(ForwardRef), {
        key: 0,
        "set-ref": setTriggerRef,
        "only-child": ""
      }, {
        default: (0, import_vue567.withCtx)(() => [
          (0, import_vue567.renderSlot)(_ctx.$slots, "default")
        ]),
        _: 3
      })) : ((0, import_vue567.openBlock)(), (0, import_vue567.createElementBlock)("button", (0, import_vue567.mergeProps)({
        key: 1,
        ref_key: "triggerRef",
        ref: triggerRef2
      }, _ctx.$attrs), [
        (0, import_vue567.renderSlot)(_ctx.$slots, "default")
      ], 16));
    };
  }
});
var TooltipV2Trigger = /* @__PURE__ */ _export_sfc(_sfc_main130, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/src/tooltip2.mjs
var __default__90 = (0, import_vue568.defineComponent)({
  name: "ElTooltipV2"
});
var _sfc_main131 = /* @__PURE__ */ (0, import_vue568.defineComponent)({
  ...__default__90,
  props: tooltipV2Props,
  setup(__props) {
    const props = __props;
    const refedProps = (0, import_vue568.toRefs)(props);
    const arrowProps = (0, import_vue568.reactive)(pick_default(refedProps, Object.keys(tooltipV2ArrowProps)));
    const contentProps = (0, import_vue568.reactive)(pick_default(refedProps, Object.keys(tooltipV2ContentProps)));
    const rootProps = (0, import_vue568.reactive)(pick_default(refedProps, Object.keys(tooltipV2RootProps)));
    const triggerProps = (0, import_vue568.reactive)(pick_default(refedProps, Object.keys(tooltipV2TriggerProps)));
    return (_ctx, _cache) => {
      return (0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(TooltipV2Root, (0, import_vue568.normalizeProps)((0, import_vue568.guardReactiveProps)(rootProps)), {
        default: (0, import_vue568.withCtx)(({ open }) => [
          (0, import_vue568.createVNode)(TooltipV2Trigger, (0, import_vue568.mergeProps)(triggerProps, { nowrap: "" }), {
            default: (0, import_vue568.withCtx)(() => [
              (0, import_vue568.renderSlot)(_ctx.$slots, "trigger")
            ]),
            _: 3
          }, 16),
          ((0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(import_vue568.Teleport, {
            to: _ctx.to,
            disabled: !_ctx.teleported
          }, [
            _ctx.fullTransition ? ((0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(import_vue568.Transition, (0, import_vue568.normalizeProps)((0, import_vue568.mergeProps)({ key: 0 }, _ctx.transitionProps)), {
              default: (0, import_vue568.withCtx)(() => [
                _ctx.alwaysOn || open ? ((0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(TooltipV2Content, (0, import_vue568.normalizeProps)((0, import_vue568.mergeProps)({ key: 0 }, contentProps)), {
                  arrow: (0, import_vue568.withCtx)(({ style, side }) => [
                    _ctx.showArrow ? ((0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(TooltipV2Arrow, (0, import_vue568.mergeProps)({ key: 0 }, arrowProps, {
                      style,
                      side
                    }), null, 16, ["style", "side"])) : (0, import_vue568.createCommentVNode)("v-if", true)
                  ]),
                  default: (0, import_vue568.withCtx)(() => [
                    (0, import_vue568.renderSlot)(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16)) : (0, import_vue568.createCommentVNode)("v-if", true)
              ]),
              _: 2
            }, 1040)) : ((0, import_vue568.openBlock)(), (0, import_vue568.createElementBlock)(import_vue568.Fragment, { key: 1 }, [
              _ctx.alwaysOn || open ? ((0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(TooltipV2Content, (0, import_vue568.normalizeProps)((0, import_vue568.mergeProps)({ key: 0 }, contentProps)), {
                arrow: (0, import_vue568.withCtx)(({ style, side }) => [
                  _ctx.showArrow ? ((0, import_vue568.openBlock)(), (0, import_vue568.createBlock)(TooltipV2Arrow, (0, import_vue568.mergeProps)({ key: 0 }, arrowProps, {
                    style,
                    side
                  }), null, 16, ["style", "side"])) : (0, import_vue568.createCommentVNode)("v-if", true)
                ]),
                default: (0, import_vue568.withCtx)(() => [
                  (0, import_vue568.renderSlot)(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16)) : (0, import_vue568.createCommentVNode)("v-if", true)
            ], 64))
          ], 8, ["to", "disabled"]))
        ]),
        _: 3
      }, 16);
    };
  }
});
var TooltipV2 = /* @__PURE__ */ _export_sfc(_sfc_main131, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tooltip-v2/index.mjs
var ElTooltipV2 = withInstall(TooltipV2);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/transfer2.mjs
var import_vue573 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/transfer.mjs
var import_shared100 = require("@vue/shared");
var LEFT_CHECK_CHANGE_EVENT = "left-check-change";
var RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
var transferProps = buildProps({
  data: {
    type: definePropType(Array),
    default: () => []
  },
  titles: {
    type: definePropType(Array),
    default: () => []
  },
  buttonTexts: {
    type: definePropType(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: definePropType(Function)
  },
  leftDefaultChecked: {
    type: definePropType(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: definePropType(Array),
    default: () => []
  },
  renderContent: {
    type: definePropType(Function)
  },
  modelValue: {
    type: definePropType(Array),
    default: () => []
  },
  format: {
    type: definePropType(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: definePropType(Object),
    default: () => mutable({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
var transferCheckedChangeFn = (value, movedKeys) => [value, movedKeys].every(import_shared100.isArray) || (0, import_shared100.isArray)(value) && isNil_default(movedKeys);
var transferEmits = {
  [CHANGE_EVENT]: (value, direction2, movedKeys) => [value, movedKeys].every(import_shared100.isArray) && ["left", "right"].includes(direction2),
  [UPDATE_MODEL_EVENT]: (value) => (0, import_shared100.isArray)(value),
  [LEFT_CHECK_CHANGE_EVENT]: transferCheckedChangeFn,
  [RIGHT_CHECK_CHANGE_EVENT]: transferCheckedChangeFn
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/composables/use-check.mjs
var import_vue570 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/transfer-panel.mjs
var CHECKED_CHANGE_EVENT = "checked-change";
var transferPanelProps = buildProps({
  data: transferProps.data,
  optionRender: {
    type: definePropType(Function)
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: transferProps.format,
  filterMethod: transferProps.filterMethod,
  defaultChecked: transferProps.leftDefaultChecked,
  props: transferProps.props
});
var transferPanelEmits = {
  [CHECKED_CHANGE_EVENT]: transferCheckedChangeFn
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/composables/use-props-alias.mjs
var import_vue569 = require("vue");
var usePropsAlias = (props) => {
  const initProps = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return (0, import_vue569.computed)(() => ({
    ...initProps,
    ...props.props
  }));
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/composables/use-check.mjs
var import_shared101 = require("@vue/shared");
var useCheck = (props, panelState, emit) => {
  const propsAlias = usePropsAlias(props);
  const filteredData = (0, import_vue570.computed)(() => {
    return props.data.filter((item) => {
      if ((0, import_shared101.isFunction)(props.filterMethod)) {
        return props.filterMethod(panelState.query, item);
      } else {
        const label = String(item[propsAlias.value.label] || item[propsAlias.value.key]);
        return label.toLowerCase().includes(panelState.query.toLowerCase());
      }
    });
  });
  const checkableData = (0, import_vue570.computed)(() => filteredData.value.filter((item) => !item[propsAlias.value.disabled]));
  const checkedSummary = (0, import_vue570.computed)(() => {
    const checkedLength = panelState.checked.length;
    const dataLength = props.data.length;
    const { noChecked, hasChecked } = props.format;
    if (noChecked && hasChecked) {
      return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength.toString()).replace(/\${total}/g, dataLength.toString()) : noChecked.replace(/\${total}/g, dataLength.toString());
    } else {
      return `${checkedLength}/${dataLength}`;
    }
  });
  const isIndeterminate = (0, import_vue570.computed)(() => {
    const checkedLength = panelState.checked.length;
    return checkedLength > 0 && checkedLength < checkableData.value.length;
  });
  const updateAllChecked = () => {
    const checkableDataKeys = checkableData.value.map((item) => item[propsAlias.value.key]);
    panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item) => panelState.checked.includes(item));
  };
  const handleAllCheckedChange = (value) => {
    panelState.checked = value ? checkableData.value.map((item) => item[propsAlias.value.key]) : [];
  };
  (0, import_vue570.watch)(() => panelState.checked, (val, oldVal) => {
    updateAllChecked();
    if (panelState.checkChangeByUser) {
      const movedKeys = val.concat(oldVal).filter((v3) => !val.includes(v3) || !oldVal.includes(v3));
      emit(CHECKED_CHANGE_EVENT, val, movedKeys);
    } else {
      emit(CHECKED_CHANGE_EVENT, val);
      panelState.checkChangeByUser = true;
    }
  });
  (0, import_vue570.watch)(checkableData, () => {
    updateAllChecked();
  });
  (0, import_vue570.watch)(() => props.data, () => {
    const checked = [];
    const filteredDataKeys = filteredData.value.map((item) => item[propsAlias.value.key]);
    panelState.checked.forEach((item) => {
      if (filteredDataKeys.includes(item)) {
        checked.push(item);
      }
    });
    panelState.checkChangeByUser = false;
    panelState.checked = checked;
  });
  (0, import_vue570.watch)(() => props.defaultChecked, (val, oldVal) => {
    if (oldVal && val.length === oldVal.length && val.every((item) => oldVal.includes(item)))
      return;
    const checked = [];
    const checkableDataKeys = checkableData.value.map((item) => item[propsAlias.value.key]);
    val.forEach((item) => {
      if (checkableDataKeys.includes(item)) {
        checked.push(item);
      }
    });
    panelState.checkChangeByUser = false;
    panelState.checked = checked;
  }, {
    immediate: true
  });
  return {
    filteredData,
    checkableData,
    checkedSummary,
    isIndeterminate,
    updateAllChecked,
    handleAllCheckedChange
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/composables/use-checked-change.mjs
var useCheckedChange = (checkedState, emit) => {
  const onSourceCheckedChange = (val, movedKeys) => {
    checkedState.leftChecked = val;
    if (!movedKeys)
      return;
    emit(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
  };
  const onTargetCheckedChange = (val, movedKeys) => {
    checkedState.rightChecked = val;
    if (!movedKeys)
      return;
    emit(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
  };
  return {
    onSourceCheckedChange,
    onTargetCheckedChange
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/composables/use-computed-data.mjs
var import_vue571 = require("vue");
var useComputedData = (props) => {
  const propsAlias = usePropsAlias(props);
  const dataObj = (0, import_vue571.computed)(() => props.data.reduce((o2, cur) => (o2[cur[propsAlias.value.key]] = cur) && o2, {}));
  const sourceData = (0, import_vue571.computed)(() => props.data.filter((item) => !props.modelValue.includes(item[propsAlias.value.key])));
  const targetData = (0, import_vue571.computed)(() => {
    if (props.targetOrder === "original") {
      return props.data.filter((item) => props.modelValue.includes(item[propsAlias.value.key]));
    } else {
      return props.modelValue.reduce((arr, cur) => {
        const val = dataObj.value[cur];
        if (val) {
          arr.push(val);
        }
        return arr;
      }, []);
    }
  });
  return {
    sourceData,
    targetData
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/composables/use-move.mjs
var useMove = (props, checkedState, emit) => {
  const propsAlias = usePropsAlias(props);
  const _emit = (value, direction2, movedKeys) => {
    emit(UPDATE_MODEL_EVENT, value);
    emit(CHANGE_EVENT, value, direction2, movedKeys);
  };
  const addToLeft = () => {
    const currentValue = props.modelValue.slice();
    checkedState.rightChecked.forEach((item) => {
      const index2 = currentValue.indexOf(item);
      if (index2 > -1) {
        currentValue.splice(index2, 1);
      }
    });
    _emit(currentValue, "left", checkedState.rightChecked);
  };
  const addToRight = () => {
    let currentValue = props.modelValue.slice();
    const itemsToBeMoved = props.data.filter((item) => {
      const itemKey = item[propsAlias.value.key];
      return checkedState.leftChecked.includes(itemKey) && !props.modelValue.includes(itemKey);
    }).map((item) => item[propsAlias.value.key]);
    currentValue = props.targetOrder === "unshift" ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
    if (props.targetOrder === "original") {
      currentValue = props.data.filter((item) => currentValue.includes(item[propsAlias.value.key])).map((item) => item[propsAlias.value.key]);
    }
    _emit(currentValue, "right", checkedState.leftChecked);
  };
  return {
    addToLeft,
    addToRight
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/transfer-panel2.mjs
var import_vue572 = require("vue");
var __default__91 = (0, import_vue572.defineComponent)({
  name: "ElTransferPanel"
});
var _sfc_main132 = /* @__PURE__ */ (0, import_vue572.defineComponent)({
  ...__default__91,
  props: transferPanelProps,
  emits: transferPanelEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots = (0, import_vue572.useSlots)();
    const OptionContent = ({ option: option2 }) => option2;
    const { t } = useLocale();
    const ns2 = useNamespace("transfer");
    const panelState = (0, import_vue572.reactive)({
      checked: [],
      allChecked: false,
      query: "",
      checkChangeByUser: true
    });
    const propsAlias = usePropsAlias(props);
    const {
      filteredData,
      checkedSummary,
      isIndeterminate,
      handleAllCheckedChange
    } = useCheck(props, panelState, emit);
    const hasNoMatch = (0, import_vue572.computed)(() => !isEmpty(panelState.query) && isEmpty(filteredData.value));
    const hasFooter = (0, import_vue572.computed)(() => !isEmpty(slots.default()[0].children));
    const { checked, allChecked, query } = (0, import_vue572.toRefs)(panelState);
    expose({
      query
    });
    return (_ctx, _cache) => {
      return (0, import_vue572.openBlock)(), (0, import_vue572.createElementBlock)("div", {
        class: (0, import_vue572.normalizeClass)((0, import_vue572.unref)(ns2).b("panel"))
      }, [
        (0, import_vue572.createElementVNode)("p", {
          class: (0, import_vue572.normalizeClass)((0, import_vue572.unref)(ns2).be("panel", "header"))
        }, [
          (0, import_vue572.createVNode)((0, import_vue572.unref)(ElCheckbox), {
            modelValue: (0, import_vue572.unref)(allChecked),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, import_vue572.isRef)(allChecked) ? allChecked.value = $event : null),
            indeterminate: (0, import_vue572.unref)(isIndeterminate),
            "validate-event": false,
            onChange: (0, import_vue572.unref)(handleAllCheckedChange)
          }, {
            default: (0, import_vue572.withCtx)(() => [
              (0, import_vue572.createTextVNode)((0, import_vue572.toDisplayString)(_ctx.title) + " ", 1),
              (0, import_vue572.createElementVNode)("span", null, (0, import_vue572.toDisplayString)((0, import_vue572.unref)(checkedSummary)), 1)
            ]),
            _: 1
          }, 8, ["modelValue", "indeterminate", "onChange"])
        ], 2),
        (0, import_vue572.createElementVNode)("div", {
          class: (0, import_vue572.normalizeClass)([(0, import_vue572.unref)(ns2).be("panel", "body"), (0, import_vue572.unref)(ns2).is("with-footer", (0, import_vue572.unref)(hasFooter))])
        }, [
          _ctx.filterable ? ((0, import_vue572.openBlock)(), (0, import_vue572.createBlock)((0, import_vue572.unref)(ElInput), {
            key: 0,
            modelValue: (0, import_vue572.unref)(query),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => (0, import_vue572.isRef)(query) ? query.value = $event : null),
            class: (0, import_vue572.normalizeClass)((0, import_vue572.unref)(ns2).be("panel", "filter")),
            size: "default",
            placeholder: _ctx.placeholder,
            "prefix-icon": (0, import_vue572.unref)(search_default),
            clearable: "",
            "validate-event": false
          }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : (0, import_vue572.createCommentVNode)("v-if", true),
          (0, import_vue572.withDirectives)((0, import_vue572.createVNode)((0, import_vue572.unref)(ElCheckboxGroup), {
            modelValue: (0, import_vue572.unref)(checked),
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => (0, import_vue572.isRef)(checked) ? checked.value = $event : null),
            "validate-event": false,
            class: (0, import_vue572.normalizeClass)([(0, import_vue572.unref)(ns2).is("filterable", _ctx.filterable), (0, import_vue572.unref)(ns2).be("panel", "list")])
          }, {
            default: (0, import_vue572.withCtx)(() => [
              ((0, import_vue572.openBlock)(true), (0, import_vue572.createElementBlock)(import_vue572.Fragment, null, (0, import_vue572.renderList)((0, import_vue572.unref)(filteredData), (item) => {
                return (0, import_vue572.openBlock)(), (0, import_vue572.createBlock)((0, import_vue572.unref)(ElCheckbox), {
                  key: item[(0, import_vue572.unref)(propsAlias).key],
                  class: (0, import_vue572.normalizeClass)((0, import_vue572.unref)(ns2).be("panel", "item")),
                  label: item[(0, import_vue572.unref)(propsAlias).key],
                  disabled: item[(0, import_vue572.unref)(propsAlias).disabled],
                  "validate-event": false
                }, {
                  default: (0, import_vue572.withCtx)(() => {
                    var _a2;
                    return [
                      (0, import_vue572.createVNode)(OptionContent, {
                        option: (_a2 = _ctx.optionRender) == null ? void 0 : _a2.call(_ctx, item)
                      }, null, 8, ["option"])
                    ];
                  }),
                  _: 2
                }, 1032, ["class", "label", "disabled"]);
              }), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "class"]), [
            [import_vue572.vShow, !(0, import_vue572.unref)(hasNoMatch) && !(0, import_vue572.unref)(isEmpty)(_ctx.data)]
          ]),
          (0, import_vue572.withDirectives)((0, import_vue572.createElementVNode)("p", {
            class: (0, import_vue572.normalizeClass)((0, import_vue572.unref)(ns2).be("panel", "empty"))
          }, (0, import_vue572.toDisplayString)((0, import_vue572.unref)(hasNoMatch) ? (0, import_vue572.unref)(t)("el.transfer.noMatch") : (0, import_vue572.unref)(t)("el.transfer.noData")), 3), [
            [import_vue572.vShow, (0, import_vue572.unref)(hasNoMatch) || (0, import_vue572.unref)(isEmpty)(_ctx.data)]
          ])
        ], 2),
        (0, import_vue572.unref)(hasFooter) ? ((0, import_vue572.openBlock)(), (0, import_vue572.createElementBlock)("p", {
          key: 0,
          class: (0, import_vue572.normalizeClass)((0, import_vue572.unref)(ns2).be("panel", "footer"))
        }, [
          (0, import_vue572.renderSlot)(_ctx.$slots, "default")
        ], 2)) : (0, import_vue572.createCommentVNode)("v-if", true)
      ], 2);
    };
  }
});
var TransferPanel = /* @__PURE__ */ _export_sfc(_sfc_main132, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/src/transfer2.mjs
var _hoisted_183 = { key: 0 };
var _hoisted_252 = { key: 0 };
var __default__92 = (0, import_vue573.defineComponent)({
  name: "ElTransfer"
});
var _sfc_main133 = /* @__PURE__ */ (0, import_vue573.defineComponent)({
  ...__default__92,
  props: transferProps,
  emits: transferEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots = (0, import_vue573.useSlots)();
    const { t } = useLocale();
    const ns2 = useNamespace("transfer");
    const { formItem } = useFormItem();
    const checkedState = (0, import_vue573.reactive)({
      leftChecked: [],
      rightChecked: []
    });
    const propsAlias = usePropsAlias(props);
    const { sourceData, targetData } = useComputedData(props);
    const { onSourceCheckedChange, onTargetCheckedChange } = useCheckedChange(checkedState, emit);
    const { addToLeft, addToRight } = useMove(props, checkedState, emit);
    const leftPanel = (0, import_vue573.ref)();
    const rightPanel = (0, import_vue573.ref)();
    const clearQuery = (which) => {
      switch (which) {
        case "left":
          leftPanel.value.query = "";
          break;
        case "right":
          rightPanel.value.query = "";
          break;
      }
    };
    const hasButtonTexts = (0, import_vue573.computed)(() => props.buttonTexts.length === 2);
    const leftPanelTitle = (0, import_vue573.computed)(() => props.titles[0] || t("el.transfer.titles.0"));
    const rightPanelTitle = (0, import_vue573.computed)(() => props.titles[1] || t("el.transfer.titles.1"));
    const panelFilterPlaceholder = (0, import_vue573.computed)(() => props.filterPlaceholder || t("el.transfer.filterPlaceholder"));
    (0, import_vue573.watch)(() => props.modelValue, () => {
      var _a2;
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn(err));
      }
    });
    const optionRender = (0, import_vue573.computed)(() => (option2) => {
      if (props.renderContent)
        return props.renderContent(import_vue573.h, option2);
      if (slots.default)
        return slots.default({ option: option2 });
      return (0, import_vue573.h)("span", option2[propsAlias.value.label] || option2[propsAlias.value.key]);
    });
    expose({
      clearQuery,
      leftPanel,
      rightPanel
    });
    return (_ctx, _cache) => {
      return (0, import_vue573.openBlock)(), (0, import_vue573.createElementBlock)("div", {
        class: (0, import_vue573.normalizeClass)((0, import_vue573.unref)(ns2).b())
      }, [
        (0, import_vue573.createVNode)(TransferPanel, {
          ref_key: "leftPanel",
          ref: leftPanel,
          data: (0, import_vue573.unref)(sourceData),
          "option-render": (0, import_vue573.unref)(optionRender),
          placeholder: (0, import_vue573.unref)(panelFilterPlaceholder),
          title: (0, import_vue573.unref)(leftPanelTitle),
          filterable: _ctx.filterable,
          format: _ctx.format,
          "filter-method": _ctx.filterMethod,
          "default-checked": _ctx.leftDefaultChecked,
          props: props.props,
          onCheckedChange: (0, import_vue573.unref)(onSourceCheckedChange)
        }, {
          default: (0, import_vue573.withCtx)(() => [
            (0, import_vue573.renderSlot)(_ctx.$slots, "left-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
        (0, import_vue573.createElementVNode)("div", {
          class: (0, import_vue573.normalizeClass)((0, import_vue573.unref)(ns2).e("buttons"))
        }, [
          (0, import_vue573.createVNode)((0, import_vue573.unref)(ElButton), {
            type: "primary",
            class: (0, import_vue573.normalizeClass)([(0, import_vue573.unref)(ns2).e("button"), (0, import_vue573.unref)(ns2).is("with-texts", (0, import_vue573.unref)(hasButtonTexts))]),
            disabled: (0, import_vue573.unref)(isEmpty)(checkedState.rightChecked),
            onClick: (0, import_vue573.unref)(addToLeft)
          }, {
            default: (0, import_vue573.withCtx)(() => [
              (0, import_vue573.createVNode)((0, import_vue573.unref)(ElIcon), null, {
                default: (0, import_vue573.withCtx)(() => [
                  (0, import_vue573.createVNode)((0, import_vue573.unref)(arrow_left_default))
                ]),
                _: 1
              }),
              !(0, import_vue573.unref)(isUndefined)(_ctx.buttonTexts[0]) ? ((0, import_vue573.openBlock)(), (0, import_vue573.createElementBlock)("span", _hoisted_183, (0, import_vue573.toDisplayString)(_ctx.buttonTexts[0]), 1)) : (0, import_vue573.createCommentVNode)("v-if", true)
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"]),
          (0, import_vue573.createVNode)((0, import_vue573.unref)(ElButton), {
            type: "primary",
            class: (0, import_vue573.normalizeClass)([(0, import_vue573.unref)(ns2).e("button"), (0, import_vue573.unref)(ns2).is("with-texts", (0, import_vue573.unref)(hasButtonTexts))]),
            disabled: (0, import_vue573.unref)(isEmpty)(checkedState.leftChecked),
            onClick: (0, import_vue573.unref)(addToRight)
          }, {
            default: (0, import_vue573.withCtx)(() => [
              !(0, import_vue573.unref)(isUndefined)(_ctx.buttonTexts[1]) ? ((0, import_vue573.openBlock)(), (0, import_vue573.createElementBlock)("span", _hoisted_252, (0, import_vue573.toDisplayString)(_ctx.buttonTexts[1]), 1)) : (0, import_vue573.createCommentVNode)("v-if", true),
              (0, import_vue573.createVNode)((0, import_vue573.unref)(ElIcon), null, {
                default: (0, import_vue573.withCtx)(() => [
                  (0, import_vue573.createVNode)((0, import_vue573.unref)(arrow_right_default))
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"])
        ], 2),
        (0, import_vue573.createVNode)(TransferPanel, {
          ref_key: "rightPanel",
          ref: rightPanel,
          data: (0, import_vue573.unref)(targetData),
          "option-render": (0, import_vue573.unref)(optionRender),
          placeholder: (0, import_vue573.unref)(panelFilterPlaceholder),
          filterable: _ctx.filterable,
          format: _ctx.format,
          "filter-method": _ctx.filterMethod,
          title: (0, import_vue573.unref)(rightPanelTitle),
          "default-checked": _ctx.rightDefaultChecked,
          props: props.props,
          onCheckedChange: (0, import_vue573.unref)(onTargetCheckedChange)
        }, {
          default: (0, import_vue573.withCtx)(() => [
            (0, import_vue573.renderSlot)(_ctx.$slots, "right-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
      ], 2);
    };
  }
});
var Transfer = /* @__PURE__ */ _export_sfc(_sfc_main133, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/transfer/index.mjs
var ElTransfer = withInstall(Transfer);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/tree.mjs
var import_vue580 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/node.mjs
var import_vue574 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/util.mjs
var NODE_KEY = "$treeNodeId";
var markNodeData = function(node, data) {
  if (!data || data[NODE_KEY])
    return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
var getNodeKey = function(key, data) {
  if (!key)
    return data[NODE_KEY];
  return data[key];
};
var handleCurrentChange = (store, emit, setCurrent) => {
  const preCurrentNode = store.value.currentNode;
  setCurrent();
  const currentNode = store.value.currentNode;
  if (preCurrentNode === currentNode)
    return;
  emit("current-change", currentNode ? currentNode.data : null, currentNode);
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/node.mjs
var import_shared102 = require("@vue/shared");
var getChildState = (node) => {
  let all = true;
  let none = true;
  let allWithoutDisable = true;
  for (let i = 0, j = node.length; i < j; i++) {
    const n = node[i];
    if (n.checked !== true || n.indeterminate) {
      all = false;
      if (!n.disabled) {
        allWithoutDisable = false;
      }
    }
    if (n.checked !== false || n.indeterminate) {
      none = false;
    }
  }
  return { all, none, allWithoutDisable, half: !all && !none };
};
var reInitChecked = function(node) {
  if (node.childNodes.length === 0 || node.loading)
    return;
  const { all, none, half } = getChildState(node.childNodes);
  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }
  const parent = node.parent;
  if (!parent || parent.level === 0)
    return;
  if (!node.store.checkStrictly) {
    reInitChecked(parent);
  }
};
var getPropertyFromData = function(node, prop) {
  const props = node.store.props;
  const data = node.data || {};
  const config = props[prop];
  if (typeof config === "function") {
    return config(data, node);
  } else if (typeof config === "string") {
    return data[config];
  } else if (typeof config === "undefined") {
    const dataProp = data[prop];
    return dataProp === void 0 ? "" : dataProp;
  }
};
var nodeIdSeed = 0;
var Node2 = class {
  constructor(options) {
    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;
    this.isCurrent = false;
    this.canFocus = false;
    for (const name in options) {
      if ((0, import_shared102.hasOwn)(options, name)) {
        this[name] = options[name];
      }
    }
    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;
    if (this.parent) {
      this.level = this.parent.level + 1;
    }
  }
  initialize() {
    const store = this.store;
    if (!store) {
      throw new Error("[Node]store is required!");
    }
    store.registerNode(this);
    const props = store.props;
    if (props && typeof props.isLeaf !== "undefined") {
      const isLeaf2 = getPropertyFromData(this, "isLeaf");
      if (typeof isLeaf2 === "boolean") {
        this.isLeafByUser = isLeaf2;
      }
    }
    if (store.lazy !== true && this.data) {
      this.setData(this.data);
      if (store.defaultExpandAll) {
        this.expanded = true;
        this.canFocus = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }
    if (!Array.isArray(this.data)) {
      markNodeData(this, this.data);
    }
    if (!this.data)
      return;
    const defaultExpandedKeys = store.defaultExpandedKeys;
    const key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {
      this.expand(null, store.autoExpandParent);
    }
    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
      store.currentNode = this;
      store.currentNode.isCurrent = true;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }
    this.updateLeafState();
    if (this.parent && (this.level === 1 || this.parent.expanded === true))
      this.canFocus = true;
  }
  setData(data) {
    if (!Array.isArray(data)) {
      markNodeData(this, data);
    }
    this.data = data;
    this.childNodes = [];
    let children;
    if (this.level === 0 && Array.isArray(this.data)) {
      children = this.data;
    } else {
      children = getPropertyFromData(this, "children") || [];
    }
    for (let i = 0, j = children.length; i < j; i++) {
      this.insertChild({ data: children[i] });
    }
  }
  get label() {
    return getPropertyFromData(this, "label");
  }
  get key() {
    const nodeKey = this.store.key;
    if (this.data)
      return this.data[nodeKey];
    return null;
  }
  get disabled() {
    return getPropertyFromData(this, "disabled");
  }
  get nextSibling() {
    const parent = this.parent;
    if (parent) {
      const index2 = parent.childNodes.indexOf(this);
      if (index2 > -1) {
        return parent.childNodes[index2 + 1];
      }
    }
    return null;
  }
  get previousSibling() {
    const parent = this.parent;
    if (parent) {
      const index2 = parent.childNodes.indexOf(this);
      if (index2 > -1) {
        return index2 > 0 ? parent.childNodes[index2 - 1] : null;
      }
    }
    return null;
  }
  contains(target, deep = true) {
    return (this.childNodes || []).some((child) => child === target || deep && child.contains(target));
  }
  remove() {
    const parent = this.parent;
    if (parent) {
      parent.removeChild(this);
    }
  }
  insertChild(child, index2, batch) {
    if (!child)
      throw new Error("InsertChild error: child is required.");
    if (!(child instanceof Node2)) {
      if (!batch) {
        const children = this.getChildren(true);
        if (!children.includes(child.data)) {
          if (typeof index2 === "undefined" || index2 < 0) {
            children.push(child.data);
          } else {
            children.splice(index2, 0, child.data);
          }
        }
      }
      Object.assign(child, {
        parent: this,
        store: this.store
      });
      child = (0, import_vue574.reactive)(new Node2(child));
      if (child instanceof Node2) {
        child.initialize();
      }
    }
    ;
    child.level = this.level + 1;
    if (typeof index2 === "undefined" || index2 < 0) {
      this.childNodes.push(child);
    } else {
      this.childNodes.splice(index2, 0, child);
    }
    this.updateLeafState();
  }
  insertBefore(child, ref162) {
    let index2;
    if (ref162) {
      index2 = this.childNodes.indexOf(ref162);
    }
    this.insertChild(child, index2);
  }
  insertAfter(child, ref162) {
    let index2;
    if (ref162) {
      index2 = this.childNodes.indexOf(ref162);
      if (index2 !== -1)
        index2 += 1;
    }
    this.insertChild(child, index2);
  }
  removeChild(child) {
    const children = this.getChildren() || [];
    const dataIndex = children.indexOf(child.data);
    if (dataIndex > -1) {
      children.splice(dataIndex, 1);
    }
    const index2 = this.childNodes.indexOf(child);
    if (index2 > -1) {
      this.store && this.store.deregisterNode(child);
      child.parent = null;
      this.childNodes.splice(index2, 1);
    }
    this.updateLeafState();
  }
  removeChildByData(data) {
    let targetNode = null;
    for (let i = 0; i < this.childNodes.length; i++) {
      if (this.childNodes[i].data === data) {
        targetNode = this.childNodes[i];
        break;
      }
    }
    if (targetNode) {
      this.removeChild(targetNode);
    }
  }
  expand(callback, expandParent) {
    const done = () => {
      if (expandParent) {
        let parent = this.parent;
        while (parent.level > 0) {
          parent.expanded = true;
          parent = parent.parent;
        }
      }
      this.expanded = true;
      if (callback)
        callback();
      this.childNodes.forEach((item) => {
        item.canFocus = true;
      });
    };
    if (this.shouldLoadData()) {
      this.loadData((data) => {
        if (Array.isArray(data)) {
          if (this.checked) {
            this.setChecked(true, true);
          } else if (!this.store.checkStrictly) {
            reInitChecked(this);
          }
          done();
        }
      });
    } else {
      done();
    }
  }
  doCreateChildren(array4, defaultProps4 = {}) {
    array4.forEach((item) => {
      this.insertChild(Object.assign({ data: item }, defaultProps4), void 0, true);
    });
  }
  collapse() {
    this.expanded = false;
    this.childNodes.forEach((item) => {
      item.canFocus = false;
    });
  }
  shouldLoadData() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const childNodes = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    this.isLeaf = false;
  }
  setChecked(value, deep, recursion, passValue) {
    this.indeterminate = value === "half";
    this.checked = value === true;
    if (this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all, allWithoutDisable } = getChildState(this.childNodes);
      if (!this.isLeaf && !all && allWithoutDisable) {
        this.checked = false;
        value = false;
      }
      const handleDescendants = () => {
        if (deep) {
          const childNodes = this.childNodes;
          for (let i = 0, j = childNodes.length; i < j; i++) {
            const child = childNodes[i];
            passValue = passValue || value !== false;
            const isCheck = child.disabled ? child.checked : passValue;
            child.setChecked(isCheck, deep, true, passValue);
          }
          const { half, all: all2 } = getChildState(childNodes);
          if (!all2) {
            this.checked = all2;
            this.indeterminate = half;
          }
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          handleDescendants();
          reInitChecked(this);
        }, {
          checked: value !== false
        });
        return;
      } else {
        handleDescendants();
      }
    }
    const parent = this.parent;
    if (!parent || parent.level === 0)
      return;
    if (!recursion) {
      reInitChecked(parent);
    }
  }
  getChildren(forceInit = false) {
    if (this.level === 0)
      return this.data;
    const data = this.data;
    if (!data)
      return null;
    const props = this.store.props;
    let children = "children";
    if (props) {
      children = props.children || "children";
    }
    if (data[children] === void 0) {
      data[children] = null;
    }
    if (forceInit && !data[children]) {
      data[children] = [];
    }
    return data[children];
  }
  updateChildren() {
    const newData = this.getChildren() || [];
    const oldData = this.childNodes.map((node) => node.data);
    const newDataMap = {};
    const newNodes = [];
    newData.forEach((item, index2) => {
      const key = item[NODE_KEY];
      const isNodeExists = !!key && oldData.findIndex((data) => data[NODE_KEY] === key) >= 0;
      if (isNodeExists) {
        newDataMap[key] = { index: index2, data: item };
      } else {
        newNodes.push({ index: index2, data: item });
      }
    });
    if (!this.store.lazy) {
      oldData.forEach((item) => {
        if (!newDataMap[item[NODE_KEY]])
          this.removeChildByData(item);
      });
    }
    newNodes.forEach(({ index: index2, data }) => {
      this.insertChild({ data }, index2);
    });
    this.updateLeafState();
  }
  loadData(callback, defaultProps4 = {}) {
    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps4).length)) {
      this.loading = true;
      const resolve = (children) => {
        this.childNodes = [];
        this.doCreateChildren(children, defaultProps4);
        this.loaded = true;
        this.loading = false;
        this.updateLeafState();
        if (callback) {
          callback.call(this, children);
        }
      };
      this.store.load(this, resolve);
    } else {
      if (callback) {
        callback.call(this);
      }
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/tree-store.mjs
var import_shared103 = require("@vue/shared");
var TreeStore = class {
  constructor(options) {
    this.currentNode = null;
    this.currentNodeKey = null;
    for (const option2 in options) {
      if ((0, import_shared103.hasOwn)(options, option2)) {
        this[option2] = options[option2];
      }
    }
    this.nodesMap = {};
  }
  initialize() {
    this.root = new Node2({
      data: this.data,
      store: this
    });
    this.root.initialize();
    if (this.lazy && this.load) {
      const loadFn = this.load;
      loadFn(this.root, (data) => {
        this.root.doCreateChildren(data);
        this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }
  filter(value) {
    const filterNodeMethod = this.filterNodeMethod;
    const lazy = this.lazy;
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        child.visible = filterNodeMethod.call(child, value, child.data, child);
        traverse(child);
      });
      if (!node.visible && childNodes.length) {
        let allHidden = true;
        allHidden = !childNodes.some((child) => child.visible);
        if (node.root) {
          ;
          node.root.visible = allHidden === false;
        } else {
          ;
          node.visible = allHidden === false;
        }
      }
      if (!value)
        return;
      if (node.visible && !node.isLeaf && !lazy)
        node.expand();
    };
    traverse(this);
  }
  setData(newVal) {
    const instanceChanged = newVal !== this.root.data;
    if (instanceChanged) {
      this.root.setData(newVal);
      this._initDefaultCheckedNodes();
    } else {
      this.root.updateChildren();
    }
  }
  getNode(data) {
    if (data instanceof Node2)
      return data;
    const key = (0, import_shared103.isObject)(data) ? getNodeKey(this.key, data) : data;
    return this.nodesMap[key] || null;
  }
  insertBefore(data, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertBefore({ data }, refNode);
  }
  insertAfter(data, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertAfter({ data }, refNode);
  }
  remove(data) {
    const node = this.getNode(data);
    if (node && node.parent) {
      if (node === this.currentNode) {
        this.currentNode = null;
      }
      node.parent.removeChild(node);
    }
  }
  append(data, parentData) {
    const parentNode = parentData ? this.getNode(parentData) : this.root;
    if (parentNode) {
      parentNode.insertChild({ data });
    }
  }
  _initDefaultCheckedNodes() {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    const nodesMap = this.nodesMap;
    defaultCheckedKeys.forEach((checkedKey) => {
      const node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !this.checkStrictly);
      }
    });
  }
  _initDefaultCheckedNode(node) {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    if (defaultCheckedKeys.includes(node.key)) {
      node.setChecked(true, !this.checkStrictly);
    }
  }
  setDefaultCheckedKey(newVal) {
    if (newVal !== this.defaultCheckedKeys) {
      this.defaultCheckedKeys = newVal;
      this._initDefaultCheckedNodes();
    }
  }
  registerNode(node) {
    const key = this.key;
    if (!node || !node.data)
      return;
    if (!key) {
      this.nodesMap[node.id] = node;
    } else {
      const nodeKey = node.key;
      if (nodeKey !== void 0)
        this.nodesMap[node.key] = node;
    }
  }
  deregisterNode(node) {
    const key = this.key;
    if (!key || !node || !node.data)
      return;
    node.childNodes.forEach((child) => {
      this.deregisterNode(child);
    });
    delete this.nodesMap[node.key];
  }
  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
    const checkedNodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
          checkedNodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return checkedNodes;
  }
  getCheckedKeys(leafOnly = false) {
    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const nodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if (child.indeterminate) {
          nodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return nodes;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
  }
  _getAllNodes() {
    const allNodes = [];
    const nodesMap = this.nodesMap;
    for (const nodeKey in nodesMap) {
      if ((0, import_shared103.hasOwn)(nodesMap, nodeKey)) {
        allNodes.push(nodesMap[nodeKey]);
      }
    }
    return allNodes;
  }
  updateChildren(key, data) {
    const node = this.nodesMap[key];
    if (!node)
      return;
    const childNodes = node.childNodes;
    for (let i = childNodes.length - 1; i >= 0; i--) {
      const child = childNodes[i];
      this.remove(child.data);
    }
    for (let i = 0, j = data.length; i < j; i++) {
      const child = data[i];
      this.append(child, node.data);
    }
  }
  _setCheckedKeys(key, leafOnly = false, checkedKeys) {
    const allNodes = this._getAllNodes().sort((a3, b3) => b3.level - a3.level);
    const cache2 = /* @__PURE__ */ Object.create(null);
    const keys2 = Object.keys(checkedKeys);
    allNodes.forEach((node) => node.setChecked(false, false));
    for (let i = 0, j = allNodes.length; i < j; i++) {
      const node = allNodes[i];
      const nodeKey = node.data[key].toString();
      const checked = keys2.includes(nodeKey);
      if (!checked) {
        if (node.checked && !cache2[nodeKey]) {
          node.setChecked(false, false);
        }
        continue;
      }
      let parent = node.parent;
      while (parent && parent.level > 0) {
        cache2[parent.data[key]] = true;
        parent = parent.parent;
      }
      if (node.isLeaf || this.checkStrictly) {
        node.setChecked(true, false);
        continue;
      }
      node.setChecked(true, true);
      if (leafOnly) {
        node.setChecked(false, false);
        const traverse = function(node2) {
          const childNodes = node2.childNodes;
          childNodes.forEach((child) => {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    }
  }
  setCheckedNodes(array4, leafOnly = false) {
    const key = this.key;
    const checkedKeys = {};
    array4.forEach((item) => {
      checkedKeys[(item || {})[key]] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setCheckedKeys(keys2, leafOnly = false) {
    this.defaultCheckedKeys = keys2;
    const key = this.key;
    const checkedKeys = {};
    keys2.forEach((key2) => {
      checkedKeys[key2] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setDefaultExpandedKeys(keys2) {
    keys2 = keys2 || [];
    this.defaultExpandedKeys = keys2;
    keys2.forEach((key) => {
      const node = this.getNode(key);
      if (node)
        node.expand(null, this.autoExpandParent);
    });
  }
  setChecked(data, checked, deep) {
    const node = this.getNode(data);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(currentNode) {
    const prevCurrentNode = this.currentNode;
    if (prevCurrentNode) {
      prevCurrentNode.isCurrent = false;
    }
    this.currentNode = currentNode;
    this.currentNode.isCurrent = true;
  }
  setUserCurrentNode(node, shouldAutoExpandParent = true) {
    const key = node[this.key];
    const currNode = this.nodesMap[key];
    this.setCurrentNode(currNode);
    if (shouldAutoExpandParent && this.currentNode.level > 1) {
      this.currentNode.parent.expand(null, true);
    }
  }
  setCurrentNodeKey(key, shouldAutoExpandParent = true) {
    if (key === null || key === void 0) {
      this.currentNode && (this.currentNode.isCurrent = false);
      this.currentNode = null;
      return;
    }
    const node = this.getNode(key);
    if (node) {
      this.setCurrentNode(node);
      if (shouldAutoExpandParent && this.currentNode.level > 1) {
        this.currentNode.parent.expand(null, true);
      }
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/tree-node.mjs
var import_vue578 = require("vue");
var import_shared104 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/tree-node-content.mjs
var import_vue575 = require("vue");
var _sfc_main134 = (0, import_vue575.defineComponent)({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: true
    },
    renderContent: Function
  },
  setup(props) {
    const ns2 = useNamespace("tree");
    const nodeInstance = (0, import_vue575.inject)("NodeInstance");
    const tree = (0, import_vue575.inject)("RootTree");
    return () => {
      const node = props.node;
      const { data, store } = node;
      return props.renderContent ? props.renderContent(import_vue575.h, { _self: nodeInstance, node, data, store }) : tree.ctx.slots.default ? tree.ctx.slots.default({ node, data }) : (0, import_vue575.h)("span", { class: ns2.be("node", "label") }, [node.label]);
    };
  }
});
var NodeContent2 = /* @__PURE__ */ _export_sfc(_sfc_main134, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/useNodeExpandEventBroadcast.mjs
var import_vue576 = require("vue");
function useNodeExpandEventBroadcast(props) {
  const parentNodeMap = (0, import_vue576.inject)("TreeNodeMap", null);
  const currentNodeMap = {
    treeNodeExpand: (node) => {
      if (props.node !== node) {
        props.node.collapse();
      }
    },
    children: []
  };
  if (parentNodeMap) {
    parentNodeMap.children.push(currentNodeMap);
  }
  (0, import_vue576.provide)("TreeNodeMap", currentNodeMap);
  return {
    broadcastExpanded: (node) => {
      if (!props.accordion)
        return;
      for (const childNode of currentNodeMap.children) {
        childNode.treeNodeExpand(node);
      }
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/useDragNode.mjs
var import_vue577 = require("vue");
var dragEventsKey = Symbol("dragEvents");
function useDragNodeHandler({ props, ctx, el$, dropIndicator$, store }) {
  const ns2 = useNamespace("tree");
  const dragState = (0, import_vue577.ref)({
    showDropIndicator: false,
    draggingNode: null,
    dropNode: null,
    allowDrop: true,
    dropType: null
  });
  const treeNodeDragStart = ({ event, treeNode }) => {
    if (typeof props.allowDrag === "function" && !props.allowDrag(treeNode.node)) {
      event.preventDefault();
      return false;
    }
    event.dataTransfer.effectAllowed = "move";
    try {
      event.dataTransfer.setData("text/plain", "");
    } catch (e) {
    }
    dragState.value.draggingNode = treeNode;
    ctx.emit("node-drag-start", treeNode.node, event);
  };
  const treeNodeDragOver = ({ event, treeNode }) => {
    const dropNode = treeNode;
    const oldDropNode = dragState.value.dropNode;
    if (oldDropNode && oldDropNode !== dropNode) {
      removeClass(oldDropNode.$el, ns2.is("drop-inner"));
    }
    const draggingNode = dragState.value.draggingNode;
    if (!draggingNode || !dropNode)
      return;
    let dropPrev = true;
    let dropInner = true;
    let dropNext = true;
    let userAllowDropInner = true;
    if (typeof props.allowDrop === "function") {
      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, "prev");
      userAllowDropInner = dropInner = props.allowDrop(draggingNode.node, dropNode.node, "inner");
      dropNext = props.allowDrop(draggingNode.node, dropNode.node, "next");
    }
    event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? "move" : "none";
    if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
      if (oldDropNode) {
        ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
      }
      ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
    }
    if (dropPrev || dropInner || dropNext) {
      dragState.value.dropNode = dropNode;
    }
    if (dropNode.node.nextSibling === draggingNode.node) {
      dropNext = false;
    }
    if (dropNode.node.previousSibling === draggingNode.node) {
      dropPrev = false;
    }
    if (dropNode.node.contains(draggingNode.node, false)) {
      dropInner = false;
    }
    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
      dropPrev = false;
      dropInner = false;
      dropNext = false;
    }
    const targetPosition = dropNode.$el.getBoundingClientRect();
    const treePosition = el$.value.getBoundingClientRect();
    let dropType;
    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
    let indicatorTop = -9999;
    const distance = event.clientY - targetPosition.top;
    if (distance < targetPosition.height * prevPercent) {
      dropType = "before";
    } else if (distance > targetPosition.height * nextPercent) {
      dropType = "after";
    } else if (dropInner) {
      dropType = "inner";
    } else {
      dropType = "none";
    }
    const iconPosition = dropNode.$el.querySelector(`.${ns2.be("node", "expand-icon")}`).getBoundingClientRect();
    const dropIndicator = dropIndicator$.value;
    if (dropType === "before") {
      indicatorTop = iconPosition.top - treePosition.top;
    } else if (dropType === "after") {
      indicatorTop = iconPosition.bottom - treePosition.top;
    }
    dropIndicator.style.top = `${indicatorTop}px`;
    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
    if (dropType === "inner") {
      addClass(dropNode.$el, ns2.is("drop-inner"));
    } else {
      removeClass(dropNode.$el, ns2.is("drop-inner"));
    }
    dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
    dragState.value.dropType = dropType;
    ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
  };
  const treeNodeDragEnd = (event) => {
    const { draggingNode, dropType, dropNode } = dragState.value;
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    if (draggingNode && dropNode) {
      const draggingNodeCopy = { data: draggingNode.node.data };
      if (dropType !== "none") {
        draggingNode.node.remove();
      }
      if (dropType === "before") {
        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
      } else if (dropType === "after") {
        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
      } else if (dropType === "inner") {
        dropNode.node.insertChild(draggingNodeCopy);
      }
      if (dropType !== "none") {
        store.value.registerNode(draggingNodeCopy);
      }
      removeClass(dropNode.$el, ns2.is("drop-inner"));
      ctx.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event);
      if (dropType !== "none") {
        ctx.emit("node-drop", draggingNode.node, dropNode.node, dropType, event);
      }
    }
    if (draggingNode && !dropNode) {
      ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
    }
    dragState.value.showDropIndicator = false;
    dragState.value.draggingNode = null;
    dragState.value.dropNode = null;
    dragState.value.allowDrop = true;
  };
  (0, import_vue577.provide)(dragEventsKey, {
    treeNodeDragStart,
    treeNodeDragOver,
    treeNodeDragEnd
  });
  return {
    dragState
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/tree-node.mjs
var _sfc_main135 = (0, import_vue578.defineComponent)({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: _CollapseTransition,
    ElCheckbox,
    NodeContent: NodeContent2,
    ElIcon,
    Loading: loading_default
  },
  props: {
    node: {
      type: Node2,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: false
    }
  },
  emits: ["node-expand"],
  setup(props, ctx) {
    const ns2 = useNamespace("tree");
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
    const tree = (0, import_vue578.inject)("RootTree");
    const expanded = (0, import_vue578.ref)(false);
    const childNodeRendered = (0, import_vue578.ref)(false);
    const oldChecked = (0, import_vue578.ref)(null);
    const oldIndeterminate = (0, import_vue578.ref)(null);
    const node$ = (0, import_vue578.ref)(null);
    const dragEvents = (0, import_vue578.inject)(dragEventsKey);
    const instance = (0, import_vue578.getCurrentInstance)();
    (0, import_vue578.provide)("NodeInstance", instance);
    if (!tree) {
      debugWarn("Tree", "Can not find node's tree.");
    }
    if (props.node.expanded) {
      expanded.value = true;
      childNodeRendered.value = true;
    }
    const childrenKey = tree.props["children"] || "children";
    (0, import_vue578.watch)(() => {
      const children = props.node.data[childrenKey];
      return children && [...children];
    }, () => {
      props.node.updateChildren();
    });
    (0, import_vue578.watch)(() => props.node.indeterminate, (val) => {
      handleSelectChange(props.node.checked, val);
    });
    (0, import_vue578.watch)(() => props.node.checked, (val) => {
      handleSelectChange(val, props.node.indeterminate);
    });
    (0, import_vue578.watch)(() => props.node.expanded, (val) => {
      (0, import_vue578.nextTick)(() => expanded.value = val);
      if (val) {
        childNodeRendered.value = true;
      }
    });
    const getNodeKey$1 = (node) => {
      return getNodeKey(tree.props.nodeKey, node.data);
    };
    const getNodeClass = (node) => {
      const nodeClassFunc = props.props.class;
      if (!nodeClassFunc) {
        return {};
      }
      let className;
      if ((0, import_shared104.isFunction)(nodeClassFunc)) {
        const { data } = node;
        className = nodeClassFunc(data, node);
      } else {
        className = nodeClassFunc;
      }
      if ((0, import_shared104.isString)(className)) {
        return { [className]: true };
      } else {
        return className;
      }
    };
    const handleSelectChange = (checked, indeterminate) => {
      if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {
        tree.ctx.emit("check-change", props.node.data, checked, indeterminate);
      }
      oldChecked.value = checked;
      oldIndeterminate.value = indeterminate;
    };
    const handleClick = (e) => {
      handleCurrentChange(tree.store, tree.ctx.emit, () => tree.store.value.setCurrentNode(props.node));
      tree.currentNode.value = props.node;
      if (tree.props.expandOnClickNode) {
        handleExpandIconClick();
      }
      if (tree.props.checkOnClickNode && !props.node.disabled) {
        handleCheckChange(null, {
          target: { checked: !props.node.checked }
        });
      }
      tree.ctx.emit("node-click", props.node.data, props.node, instance, e);
    };
    const handleContextMenu = (event) => {
      if (tree.instance.vnode.props["onNodeContextmenu"]) {
        event.stopPropagation();
        event.preventDefault();
      }
      tree.ctx.emit("node-contextmenu", event, props.node.data, props.node, instance);
    };
    const handleExpandIconClick = () => {
      if (props.node.isLeaf)
        return;
      if (expanded.value) {
        tree.ctx.emit("node-collapse", props.node.data, props.node, instance);
        props.node.collapse();
      } else {
        props.node.expand();
        ctx.emit("node-expand", props.node.data, props.node, instance);
      }
    };
    const handleCheckChange = (value, ev) => {
      props.node.setChecked(ev.target.checked, !tree.props.checkStrictly);
      (0, import_vue578.nextTick)(() => {
        const store = tree.store.value;
        tree.ctx.emit("check", props.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        });
      });
    };
    const handleChildNodeExpand = (nodeData, node, instance2) => {
      broadcastExpanded(node);
      tree.ctx.emit("node-expand", nodeData, node, instance2);
    };
    const handleDragStart = (event) => {
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragStart({ event, treeNode: props });
    };
    const handleDragOver = (event) => {
      event.preventDefault();
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragOver({
        event,
        treeNode: { $el: node$.value, node: props.node }
      });
    };
    const handleDrop = (event) => {
      event.preventDefault();
    };
    const handleDragEnd = (event) => {
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragEnd(event);
    };
    return {
      ns: ns2,
      node$,
      tree,
      expanded,
      childNodeRendered,
      oldChecked,
      oldIndeterminate,
      getNodeKey: getNodeKey$1,
      getNodeClass,
      handleSelectChange,
      handleClick,
      handleContextMenu,
      handleExpandIconClick,
      handleCheckChange,
      handleChildNodeExpand,
      handleDragStart,
      handleDragOver,
      handleDrop,
      handleDragEnd,
      CaretRight: caret_right_default
    };
  }
});
var _hoisted_184 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"];
var _hoisted_253 = ["aria-expanded"];
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = (0, import_vue578.resolveComponent)("el-icon");
  const _component_el_checkbox = (0, import_vue578.resolveComponent)("el-checkbox");
  const _component_loading = (0, import_vue578.resolveComponent)("loading");
  const _component_node_content = (0, import_vue578.resolveComponent)("node-content");
  const _component_el_tree_node = (0, import_vue578.resolveComponent)("el-tree-node");
  const _component_el_collapse_transition = (0, import_vue578.resolveComponent)("el-collapse-transition");
  return (0, import_vue578.withDirectives)(((0, import_vue578.openBlock)(), (0, import_vue578.createElementBlock)("div", {
    ref: "node$",
    class: (0, import_vue578.normalizeClass)([
      _ctx.ns.b("node"),
      _ctx.ns.is("expanded", _ctx.expanded),
      _ctx.ns.is("current", _ctx.node.isCurrent),
      _ctx.ns.is("hidden", !_ctx.node.visible),
      _ctx.ns.is("focusable", !_ctx.node.disabled),
      _ctx.ns.is("checked", !_ctx.node.disabled && _ctx.node.checked),
      _ctx.getNodeClass(_ctx.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": _ctx.expanded,
    "aria-disabled": _ctx.node.disabled,
    "aria-checked": _ctx.node.checked,
    draggable: _ctx.tree.props.draggable,
    "data-key": _ctx.getNodeKey(_ctx.node),
    onClick: _cache[1] || (_cache[1] = (0, import_vue578.withModifiers)((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args)),
    onDragstart: _cache[3] || (_cache[3] = (0, import_vue578.withModifiers)((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[4] || (_cache[4] = (0, import_vue578.withModifiers)((...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args), ["stop"])),
    onDragend: _cache[5] || (_cache[5] = (0, import_vue578.withModifiers)((...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args), ["stop"])),
    onDrop: _cache[6] || (_cache[6] = (0, import_vue578.withModifiers)((...args) => _ctx.handleDrop && _ctx.handleDrop(...args), ["stop"]))
  }, [
    (0, import_vue578.createElementVNode)("div", {
      class: (0, import_vue578.normalizeClass)(_ctx.ns.be("node", "content")),
      style: (0, import_vue578.normalizeStyle)({ paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
    }, [
      _ctx.tree.props.icon || _ctx.CaretRight ? ((0, import_vue578.openBlock)(), (0, import_vue578.createBlock)(_component_el_icon, {
        key: 0,
        class: (0, import_vue578.normalizeClass)([
          _ctx.ns.be("node", "expand-icon"),
          _ctx.ns.is("leaf", _ctx.node.isLeaf),
          {
            expanded: !_ctx.node.isLeaf && _ctx.expanded
          }
        ]),
        onClick: (0, import_vue578.withModifiers)(_ctx.handleExpandIconClick, ["stop"])
      }, {
        default: (0, import_vue578.withCtx)(() => [
          ((0, import_vue578.openBlock)(), (0, import_vue578.createBlock)((0, import_vue578.resolveDynamicComponent)(_ctx.tree.props.icon || _ctx.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : (0, import_vue578.createCommentVNode)("v-if", true),
      _ctx.showCheckbox ? ((0, import_vue578.openBlock)(), (0, import_vue578.createBlock)(_component_el_checkbox, {
        key: 1,
        "model-value": _ctx.node.checked,
        indeterminate: _ctx.node.indeterminate,
        disabled: !!_ctx.node.disabled,
        onClick: _cache[0] || (_cache[0] = (0, import_vue578.withModifiers)(() => {
        }, ["stop"])),
        onChange: _ctx.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : (0, import_vue578.createCommentVNode)("v-if", true),
      _ctx.node.loading ? ((0, import_vue578.openBlock)(), (0, import_vue578.createBlock)(_component_el_icon, {
        key: 2,
        class: (0, import_vue578.normalizeClass)([_ctx.ns.be("node", "loading-icon"), _ctx.ns.is("loading")])
      }, {
        default: (0, import_vue578.withCtx)(() => [
          (0, import_vue578.createVNode)(_component_loading)
        ]),
        _: 1
      }, 8, ["class"])) : (0, import_vue578.createCommentVNode)("v-if", true),
      (0, import_vue578.createVNode)(_component_node_content, {
        node: _ctx.node,
        "render-content": _ctx.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    (0, import_vue578.createVNode)(_component_el_collapse_transition, null, {
      default: (0, import_vue578.withCtx)(() => [
        !_ctx.renderAfterExpand || _ctx.childNodeRendered ? (0, import_vue578.withDirectives)(((0, import_vue578.openBlock)(), (0, import_vue578.createElementBlock)("div", {
          key: 0,
          class: (0, import_vue578.normalizeClass)(_ctx.ns.be("node", "children")),
          role: "group",
          "aria-expanded": _ctx.expanded
        }, [
          ((0, import_vue578.openBlock)(true), (0, import_vue578.createElementBlock)(import_vue578.Fragment, null, (0, import_vue578.renderList)(_ctx.node.childNodes, (child) => {
            return (0, import_vue578.openBlock)(), (0, import_vue578.createBlock)(_component_el_tree_node, {
              key: _ctx.getNodeKey(child),
              "render-content": _ctx.renderContent,
              "render-after-expand": _ctx.renderAfterExpand,
              "show-checkbox": _ctx.showCheckbox,
              node: child,
              accordion: _ctx.accordion,
              props: _ctx.props,
              onNodeExpand: _ctx.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]);
          }), 128))
        ], 10, _hoisted_253)), [
          [import_vue578.vShow, _ctx.expanded]
        ]) : (0, import_vue578.createCommentVNode)("v-if", true)
      ]),
      _: 1
    })
  ], 42, _hoisted_184)), [
    [import_vue578.vShow, _ctx.node.visible]
  ]);
}
var ElTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main135, [["render", _sfc_render40], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/model/useKeydown.mjs
var import_vue579 = require("vue");
function useKeydown({ el$ }, store) {
  const ns2 = useNamespace("tree");
  const treeItems = (0, import_vue579.shallowRef)([]);
  const checkboxItems = (0, import_vue579.shallowRef)([]);
  (0, import_vue579.onMounted)(() => {
    initTabIndex();
  });
  (0, import_vue579.onUpdated)(() => {
    treeItems.value = Array.from(el$.value.querySelectorAll("[role=treeitem]"));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
  });
  (0, import_vue579.watch)(checkboxItems, (val) => {
    val.forEach((checkbox) => {
      checkbox.setAttribute("tabindex", "-1");
    });
  });
  const handleKeydown = (ev) => {
    const currentItem = ev.target;
    if (!currentItem.className.includes(ns2.b("node")))
      return;
    const code = ev.code;
    treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns2.is("focusable")}[role=treeitem]`));
    const currentIndex = treeItems.value.indexOf(currentItem);
    let nextIndex;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      ev.preventDefault();
      if (code === EVENT_CODE.up) {
        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;
        const startIndex = nextIndex;
        while (true) {
          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex--;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex < 0) {
            nextIndex = treeItems.value.length - 1;
          }
        }
      } else {
        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;
        const startIndex = nextIndex;
        while (true) {
          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex++;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex >= treeItems.value.length) {
            nextIndex = 0;
          }
        }
      }
      nextIndex !== -1 && treeItems.value[nextIndex].focus();
    }
    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {
      ev.preventDefault();
      currentItem.click();
    }
    const hasInput = currentItem.querySelector('[type="checkbox"]');
    if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code) && hasInput) {
      ev.preventDefault();
      hasInput.click();
    }
  };
  useEventListener(el$, "keydown", handleKeydown);
  const initTabIndex = () => {
    var _a2;
    treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns2.is("focusable")}[role=treeitem]`));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
    const checkedItem = el$.value.querySelectorAll(`.${ns2.is("checked")}[role=treeitem]`);
    if (checkedItem.length) {
      checkedItem[0].setAttribute("tabindex", "0");
      return;
    }
    (_a2 = treeItems.value[0]) == null ? void 0 : _a2.setAttribute("tabindex", "0");
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/src/tree.mjs
var _sfc_main136 = (0, import_vue580.defineComponent)({
  name: "ElTree",
  components: { ElTreeNode },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: iconPropType
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(props, ctx) {
    const { t } = useLocale();
    const ns2 = useNamespace("tree");
    const store = (0, import_vue580.ref)(new TreeStore({
      key: props.nodeKey,
      data: props.data,
      lazy: props.lazy,
      props: props.props,
      load: props.load,
      currentNodeKey: props.currentNodeKey,
      checkStrictly: props.checkStrictly,
      checkDescendants: props.checkDescendants,
      defaultCheckedKeys: props.defaultCheckedKeys,
      defaultExpandedKeys: props.defaultExpandedKeys,
      autoExpandParent: props.autoExpandParent,
      defaultExpandAll: props.defaultExpandAll,
      filterNodeMethod: props.filterNodeMethod
    }));
    store.value.initialize();
    const root2 = (0, import_vue580.ref)(store.value.root);
    const currentNode = (0, import_vue580.ref)(null);
    const el$ = (0, import_vue580.ref)(null);
    const dropIndicator$ = (0, import_vue580.ref)(null);
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
    const { dragState } = useDragNodeHandler({
      props,
      ctx,
      el$,
      dropIndicator$,
      store
    });
    useKeydown({ el$ }, store);
    const isEmpty2 = (0, import_vue580.computed)(() => {
      const { childNodes } = root2.value;
      return !childNodes || childNodes.length === 0 || childNodes.every(({ visible }) => !visible);
    });
    (0, import_vue580.watch)(() => props.currentNodeKey, (newVal) => {
      store.value.setCurrentNodeKey(newVal);
    });
    (0, import_vue580.watch)(() => props.defaultCheckedKeys, (newVal) => {
      store.value.setDefaultCheckedKey(newVal);
    });
    (0, import_vue580.watch)(() => props.defaultExpandedKeys, (newVal) => {
      store.value.setDefaultExpandedKeys(newVal);
    });
    (0, import_vue580.watch)(() => props.data, (newVal) => {
      store.value.setData(newVal);
    }, { deep: true });
    (0, import_vue580.watch)(() => props.checkStrictly, (newVal) => {
      store.value.checkStrictly = newVal;
    });
    const filter = (value) => {
      if (!props.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      store.value.filter(value);
    };
    const getNodeKey$1 = (node) => {
      return getNodeKey(props.nodeKey, node.data);
    };
    const getNodePath = (data) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const node = store.value.getNode(data);
      if (!node)
        return [];
      const path = [node.data];
      let parent = node.parent;
      while (parent && parent !== root2.value) {
        path.push(parent.data);
        parent = parent.parent;
      }
      return path.reverse();
    };
    const getCheckedNodes = (leafOnly, includeHalfChecked) => {
      return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
    };
    const getCheckedKeys = (leafOnly) => {
      return store.value.getCheckedKeys(leafOnly);
    };
    const getCurrentNode = () => {
      const currentNode2 = store.value.getCurrentNode();
      return currentNode2 ? currentNode2.data : null;
    };
    const getCurrentKey = () => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const currentNode2 = getCurrentNode();
      return currentNode2 ? currentNode2[props.nodeKey] : null;
    };
    const setCheckedNodes = (nodes, leafOnly) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      store.value.setCheckedNodes(nodes, leafOnly);
    };
    const setCheckedKeys = (keys2, leafOnly) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      store.value.setCheckedKeys(keys2, leafOnly);
    };
    const setChecked = (data, checked, deep) => {
      store.value.setChecked(data, checked, deep);
    };
    const getHalfCheckedNodes = () => {
      return store.value.getHalfCheckedNodes();
    };
    const getHalfCheckedKeys = () => {
      return store.value.getHalfCheckedKeys();
    };
    const setCurrentNode = (node, shouldAutoExpandParent = true) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      handleCurrentChange(store, ctx.emit, () => store.value.setUserCurrentNode(node, shouldAutoExpandParent));
    };
    const setCurrentKey = (key, shouldAutoExpandParent = true) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      handleCurrentChange(store, ctx.emit, () => store.value.setCurrentNodeKey(key, shouldAutoExpandParent));
    };
    const getNode = (data) => {
      return store.value.getNode(data);
    };
    const remove = (data) => {
      store.value.remove(data);
    };
    const append = (data, parentNode) => {
      store.value.append(data, parentNode);
    };
    const insertBefore = (data, refNode) => {
      store.value.insertBefore(data, refNode);
    };
    const insertAfter = (data, refNode) => {
      store.value.insertAfter(data, refNode);
    };
    const handleNodeExpand = (nodeData, node, instance) => {
      broadcastExpanded(node);
      ctx.emit("node-expand", nodeData, node, instance);
    };
    const updateKeyChildren = (key, data) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      store.value.updateChildren(key, data);
    };
    (0, import_vue580.provide)("RootTree", {
      ctx,
      props,
      store,
      root: root2,
      currentNode,
      instance: (0, import_vue580.getCurrentInstance)()
    });
    (0, import_vue580.provide)(formItemContextKey, void 0);
    return {
      ns: ns2,
      store,
      root: root2,
      currentNode,
      dragState,
      el$,
      dropIndicator$,
      isEmpty: isEmpty2,
      filter,
      getNodeKey: getNodeKey$1,
      getNodePath,
      getCheckedNodes,
      getCheckedKeys,
      getCurrentNode,
      getCurrentKey,
      setCheckedNodes,
      setCheckedKeys,
      setChecked,
      getHalfCheckedNodes,
      getHalfCheckedKeys,
      setCurrentNode,
      setCurrentKey,
      t,
      getNode,
      remove,
      append,
      insertBefore,
      insertAfter,
      handleNodeExpand,
      updateKeyChildren
    };
  }
});
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_el_tree_node = (0, import_vue580.resolveComponent)("el-tree-node");
  return (0, import_vue580.openBlock)(), (0, import_vue580.createElementBlock)("div", {
    ref: "el$",
    class: (0, import_vue580.normalizeClass)([
      _ctx.ns.b(),
      _ctx.ns.is("dragging", !!_ctx.dragState.draggingNode),
      _ctx.ns.is("drop-not-allow", !_ctx.dragState.allowDrop),
      _ctx.ns.is("drop-inner", _ctx.dragState.dropType === "inner"),
      { [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent }
    ]),
    role: "tree"
  }, [
    ((0, import_vue580.openBlock)(true), (0, import_vue580.createElementBlock)(import_vue580.Fragment, null, (0, import_vue580.renderList)(_ctx.root.childNodes, (child) => {
      return (0, import_vue580.openBlock)(), (0, import_vue580.createBlock)(_component_el_tree_node, {
        key: _ctx.getNodeKey(child),
        node: child,
        props: _ctx.props,
        accordion: _ctx.accordion,
        "render-after-expand": _ctx.renderAfterExpand,
        "show-checkbox": _ctx.showCheckbox,
        "render-content": _ctx.renderContent,
        onNodeExpand: _ctx.handleNodeExpand
      }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
    }), 128)),
    _ctx.isEmpty ? ((0, import_vue580.openBlock)(), (0, import_vue580.createElementBlock)("div", {
      key: 0,
      class: (0, import_vue580.normalizeClass)(_ctx.ns.e("empty-block"))
    }, [
      (0, import_vue580.createElementVNode)("span", {
        class: (0, import_vue580.normalizeClass)(_ctx.ns.e("empty-text"))
      }, (0, import_vue580.toDisplayString)((_a2 = _ctx.emptyText) != null ? _a2 : _ctx.t("el.tree.emptyText")), 3)
    ], 2)) : (0, import_vue580.createCommentVNode)("v-if", true),
    (0, import_vue580.withDirectives)((0, import_vue580.createElementVNode)("div", {
      ref: "dropIndicator$",
      class: (0, import_vue580.normalizeClass)(_ctx.ns.e("drop-indicator"))
    }, null, 2), [
      [import_vue580.vShow, _ctx.dragState.showDropIndicator]
    ])
  ], 2);
}
var Tree = /* @__PURE__ */ _export_sfc(_sfc_main136, [["render", _sfc_render41], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree/index.mjs
Tree.install = (app) => {
  app.component(Tree.name, Tree);
};
var _Tree = Tree;
var ElTree = _Tree;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/tree-select.mjs
var import_vue585 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/select.mjs
var import_vue581 = require("vue");
var useSelect3 = (props, { attrs }, {
  tree,
  key
}) => {
  const ns2 = useNamespace("tree-select");
  const result = {
    ...pick_default((0, import_vue581.toRefs)(props), Object.keys(ElSelect.props)),
    ...attrs,
    valueKey: key,
    popperClass: (0, import_vue581.computed)(() => {
      const classes = [ns2.e("popper")];
      if (props.popperClass)
        classes.push(props.popperClass);
      return classes.join(" ");
    }),
    filterMethod: (keyword = "") => {
      if (props.filterMethod)
        props.filterMethod(keyword);
      (0, import_vue581.nextTick)(() => {
        var _a2;
        (_a2 = tree.value) == null ? void 0 : _a2.filter(keyword);
      });
    },
    onVisibleChange: (visible) => {
      var _a2;
      (_a2 = attrs.onVisibleChange) == null ? void 0 : _a2.call(attrs, visible);
      if (props.filterable && visible) {
        result.filterMethod();
      }
    }
  };
  return result;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/tree.mjs
var import_vue583 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/tree-select-option.mjs
var import_vue582 = require("vue");
var component = (0, import_vue582.defineComponent)({
  extends: ElOption,
  setup(props, ctx) {
    const result = ElOption.setup(props, ctx);
    delete result.selectOptionClick;
    const vm = (0, import_vue582.getCurrentInstance)().proxy;
    (0, import_vue582.nextTick)(() => {
      if (!result.select.cachedOptions.get(vm.value)) {
        result.select.onOptionCreate(vm);
      }
    });
    return result;
  },
  methods: {
    selectOptionClick() {
      this.$el.parentElement.click();
    }
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/utils.mjs
function isValidValue2(val) {
  return val || val === 0;
}
function isValidArray(val) {
  return Array.isArray(val) && val.length;
}
function toValidArray(val) {
  return Array.isArray(val) ? val : isValidValue2(val) ? [val] : [];
}
function treeFind(treeData, findCallback, getChildren, resultCallback, parent) {
  for (let i = 0; i < treeData.length; i++) {
    const data = treeData[i];
    if (findCallback(data, i, treeData, parent)) {
      return resultCallback ? resultCallback(data, i, treeData, parent) : data;
    } else {
      const children = getChildren(data);
      if (isValidArray(children)) {
        const find2 = treeFind(children, findCallback, getChildren, resultCallback, data);
        if (find2)
          return find2;
      }
    }
  }
}
function treeEach(treeData, callback, getChildren, parent) {
  for (let i = 0; i < treeData.length; i++) {
    const data = treeData[i];
    callback(data, i, treeData, parent);
    const children = getChildren(data);
    if (isValidArray(children)) {
      treeEach(children, callback, getChildren, data);
    }
  }
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/tree.mjs
var import_shared105 = require("@vue/shared");
var useTree2 = (props, { attrs, slots, emit }, {
  select,
  tree,
  key
}) => {
  (0, import_vue583.watch)(() => props.modelValue, () => {
    if (props.showCheckbox) {
      (0, import_vue583.nextTick)(() => {
        const treeInstance = tree.value;
        if (treeInstance && !isEqual_default(treeInstance.getCheckedKeys(), toValidArray(props.modelValue))) {
          treeInstance.setCheckedKeys(toValidArray(props.modelValue));
        }
      });
    }
  }, {
    immediate: true,
    deep: true
  });
  const propsMap = (0, import_vue583.computed)(() => ({
    value: key.value,
    ...props.props
  }));
  const getNodeValByProp = (prop, data) => {
    var _a2;
    const propVal = propsMap.value[prop];
    if ((0, import_shared105.isFunction)(propVal)) {
      return propVal(data, (_a2 = tree.value) == null ? void 0 : _a2.getNode(getNodeValByProp("value", data)));
    } else {
      return data[propVal];
    }
  };
  const defaultExpandedParentKeys = toValidArray(props.modelValue).map((value) => {
    return treeFind(props.data || [], (data) => getNodeValByProp("value", data) === value, (data) => getNodeValByProp("children", data), (data, index2, array4, parent) => parent && getNodeValByProp("value", parent));
  }).filter((item) => isValidValue2(item));
  const cacheOptions = (0, import_vue583.computed)(() => {
    if (!props.renderAfterExpand && !props.lazy)
      return [];
    const options = [];
    treeEach(props.data.concat(props.cacheData), (node) => {
      const value = getNodeValByProp("value", node);
      options.push({
        value,
        currentLabel: getNodeValByProp("label", node),
        isDisabled: getNodeValByProp("disabled", node)
      });
    }, (data) => getNodeValByProp("children", data));
    return options;
  });
  return {
    ...pick_default((0, import_vue583.toRefs)(props), Object.keys(_Tree.props)),
    ...attrs,
    nodeKey: key,
    expandOnClickNode: (0, import_vue583.computed)(() => {
      return !props.checkStrictly && props.expandOnClickNode;
    }),
    defaultExpandedKeys: (0, import_vue583.computed)(() => {
      return props.defaultExpandedKeys ? props.defaultExpandedKeys.concat(defaultExpandedParentKeys) : defaultExpandedParentKeys;
    }),
    renderContent: (h29, { node, data, store }) => {
      return h29(component, {
        value: getNodeValByProp("value", data),
        label: getNodeValByProp("label", data),
        disabled: getNodeValByProp("disabled", data)
      }, props.renderContent ? () => props.renderContent(h29, { node, data, store }) : slots.default ? () => slots.default({ node, data, store }) : void 0);
    },
    filterNodeMethod: (value, data, node) => {
      var _a2;
      if (props.filterNodeMethod)
        return props.filterNodeMethod(value, data, node);
      if (!value)
        return true;
      return (_a2 = getNodeValByProp("label", data)) == null ? void 0 : _a2.includes(value);
    },
    onNodeClick: (data, node, e) => {
      var _a2, _b, _c;
      (_a2 = attrs.onNodeClick) == null ? void 0 : _a2.call(attrs, data, node, e);
      if (props.showCheckbox && props.checkOnClickNode)
        return;
      if (!props.showCheckbox && (props.checkStrictly || node.isLeaf)) {
        if (!getNodeValByProp("disabled", data)) {
          const option2 = (_b = select.value) == null ? void 0 : _b.options.get(getNodeValByProp("value", data));
          (_c = select.value) == null ? void 0 : _c.handleOptionSelect(option2, true);
        }
      } else if (props.expandOnClickNode) {
        e.proxy.handleExpandIconClick();
      }
    },
    onCheck: (data, params) => {
      var _a2;
      (_a2 = attrs.onCheck) == null ? void 0 : _a2.call(attrs, data, params);
      const dataValue = getNodeValByProp("value", data);
      if (props.checkStrictly) {
        emit(UPDATE_MODEL_EVENT, props.multiple ? params.checkedKeys : params.checkedKeys.includes(dataValue) ? dataValue : void 0);
      } else {
        if (props.multiple) {
          emit(UPDATE_MODEL_EVENT, tree.value.getCheckedKeys(true));
        } else {
          const firstLeaf = treeFind([data], (data2) => !isValidArray(getNodeValByProp("children", data2)) && !getNodeValByProp("disabled", data2), (data2) => getNodeValByProp("children", data2));
          const firstLeafKey = firstLeaf ? getNodeValByProp("value", firstLeaf) : void 0;
          const hasCheckedChild = isValidValue2(props.modelValue) && !!treeFind([data], (data2) => getNodeValByProp("value", data2) === props.modelValue, (data2) => getNodeValByProp("children", data2));
          emit(UPDATE_MODEL_EVENT, firstLeafKey === props.modelValue || hasCheckedChild ? void 0 : firstLeafKey);
        }
      }
    },
    cacheOptions
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/cache-options.mjs
var import_vue584 = require("vue");
var CacheOptions = (0, import_vue584.defineComponent)({
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const select = (0, import_vue584.inject)(selectKey);
    (0, import_vue584.watch)(() => props.data, () => {
      props.data.forEach((item) => {
        if (!select.cachedOptions.has(item.value)) {
          select.cachedOptions.set(item.value, item);
        }
      });
      select.setSelected();
    }, { immediate: true, deep: true });
    return () => void 0;
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/src/tree-select.mjs
var _sfc_main137 = (0, import_vue585.defineComponent)({
  name: "ElTreeSelect",
  inheritAttrs: false,
  props: {
    ...ElSelect.props,
    ..._Tree.props,
    cacheData: {
      type: Array,
      default: () => []
    }
  },
  setup(props, context) {
    const { slots, expose } = context;
    const select = (0, import_vue585.ref)();
    const tree = (0, import_vue585.ref)();
    const key = (0, import_vue585.computed)(() => props.nodeKey || props.valueKey || "value");
    const selectProps = useSelect3(props, context, { select, tree, key });
    const { cacheOptions, ...treeProps2 } = useTree2(props, context, {
      select,
      tree,
      key
    });
    const methods = (0, import_vue585.reactive)({});
    expose(methods);
    (0, import_vue585.onMounted)(() => {
      Object.assign(methods, {
        ...pick_default(tree.value, [
          "filter",
          "updateKeyChildren",
          "getCheckedNodes",
          "setCheckedNodes",
          "getCheckedKeys",
          "setCheckedKeys",
          "setChecked",
          "getHalfCheckedNodes",
          "getHalfCheckedKeys",
          "getCurrentKey",
          "getCurrentNode",
          "setCurrentKey",
          "setCurrentNode",
          "getNode",
          "remove",
          "append",
          "insertBefore",
          "insertAfter"
        ]),
        ...pick_default(select.value, ["focus", "blur"])
      });
    });
    return () => (0, import_vue585.h)(ElSelect, (0, import_vue585.reactive)({
      ...selectProps,
      ref: (ref210) => select.value = ref210
    }), {
      ...slots,
      default: () => [
        (0, import_vue585.h)(CacheOptions, { data: cacheOptions.value }),
        (0, import_vue585.h)(_Tree, (0, import_vue585.reactive)({
          ...treeProps2,
          ref: (ref210) => tree.value = ref210
        }))
      ]
    });
  }
});
var TreeSelect = /* @__PURE__ */ _export_sfc(_sfc_main137, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-select/index.mjs
TreeSelect.install = (app) => {
  app.component(TreeSelect.name, TreeSelect);
};
var _TreeSelect = TreeSelect;
var ElTreeSelect = _TreeSelect;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/tree.mjs
var import_vue591 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/composables/useTree.mjs
var import_vue588 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/virtual-tree.mjs
var ROOT_TREE_INJECTION_KEY = Symbol();
var EMPTY_NODE = {
  key: -1,
  level: -1,
  data: {}
};
var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
  TreeOptionsEnum2["KEY"] = "id";
  TreeOptionsEnum2["LABEL"] = "label";
  TreeOptionsEnum2["CHILDREN"] = "children";
  TreeOptionsEnum2["DISABLED"] = "disabled";
  return TreeOptionsEnum2;
})(TreeOptionsEnum || {});
var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
  SetOperationEnum2["ADD"] = "add";
  SetOperationEnum2["DELETE"] = "delete";
  return SetOperationEnum2;
})(SetOperationEnum || {});
var treeProps = buildProps({
  data: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: definePropType(Object),
    default: () => mutable({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id"
      /* KEY */
    })
  },
  highlightCurrent: {
    type: Boolean,
    default: false
  },
  showCheckbox: {
    type: Boolean,
    default: false
  },
  defaultCheckedKeys: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  checkStrictly: {
    type: Boolean,
    default: false
  },
  defaultExpandedKeys: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  indent: {
    type: Number,
    default: 16
  },
  icon: {
    type: iconPropType
  },
  expandOnClickNode: {
    type: Boolean,
    default: true
  },
  checkOnClickNode: {
    type: Boolean,
    default: false
  },
  currentNodeKey: {
    type: definePropType([String, Number])
  },
  accordion: {
    type: Boolean,
    default: false
  },
  filterMethod: {
    type: definePropType(Function)
  },
  perfMode: {
    type: Boolean,
    default: true
  }
});
var treeNodeProps = buildProps({
  node: {
    type: definePropType(Object),
    default: () => mutable(EMPTY_NODE)
  },
  expanded: {
    type: Boolean,
    default: false
  },
  checked: {
    type: Boolean,
    default: false
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  showCheckbox: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  current: {
    type: Boolean,
    default: false
  },
  hiddenExpandIcon: {
    type: Boolean,
    default: false
  }
});
var treeNodeContentProps = buildProps({
  node: {
    type: definePropType(Object),
    required: true
  }
});
var NODE_CLICK = "node-click";
var NODE_EXPAND = "node-expand";
var NODE_COLLAPSE = "node-collapse";
var CURRENT_CHANGE = "current-change";
var NODE_CHECK = "check";
var NODE_CHECK_CHANGE = "check-change";
var NODE_CONTEXTMENU = "node-contextmenu";
var treeEmits = {
  [NODE_CLICK]: (data, node, e) => data && node && e,
  [NODE_EXPAND]: (data, node) => data && node,
  [NODE_COLLAPSE]: (data, node) => data && node,
  [CURRENT_CHANGE]: (data, node) => data && node,
  [NODE_CHECK]: (data, checkedInfo) => data && checkedInfo,
  [NODE_CHECK_CHANGE]: (data, checked) => data && typeof checked === "boolean",
  [NODE_CONTEXTMENU]: (event, data, node) => event && data && node
};
var treeNodeEmits = {
  click: (node, e) => !!(node && e),
  toggle: (node) => !!node,
  check: (node, checked) => node && typeof checked === "boolean"
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/composables/useCheck.mjs
var import_vue586 = require("vue");
function useCheck2(props, tree) {
  const checkedKeys = (0, import_vue586.ref)(/* @__PURE__ */ new Set());
  const indeterminateKeys = (0, import_vue586.ref)(/* @__PURE__ */ new Set());
  const { emit } = (0, import_vue586.getCurrentInstance)();
  (0, import_vue586.watch)([() => tree.value, () => props.defaultCheckedKeys], () => {
    return (0, import_vue586.nextTick)(() => {
      _setCheckedKeys(props.defaultCheckedKeys);
    });
  }, {
    immediate: true
  });
  const updateCheckedKeys = () => {
    if (!tree.value || !props.showCheckbox || props.checkStrictly) {
      return;
    }
    const { levelTreeNodeMap, maxLevel } = tree.value;
    const checkedKeySet = checkedKeys.value;
    const indeterminateKeySet = /* @__PURE__ */ new Set();
    for (let level = maxLevel - 1; level >= 1; --level) {
      const nodes = levelTreeNodeMap.get(level);
      if (!nodes)
        continue;
      nodes.forEach((node) => {
        const children = node.children;
        if (children) {
          let allChecked = true;
          let hasChecked = false;
          for (const childNode of children) {
            const key = childNode.key;
            if (checkedKeySet.has(key)) {
              hasChecked = true;
            } else if (indeterminateKeySet.has(key)) {
              allChecked = false;
              hasChecked = true;
              break;
            } else {
              allChecked = false;
            }
          }
          if (allChecked) {
            checkedKeySet.add(node.key);
          } else if (hasChecked) {
            indeterminateKeySet.add(node.key);
            checkedKeySet.delete(node.key);
          } else {
            checkedKeySet.delete(node.key);
            indeterminateKeySet.delete(node.key);
          }
        }
      });
    }
    indeterminateKeys.value = indeterminateKeySet;
  };
  const isChecked = (node) => checkedKeys.value.has(node.key);
  const isIndeterminate = (node) => indeterminateKeys.value.has(node.key);
  const toggleCheckbox = (node, isChecked2, nodeClick = true) => {
    const checkedKeySet = checkedKeys.value;
    const toggle = (node2, checked) => {
      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);
      const children = node2.children;
      if (!props.checkStrictly && children) {
        children.forEach((childNode) => {
          if (!childNode.disabled) {
            toggle(childNode, checked);
          }
        });
      }
    };
    toggle(node, isChecked2);
    updateCheckedKeys();
    if (nodeClick) {
      afterNodeCheck(node, isChecked2);
    }
  };
  const afterNodeCheck = (node, checked) => {
    const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
    emit(NODE_CHECK, node.data, {
      checkedKeys: checkedKeys2,
      checkedNodes,
      halfCheckedKeys,
      halfCheckedNodes
    });
    emit(NODE_CHECK_CHANGE, node.data, checked);
  };
  function getCheckedKeys(leafOnly = false) {
    return getChecked(leafOnly).checkedKeys;
  }
  function getCheckedNodes(leafOnly = false) {
    return getChecked(leafOnly).checkedNodes;
  }
  function getHalfCheckedKeys() {
    return getHalfChecked().halfCheckedKeys;
  }
  function getHalfCheckedNodes() {
    return getHalfChecked().halfCheckedNodes;
  }
  function getChecked(leafOnly = false) {
    const checkedNodes = [];
    const keys2 = [];
    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
      const { treeNodeMap } = tree.value;
      checkedKeys.value.forEach((key) => {
        const node = treeNodeMap.get(key);
        if (node && (!leafOnly || leafOnly && node.isLeaf)) {
          keys2.push(key);
          checkedNodes.push(node.data);
        }
      });
    }
    return {
      checkedKeys: keys2,
      checkedNodes
    };
  }
  function getHalfChecked() {
    const halfCheckedNodes = [];
    const halfCheckedKeys = [];
    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
      const { treeNodeMap } = tree.value;
      indeterminateKeys.value.forEach((key) => {
        const node = treeNodeMap.get(key);
        if (node) {
          halfCheckedKeys.push(key);
          halfCheckedNodes.push(node.data);
        }
      });
    }
    return {
      halfCheckedNodes,
      halfCheckedKeys
    };
  }
  function setCheckedKeys(keys2) {
    checkedKeys.value.clear();
    indeterminateKeys.value.clear();
    _setCheckedKeys(keys2);
  }
  function setChecked(key, isChecked2) {
    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
      const node = tree.value.treeNodeMap.get(key);
      if (node) {
        toggleCheckbox(node, isChecked2, false);
      }
    }
  }
  function _setCheckedKeys(keys2) {
    if (tree == null ? void 0 : tree.value) {
      const { treeNodeMap } = tree.value;
      if (props.showCheckbox && treeNodeMap && keys2) {
        for (const key of keys2) {
          const node = treeNodeMap.get(key);
          if (node && !isChecked(node)) {
            toggleCheckbox(node, true, false);
          }
        }
      }
    }
  }
  return {
    updateCheckedKeys,
    toggleCheckbox,
    isChecked,
    isIndeterminate,
    getCheckedKeys,
    getCheckedNodes,
    getHalfCheckedKeys,
    getHalfCheckedNodes,
    setChecked,
    setCheckedKeys
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/composables/useFilter.mjs
var import_vue587 = require("vue");
var import_shared106 = require("@vue/shared");
function useFilter(props, tree) {
  const hiddenNodeKeySet = (0, import_vue587.ref)(/* @__PURE__ */ new Set([]));
  const hiddenExpandIconKeySet = (0, import_vue587.ref)(/* @__PURE__ */ new Set([]));
  const filterable = (0, import_vue587.computed)(() => {
    return (0, import_shared106.isFunction)(props.filterMethod);
  });
  function doFilter(query) {
    var _a2;
    if (!filterable.value) {
      return;
    }
    const expandKeySet = /* @__PURE__ */ new Set();
    const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
    const hiddenKeys = hiddenNodeKeySet.value;
    const family = [];
    const nodes = ((_a2 = tree.value) == null ? void 0 : _a2.treeNodes) || [];
    const filter = props.filterMethod;
    hiddenKeys.clear();
    function traverse(nodes2) {
      nodes2.forEach((node) => {
        family.push(node);
        if (filter == null ? void 0 : filter(query, node.data)) {
          family.forEach((member) => {
            expandKeySet.add(member.key);
          });
        } else if (node.isLeaf) {
          hiddenKeys.add(node.key);
        }
        const children = node.children;
        if (children) {
          traverse(children);
        }
        if (!node.isLeaf) {
          if (!expandKeySet.has(node.key)) {
            hiddenKeys.add(node.key);
          } else if (children) {
            let allHidden = true;
            for (const childNode of children) {
              if (!hiddenKeys.has(childNode.key)) {
                allHidden = false;
                break;
              }
            }
            if (allHidden) {
              hiddenExpandIconKeys.add(node.key);
            } else {
              hiddenExpandIconKeys.delete(node.key);
            }
          }
        }
        family.pop();
      });
    }
    traverse(nodes);
    return expandKeySet;
  }
  function isForceHiddenExpandIcon(node) {
    return hiddenExpandIconKeySet.value.has(node.key);
  }
  return {
    hiddenExpandIconKeySet,
    hiddenNodeKeySet,
    doFilter,
    isForceHiddenExpandIcon
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/composables/useTree.mjs
var import_shared107 = require("@vue/shared");
function useTree3(props, emit) {
  const expandedKeySet = (0, import_vue588.ref)(new Set(props.defaultExpandedKeys));
  const currentKey = (0, import_vue588.ref)();
  const tree = (0, import_vue588.shallowRef)();
  (0, import_vue588.watch)(() => props.currentNodeKey, (key) => {
    currentKey.value = key;
  }, {
    immediate: true
  });
  (0, import_vue588.watch)(() => props.data, (data) => {
    setData(data);
  }, {
    immediate: true
  });
  const {
    isIndeterminate,
    isChecked,
    toggleCheckbox,
    getCheckedKeys,
    getCheckedNodes,
    getHalfCheckedKeys,
    getHalfCheckedNodes,
    setChecked,
    setCheckedKeys
  } = useCheck2(props, tree);
  const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(props, tree);
  const valueKey = (0, import_vue588.computed)(() => {
    var _a2;
    return ((_a2 = props.props) == null ? void 0 : _a2.value) || TreeOptionsEnum.KEY;
  });
  const childrenKey = (0, import_vue588.computed)(() => {
    var _a2;
    return ((_a2 = props.props) == null ? void 0 : _a2.children) || TreeOptionsEnum.CHILDREN;
  });
  const disabledKey = (0, import_vue588.computed)(() => {
    var _a2;
    return ((_a2 = props.props) == null ? void 0 : _a2.disabled) || TreeOptionsEnum.DISABLED;
  });
  const labelKey = (0, import_vue588.computed)(() => {
    var _a2;
    return ((_a2 = props.props) == null ? void 0 : _a2.label) || TreeOptionsEnum.LABEL;
  });
  const flattenTree = (0, import_vue588.computed)(() => {
    const expandedKeys = expandedKeySet.value;
    const hiddenKeys = hiddenNodeKeySet.value;
    const flattenNodes = [];
    const nodes = tree.value && tree.value.treeNodes || [];
    function traverse() {
      const stack = [];
      for (let i = nodes.length - 1; i >= 0; --i) {
        stack.push(nodes[i]);
      }
      while (stack.length) {
        const node = stack.pop();
        if (!node)
          continue;
        if (!hiddenKeys.has(node.key)) {
          flattenNodes.push(node);
        }
        if (expandedKeys.has(node.key)) {
          const children = node.children;
          if (children) {
            const length = children.length;
            for (let i = length - 1; i >= 0; --i) {
              stack.push(children[i]);
            }
          }
        }
      }
    }
    traverse();
    return flattenNodes;
  });
  const isNotEmpty = (0, import_vue588.computed)(() => {
    return flattenTree.value.length > 0;
  });
  function createTree(data) {
    const treeNodeMap = /* @__PURE__ */ new Map();
    const levelTreeNodeMap = /* @__PURE__ */ new Map();
    let maxLevel = 1;
    function traverse(nodes, level = 1, parent = void 0) {
      var _a2;
      const siblings = [];
      for (const rawNode of nodes) {
        const value = getKey(rawNode);
        const node = {
          level,
          key: value,
          data: rawNode
        };
        node.label = getLabel(rawNode);
        node.parent = parent;
        const children = getChildren(rawNode);
        node.disabled = getDisabled(rawNode);
        node.isLeaf = !children || children.length === 0;
        if (children && children.length) {
          node.children = traverse(children, level + 1, node);
        }
        siblings.push(node);
        treeNodeMap.set(value, node);
        if (!levelTreeNodeMap.has(level)) {
          levelTreeNodeMap.set(level, []);
        }
        (_a2 = levelTreeNodeMap.get(level)) == null ? void 0 : _a2.push(node);
      }
      if (level > maxLevel) {
        maxLevel = level;
      }
      return siblings;
    }
    const treeNodes = traverse(data);
    return {
      treeNodeMap,
      levelTreeNodeMap,
      maxLevel,
      treeNodes
    };
  }
  function filter(query) {
    const keys2 = doFilter(query);
    if (keys2) {
      expandedKeySet.value = keys2;
    }
  }
  function getChildren(node) {
    return node[childrenKey.value];
  }
  function getKey(node) {
    if (!node) {
      return "";
    }
    return node[valueKey.value];
  }
  function getDisabled(node) {
    return node[disabledKey.value];
  }
  function getLabel(node) {
    return node[labelKey.value];
  }
  function toggleExpand(node) {
    const expandedKeys = expandedKeySet.value;
    if (expandedKeys.has(node.key)) {
      collapseNode(node);
    } else {
      expandNode(node);
    }
  }
  function setExpandedKeys(keys2) {
    expandedKeySet.value = new Set(keys2);
  }
  function handleNodeClick(node, e) {
    emit(NODE_CLICK, node.data, node, e);
    handleCurrentChange2(node);
    if (props.expandOnClickNode) {
      toggleExpand(node);
    }
    if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {
      toggleCheckbox(node, !isChecked(node), true);
    }
  }
  function handleCurrentChange2(node) {
    if (!isCurrent(node)) {
      currentKey.value = node.key;
      emit(CURRENT_CHANGE, node.data, node);
    }
  }
  function handleNodeCheck(node, checked) {
    toggleCheckbox(node, checked);
  }
  function expandNode(node) {
    const keySet = expandedKeySet.value;
    if (tree.value && props.accordion) {
      const { treeNodeMap } = tree.value;
      keySet.forEach((key) => {
        const treeNode = treeNodeMap.get(key);
        if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {
          keySet.delete(key);
        }
      });
    }
    keySet.add(node.key);
    emit(NODE_EXPAND, node.data, node);
  }
  function collapseNode(node) {
    expandedKeySet.value.delete(node.key);
    emit(NODE_COLLAPSE, node.data, node);
  }
  function isExpanded(node) {
    return expandedKeySet.value.has(node.key);
  }
  function isDisabled(node) {
    return !!node.disabled;
  }
  function isCurrent(node) {
    const current = currentKey.value;
    return !!current && current === node.key;
  }
  function getCurrentNode() {
    var _a2, _b;
    if (!currentKey.value)
      return void 0;
    return (_b = (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
  }
  function getCurrentKey() {
    return currentKey.value;
  }
  function setCurrentKey(key) {
    currentKey.value = key;
  }
  function setData(data) {
    (0, import_vue588.nextTick)(() => tree.value = createTree(data));
  }
  function getNode(data) {
    var _a2;
    const key = (0, import_shared107.isObject)(data) ? getKey(data) : data;
    return (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(key);
  }
  return {
    tree,
    flattenTree,
    isNotEmpty,
    getKey,
    getChildren,
    toggleExpand,
    toggleCheckbox,
    isExpanded,
    isChecked,
    isIndeterminate,
    isDisabled,
    isCurrent,
    isForceHiddenExpandIcon,
    handleNodeClick,
    handleNodeCheck,
    getCurrentNode,
    getCurrentKey,
    setCurrentKey,
    getCheckedKeys,
    getCheckedNodes,
    getHalfCheckedKeys,
    getHalfCheckedNodes,
    setChecked,
    setCheckedKeys,
    filter,
    setData,
    getNode,
    expandNode,
    collapseNode,
    setExpandedKeys
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/tree-node.mjs
var import_vue590 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/tree-node-content.mjs
var import_vue589 = require("vue");
var ElNodeContent = (0, import_vue589.defineComponent)({
  name: "ElTreeNodeContent",
  props: treeNodeContentProps,
  setup(props) {
    const tree = (0, import_vue589.inject)(ROOT_TREE_INJECTION_KEY);
    const ns2 = useNamespace("tree");
    return () => {
      const node = props.node;
      const { data } = node;
      return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({ node, data }) : (0, import_vue589.h)("span", { class: ns2.be("node", "label") }, [node == null ? void 0 : node.label]);
    };
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/tree-node.mjs
var _hoisted_185 = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"];
var __default__93 = (0, import_vue590.defineComponent)({
  name: "ElTreeNode"
});
var _sfc_main138 = /* @__PURE__ */ (0, import_vue590.defineComponent)({
  ...__default__93,
  props: treeNodeProps,
  emits: treeNodeEmits,
  setup(__props, { emit }) {
    const props = __props;
    const tree = (0, import_vue590.inject)(ROOT_TREE_INJECTION_KEY);
    const ns2 = useNamespace("tree");
    const indent = (0, import_vue590.computed)(() => {
      var _a2;
      return (_a2 = tree == null ? void 0 : tree.props.indent) != null ? _a2 : 16;
    });
    const icon = (0, import_vue590.computed)(() => {
      var _a2;
      return (_a2 = tree == null ? void 0 : tree.props.icon) != null ? _a2 : caret_right_default;
    });
    const handleClick = (e) => {
      emit("click", props.node, e);
    };
    const handleExpandIconClick = () => {
      emit("toggle", props.node);
    };
    const handleCheckChange = (value) => {
      emit("check", props.node, value);
    };
    const handleContextMenu = (event) => {
      var _a2, _b, _c, _d;
      if ((_c = (_b = (_a2 = tree == null ? void 0 : tree.instance) == null ? void 0 : _a2.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
        event.stopPropagation();
        event.preventDefault();
      }
      tree == null ? void 0 : tree.ctx.emit(NODE_CONTEXTMENU, event, (_d = props.node) == null ? void 0 : _d.data, props.node);
    };
    return (_ctx, _cache) => {
      var _a2, _b, _c;
      return (0, import_vue590.openBlock)(), (0, import_vue590.createElementBlock)("div", {
        ref: "node$",
        class: (0, import_vue590.normalizeClass)([
          (0, import_vue590.unref)(ns2).b("node"),
          (0, import_vue590.unref)(ns2).is("expanded", _ctx.expanded),
          (0, import_vue590.unref)(ns2).is("current", _ctx.current),
          (0, import_vue590.unref)(ns2).is("focusable", !_ctx.disabled),
          (0, import_vue590.unref)(ns2).is("checked", !_ctx.disabled && _ctx.checked)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": _ctx.expanded,
        "aria-disabled": _ctx.disabled,
        "aria-checked": _ctx.checked,
        "data-key": (_a2 = _ctx.node) == null ? void 0 : _a2.key,
        onClick: (0, import_vue590.withModifiers)(handleClick, ["stop"]),
        onContextmenu: handleContextMenu
      }, [
        (0, import_vue590.createElementVNode)("div", {
          class: (0, import_vue590.normalizeClass)((0, import_vue590.unref)(ns2).be("node", "content")),
          style: (0, import_vue590.normalizeStyle)({ paddingLeft: `${(_ctx.node.level - 1) * (0, import_vue590.unref)(indent)}px` })
        }, [
          (0, import_vue590.unref)(icon) ? ((0, import_vue590.openBlock)(), (0, import_vue590.createBlock)((0, import_vue590.unref)(ElIcon), {
            key: 0,
            class: (0, import_vue590.normalizeClass)([
              (0, import_vue590.unref)(ns2).is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
              (0, import_vue590.unref)(ns2).is("hidden", _ctx.hiddenExpandIcon),
              {
                expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
              },
              (0, import_vue590.unref)(ns2).be("node", "expand-icon")
            ]),
            onClick: (0, import_vue590.withModifiers)(handleExpandIconClick, ["stop"])
          }, {
            default: (0, import_vue590.withCtx)(() => [
              ((0, import_vue590.openBlock)(), (0, import_vue590.createBlock)((0, import_vue590.resolveDynamicComponent)((0, import_vue590.unref)(icon))))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : (0, import_vue590.createCommentVNode)("v-if", true),
          _ctx.showCheckbox ? ((0, import_vue590.openBlock)(), (0, import_vue590.createBlock)((0, import_vue590.unref)(ElCheckbox), {
            key: 1,
            "model-value": _ctx.checked,
            indeterminate: _ctx.indeterminate,
            disabled: _ctx.disabled,
            onChange: handleCheckChange,
            onClick: _cache[0] || (_cache[0] = (0, import_vue590.withModifiers)(() => {
            }, ["stop"]))
          }, null, 8, ["model-value", "indeterminate", "disabled"])) : (0, import_vue590.createCommentVNode)("v-if", true),
          (0, import_vue590.createVNode)((0, import_vue590.unref)(ElNodeContent), { node: _ctx.node }, null, 8, ["node"])
        ], 6)
      ], 42, _hoisted_185);
    };
  }
});
var ElTreeNode2 = /* @__PURE__ */ _export_sfc(_sfc_main138, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/src/tree.mjs
var itemSize2 = 26;
var __default__94 = (0, import_vue591.defineComponent)({
  name: "ElTreeV2"
});
var _sfc_main139 = /* @__PURE__ */ (0, import_vue591.defineComponent)({
  ...__default__94,
  props: treeProps,
  emits: treeEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots = (0, import_vue591.useSlots)();
    (0, import_vue591.provide)(ROOT_TREE_INJECTION_KEY, {
      ctx: {
        emit,
        slots
      },
      props,
      instance: (0, import_vue591.getCurrentInstance)()
    });
    (0, import_vue591.provide)(formItemContextKey, void 0);
    const { t } = useLocale();
    const ns2 = useNamespace("tree");
    const {
      flattenTree,
      isNotEmpty,
      toggleExpand,
      isExpanded,
      isIndeterminate,
      isChecked,
      isDisabled,
      isCurrent,
      isForceHiddenExpandIcon,
      handleNodeClick,
      handleNodeCheck,
      toggleCheckbox,
      getCurrentNode,
      getCurrentKey,
      setCurrentKey,
      getCheckedKeys,
      getCheckedNodes,
      getHalfCheckedKeys,
      getHalfCheckedNodes,
      setChecked,
      setCheckedKeys,
      filter,
      setData,
      getNode,
      expandNode,
      collapseNode,
      setExpandedKeys
    } = useTree3(props, emit);
    expose({
      toggleCheckbox,
      getCurrentNode,
      getCurrentKey,
      setCurrentKey,
      getCheckedKeys,
      getCheckedNodes,
      getHalfCheckedKeys,
      getHalfCheckedNodes,
      setChecked,
      setCheckedKeys,
      filter,
      setData,
      getNode,
      expandNode,
      collapseNode,
      setExpandedKeys
    });
    return (_ctx, _cache) => {
      var _a2;
      return (0, import_vue591.openBlock)(), (0, import_vue591.createElementBlock)("div", {
        class: (0, import_vue591.normalizeClass)([(0, import_vue591.unref)(ns2).b(), { [(0, import_vue591.unref)(ns2).m("highlight-current")]: _ctx.highlightCurrent }]),
        role: "tree"
      }, [
        (0, import_vue591.unref)(isNotEmpty) ? ((0, import_vue591.openBlock)(), (0, import_vue591.createBlock)((0, import_vue591.unref)(FixedSizeList), {
          key: 0,
          "class-name": (0, import_vue591.unref)(ns2).b("virtual-list"),
          data: (0, import_vue591.unref)(flattenTree),
          total: (0, import_vue591.unref)(flattenTree).length,
          height: _ctx.height,
          "item-size": itemSize2,
          "perf-mode": _ctx.perfMode
        }, {
          default: (0, import_vue591.withCtx)(({ data, index: index2, style }) => [
            ((0, import_vue591.openBlock)(), (0, import_vue591.createBlock)(ElTreeNode2, {
              key: data[index2].key,
              style: (0, import_vue591.normalizeStyle)(style),
              node: data[index2],
              expanded: (0, import_vue591.unref)(isExpanded)(data[index2]),
              "show-checkbox": _ctx.showCheckbox,
              checked: (0, import_vue591.unref)(isChecked)(data[index2]),
              indeterminate: (0, import_vue591.unref)(isIndeterminate)(data[index2]),
              disabled: (0, import_vue591.unref)(isDisabled)(data[index2]),
              current: (0, import_vue591.unref)(isCurrent)(data[index2]),
              "hidden-expand-icon": (0, import_vue591.unref)(isForceHiddenExpandIcon)(data[index2]),
              onClick: (0, import_vue591.unref)(handleNodeClick),
              onToggle: (0, import_vue591.unref)(toggleExpand),
              onCheck: (0, import_vue591.unref)(handleNodeCheck)
            }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
          ]),
          _: 1
        }, 8, ["class-name", "data", "total", "height", "perf-mode"])) : ((0, import_vue591.openBlock)(), (0, import_vue591.createElementBlock)("div", {
          key: 1,
          class: (0, import_vue591.normalizeClass)((0, import_vue591.unref)(ns2).e("empty-block"))
        }, [
          (0, import_vue591.createElementVNode)("span", {
            class: (0, import_vue591.normalizeClass)((0, import_vue591.unref)(ns2).e("empty-text"))
          }, (0, import_vue591.toDisplayString)((_a2 = _ctx.emptyText) != null ? _a2 : (0, import_vue591.unref)(t)("el.tree.emptyText")), 3)
        ], 2))
      ], 2);
    };
  }
});
var TreeV2 = /* @__PURE__ */ _export_sfc(_sfc_main139, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/tree-v2/index.mjs
var ElTreeV2 = withInstall(TreeV2);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload2.mjs
var import_vue596 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-list2.mjs
var import_vue592 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-list.mjs
var import_shared109 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload.mjs
var import_shared108 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/ajax.mjs
var SCOPE7 = "ElUpload";
var UploadAjaxError = class extends Error {
  constructor(message2, status, method4, url2) {
    super(message2);
    this.name = "UploadAjaxError";
    this.status = status;
    this.method = method4;
    this.url = url2;
  }
};
function getError(action, option2, xhr) {
  let msg;
  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to ${option2.method} ${action} ${xhr.status}`;
  }
  return new UploadAjaxError(msg, xhr.status, option2.method, action);
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
var ajaxUpload = (option2) => {
  if (typeof XMLHttpRequest === "undefined")
    throwError(SCOPE7, "XMLHttpRequest is undefined");
  const xhr = new XMLHttpRequest();
  const action = option2.action;
  if (xhr.upload) {
    xhr.upload.addEventListener("progress", (evt) => {
      const progressEvt = evt;
      progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
      option2.onProgress(progressEvt);
    });
  }
  const formData = new FormData();
  if (option2.data) {
    for (const [key, value] of Object.entries(option2.data)) {
      if (Array.isArray(value))
        formData.append(key, ...value);
      else
        formData.append(key, value);
    }
  }
  formData.append(option2.filename, option2.file, option2.file.name);
  xhr.addEventListener("error", () => {
    option2.onError(getError(action, option2, xhr));
  });
  xhr.addEventListener("load", () => {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option2.onError(getError(action, option2, xhr));
    }
    option2.onSuccess(getBody(xhr));
  });
  xhr.open(option2.method, action, true);
  if (option2.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option2.headers || {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => xhr.setRequestHeader(key, value));
  } else {
    for (const [key, value] of Object.entries(headers)) {
      if (isNil_default(value))
        continue;
      xhr.setRequestHeader(key, String(value));
    }
  }
  xhr.send(formData);
  return xhr;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload.mjs
var uploadListTypes = ["text", "picture", "picture-card"];
var fileId = 1;
var genFileId = () => Date.now() + fileId++;
var uploadBaseProps = buildProps({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: definePropType(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Object,
    default: () => mutable({})
  },
  multiple: {
    type: Boolean,
    default: false
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: false
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: true
  },
  accept: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "select"
  },
  fileList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  autoUpload: {
    type: Boolean,
    default: true
  },
  listType: {
    type: String,
    values: uploadListTypes,
    default: "text"
  },
  httpRequest: {
    type: definePropType(Function),
    default: ajaxUpload
  },
  disabled: Boolean,
  limit: Number
});
var uploadProps = buildProps({
  ...uploadBaseProps,
  beforeUpload: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  beforeRemove: {
    type: definePropType(Function)
  },
  onRemove: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  onChange: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  onPreview: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  onSuccess: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  onProgress: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  onError: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  },
  onExceed: {
    type: definePropType(Function),
    default: import_shared108.NOOP
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-list.mjs
var uploadListProps = buildProps({
  files: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  disabled: {
    type: Boolean,
    default: false
  },
  handlePreview: {
    type: definePropType(Function),
    default: import_shared109.NOOP
  },
  listType: {
    type: String,
    values: uploadListTypes,
    default: "text"
  }
});
var uploadListEmits = {
  remove: (file) => !!file
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-list2.mjs
var _hoisted_186 = ["onKeydown"];
var _hoisted_255 = ["src"];
var _hoisted_324 = ["onClick"];
var _hoisted_412 = ["onClick"];
var _hoisted_59 = ["onClick"];
var __default__95 = (0, import_vue592.defineComponent)({
  name: "ElUploadList"
});
var _sfc_main140 = /* @__PURE__ */ (0, import_vue592.defineComponent)({
  ...__default__95,
  props: uploadListProps,
  emits: uploadListEmits,
  setup(__props, { emit }) {
    const { t } = useLocale();
    const nsUpload = useNamespace("upload");
    const nsIcon = useNamespace("icon");
    const nsList = useNamespace("list");
    const disabled = useDisabled();
    const focusing = (0, import_vue592.ref)(false);
    const handleRemove = (file) => {
      emit("remove", file);
    };
    return (_ctx, _cache) => {
      return (0, import_vue592.openBlock)(), (0, import_vue592.createBlock)(import_vue592.TransitionGroup, {
        tag: "ul",
        class: (0, import_vue592.normalizeClass)([
          (0, import_vue592.unref)(nsUpload).b("list"),
          (0, import_vue592.unref)(nsUpload).bm("list", _ctx.listType),
          (0, import_vue592.unref)(nsUpload).is("disabled", (0, import_vue592.unref)(disabled))
        ]),
        name: (0, import_vue592.unref)(nsList).b()
      }, {
        default: (0, import_vue592.withCtx)(() => [
          ((0, import_vue592.openBlock)(true), (0, import_vue592.createElementBlock)(import_vue592.Fragment, null, (0, import_vue592.renderList)(_ctx.files, (file) => {
            return (0, import_vue592.openBlock)(), (0, import_vue592.createElementBlock)("li", {
              key: file.uid || file.name,
              class: (0, import_vue592.normalizeClass)([
                (0, import_vue592.unref)(nsUpload).be("list", "item"),
                (0, import_vue592.unref)(nsUpload).is(file.status),
                { focusing: focusing.value }
              ]),
              tabindex: "0",
              onKeydown: (0, import_vue592.withKeys)(($event) => !(0, import_vue592.unref)(disabled) && handleRemove(file), ["delete"]),
              onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
              onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
              onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
            }, [
              (0, import_vue592.renderSlot)(_ctx.$slots, "default", { file }, () => [
                _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? ((0, import_vue592.openBlock)(), (0, import_vue592.createElementBlock)("img", {
                  key: 0,
                  class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-thumbnail")),
                  src: file.url,
                  alt: ""
                }, null, 10, _hoisted_255)) : (0, import_vue592.createCommentVNode)("v-if", true),
                file.status === "uploading" || _ctx.listType !== "picture-card" ? ((0, import_vue592.openBlock)(), (0, import_vue592.createElementBlock)("div", {
                  key: 1,
                  class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-info"))
                }, [
                  (0, import_vue592.createElementVNode)("a", {
                    class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-name")),
                    onClick: (0, import_vue592.withModifiers)(($event) => _ctx.handlePreview(file), ["prevent"])
                  }, [
                    (0, import_vue592.createVNode)((0, import_vue592.unref)(ElIcon), {
                      class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsIcon).m("document"))
                    }, {
                      default: (0, import_vue592.withCtx)(() => [
                        (0, import_vue592.createVNode)((0, import_vue592.unref)(document_default))
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    (0, import_vue592.createElementVNode)("span", {
                      class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-file-name"))
                    }, (0, import_vue592.toDisplayString)(file.name), 3)
                  ], 10, _hoisted_324),
                  file.status === "uploading" ? ((0, import_vue592.openBlock)(), (0, import_vue592.createBlock)((0, import_vue592.unref)(ElProgress), {
                    key: 0,
                    type: _ctx.listType === "picture-card" ? "circle" : "line",
                    "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                    percentage: Number(file.percentage),
                    style: (0, import_vue592.normalizeStyle)(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                  }, null, 8, ["type", "stroke-width", "percentage", "style"])) : (0, import_vue592.createCommentVNode)("v-if", true)
                ], 2)) : (0, import_vue592.createCommentVNode)("v-if", true),
                (0, import_vue592.createElementVNode)("label", {
                  class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-status-label"))
                }, [
                  _ctx.listType === "text" ? ((0, import_vue592.openBlock)(), (0, import_vue592.createBlock)((0, import_vue592.unref)(ElIcon), {
                    key: 0,
                    class: (0, import_vue592.normalizeClass)([(0, import_vue592.unref)(nsIcon).m("upload-success"), (0, import_vue592.unref)(nsIcon).m("circle-check")])
                  }, {
                    default: (0, import_vue592.withCtx)(() => [
                      (0, import_vue592.createVNode)((0, import_vue592.unref)(circle_check_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? ((0, import_vue592.openBlock)(), (0, import_vue592.createBlock)((0, import_vue592.unref)(ElIcon), {
                    key: 1,
                    class: (0, import_vue592.normalizeClass)([(0, import_vue592.unref)(nsIcon).m("upload-success"), (0, import_vue592.unref)(nsIcon).m("check")])
                  }, {
                    default: (0, import_vue592.withCtx)(() => [
                      (0, import_vue592.createVNode)((0, import_vue592.unref)(check_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : (0, import_vue592.createCommentVNode)("v-if", true)
                ], 2),
                !(0, import_vue592.unref)(disabled) ? ((0, import_vue592.openBlock)(), (0, import_vue592.createBlock)((0, import_vue592.unref)(ElIcon), {
                  key: 2,
                  class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsIcon).m("close")),
                  onClick: ($event) => handleRemove(file)
                }, {
                  default: (0, import_vue592.withCtx)(() => [
                    (0, import_vue592.createVNode)((0, import_vue592.unref)(close_default))
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])) : (0, import_vue592.createCommentVNode)("v-if", true),
                (0, import_vue592.createCommentVNode)(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                (0, import_vue592.createCommentVNode)(" This is a bug which needs to be fixed "),
                (0, import_vue592.createCommentVNode)(" TODO: Fix the incorrect navigation interaction "),
                !(0, import_vue592.unref)(disabled) ? ((0, import_vue592.openBlock)(), (0, import_vue592.createElementBlock)("i", {
                  key: 3,
                  class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsIcon).m("close-tip"))
                }, (0, import_vue592.toDisplayString)((0, import_vue592.unref)(t)("el.upload.deleteTip")), 3)) : (0, import_vue592.createCommentVNode)("v-if", true),
                _ctx.listType === "picture-card" ? ((0, import_vue592.openBlock)(), (0, import_vue592.createElementBlock)("span", {
                  key: 4,
                  class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-actions"))
                }, [
                  (0, import_vue592.createElementVNode)("span", {
                    class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-preview")),
                    onClick: ($event) => _ctx.handlePreview(file)
                  }, [
                    (0, import_vue592.createVNode)((0, import_vue592.unref)(ElIcon), {
                      class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsIcon).m("zoom-in"))
                    }, {
                      default: (0, import_vue592.withCtx)(() => [
                        (0, import_vue592.createVNode)((0, import_vue592.unref)(zoom_in_default))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, _hoisted_412),
                  !(0, import_vue592.unref)(disabled) ? ((0, import_vue592.openBlock)(), (0, import_vue592.createElementBlock)("span", {
                    key: 0,
                    class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsUpload).be("list", "item-delete")),
                    onClick: ($event) => handleRemove(file)
                  }, [
                    (0, import_vue592.createVNode)((0, import_vue592.unref)(ElIcon), {
                      class: (0, import_vue592.normalizeClass)((0, import_vue592.unref)(nsIcon).m("delete"))
                    }, {
                      default: (0, import_vue592.withCtx)(() => [
                        (0, import_vue592.createVNode)((0, import_vue592.unref)(delete_default))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, _hoisted_59)) : (0, import_vue592.createCommentVNode)("v-if", true)
                ], 2)) : (0, import_vue592.createCommentVNode)("v-if", true)
              ])
            ], 42, _hoisted_186);
          }), 128)),
          (0, import_vue592.renderSlot)(_ctx.$slots, "append")
        ]),
        _: 3
      }, 8, ["class", "name"]);
    };
  }
});
var UploadList = /* @__PURE__ */ _export_sfc(_sfc_main140, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-content2.mjs
var import_vue594 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-dragger2.mjs
var import_vue593 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-dragger.mjs
var import_shared110 = require("@vue/shared");
var uploadDraggerProps = buildProps({
  disabled: {
    type: Boolean,
    default: false
  }
});
var uploadDraggerEmits = {
  file: (file) => (0, import_shared110.isArray)(file)
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-dragger2.mjs
var _hoisted_187 = ["onDrop", "onDragover"];
var COMPONENT_NAME24 = "ElUploadDrag";
var __default__96 = (0, import_vue593.defineComponent)({
  name: COMPONENT_NAME24
});
var _sfc_main141 = /* @__PURE__ */ (0, import_vue593.defineComponent)({
  ...__default__96,
  props: uploadDraggerProps,
  emits: uploadDraggerEmits,
  setup(__props, { emit }) {
    const uploaderContext = (0, import_vue593.inject)(uploadContextKey);
    if (!uploaderContext) {
      throwError(COMPONENT_NAME24, "usage: <el-upload><el-upload-dragger /></el-upload>");
    }
    const ns2 = useNamespace("upload");
    const dragover = (0, import_vue593.ref)(false);
    const disabled = useDisabled();
    const onDrop = (e) => {
      if (disabled.value)
        return;
      dragover.value = false;
      const files = Array.from(e.dataTransfer.files);
      const accept = uploaderContext.accept.value;
      if (!accept) {
        emit("file", files);
        return;
      }
      const filesFiltered = files.filter((file) => {
        const { type: type4, name } = file;
        const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
        const baseType = type4.replace(/\/.*$/, "");
        return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
          if (acceptedType.startsWith(".")) {
            return extension === acceptedType;
          }
          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, "");
          }
          if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
            return type4 === acceptedType;
          }
          return false;
        });
      });
      emit("file", filesFiltered);
    };
    const onDragover = () => {
      if (!disabled.value)
        dragover.value = true;
    };
    return (_ctx, _cache) => {
      return (0, import_vue593.openBlock)(), (0, import_vue593.createElementBlock)("div", {
        class: (0, import_vue593.normalizeClass)([(0, import_vue593.unref)(ns2).b("dragger"), (0, import_vue593.unref)(ns2).is("dragover", dragover.value)]),
        onDrop: (0, import_vue593.withModifiers)(onDrop, ["prevent"]),
        onDragover: (0, import_vue593.withModifiers)(onDragover, ["prevent"]),
        onDragleave: _cache[0] || (_cache[0] = (0, import_vue593.withModifiers)(($event) => dragover.value = false, ["prevent"]))
      }, [
        (0, import_vue593.renderSlot)(_ctx.$slots, "default")
      ], 42, _hoisted_187);
    };
  }
});
var UploadDragger = /* @__PURE__ */ _export_sfc(_sfc_main141, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-content.mjs
var import_shared111 = require("@vue/shared");
var uploadContentProps = buildProps({
  ...uploadBaseProps,
  beforeUpload: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  },
  onRemove: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  },
  onStart: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  },
  onSuccess: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  },
  onProgress: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  },
  onError: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  },
  onExceed: {
    type: definePropType(Function),
    default: import_shared111.NOOP
  }
});

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload-content2.mjs
var _hoisted_188 = ["onKeydown"];
var _hoisted_257 = ["name", "multiple", "accept"];
var __default__97 = (0, import_vue594.defineComponent)({
  name: "ElUploadContent",
  inheritAttrs: false
});
var _sfc_main142 = /* @__PURE__ */ (0, import_vue594.defineComponent)({
  ...__default__97,
  props: uploadContentProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("upload");
    const disabled = useDisabled();
    const requests = (0, import_vue594.shallowRef)({});
    const inputRef = (0, import_vue594.shallowRef)();
    const uploadFiles = (files) => {
      if (files.length === 0)
        return;
      const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
      if (limit && fileList.length + files.length > limit) {
        onExceed(files, fileList);
        return;
      }
      if (!multiple) {
        files = files.slice(0, 1);
      }
      for (const file of files) {
        const rawFile = file;
        rawFile.uid = genFileId();
        onStart(rawFile);
        if (autoUpload)
          upload(rawFile);
      }
    };
    const upload = async (rawFile) => {
      inputRef.value.value = "";
      if (!props.beforeUpload) {
        return doUpload(rawFile);
      }
      let hookResult;
      try {
        hookResult = await props.beforeUpload(rawFile);
      } catch (e) {
        hookResult = false;
      }
      if (hookResult === false) {
        props.onRemove(rawFile);
        return;
      }
      let file = rawFile;
      if (hookResult instanceof Blob) {
        if (hookResult instanceof File) {
          file = hookResult;
        } else {
          file = new File([hookResult], rawFile.name, {
            type: rawFile.type
          });
        }
      }
      doUpload(Object.assign(file, {
        uid: rawFile.uid
      }));
    };
    const doUpload = (rawFile) => {
      const {
        headers,
        data,
        method: method4,
        withCredentials,
        name: filename,
        action,
        onProgress,
        onSuccess,
        onError,
        httpRequest
      } = props;
      const { uid: uid2 } = rawFile;
      const options = {
        headers: headers || {},
        withCredentials,
        file: rawFile,
        data,
        method: method4,
        filename,
        action,
        onProgress: (evt) => {
          onProgress(evt, rawFile);
        },
        onSuccess: (res) => {
          onSuccess(res, rawFile);
          delete requests.value[uid2];
        },
        onError: (err) => {
          onError(err, rawFile);
          delete requests.value[uid2];
        }
      };
      const request = httpRequest(options);
      requests.value[uid2] = request;
      if (request instanceof Promise) {
        request.then(options.onSuccess, options.onError);
      }
    };
    const handleChange = (e) => {
      const files = e.target.files;
      if (!files)
        return;
      uploadFiles(Array.from(files));
    };
    const handleClick = () => {
      if (!disabled.value) {
        inputRef.value.value = "";
        inputRef.value.click();
      }
    };
    const handleKeydown = () => {
      handleClick();
    };
    const abort = (file) => {
      const _reqs = entriesOf(requests.value).filter(file ? ([uid2]) => String(file.uid) === uid2 : () => true);
      _reqs.forEach(([uid2, req]) => {
        if (req instanceof XMLHttpRequest)
          req.abort();
        delete requests.value[uid2];
      });
    };
    expose({
      abort,
      upload
    });
    return (_ctx, _cache) => {
      return (0, import_vue594.openBlock)(), (0, import_vue594.createElementBlock)("div", {
        class: (0, import_vue594.normalizeClass)([(0, import_vue594.unref)(ns2).b(), (0, import_vue594.unref)(ns2).m(_ctx.listType), (0, import_vue594.unref)(ns2).is("drag", _ctx.drag)]),
        tabindex: "0",
        onClick: handleClick,
        onKeydown: (0, import_vue594.withKeys)((0, import_vue594.withModifiers)(handleKeydown, ["self"]), ["enter", "space"])
      }, [
        _ctx.drag ? ((0, import_vue594.openBlock)(), (0, import_vue594.createBlock)(UploadDragger, {
          key: 0,
          disabled: (0, import_vue594.unref)(disabled),
          onFile: uploadFiles
        }, {
          default: (0, import_vue594.withCtx)(() => [
            (0, import_vue594.renderSlot)(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"])) : (0, import_vue594.renderSlot)(_ctx.$slots, "default", { key: 1 }),
        (0, import_vue594.createElementVNode)("input", {
          ref_key: "inputRef",
          ref: inputRef,
          class: (0, import_vue594.normalizeClass)((0, import_vue594.unref)(ns2).e("input")),
          name: _ctx.name,
          multiple: _ctx.multiple,
          accept: _ctx.accept,
          type: "file",
          onChange: handleChange,
          onClick: _cache[0] || (_cache[0] = (0, import_vue594.withModifiers)(() => {
          }, ["stop"]))
        }, null, 42, _hoisted_257)
      ], 42, _hoisted_188);
    };
  }
});
var UploadContent = /* @__PURE__ */ _export_sfc(_sfc_main142, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/use-handlers.mjs
var import_vue595 = require("vue");
var SCOPE8 = "ElUpload";
var revokeObjectURL = (file) => {
  var _a2;
  if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
    URL.revokeObjectURL(file.url);
  }
};
var useHandlers = (props, uploadRef) => {
  const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
  const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
  function abort(file) {
    var _a2;
    (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
  }
  function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
    uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
  }
  const handleError = (err, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    console.error(err);
    file.status = "fail";
    uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
    props.onError(err, file, uploadFiles.value);
    props.onChange(file, uploadFiles.value);
  };
  const handleProgress = (evt, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    props.onProgress(evt, file, uploadFiles.value);
    file.status = "uploading";
    file.percentage = Math.round(evt.percent);
  };
  const handleSuccess = (response, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    file.status = "success";
    file.response = response;
    props.onSuccess(response, file, uploadFiles.value);
    props.onChange(file, uploadFiles.value);
  };
  const handleStart = (file) => {
    if (isNil_default(file.uid))
      file.uid = genFileId();
    const uploadFile = {
      name: file.name,
      percentage: 0,
      status: "ready",
      size: file.size,
      raw: file,
      uid: file.uid
    };
    if (props.listType === "picture-card" || props.listType === "picture") {
      try {
        uploadFile.url = URL.createObjectURL(file);
      } catch (err) {
        debugWarn(SCOPE8, err.message);
        props.onError(err, uploadFile, uploadFiles.value);
      }
    }
    uploadFiles.value = [...uploadFiles.value, uploadFile];
    props.onChange(uploadFile, uploadFiles.value);
  };
  const handleRemove = async (file) => {
    const uploadFile = file instanceof File ? getFile(file) : file;
    if (!uploadFile)
      throwError(SCOPE8, "file to be removed not found");
    const doRemove = (file2) => {
      abort(file2);
      const fileList = uploadFiles.value;
      fileList.splice(fileList.indexOf(file2), 1);
      props.onRemove(file2, fileList);
      revokeObjectURL(file2);
    };
    if (props.beforeRemove) {
      const before = await props.beforeRemove(uploadFile, uploadFiles.value);
      if (before !== false)
        doRemove(uploadFile);
    } else {
      doRemove(uploadFile);
    }
  };
  function submit() {
    uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
      var _a2;
      return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
    });
  }
  (0, import_vue595.watch)(() => props.listType, (val) => {
    if (val !== "picture-card" && val !== "picture") {
      return;
    }
    uploadFiles.value = uploadFiles.value.map((file) => {
      const { raw, url: url2 } = file;
      if (!url2 && raw) {
        try {
          file.url = URL.createObjectURL(raw);
        } catch (err) {
          props.onError(err, file, uploadFiles.value);
        }
      }
      return file;
    });
  });
  (0, import_vue595.watch)(uploadFiles, (files) => {
    for (const file of files) {
      file.uid || (file.uid = genFileId());
      file.status || (file.status = "success");
    }
  }, { immediate: true, deep: true });
  return {
    uploadFiles,
    abort,
    clearFiles,
    handleError,
    handleProgress,
    handleStart,
    handleSuccess,
    handleRemove,
    submit
  };
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/src/upload2.mjs
var __default__98 = (0, import_vue596.defineComponent)({
  name: "ElUpload"
});
var _sfc_main143 = /* @__PURE__ */ (0, import_vue596.defineComponent)({
  ...__default__98,
  props: uploadProps,
  setup(__props, { expose }) {
    const props = __props;
    const slots = (0, import_vue596.useSlots)();
    const disabled = useDisabled();
    const uploadRef = (0, import_vue596.shallowRef)();
    const {
      abort,
      submit,
      clearFiles,
      uploadFiles,
      handleStart,
      handleError,
      handleRemove,
      handleSuccess,
      handleProgress
    } = useHandlers(props, uploadRef);
    const isPictureCard = (0, import_vue596.computed)(() => props.listType === "picture-card");
    const uploadContentProps2 = (0, import_vue596.computed)(() => ({
      ...props,
      fileList: uploadFiles.value,
      onStart: handleStart,
      onProgress: handleProgress,
      onSuccess: handleSuccess,
      onError: handleError,
      onRemove: handleRemove
    }));
    (0, import_vue596.onBeforeUnmount)(() => {
      uploadFiles.value.forEach(({ url: url2 }) => {
        if (url2 == null ? void 0 : url2.startsWith("blob:"))
          URL.revokeObjectURL(url2);
      });
    });
    (0, import_vue596.provide)(uploadContextKey, {
      accept: (0, import_vue596.toRef)(props, "accept")
    });
    expose({
      abort,
      submit,
      clearFiles,
      handleStart,
      handleRemove
    });
    return (_ctx, _cache) => {
      return (0, import_vue596.openBlock)(), (0, import_vue596.createElementBlock)("div", null, [
        (0, import_vue596.unref)(isPictureCard) && _ctx.showFileList ? ((0, import_vue596.openBlock)(), (0, import_vue596.createBlock)(UploadList, {
          key: 0,
          disabled: (0, import_vue596.unref)(disabled),
          "list-type": _ctx.listType,
          files: (0, import_vue596.unref)(uploadFiles),
          "handle-preview": _ctx.onPreview,
          onRemove: (0, import_vue596.unref)(handleRemove)
        }, (0, import_vue596.createSlots)({
          append: (0, import_vue596.withCtx)(() => [
            (0, import_vue596.createVNode)(UploadContent, (0, import_vue596.mergeProps)({
              ref_key: "uploadRef",
              ref: uploadRef
            }, (0, import_vue596.unref)(uploadContentProps2)), {
              default: (0, import_vue596.withCtx)(() => [
                (0, import_vue596.unref)(slots).trigger ? (0, import_vue596.renderSlot)(_ctx.$slots, "trigger", { key: 0 }) : (0, import_vue596.createCommentVNode)("v-if", true),
                !(0, import_vue596.unref)(slots).trigger && (0, import_vue596.unref)(slots).default ? (0, import_vue596.renderSlot)(_ctx.$slots, "default", { key: 1 }) : (0, import_vue596.createCommentVNode)("v-if", true)
              ]),
              _: 3
            }, 16)
          ]),
          _: 2
        }, [
          _ctx.$slots.file ? {
            name: "default",
            fn: (0, import_vue596.withCtx)(({ file }) => [
              (0, import_vue596.renderSlot)(_ctx.$slots, "file", { file })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : (0, import_vue596.createCommentVNode)("v-if", true),
        !(0, import_vue596.unref)(isPictureCard) || (0, import_vue596.unref)(isPictureCard) && !_ctx.showFileList ? ((0, import_vue596.openBlock)(), (0, import_vue596.createBlock)(UploadContent, (0, import_vue596.mergeProps)({
          key: 1,
          ref_key: "uploadRef",
          ref: uploadRef
        }, (0, import_vue596.unref)(uploadContentProps2)), {
          default: (0, import_vue596.withCtx)(() => [
            (0, import_vue596.unref)(slots).trigger ? (0, import_vue596.renderSlot)(_ctx.$slots, "trigger", { key: 0 }) : (0, import_vue596.createCommentVNode)("v-if", true),
            !(0, import_vue596.unref)(slots).trigger && (0, import_vue596.unref)(slots).default ? (0, import_vue596.renderSlot)(_ctx.$slots, "default", { key: 1 }) : (0, import_vue596.createCommentVNode)("v-if", true)
          ]),
          _: 3
        }, 16)) : (0, import_vue596.createCommentVNode)("v-if", true),
        _ctx.$slots.trigger ? (0, import_vue596.renderSlot)(_ctx.$slots, "default", { key: 2 }) : (0, import_vue596.createCommentVNode)("v-if", true),
        (0, import_vue596.renderSlot)(_ctx.$slots, "tip"),
        !(0, import_vue596.unref)(isPictureCard) && _ctx.showFileList ? ((0, import_vue596.openBlock)(), (0, import_vue596.createBlock)(UploadList, {
          key: 3,
          disabled: (0, import_vue596.unref)(disabled),
          "list-type": _ctx.listType,
          files: (0, import_vue596.unref)(uploadFiles),
          "handle-preview": _ctx.onPreview,
          onRemove: (0, import_vue596.unref)(handleRemove)
        }, (0, import_vue596.createSlots)({ _: 2 }, [
          _ctx.$slots.file ? {
            name: "default",
            fn: (0, import_vue596.withCtx)(({ file }) => [
              (0, import_vue596.renderSlot)(_ctx.$slots, "file", { file })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : (0, import_vue596.createCommentVNode)("v-if", true)
      ]);
    };
  }
});
var Upload = /* @__PURE__ */ _export_sfc(_sfc_main143, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/upload/index.mjs
var ElUpload = withInstall(Upload);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/component.mjs
var Components = [
  ElAffix,
  ElAlert,
  ElAutocomplete,
  ElAutoResizer,
  ElAvatar,
  ElBacktop,
  ElBadge,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElButton,
  ElButtonGroup,
  ElCalendar,
  ElCard,
  ElCarousel,
  ElCarouselItem,
  ElCascader,
  ElCascaderPanel,
  ElCheckTag,
  ElCheckbox,
  ElCheckboxButton,
  ElCheckboxGroup,
  ElCol,
  ElCollapse,
  ElCollapseItem,
  ElCollapseTransition,
  ElColorPicker,
  ElConfigProvider,
  ElContainer,
  ElAside,
  ElFooter,
  ElHeader,
  ElMain,
  ElDatePicker,
  ElDescriptions,
  ElDescriptionsItem,
  ElDialog,
  ElDivider,
  ElDrawer,
  ElDropdown,
  ElDropdownItem,
  ElDropdownMenu,
  ElEmpty,
  ElForm,
  ElFormItem,
  ElIcon,
  ElImage,
  ElImageViewer,
  ElInput,
  ElInputNumber,
  ElLink,
  ElMenu,
  ElMenuItem,
  ElMenuItemGroup,
  ElSubMenu,
  ElPageHeader,
  ElPagination,
  ElPopconfirm,
  ElPopover,
  ElPopper,
  ElProgress,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElRate,
  ElResult,
  ElRow,
  ElScrollbar,
  ElSelect,
  ElOption,
  ElOptionGroup,
  ElSelectV2,
  ElSkeleton,
  ElSkeletonItem,
  ElSlider,
  ElSpace,
  ElStatistic,
  ElCountdown,
  ElSteps,
  ElStep,
  ElSwitch,
  ElTable,
  ElTableColumn2,
  ElTableV2,
  ElTabs,
  ElTabPane,
  ElTag,
  ElTimePicker,
  ElTimeSelect,
  ElTimeline,
  ElTimelineItem,
  ElTooltip,
  ElTooltipV2,
  ElTransfer,
  ElTree,
  ElTreeSelect,
  ElTreeV2,
  ElUpload
];

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/infinite-scroll/src/index.mjs
var import_vue597 = require("vue");
var import_shared112 = require("@vue/shared");
var SCOPE9 = "ElInfiniteScroll";
var CHECK_INTERVAL = 50;
var DEFAULT_DELAY = 200;
var DEFAULT_DISTANCE = 0;
var attributes = {
  delay: {
    type: Number,
    default: DEFAULT_DELAY
  },
  distance: {
    type: Number,
    default: DEFAULT_DISTANCE
  },
  disabled: {
    type: Boolean,
    default: false
  },
  immediate: {
    type: Boolean,
    default: true
  }
};
var getScrollOptions = (el, instance) => {
  return Object.entries(attributes).reduce((acm, [name, option2]) => {
    var _a2, _b;
    const { type: type4, default: defaultValue } = option2;
    const attrVal = el.getAttribute(`infinite-scroll-${name}`);
    let value = (_b = (_a2 = instance[attrVal]) != null ? _a2 : attrVal) != null ? _b : defaultValue;
    value = value === "false" ? false : value;
    value = type4(value);
    acm[name] = Number.isNaN(value) ? defaultValue : value;
    return acm;
  }, {});
};
var destroyObserver = (el) => {
  const { observer } = el[SCOPE9];
  if (observer) {
    observer.disconnect();
    delete el[SCOPE9].observer;
  }
};
var handleScroll = (el, cb) => {
  const { container, containerEl, instance, observer, lastScrollTop } = el[SCOPE9];
  const { disabled, distance } = getScrollOptions(el, instance);
  const { clientHeight, scrollHeight, scrollTop } = containerEl;
  const delta = scrollTop - lastScrollTop;
  el[SCOPE9].lastScrollTop = scrollTop;
  if (observer || disabled || delta < 0)
    return;
  let shouldTrigger = false;
  if (container === el) {
    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
  } else {
    const { clientTop, scrollHeight: height } = el;
    const offsetTop = getOffsetTopDistance(el, containerEl);
    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
  }
  if (shouldTrigger) {
    cb.call(instance);
  }
};
function checkFull(el, cb) {
  const { containerEl, instance } = el[SCOPE9];
  const { disabled } = getScrollOptions(el, instance);
  if (disabled || containerEl.clientHeight === 0)
    return;
  if (containerEl.scrollHeight <= containerEl.clientHeight) {
    cb.call(instance);
  } else {
    destroyObserver(el);
  }
}
var InfiniteScroll = {
  async mounted(el, binding) {
    const { instance, value: cb } = binding;
    if (!(0, import_shared112.isFunction)(cb)) {
      throwError(SCOPE9, "'v-infinite-scroll' binding value must be a function");
    }
    await (0, import_vue597.nextTick)();
    const { delay, immediate } = getScrollOptions(el, instance);
    const container = getScrollContainer(el, true);
    const containerEl = container === window ? document.documentElement : container;
    const onScroll = throttle_default(handleScroll.bind(null, el, cb), delay);
    if (!container)
      return;
    el[SCOPE9] = {
      instance,
      container,
      containerEl,
      delay,
      cb,
      onScroll,
      lastScrollTop: containerEl.scrollTop
    };
    if (immediate) {
      const observer = new MutationObserver(throttle_default(checkFull.bind(null, el, cb), CHECK_INTERVAL));
      el[SCOPE9].observer = observer;
      observer.observe(el, { childList: true, subtree: true });
      checkFull(el, cb);
    }
    container.addEventListener("scroll", onScroll);
  },
  unmounted(el) {
    const { container, onScroll } = el[SCOPE9];
    container == null ? void 0 : container.removeEventListener("scroll", onScroll);
    destroyObserver(el);
  },
  async updated(el) {
    if (!el[SCOPE9]) {
      await (0, import_vue597.nextTick)();
    }
    const { containerEl, cb, observer } = el[SCOPE9];
    if (containerEl.clientHeight && observer) {
      checkFull(el, cb);
    }
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/infinite-scroll/index.mjs
var _InfiniteScroll = InfiniteScroll;
_InfiniteScroll.install = (app) => {
  app.directive("InfiniteScroll", _InfiniteScroll);
};
var ElInfiniteScroll = _InfiniteScroll;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/loading/src/service.mjs
var import_vue599 = require("vue");
var import_shared113 = require("@vue/shared");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/loading/src/loading.mjs
var import_vue598 = require("vue");
function createLoadingComponent(options) {
  let afterLeaveTimer;
  const ns2 = useNamespace("loading");
  const afterLeaveFlag = (0, import_vue598.ref)(false);
  const data = (0, import_vue598.reactive)({
    ...options,
    originalPosition: "",
    originalOverflow: "",
    visible: false
  });
  function setText(text) {
    data.text = text;
  }
  function destroySelf() {
    const target = data.parent;
    if (!target.vLoadingAddClassList) {
      let loadingNumber = target.getAttribute("loading-number");
      loadingNumber = Number.parseInt(loadingNumber) - 1;
      if (!loadingNumber) {
        removeClass(target, ns2.bm("parent", "relative"));
        target.removeAttribute("loading-number");
      } else {
        target.setAttribute("loading-number", loadingNumber.toString());
      }
      removeClass(target, ns2.bm("parent", "hidden"));
    }
    removeElLoadingChild();
    loadingInstance.unmount();
  }
  function removeElLoadingChild() {
    var _a2, _b;
    (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
  }
  function close2() {
    var _a2;
    if (options.beforeClose && !options.beforeClose())
      return;
    afterLeaveFlag.value = true;
    clearTimeout(afterLeaveTimer);
    afterLeaveTimer = window.setTimeout(handleAfterLeave, 400);
    data.visible = false;
    (_a2 = options.closed) == null ? void 0 : _a2.call(options);
  }
  function handleAfterLeave() {
    if (!afterLeaveFlag.value)
      return;
    const target = data.parent;
    afterLeaveFlag.value = false;
    target.vLoadingAddClassList = void 0;
    destroySelf();
  }
  const elLoadingComponent = {
    name: "ElLoading",
    setup() {
      return () => {
        const svg = data.spinner || data.svg;
        const spinner = (0, import_vue598.h)("svg", {
          class: "circular",
          viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50",
          ...svg ? { innerHTML: svg } : {}
        }, [
          (0, import_vue598.h)("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]);
        const spinnerText = data.text ? (0, import_vue598.h)("p", { class: ns2.b("text") }, [data.text]) : void 0;
        return (0, import_vue598.h)(import_vue598.Transition, {
          name: ns2.b("fade"),
          onAfterLeave: handleAfterLeave
        }, {
          default: (0, import_vue598.withCtx)(() => [
            (0, import_vue598.withDirectives)((0, import_vue598.createVNode)("div", {
              style: {
                backgroundColor: data.background || ""
              },
              class: [
                ns2.b("mask"),
                data.customClass,
                data.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              (0, import_vue598.h)("div", {
                class: ns2.b("spinner")
              }, [spinner, spinnerText])
            ]), [[import_vue598.vShow, data.visible]])
          ])
        });
      };
    }
  };
  const loadingInstance = (0, import_vue598.createApp)(elLoadingComponent);
  const vm = loadingInstance.mount(document.createElement("div"));
  return {
    ...(0, import_vue598.toRefs)(data),
    setText,
    removeElLoadingChild,
    close: close2,
    handleAfterLeave,
    vm,
    get $el() {
      return vm.$el;
    }
  };
}

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/loading/src/service.mjs
var fullscreenInstance = void 0;
var Loading = function(options = {}) {
  if (!isClient)
    return void 0;
  const resolved = resolveOptions(options);
  if (resolved.fullscreen && fullscreenInstance) {
    return fullscreenInstance;
  }
  const instance = createLoadingComponent({
    ...resolved,
    closed: () => {
      var _a2;
      (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
      if (resolved.fullscreen)
        fullscreenInstance = void 0;
    }
  });
  addStyle(resolved, resolved.parent, instance);
  addClassList(resolved, resolved.parent, instance);
  resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
  let loadingNumber = resolved.parent.getAttribute("loading-number");
  if (!loadingNumber) {
    loadingNumber = "1";
  } else {
    loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
  }
  resolved.parent.setAttribute("loading-number", loadingNumber);
  resolved.parent.appendChild(instance.$el);
  (0, import_vue599.nextTick)(() => instance.visible.value = resolved.visible);
  if (resolved.fullscreen) {
    fullscreenInstance = instance;
  }
  return instance;
};
var resolveOptions = (options) => {
  var _a2, _b, _c, _d;
  let target;
  if ((0, import_shared113.isString)(options.target)) {
    target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
  } else {
    target = options.target || document.body;
  }
  return {
    parent: target === document.body || options.body ? document.body : target,
    background: options.background || "",
    svg: options.svg || "",
    svgViewBox: options.svgViewBox || "",
    spinner: options.spinner || false,
    text: options.text || "",
    fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
    lock: (_c = options.lock) != null ? _c : false,
    customClass: options.customClass || "",
    visible: (_d = options.visible) != null ? _d : true,
    target
  };
};
var addStyle = async (options, parent, instance) => {
  const { nextZIndex } = useZIndex();
  const maskStyle = {};
  if (options.fullscreen) {
    instance.originalPosition.value = getStyle(document.body, "position");
    instance.originalOverflow.value = getStyle(document.body, "overflow");
    maskStyle.zIndex = nextZIndex();
  } else if (options.parent === document.body) {
    instance.originalPosition.value = getStyle(document.body, "position");
    await (0, import_vue599.nextTick)();
    for (const property2 of ["top", "left"]) {
      const scroll = property2 === "top" ? "scrollTop" : "scrollLeft";
      maskStyle[property2] = `${options.target.getBoundingClientRect()[property2] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property2}`), 10)}px`;
    }
    for (const property2 of ["height", "width"]) {
      maskStyle[property2] = `${options.target.getBoundingClientRect()[property2]}px`;
    }
  } else {
    instance.originalPosition.value = getStyle(parent, "position");
  }
  for (const [key, value] of Object.entries(maskStyle)) {
    instance.$el.style[key] = value;
  }
};
var addClassList = (options, parent, instance) => {
  const ns2 = useNamespace("loading");
  if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
    addClass(parent, ns2.bm("parent", "relative"));
  } else {
    removeClass(parent, ns2.bm("parent", "relative"));
  }
  if (options.fullscreen && options.lock) {
    addClass(parent, ns2.bm("parent", "hidden"));
  } else {
    removeClass(parent, ns2.bm("parent", "hidden"));
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/loading/src/directive.mjs
var import_vue600 = require("vue");
var import_shared114 = require("@vue/shared");
var INSTANCE_KEY = Symbol("ElLoading");
var createInstance = (el, binding) => {
  var _a2, _b, _c, _d;
  const vm = binding.instance;
  const getBindingProp = (key) => (0, import_shared114.isObject)(binding.value) ? binding.value[key] : void 0;
  const resolveExpression = (key) => {
    const data = (0, import_shared114.isString)(key) && (vm == null ? void 0 : vm[key]) || key;
    if (data)
      return (0, import_vue600.ref)(data);
    else
      return data;
  };
  const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${(0, import_shared114.hyphenate)(name)}`));
  const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
  const options = {
    text: getProp2("text"),
    svg: getProp2("svg"),
    svgViewBox: getProp2("svgViewBox"),
    spinner: getProp2("spinner"),
    background: getProp2("background"),
    customClass: getProp2("customClass"),
    fullscreen,
    target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
    body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
    lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
  };
  el[INSTANCE_KEY] = {
    options,
    instance: Loading(options)
  };
};
var updateOptions = (newOptions, originalOptions) => {
  for (const key of Object.keys(originalOptions)) {
    if ((0, import_vue600.isRef)(originalOptions[key]))
      originalOptions[key].value = newOptions[key];
  }
};
var vLoading = {
  mounted(el, binding) {
    if (binding.value) {
      createInstance(el, binding);
    }
  },
  updated(el, binding) {
    const instance = el[INSTANCE_KEY];
    if (binding.oldValue !== binding.value) {
      if (binding.value && !binding.oldValue) {
        createInstance(el, binding);
      } else if (binding.value && binding.oldValue) {
        if ((0, import_shared114.isObject)(binding.value))
          updateOptions(binding.value, instance.options);
      } else {
        instance == null ? void 0 : instance.instance.close();
      }
    }
  },
  unmounted(el) {
    var _a2;
    (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
  }
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/loading/index.mjs
var ElLoading = {
  install(app) {
    app.directive("loading", vLoading);
    app.config.globalProperties.$loading = Loading;
  },
  directive: vLoading,
  service: Loading
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/src/method.mjs
var import_vue603 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/src/message2.mjs
var import_vue602 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/src/message.mjs
var messageTypes = ["success", "info", "warning", "error"];
var messageDefaults = mutable({
  customClass: "",
  center: false,
  dangerouslyUseHTMLString: false,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: false,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: false,
  repeatNum: 1,
  appendTo: isClient ? document.body : void 0
});
var messageProps = buildProps({
  customClass: {
    type: String,
    default: messageDefaults.customClass
  },
  center: {
    type: Boolean,
    default: messageDefaults.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: messageDefaults.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: messageDefaults.duration
  },
  icon: {
    type: iconPropType,
    default: messageDefaults.icon
  },
  id: {
    type: String,
    default: messageDefaults.id
  },
  message: {
    type: definePropType([
      String,
      Object,
      Function
    ]),
    default: messageDefaults.message
  },
  onClose: {
    type: definePropType(Function),
    required: false
  },
  showClose: {
    type: Boolean,
    default: messageDefaults.showClose
  },
  type: {
    type: String,
    values: messageTypes,
    default: messageDefaults.type
  },
  offset: {
    type: Number,
    default: messageDefaults.offset
  },
  zIndex: {
    type: Number,
    default: messageDefaults.zIndex
  },
  grouping: {
    type: Boolean,
    default: messageDefaults.grouping
  },
  repeatNum: {
    type: Number,
    default: messageDefaults.repeatNum
  }
});
var messageEmits = {
  destroy: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/src/instance.mjs
var import_vue601 = require("vue");
var instances = (0, import_vue601.shallowReactive)([]);
var getInstance = (id2) => {
  const idx = instances.findIndex((instance) => instance.id === id2);
  const current = instances[idx];
  let prev;
  if (idx > 0) {
    prev = instances[idx - 1];
  }
  return { current, prev };
};
var getLastOffset = (id2) => {
  const { prev } = getInstance(id2);
  if (!prev)
    return 0;
  return prev.vm.exposed.bottom.value;
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/src/message2.mjs
var _hoisted_189 = ["id"];
var _hoisted_258 = ["innerHTML"];
var __default__99 = (0, import_vue602.defineComponent)({
  name: "ElMessage"
});
var _sfc_main144 = /* @__PURE__ */ (0, import_vue602.defineComponent)({
  ...__default__99,
  props: messageProps,
  emits: messageEmits,
  setup(__props, { expose }) {
    const props = __props;
    const { Close } = TypeComponents;
    const ns2 = useNamespace("message");
    const messageRef = (0, import_vue602.ref)();
    const visible = (0, import_vue602.ref)(false);
    const height = (0, import_vue602.ref)(0);
    let stopTimer = void 0;
    const badgeType = (0, import_vue602.computed)(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
    const typeClass = (0, import_vue602.computed)(() => {
      const type4 = props.type;
      return { [ns2.bm("icon", type4)]: type4 && TypeComponentsMap[type4] };
    });
    const iconComponent = (0, import_vue602.computed)(() => props.icon || TypeComponentsMap[props.type] || "");
    const lastOffset = (0, import_vue602.computed)(() => getLastOffset(props.id));
    const offset2 = (0, import_vue602.computed)(() => props.offset + lastOffset.value);
    const bottom = (0, import_vue602.computed)(() => height.value + offset2.value);
    const customStyle = (0, import_vue602.computed)(() => ({
      top: `${offset2.value}px`,
      zIndex: props.zIndex
    }));
    function startTimer() {
      if (props.duration === 0)
        return;
      ({ stop: stopTimer } = useTimeoutFn(() => {
        close2();
      }, props.duration));
    }
    function clearTimer() {
      stopTimer == null ? void 0 : stopTimer();
    }
    function close2() {
      visible.value = false;
    }
    function keydown({ code }) {
      if (code === EVENT_CODE.esc) {
        close2();
      }
    }
    (0, import_vue602.onMounted)(() => {
      startTimer();
      visible.value = true;
    });
    (0, import_vue602.watch)(() => props.repeatNum, () => {
      clearTimer();
      startTimer();
    });
    useEventListener(document, "keydown", keydown);
    useResizeObserver(messageRef, () => {
      height.value = messageRef.value.getBoundingClientRect().height;
    });
    expose({
      visible,
      bottom,
      close: close2
    });
    return (_ctx, _cache) => {
      return (0, import_vue602.openBlock)(), (0, import_vue602.createBlock)(import_vue602.Transition, {
        name: (0, import_vue602.unref)(ns2).b("fade"),
        onBeforeLeave: _ctx.onClose,
        onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
        persisted: ""
      }, {
        default: (0, import_vue602.withCtx)(() => [
          (0, import_vue602.withDirectives)((0, import_vue602.createElementVNode)("div", {
            id: _ctx.id,
            ref_key: "messageRef",
            ref: messageRef,
            class: (0, import_vue602.normalizeClass)([
              (0, import_vue602.unref)(ns2).b(),
              { [(0, import_vue602.unref)(ns2).m(_ctx.type)]: _ctx.type && !_ctx.icon },
              (0, import_vue602.unref)(ns2).is("center", _ctx.center),
              (0, import_vue602.unref)(ns2).is("closable", _ctx.showClose),
              _ctx.customClass
            ]),
            style: (0, import_vue602.normalizeStyle)((0, import_vue602.unref)(customStyle)),
            role: "alert",
            onMouseenter: clearTimer,
            onMouseleave: startTimer
          }, [
            _ctx.repeatNum > 1 ? ((0, import_vue602.openBlock)(), (0, import_vue602.createBlock)((0, import_vue602.unref)(ElBadge), {
              key: 0,
              value: _ctx.repeatNum,
              type: (0, import_vue602.unref)(badgeType),
              class: (0, import_vue602.normalizeClass)((0, import_vue602.unref)(ns2).e("badge"))
            }, null, 8, ["value", "type", "class"])) : (0, import_vue602.createCommentVNode)("v-if", true),
            (0, import_vue602.unref)(iconComponent) ? ((0, import_vue602.openBlock)(), (0, import_vue602.createBlock)((0, import_vue602.unref)(ElIcon), {
              key: 1,
              class: (0, import_vue602.normalizeClass)([(0, import_vue602.unref)(ns2).e("icon"), (0, import_vue602.unref)(typeClass)])
            }, {
              default: (0, import_vue602.withCtx)(() => [
                ((0, import_vue602.openBlock)(), (0, import_vue602.createBlock)((0, import_vue602.resolveDynamicComponent)((0, import_vue602.unref)(iconComponent))))
              ]),
              _: 1
            }, 8, ["class"])) : (0, import_vue602.createCommentVNode)("v-if", true),
            (0, import_vue602.renderSlot)(_ctx.$slots, "default", {}, () => [
              !_ctx.dangerouslyUseHTMLString ? ((0, import_vue602.openBlock)(), (0, import_vue602.createElementBlock)("p", {
                key: 0,
                class: (0, import_vue602.normalizeClass)((0, import_vue602.unref)(ns2).e("content"))
              }, (0, import_vue602.toDisplayString)(_ctx.message), 3)) : ((0, import_vue602.openBlock)(), (0, import_vue602.createElementBlock)(import_vue602.Fragment, { key: 1 }, [
                (0, import_vue602.createCommentVNode)(" Caution here, message could've been compromised, never use user's input as message "),
                (0, import_vue602.createElementVNode)("p", {
                  class: (0, import_vue602.normalizeClass)((0, import_vue602.unref)(ns2).e("content")),
                  innerHTML: _ctx.message
                }, null, 10, _hoisted_258)
              ], 2112))
            ]),
            _ctx.showClose ? ((0, import_vue602.openBlock)(), (0, import_vue602.createBlock)((0, import_vue602.unref)(ElIcon), {
              key: 2,
              class: (0, import_vue602.normalizeClass)((0, import_vue602.unref)(ns2).e("closeBtn")),
              onClick: (0, import_vue602.withModifiers)(close2, ["stop"])
            }, {
              default: (0, import_vue602.withCtx)(() => [
                (0, import_vue602.createVNode)((0, import_vue602.unref)(Close))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : (0, import_vue602.createCommentVNode)("v-if", true)
          ], 46, _hoisted_189), [
            [import_vue602.vShow, visible.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave"]);
    };
  }
});
var MessageConstructor = /* @__PURE__ */ _export_sfc(_sfc_main144, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/src/method.mjs
var import_shared115 = require("@vue/shared");
var seed = 1;
var normalizeOptions = (params) => {
  const options = !params || (0, import_shared115.isString)(params) || (0, import_vue603.isVNode)(params) || (0, import_shared115.isFunction)(params) ? { message: params } : params;
  const normalized = {
    ...messageDefaults,
    ...options
  };
  if (!normalized.appendTo) {
    normalized.appendTo = document.body;
  } else if ((0, import_shared115.isString)(normalized.appendTo)) {
    let appendTo = document.querySelector(normalized.appendTo);
    if (!isElement(appendTo)) {
      debugWarn("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body.");
      appendTo = document.body;
    }
    normalized.appendTo = appendTo;
  }
  return normalized;
};
var closeMessage = (instance) => {
  const idx = instances.indexOf(instance);
  if (idx === -1)
    return;
  instances.splice(idx, 1);
  const { handler } = instance;
  handler.close();
};
var createMessage = ({ appendTo, ...options }, context) => {
  const { nextZIndex } = useZIndex();
  const id2 = `message_${seed++}`;
  const userOnClose = options.onClose;
  const container = document.createElement("div");
  const props = {
    ...options,
    zIndex: nextZIndex() + options.zIndex,
    id: id2,
    onClose: () => {
      userOnClose == null ? void 0 : userOnClose();
      closeMessage(instance);
    },
    onDestroy: () => {
      (0, import_vue603.render)(null, container);
    }
  };
  const vnode = (0, import_vue603.createVNode)(MessageConstructor, props, (0, import_shared115.isFunction)(props.message) || (0, import_vue603.isVNode)(props.message) ? {
    default: (0, import_shared115.isFunction)(props.message) ? props.message : () => props.message
  } : null);
  vnode.appContext = context || message._context;
  (0, import_vue603.render)(vnode, container);
  appendTo.appendChild(container.firstElementChild);
  const vm = vnode.component;
  const handler = {
    close: () => {
      vm.exposed.visible.value = false;
    }
  };
  const instance = {
    id: id2,
    vnode,
    vm,
    handler,
    props: vnode.component.props
  };
  return instance;
};
var message = (options = {}, context) => {
  if (!isClient)
    return { close: () => void 0 };
  if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
    return { close: () => void 0 };
  }
  const normalized = normalizeOptions(options);
  if (normalized.grouping && instances.length) {
    const instance2 = instances.find(({ vnode: vm }) => {
      var _a2;
      return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
    });
    if (instance2) {
      instance2.props.repeatNum += 1;
      instance2.props.type = normalized.type;
      return instance2.handler;
    }
  }
  const instance = createMessage(normalized, context);
  instances.push(instance);
  return instance.handler;
};
messageTypes.forEach((type4) => {
  message[type4] = (options = {}, appContext) => {
    const normalized = normalizeOptions(options);
    return message({ ...normalized, type: type4 }, appContext);
  };
});
function closeAll(type4) {
  for (const instance of instances) {
    if (!type4 || type4 === instance.props.type) {
      instance.handler.close();
    }
  }
}
message.closeAll = closeAll;
message._context = null;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message/index.mjs
var ElMessage = withInstallFunction(message, "$message");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message-box/src/messageBox.mjs
var import_vue605 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message-box/src/index.mjs
var import_vue604 = require("vue");
var _sfc_main145 = (0, import_vue604.defineComponent)({
  name: "ElMessageBox",
  directives: {
    TrapFocus
  },
  components: {
    ElButton,
    ElFocusTrap,
    ElInput,
    ElOverlay,
    ElIcon,
    ...TypeComponents
  },
  inheritAttrs: false,
  props: {
    buttonSize: {
      type: String,
      validator: isValidComponentSize
    },
    modal: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    center: Boolean,
    draggable: Boolean,
    roundButton: {
      default: false,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(props, { emit }) {
    const { t } = useLocale();
    const ns2 = useNamespace("message-box");
    const visible = (0, import_vue604.ref)(false);
    const { nextZIndex } = useZIndex();
    const state = (0, import_vue604.reactive)({
      autofocus: true,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: false,
      distinguishCancelAndClose: false,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: true,
      modalClass: "",
      showCancelButton: false,
      showConfirmButton: true,
      type: "",
      title: void 0,
      showInput: false,
      action: "",
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonDisabled: false,
      editorErrorMessage: "",
      validateError: false,
      zIndex: nextZIndex()
    });
    const typeClass = (0, import_vue604.computed)(() => {
      const type4 = state.type;
      return { [ns2.bm("icon", type4)]: type4 && TypeComponentsMap[type4] };
    });
    const contentId = useId();
    const inputId = useId();
    const btnSize = useSize((0, import_vue604.computed)(() => props.buttonSize), { prop: true, form: true, formItem: true });
    const iconComponent = (0, import_vue604.computed)(() => state.icon || TypeComponentsMap[state.type] || "");
    const hasMessage = (0, import_vue604.computed)(() => !!state.message);
    const rootRef = (0, import_vue604.ref)();
    const headerRef = (0, import_vue604.ref)();
    const focusStartRef = (0, import_vue604.ref)();
    const inputRef = (0, import_vue604.ref)();
    const confirmRef = (0, import_vue604.ref)();
    const confirmButtonClasses = (0, import_vue604.computed)(() => state.confirmButtonClass);
    (0, import_vue604.watch)(() => state.inputValue, async (val) => {
      await (0, import_vue604.nextTick)();
      if (props.boxType === "prompt" && val !== null) {
        validate();
      }
    }, { immediate: true });
    (0, import_vue604.watch)(() => visible.value, (val) => {
      var _a2, _b;
      if (val) {
        if (props.boxType !== "prompt") {
          if (state.autofocus) {
            focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
          } else {
            focusStartRef.value = rootRef.value;
          }
        }
        state.zIndex = nextZIndex();
      }
      if (props.boxType !== "prompt")
        return;
      if (val) {
        (0, import_vue604.nextTick)().then(() => {
          var _a22;
          if (inputRef.value && inputRef.value.$el) {
            if (state.autofocus) {
              focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
            } else {
              focusStartRef.value = rootRef.value;
            }
          }
        });
      } else {
        state.editorErrorMessage = "";
        state.validateError = false;
      }
    });
    const draggable2 = (0, import_vue604.computed)(() => props.draggable);
    useDraggable(rootRef, headerRef, draggable2);
    (0, import_vue604.onMounted)(async () => {
      await (0, import_vue604.nextTick)();
      if (props.closeOnHashChange) {
        window.addEventListener("hashchange", doClose);
      }
    });
    (0, import_vue604.onBeforeUnmount)(() => {
      if (props.closeOnHashChange) {
        window.removeEventListener("hashchange", doClose);
      }
    });
    function doClose() {
      if (!visible.value)
        return;
      visible.value = false;
      (0, import_vue604.nextTick)(() => {
        if (state.action)
          emit("action", state.action);
      });
    }
    const handleWrapperClick = () => {
      if (props.closeOnClickModal) {
        handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
      }
    };
    const overlayEvent = useSameTarget(handleWrapperClick);
    const handleInputEnter = (e) => {
      if (state.inputType !== "textarea") {
        e.preventDefault();
        return handleAction("confirm");
      }
    };
    const handleAction = (action) => {
      var _a2;
      if (props.boxType === "prompt" && action === "confirm" && !validate()) {
        return;
      }
      state.action = action;
      if (state.beforeClose) {
        (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
      } else {
        doClose();
      }
    };
    const validate = () => {
      if (props.boxType === "prompt") {
        const inputPattern = state.inputPattern;
        if (inputPattern && !inputPattern.test(state.inputValue || "")) {
          state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
          state.validateError = true;
          return false;
        }
        const inputValidator = state.inputValidator;
        if (typeof inputValidator === "function") {
          const validateResult = inputValidator(state.inputValue);
          if (validateResult === false) {
            state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
            state.validateError = true;
            return false;
          }
          if (typeof validateResult === "string") {
            state.editorErrorMessage = validateResult;
            state.validateError = true;
            return false;
          }
        }
      }
      state.editorErrorMessage = "";
      state.validateError = false;
      return true;
    };
    const getInputElement = () => {
      const inputRefs = inputRef.value.$refs;
      return inputRefs.input || inputRefs.textarea;
    };
    const handleClose = () => {
      handleAction("close");
    };
    const onCloseRequested = () => {
      if (props.closeOnPressEscape) {
        handleClose();
      }
    };
    if (props.lockScroll) {
      useLockscreen(visible);
    }
    useRestoreActive(visible);
    return {
      ...(0, import_vue604.toRefs)(state),
      ns: ns2,
      overlayEvent,
      visible,
      hasMessage,
      typeClass,
      contentId,
      inputId,
      btnSize,
      iconComponent,
      confirmButtonClasses,
      rootRef,
      focusStartRef,
      headerRef,
      inputRef,
      confirmRef,
      doClose,
      handleClose,
      onCloseRequested,
      handleWrapperClick,
      handleInputEnter,
      handleAction,
      t
    };
  }
});
var _hoisted_191 = ["aria-label", "aria-describedby"];
var _hoisted_259 = ["aria-label"];
var _hoisted_325 = ["id"];
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = (0, import_vue604.resolveComponent)("el-icon");
  const _component_close = (0, import_vue604.resolveComponent)("close");
  const _component_el_input = (0, import_vue604.resolveComponent)("el-input");
  const _component_el_button = (0, import_vue604.resolveComponent)("el-button");
  const _component_el_focus_trap = (0, import_vue604.resolveComponent)("el-focus-trap");
  const _component_el_overlay = (0, import_vue604.resolveComponent)("el-overlay");
  return (0, import_vue604.openBlock)(), (0, import_vue604.createBlock)(import_vue604.Transition, {
    name: "fade-in-linear",
    onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
    persisted: ""
  }, {
    default: (0, import_vue604.withCtx)(() => [
      (0, import_vue604.withDirectives)((0, import_vue604.createVNode)(_component_el_overlay, {
        "z-index": _ctx.zIndex,
        "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
        mask: _ctx.modal
      }, {
        default: (0, import_vue604.withCtx)(() => [
          (0, import_vue604.createElementVNode)("div", {
            role: "dialog",
            "aria-label": _ctx.title,
            "aria-modal": "true",
            "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
            class: (0, import_vue604.normalizeClass)(`${_ctx.ns.namespace.value}-overlay-message-box`),
            onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
            onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
            onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
          }, [
            (0, import_vue604.createVNode)(_component_el_focus_trap, {
              loop: "",
              trapped: _ctx.visible,
              "focus-trap-el": _ctx.rootRef,
              "focus-start-el": _ctx.focusStartRef,
              onReleaseRequested: _ctx.onCloseRequested
            }, {
              default: (0, import_vue604.withCtx)(() => [
                (0, import_vue604.createElementVNode)("div", {
                  ref: "rootRef",
                  class: (0, import_vue604.normalizeClass)([
                    _ctx.ns.b(),
                    _ctx.customClass,
                    _ctx.ns.is("draggable", _ctx.draggable),
                    { [_ctx.ns.m("center")]: _ctx.center }
                  ]),
                  style: (0, import_vue604.normalizeStyle)(_ctx.customStyle),
                  tabindex: "-1",
                  onClick: _cache[7] || (_cache[7] = (0, import_vue604.withModifiers)(() => {
                  }, ["stop"]))
                }, [
                  _ctx.title !== null && _ctx.title !== void 0 ? ((0, import_vue604.openBlock)(), (0, import_vue604.createElementBlock)("div", {
                    key: 0,
                    ref: "headerRef",
                    class: (0, import_vue604.normalizeClass)(_ctx.ns.e("header"))
                  }, [
                    (0, import_vue604.createElementVNode)("div", {
                      class: (0, import_vue604.normalizeClass)(_ctx.ns.e("title"))
                    }, [
                      _ctx.iconComponent && _ctx.center ? ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)(_component_el_icon, {
                        key: 0,
                        class: (0, import_vue604.normalizeClass)([_ctx.ns.e("status"), _ctx.typeClass])
                      }, {
                        default: (0, import_vue604.withCtx)(() => [
                          ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)((0, import_vue604.resolveDynamicComponent)(_ctx.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : (0, import_vue604.createCommentVNode)("v-if", true),
                      (0, import_vue604.createElementVNode)("span", null, (0, import_vue604.toDisplayString)(_ctx.title), 1)
                    ], 2),
                    _ctx.showClose ? ((0, import_vue604.openBlock)(), (0, import_vue604.createElementBlock)("button", {
                      key: 0,
                      type: "button",
                      class: (0, import_vue604.normalizeClass)(_ctx.ns.e("headerbtn")),
                      "aria-label": _ctx.t("el.messagebox.close"),
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                      onKeydown: _cache[1] || (_cache[1] = (0, import_vue604.withKeys)((0, import_vue604.withModifiers)(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                    }, [
                      (0, import_vue604.createVNode)(_component_el_icon, {
                        class: (0, import_vue604.normalizeClass)(_ctx.ns.e("close"))
                      }, {
                        default: (0, import_vue604.withCtx)(() => [
                          (0, import_vue604.createVNode)(_component_close)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, _hoisted_259)) : (0, import_vue604.createCommentVNode)("v-if", true)
                  ], 2)) : (0, import_vue604.createCommentVNode)("v-if", true),
                  (0, import_vue604.createElementVNode)("div", {
                    id: _ctx.contentId,
                    class: (0, import_vue604.normalizeClass)(_ctx.ns.e("content"))
                  }, [
                    (0, import_vue604.createElementVNode)("div", {
                      class: (0, import_vue604.normalizeClass)(_ctx.ns.e("container"))
                    }, [
                      _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)(_component_el_icon, {
                        key: 0,
                        class: (0, import_vue604.normalizeClass)([_ctx.ns.e("status"), _ctx.typeClass])
                      }, {
                        default: (0, import_vue604.withCtx)(() => [
                          ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)((0, import_vue604.resolveDynamicComponent)(_ctx.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : (0, import_vue604.createCommentVNode)("v-if", true),
                      _ctx.hasMessage ? ((0, import_vue604.openBlock)(), (0, import_vue604.createElementBlock)("div", {
                        key: 1,
                        class: (0, import_vue604.normalizeClass)(_ctx.ns.e("message"))
                      }, [
                        (0, import_vue604.renderSlot)(_ctx.$slots, "default", {}, () => [
                          !_ctx.dangerouslyUseHTMLString ? ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)((0, import_vue604.resolveDynamicComponent)(_ctx.showInput ? "label" : "p"), {
                            key: 0,
                            for: _ctx.showInput ? _ctx.inputId : void 0
                          }, {
                            default: (0, import_vue604.withCtx)(() => [
                              (0, import_vue604.createTextVNode)((0, import_vue604.toDisplayString)(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                            ]),
                            _: 1
                          }, 8, ["for"])) : ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)((0, import_vue604.resolveDynamicComponent)(_ctx.showInput ? "label" : "p"), {
                            key: 1,
                            for: _ctx.showInput ? _ctx.inputId : void 0,
                            innerHTML: _ctx.message
                          }, null, 8, ["for", "innerHTML"]))
                        ])
                      ], 2)) : (0, import_vue604.createCommentVNode)("v-if", true)
                    ], 2),
                    (0, import_vue604.withDirectives)((0, import_vue604.createElementVNode)("div", {
                      class: (0, import_vue604.normalizeClass)(_ctx.ns.e("input"))
                    }, [
                      (0, import_vue604.createVNode)(_component_el_input, {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        modelValue: _ctx.inputValue,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                        type: _ctx.inputType,
                        placeholder: _ctx.inputPlaceholder,
                        "aria-invalid": _ctx.validateError,
                        class: (0, import_vue604.normalizeClass)({ invalid: _ctx.validateError }),
                        onKeydown: (0, import_vue604.withKeys)(_ctx.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      (0, import_vue604.createElementVNode)("div", {
                        class: (0, import_vue604.normalizeClass)(_ctx.ns.e("errormsg")),
                        style: (0, import_vue604.normalizeStyle)({
                          visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, (0, import_vue604.toDisplayString)(_ctx.editorErrorMessage), 7)
                    ], 2), [
                      [import_vue604.vShow, _ctx.showInput]
                    ])
                  ], 10, _hoisted_325),
                  (0, import_vue604.createElementVNode)("div", {
                    class: (0, import_vue604.normalizeClass)(_ctx.ns.e("btns"))
                  }, [
                    _ctx.showCancelButton ? ((0, import_vue604.openBlock)(), (0, import_vue604.createBlock)(_component_el_button, {
                      key: 0,
                      loading: _ctx.cancelButtonLoading,
                      class: (0, import_vue604.normalizeClass)([_ctx.cancelButtonClass]),
                      round: _ctx.roundButton,
                      size: _ctx.btnSize,
                      onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                      onKeydown: _cache[4] || (_cache[4] = (0, import_vue604.withKeys)((0, import_vue604.withModifiers)(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                    }, {
                      default: (0, import_vue604.withCtx)(() => [
                        (0, import_vue604.createTextVNode)((0, import_vue604.toDisplayString)(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "size"])) : (0, import_vue604.createCommentVNode)("v-if", true),
                    (0, import_vue604.withDirectives)((0, import_vue604.createVNode)(_component_el_button, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: _ctx.confirmButtonLoading,
                      class: (0, import_vue604.normalizeClass)([_ctx.confirmButtonClasses]),
                      round: _ctx.roundButton,
                      disabled: _ctx.confirmButtonDisabled,
                      size: _ctx.btnSize,
                      onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                      onKeydown: _cache[6] || (_cache[6] = (0, import_vue604.withKeys)((0, import_vue604.withModifiers)(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                    }, {
                      default: (0, import_vue604.withCtx)(() => [
                        (0, import_vue604.createTextVNode)((0, import_vue604.toDisplayString)(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "disabled", "size"]), [
                      [import_vue604.vShow, _ctx.showConfirmButton]
                    ])
                  ], 2)
                ], 6)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, _hoisted_191)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [import_vue604.vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
var MessageBoxConstructor = /* @__PURE__ */ _export_sfc(_sfc_main145, [["render", _sfc_render42], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message-box/src/messageBox.mjs
var import_shared116 = require("@vue/shared");
var messageInstance = /* @__PURE__ */ new Map();
var getAppendToElement = (props) => {
  let appendTo = document.body;
  if (props.appendTo) {
    if ((0, import_shared116.isString)(props.appendTo)) {
      appendTo = document.querySelector(props.appendTo);
    }
    if (isElement(props.appendTo)) {
      appendTo = props.appendTo;
    }
    if (!isElement(appendTo)) {
      debugWarn("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body.");
      appendTo = document.body;
    }
  }
  return appendTo;
};
var initInstance = (props, container, appContext = null) => {
  const vnode = (0, import_vue605.createVNode)(MessageBoxConstructor, props, (0, import_shared116.isFunction)(props.message) || (0, import_vue605.isVNode)(props.message) ? {
    default: (0, import_shared116.isFunction)(props.message) ? props.message : () => props.message
  } : null);
  vnode.appContext = appContext;
  (0, import_vue605.render)(vnode, container);
  getAppendToElement(props).appendChild(container.firstElementChild);
  return vnode.component;
};
var genContainer = () => {
  return document.createElement("div");
};
var showMessage = (options, appContext) => {
  const container = genContainer();
  options.onVanish = () => {
    (0, import_vue605.render)(null, container);
    messageInstance.delete(vm);
  };
  options.onAction = (action) => {
    const currentMsg = messageInstance.get(vm);
    let resolve;
    if (options.showInput) {
      resolve = { value: vm.inputValue, action };
    } else {
      resolve = action;
    }
    if (options.callback) {
      options.callback(resolve, instance.proxy);
    } else {
      if (action === "cancel" || action === "close") {
        if (options.distinguishCancelAndClose && action !== "cancel") {
          currentMsg.reject("close");
        } else {
          currentMsg.reject("cancel");
        }
      } else {
        currentMsg.resolve(resolve);
      }
    }
  };
  const instance = initInstance(options, container, appContext);
  const vm = instance.proxy;
  for (const prop in options) {
    if ((0, import_shared116.hasOwn)(options, prop) && !(0, import_shared116.hasOwn)(vm.$props, prop)) {
      vm[prop] = options[prop];
    }
  }
  vm.visible = true;
  return vm;
};
function MessageBox(options, appContext = null) {
  if (!isClient)
    return Promise.reject();
  let callback;
  if ((0, import_shared116.isString)(options) || (0, import_vue605.isVNode)(options)) {
    options = {
      message: options
    };
  } else {
    callback = options.callback;
  }
  return new Promise((resolve, reject) => {
    const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
    messageInstance.set(vm, {
      options,
      callback,
      resolve,
      reject
    });
  });
}
var MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
var MESSAGE_BOX_DEFAULT_OPTS = {
  alert: { closeOnPressEscape: false, closeOnClickModal: false },
  confirm: { showCancelButton: true },
  prompt: { showCancelButton: true, showInput: true }
};
MESSAGE_BOX_VARIANTS.forEach((boxType) => {
  ;
  MessageBox[boxType] = messageBoxFactory(boxType);
});
function messageBoxFactory(boxType) {
  return (message2, title, options, appContext) => {
    let titleOrOpts = "";
    if ((0, import_shared116.isObject)(title)) {
      options = title;
      titleOrOpts = "";
    } else if (isUndefined(title)) {
      titleOrOpts = "";
    } else {
      titleOrOpts = title;
    }
    return MessageBox(Object.assign({
      title: titleOrOpts,
      message: message2,
      type: "",
      ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
    }, options, {
      boxType
    }), appContext);
  };
}
MessageBox.close = () => {
  messageInstance.forEach((_2, vm) => {
    vm.doClose();
  });
  messageInstance.clear();
};
MessageBox._context = null;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/message-box/index.mjs
var _MessageBox = MessageBox;
_MessageBox.install = (app) => {
  _MessageBox._context = app._context;
  app.config.globalProperties.$msgbox = _MessageBox;
  app.config.globalProperties.$messageBox = _MessageBox;
  app.config.globalProperties.$alert = _MessageBox.alert;
  app.config.globalProperties.$confirm = _MessageBox.confirm;
  app.config.globalProperties.$prompt = _MessageBox.prompt;
};
var ElMessageBox = _MessageBox;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/notification/src/notify.mjs
var import_vue607 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/notification/src/notification2.mjs
var import_vue606 = require("vue");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/notification/src/notification.mjs
var notificationTypes = [
  "success",
  "info",
  "warning",
  "error"
];
var notificationProps = buildProps({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: iconPropType
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: definePropType([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: definePropType(Function),
    default: () => void 0
  },
  onClose: {
    type: definePropType(Function),
    required: true
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...notificationTypes, ""],
    default: ""
  },
  zIndex: {
    type: Number,
    default: 0
  }
});
var notificationEmits = {
  destroy: () => true
};

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/notification/src/notification2.mjs
var _hoisted_193 = ["id"];
var _hoisted_260 = ["textContent"];
var _hoisted_326 = { key: 0 };
var _hoisted_413 = ["innerHTML"];
var __default__100 = (0, import_vue606.defineComponent)({
  name: "ElNotification"
});
var _sfc_main146 = /* @__PURE__ */ (0, import_vue606.defineComponent)({
  ...__default__100,
  props: notificationProps,
  emits: notificationEmits,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("notification");
    const { Close } = CloseComponents;
    const visible = (0, import_vue606.ref)(false);
    let timer = void 0;
    const typeClass = (0, import_vue606.computed)(() => {
      const type4 = props.type;
      return type4 && TypeComponentsMap[props.type] ? ns2.m(type4) : "";
    });
    const iconComponent = (0, import_vue606.computed)(() => {
      if (!props.type)
        return props.icon;
      return TypeComponentsMap[props.type] || props.icon;
    });
    const horizontalClass = (0, import_vue606.computed)(() => props.position.endsWith("right") ? "right" : "left");
    const verticalProperty = (0, import_vue606.computed)(() => props.position.startsWith("top") ? "top" : "bottom");
    const positionStyle = (0, import_vue606.computed)(() => {
      return {
        [verticalProperty.value]: `${props.offset}px`,
        zIndex: props.zIndex
      };
    });
    function startTimer() {
      if (props.duration > 0) {
        ;
        ({ stop: timer } = useTimeoutFn(() => {
          if (visible.value)
            close2();
        }, props.duration));
      }
    }
    function clearTimer() {
      timer == null ? void 0 : timer();
    }
    function close2() {
      visible.value = false;
    }
    function onKeydown({ code }) {
      if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
        clearTimer();
      } else if (code === EVENT_CODE.esc) {
        if (visible.value) {
          close2();
        }
      } else {
        startTimer();
      }
    }
    (0, import_vue606.onMounted)(() => {
      startTimer();
      visible.value = true;
    });
    useEventListener(document, "keydown", onKeydown);
    expose({
      visible,
      close: close2
    });
    return (_ctx, _cache) => {
      return (0, import_vue606.openBlock)(), (0, import_vue606.createBlock)(import_vue606.Transition, {
        name: (0, import_vue606.unref)(ns2).b("fade"),
        onBeforeLeave: _ctx.onClose,
        onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
        persisted: ""
      }, {
        default: (0, import_vue606.withCtx)(() => [
          (0, import_vue606.withDirectives)((0, import_vue606.createElementVNode)("div", {
            id: _ctx.id,
            class: (0, import_vue606.normalizeClass)([(0, import_vue606.unref)(ns2).b(), _ctx.customClass, (0, import_vue606.unref)(horizontalClass)]),
            style: (0, import_vue606.normalizeStyle)((0, import_vue606.unref)(positionStyle)),
            role: "alert",
            onMouseenter: clearTimer,
            onMouseleave: startTimer,
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
          }, [
            (0, import_vue606.unref)(iconComponent) ? ((0, import_vue606.openBlock)(), (0, import_vue606.createBlock)((0, import_vue606.unref)(ElIcon), {
              key: 0,
              class: (0, import_vue606.normalizeClass)([(0, import_vue606.unref)(ns2).e("icon"), (0, import_vue606.unref)(typeClass)])
            }, {
              default: (0, import_vue606.withCtx)(() => [
                ((0, import_vue606.openBlock)(), (0, import_vue606.createBlock)((0, import_vue606.resolveDynamicComponent)((0, import_vue606.unref)(iconComponent))))
              ]),
              _: 1
            }, 8, ["class"])) : (0, import_vue606.createCommentVNode)("v-if", true),
            (0, import_vue606.createElementVNode)("div", {
              class: (0, import_vue606.normalizeClass)((0, import_vue606.unref)(ns2).e("group"))
            }, [
              (0, import_vue606.createElementVNode)("h2", {
                class: (0, import_vue606.normalizeClass)((0, import_vue606.unref)(ns2).e("title")),
                textContent: (0, import_vue606.toDisplayString)(_ctx.title)
              }, null, 10, _hoisted_260),
              (0, import_vue606.withDirectives)((0, import_vue606.createElementVNode)("div", {
                class: (0, import_vue606.normalizeClass)((0, import_vue606.unref)(ns2).e("content")),
                style: (0, import_vue606.normalizeStyle)(!!_ctx.title ? void 0 : { margin: 0 })
              }, [
                (0, import_vue606.renderSlot)(_ctx.$slots, "default", {}, () => [
                  !_ctx.dangerouslyUseHTMLString ? ((0, import_vue606.openBlock)(), (0, import_vue606.createElementBlock)("p", _hoisted_326, (0, import_vue606.toDisplayString)(_ctx.message), 1)) : ((0, import_vue606.openBlock)(), (0, import_vue606.createElementBlock)(import_vue606.Fragment, { key: 1 }, [
                    (0, import_vue606.createCommentVNode)(" Caution here, message could've been compromised, never use user's input as message "),
                    (0, import_vue606.createElementVNode)("p", { innerHTML: _ctx.message }, null, 8, _hoisted_413)
                  ], 2112))
                ])
              ], 6), [
                [import_vue606.vShow, _ctx.message]
              ]),
              _ctx.showClose ? ((0, import_vue606.openBlock)(), (0, import_vue606.createBlock)((0, import_vue606.unref)(ElIcon), {
                key: 0,
                class: (0, import_vue606.normalizeClass)((0, import_vue606.unref)(ns2).e("closeBtn")),
                onClick: (0, import_vue606.withModifiers)(close2, ["stop"])
              }, {
                default: (0, import_vue606.withCtx)(() => [
                  (0, import_vue606.createVNode)((0, import_vue606.unref)(Close))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (0, import_vue606.createCommentVNode)("v-if", true)
            ], 2)
          ], 46, _hoisted_193), [
            [import_vue606.vShow, visible.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave"]);
    };
  }
});
var NotificationConstructor = /* @__PURE__ */ _export_sfc(_sfc_main146, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/notification/src/notify.mjs
var import_shared117 = require("@vue/shared");
var notifications = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
};
var GAP_SIZE = 16;
var seed2 = 1;
var notify = function(options = {}, context = null) {
  if (!isClient)
    return { close: () => void 0 };
  if (typeof options === "string" || (0, import_vue607.isVNode)(options)) {
    options = { message: options };
  }
  const position = options.position || "top-right";
  let verticalOffset = options.offset || 0;
  notifications[position].forEach(({ vm: vm2 }) => {
    var _a2;
    verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
  });
  verticalOffset += GAP_SIZE;
  const { nextZIndex } = useZIndex();
  const id2 = `notification_${seed2++}`;
  const userOnClose = options.onClose;
  const props = {
    zIndex: nextZIndex(),
    ...options,
    offset: verticalOffset,
    id: id2,
    onClose: () => {
      close(id2, position, userOnClose);
    }
  };
  let appendTo = document.body;
  if (isElement(options.appendTo)) {
    appendTo = options.appendTo;
  } else if ((0, import_shared117.isString)(options.appendTo)) {
    appendTo = document.querySelector(options.appendTo);
  }
  if (!isElement(appendTo)) {
    debugWarn("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body.");
    appendTo = document.body;
  }
  const container = document.createElement("div");
  const vm = (0, import_vue607.createVNode)(NotificationConstructor, props, (0, import_vue607.isVNode)(props.message) ? {
    default: () => props.message
  } : null);
  vm.appContext = context != null ? context : notify._context;
  vm.props.onDestroy = () => {
    (0, import_vue607.render)(null, container);
  };
  (0, import_vue607.render)(vm, container);
  notifications[position].push({ vm });
  appendTo.appendChild(container.firstElementChild);
  return {
    close: () => {
      ;
      vm.component.exposed.visible.value = false;
    }
  };
};
notificationTypes.forEach((type4) => {
  notify[type4] = (options = {}) => {
    if (typeof options === "string" || (0, import_vue607.isVNode)(options)) {
      options = {
        message: options
      };
    }
    return notify({
      ...options,
      type: type4
    });
  };
});
function close(id2, position, userOnClose) {
  const orientedNotifications = notifications[position];
  const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
    var _a2;
    return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id2;
  });
  if (idx === -1)
    return;
  const { vm } = orientedNotifications[idx];
  if (!vm)
    return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = vm.el.offsetHeight;
  const verticalPos = position.split("-")[0];
  orientedNotifications.splice(idx, 1);
  const len = orientedNotifications.length;
  if (len < 1)
    return;
  for (let i = idx; i < len; i++) {
    const { el, component: component2 } = orientedNotifications[i].vm;
    const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
    component2.props.offset = pos;
  }
}
function closeAll2() {
  for (const orientedNotifications of Object.values(notifications)) {
    orientedNotifications.forEach(({ vm }) => {
      ;
      vm.component.exposed.visible.value = false;
    });
  }
}
notify.closeAll = closeAll2;
notify._context = null;

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/components/notification/index.mjs
var ElNotification = withInstallFunction(notify, "$notify");

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/plugin.mjs
var Plugins = [
  ElInfiniteScroll,
  ElLoading,
  ElMessage,
  ElMessageBox,
  ElNotification,
  ElPopoverDirective
];

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/defaults.mjs
var installer = makeInstaller([...Components, ...Plugins]);

// ../../node_modules/.pnpm/element-plus@2.2.28_vue@3.2.45/node_modules/element-plus/es/index.mjs
var import_dayjs17 = __toESM(require_dayjs_min(), 1);
var install2 = installer.install;
var version3 = installer.version;

// src/components/YoungTable.tsx
var YoungTable_default = (0, import_vue608.defineComponent)({
  props: {
    tableData: {
      type: Object,
      required: true
    },
    tableHead: {
      type: Object,
      required: true
    },
    tableHeight: {
      type: [Number, String],
      default: "100%"
    },
    selectable: {
      type: Boolean,
      default: false
    },
    rowDraggable: {
      type: Boolean,
      default: false
    },
    enableCustomHead: {
      type: Boolean,
      default: false
    }
  },
  emits: ["row-drag-change"],
  setup(props, { emit, attrs, slots }) {
    (0, import_vue608.onMounted)(async () => {
      if (props.rowDraggable) {
        const { default: Sortable2 } = await Promise.resolve().then(() => (init_sortable_esm(), sortable_esm_exports));
        if (props.rowDraggable) {
          const el = tableRef.value.$el.querySelector("tbody");
          el.style.cursor = "move";
          new Sortable2(el, {
            animation: 150,
            onEnd: ({ oldIndex: oldIndex2, newIndex: newIndex2 }) => {
              if (oldIndex2 === newIndex2) {
                return;
              }
              const data = tableData_drag.value;
              const row = I(data[oldIndex2]);
              data.splice(oldIndex2, 1);
              data.splice(newIndex2, 0, row);
              emit("row-drag-change", tableData_drag.value);
            }
          });
        }
      }
    });
    const tableRef = (0, import_vue608.ref)();
    (0, import_vue608.onActivated)(() => {
      (0, import_vue608.nextTick)(() => {
        tableRef.value.doLayout();
      });
    });
    const tableData_1 = (0, import_vue608.ref)([]);
    const tableHead_1 = (0, import_vue608.ref)([]);
    const tableData_drag = (0, import_vue608.ref)([]);
    (0, import_vue608.watchEffect)(() => {
      const t1 = props.tableData;
      const t2 = props.tableHead;
      const len = t1.length;
      (0, import_vue608.nextTick)(() => {
        tableHead_1.value = t2.filter((item) => !item.only_export);
        const step = 50;
        if (len <= step) {
          tableData_1.value = I(t1);
          tableData_drag.value = I(t1);
        } else {
          const { elArr, load } = useAutoLoad(tableData_1, (0, import_vue608.ref)(t1), step);
          const { elArr: elArr_drag, load: load_drag } = useAutoLoad(tableData_drag, (0, import_vue608.ref)(t1), step);
          let n = 0;
          tableData_1.value = t1.slice(n, step);
          tableData_drag.value = t1.slice(n, step);
          (0, import_vue608.nextTick)(() => {
            elArr.value = tableRef.value.$el.querySelector("tbody").children;
            load();
          });
          (0, import_vue608.nextTick)(() => {
            elArr_drag.value = tableRef.value.$el.querySelector("tbody").children;
            load_drag();
          });
        }
      });
    });
    const changeHead = (heads) => {
      tableHead_1.value = props.tableHead.filter(
        (item) => !item.only_export && heads.includes(item.prop)
      );
    };
    return () => <div style={{ position: "relative" }}>
      <ElTable
        {...attrs}
        ref={tableRef}
        data={tableData_1.value}
        style={{ width: "100%" }}
        height={props.tableHeight}
      >
        {props.selectable && <ElTableColumn2 type="selection" width="55" />}
        {tableHead_1.value.map((head, index2) => <ElTableColumn2
          key={index2}
          prop={head.prop}
          label={head.label}
          width={head.width || ""}
          sortable={head.sortable || false}
          fixed={head.fixed || false}
          align={head.aligin || "left"}
          showOverflowTooltip={head.show_overflow_tooltip ?? true}
          v-slots={{
            header: (scope) => {
              if (tableHead_1.value[index2].tool_content) {
                return <div
                  style={{
                    display: head.sortable ? "inline-block" : "flex",
                    justifyContent: "center",
                    alignItems: "center"
                  }}
                >
                  <span>{scope.column.label}</span>
                  <ElTooltip
                    placement="bottom"
                    v-slots={{ content: () => tableHead_1.value[index2].tool_content }}
                  ><svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="1.2em"
                    height="1.2em"
                    viewBox="0 0 256 256"
                  ><path
                    fill="currentColor"
                    d="M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm0 168a12 12 0 1 1 12-12a12 12 0 0 1-12 12Zm8-48.72v.72a8 8 0 0 1-16 0v-8a8 8 0 0 1 8-8c13.23 0 24-9 24-20s-10.77-20-24-20s-24 9-24 20v4a8 8 0 0 1-16 0v-4c0-19.85 17.94-36 40-36s40 16.15 40 36c0 17.38-13.76 31.93-32 35.28Z"
                  /></svg></ElTooltip>
                </div>;
              } else {
                return <span>{scope.column.label}</span>;
              }
            },
            default: (scope) => {
              if (head.render) {
                return head.render(scope.row, scope.$index);
              } else {
                return <span>{scope.row[head.prop]}</span>;
              }
            }
          }}
        />)}
        {slots.switch?.()}
        {slots.operate?.()}
      </ElTable>
      {props.enableCustomHead && <ElPopover trigger="click" placement="bottom-end" width={200}>{{
        reference: () => <div
          style={{ position: "absolute", top: 0, right: 0, zIndex: 2, cursor: "pointer" }}
          title={"\u8868\u5934\u914D\u7F6E"}
        ><svg
          xmlns="http://www.w3.org/2000/svg"
          width="1.5rem"
          height="1.5rem"
          viewBox="0 0 24 24"
        ><path
          fill="currentColor"
          d="M13.875 22h-3.75q-.375 0-.65-.25t-.325-.625l-.3-2.325q-.325-.125-.613-.3t-.562-.375l-2.175.9q-.35.125-.7.025t-.55-.425L2.4 15.4q-.2-.325-.125-.7t.375-.6l1.875-1.425Q4.5 12.5 4.5 12.337v-.674q0-.163.025-.338L2.65 9.9q-.3-.225-.375-.6t.125-.7l1.85-3.225q.175-.35.537-.438t.713.038l2.175.9q.275-.2.575-.375t.6-.3l.3-2.325q.05-.375.325-.625t.65-.25h3.75q.375 0 .65.25t.325.625l.3 2.325q.325.125.613.3t.562.375l2.175-.9q.35-.125.7-.025t.55.425L21.6 8.6q.2.325.125.7t-.375.6l-1.875 1.425q.025.175.025.338v.674q0 .163-.05.338l1.875 1.425q.3.225.375.6t-.125.7l-1.85 3.2q-.2.325-.563.438t-.712-.013l-2.125-.9q-.275.2-.575.375t-.6.3l-.3 2.325q-.05.375-.325.625t-.65.25Zm-1.825-6.5q1.45 0 2.475-1.025T15.55 12q0-1.45-1.025-2.475T12.05 8.5q-1.475 0-2.488 1.025T8.55 12q0 1.45 1.012 2.475T12.05 15.5Zm0-2q-.625 0-1.063-.438T10.55 12q0-.625.438-1.063t1.062-.437q.625 0 1.063.438T13.55 12q0 .625-.438 1.063t-1.062.437ZM12 12Zm-1 8h1.975l.35-2.65q.775-.2 1.438-.588t1.212-.937l2.475 1.025l.975-1.7l-2.15-1.625q.125-.35.175-.737T17.5 12q0-.4-.05-.787t-.175-.738l2.15-1.625l-.975-1.7l-2.475 1.05q-.55-.575-1.212-.962t-1.438-.588L13 4h-1.975l-.35 2.65q-.775.2-1.437.588t-1.213.937L5.55 7.15l-.975 1.7l2.15 1.6q-.125.375-.175.75t-.05.8q0 .4.05.775t.175.75l-2.15 1.625l.975 1.7l2.475-1.05q.55.575 1.213.963t1.437.587L11 20Z"
        /></svg></div>,
        default: () => <>
          <div style={{ marginBottom: "10px", textAlign: "center", fontWeight: "bold" }}>{"\u81EA\u5B9A\u4E49\u5C55\u793A\u7684\u8868\u5934"}</div>
          <ElCheckboxGroup
            style={{
              maxHeight: "350px",
              overflowY: "auto"
            }}
            modelValue={tableHead_1.value.map((item) => item.prop)}
            onUpdate:modelValue={changeHead}
          >{props.tableHead.filter((item) => !item.only_export).map((item, index2) => (
            // @ts-ignore
            <ElCheckbox label={item.prop} key={index2} title={item.label}>{item.label}</ElCheckbox>
          ))}</ElCheckboxGroup>
        </>
      }}</ElPopover>}
    </div>;
  }
});

// src/components/YoungPagination.tsx
var import_vue609 = require("vue");
var RequiredNumber = {
  type: Number,
  required: true
};
var YoungPagination_default = (0, import_vue609.defineComponent)({
  props: {
    total: RequiredNumber,
    page: RequiredNumber,
    limit: RequiredNumber,
    pageSizes: {
      type: Object,
      default: () => [10, 20, 30, 50]
    },
    layout: {
      type: String,
      default: "total, sizes, prev, pager, next, jumper"
    },
    background: {
      type: Boolean,
      default: true
    },
    autoScroll: {
      type: Boolean,
      default: true
    },
    hidden: {
      type: Boolean,
      default: false
    }
  },
  emits: ["page-change", "update:page", "update:limit"],
  setup(props, { emit, attrs }) {
    const sizeChange = (val) => {
      emit("update:page", 1);
      emit("update:limit", val);
      emit("page-change");
    };
    const pageChange = (val) => {
      emit("update:page", val);
      emit("page-change");
    };
    const ltSm = useMediaQuery("(max-width: 639.9px)");
    return () => <ElPagination
      style={{ background: "white", paddingTop: "20px", display: "flex", flexWrap: "wrap" }}
      {...attrs}
      background={props.background}
      currentPage={props.page}
      pageSize={props.limit}
      layout={ltSm.value ? "total, sizes, jumper" : props.layout}
      pageSizes={props.pageSizes}
      total={props.total}
      onUpdate:page-size={(v3) => sizeChange(v3)}
      onUpdate:current-page={(v3) => pageChange(v3)}
    />;
  }
});

// src/components/YoungDialog.tsx
var import_vue610 = require("vue");
var YoungDialog_default = (0, import_vue610.defineComponent)({
  props: {
    modelValue: Boolean,
    realTitle: String,
    width: {
      type: [String, Number],
      default: "50%"
    },
    sureText: {
      type: String,
      default: "\u786E\u5B9A"
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    showSure: {
      type: Boolean,
      default: true
    },
    showCancel: {
      type: Boolean,
      default: true
    },
    isAdd: Boolean,
    isEdit: Boolean,
    isMore: Boolean,
    sureFn: Function,
    /**
     * 对比 form 表单
     */
    diffForm: {
      type: Object,
      default: null
    }
  },
  emits: ["sure", "clear", "update:modelValue"],
  setup(props, { emit, attrs, slots }) {
    const formHash_before = (0, import_vue610.ref)("");
    const title = (0, import_vue610.computed)(() => {
      let str = "\u65B0\u5EFA";
      if (props.isEdit) {
        str = "\u7F16\u8F91";
      }
      if (props.isMore) {
        str = "\u8BE6\u60C5";
      }
      return str;
    });
    const showDialog = (0, import_vue610.computed)({
      get: () => props.isAdd || props.isMore || props.isEdit,
      set: (v3) => null
    });
    props.diffForm && (0, import_vue610.watch)(
      () => showDialog.value,
      (v3, o2) => {
        if (v3 && !o2) {
          formHash_before.value = JSON.stringify(props.diffForm);
        }
      }
    );
    props.diffForm && (0, import_vue610.watch)(
      () => props.modelValue,
      (v3, o2) => {
        if (v3 && !o2) {
          formHash_before.value = JSON.stringify(props.diffForm);
        }
      }
    );
    const sure = async () => {
      if (props.sureFn) {
        const res = await props.sureFn();
        if (res === false) {
          return;
        }
      }
      if (props.isMore) {
        emit("clear");
        return;
      }
      emit("update:modelValue", false);
      emit("sure");
    };
    const beforeClose = () => {
      const formHash_after = JSON.stringify(props.diffForm);
      if (props.isMore || !props.showCancel) {
        emit("clear");
        emit("update:modelValue", false);
        return;
      }
      if (props.diffForm && formHash_before.value === formHash_after) {
        emit("clear");
        emit("update:modelValue", false);
        return;
      } else {
        ElMessageBox.confirm("\u6570\u636E\u672A\u4FDD\u5B58\uFF0C\u5173\u95ED\u5C06\u4E22\u5931\u6570\u636E\uFF0C\u786E\u8BA4\u5173\u95ED\uFF1F", "\u63D0\u793A", {
          confirmButtonText: "\u786E\u8BA4",
          cancelButtonText: "\u53D6\u6D88"
        }).then(() => {
          emit("update:modelValue", false);
          emit("clear");
        }).catch(() => null);
      }
    };
    const ltLg = useMediaQuery("(max-width: 1023.9px)");
    return () => <import_vue610.Teleport to="body"><ElDialog
      {...attrs}
      modelValue={props.modelValue || showDialog.value}
      title={props.realTitle || title.value}
      width={ltLg.value ? "96%" : props.width}
      closeOnClickModal={true}
      closeOnPressEscape={false}
      beforeClose={beforeClose}
      v-slots={{
        default: () => slots.body?.(),
        footer: () => {
          return <>
            {slots.button?.()}
            {props.showCancel && <ElButton onClick={() => beforeClose()}>{props.cancelText}</ElButton>}
            {slots.step1?.()}
            {slots.step2?.()}
            {props.showSure && <ElButton type="primary" onClick={() => sure()}>{props.sureText}</ElButton>}
          </>;
        }
      }}
    /></import_vue610.Teleport>;
  }
});

// src/components/YoungSelect.tsx
var import_vue611 = require("vue");
var YoungSelect_default = (0, import_vue611.defineComponent)({
  props: {
    modelValue: {
      type: [String, Number, Array],
      required: false
    },
    options: {
      type: Object,
      required: true
    }
  },
  emits: ["update:modelValue", "change"],
  setup(props, { attrs, emit }) {
    const randomSeed = ne();
    return () => <ElSelect
      modelValue={props.modelValue}
      onUpdate:modelValue={(v3) => {
        emit("update:modelValue", v3);
        emit("change", v3);
      }}
      {...attrs}
    >{props.options.map((op, index2) => <ElOption {...op} key={index2 + randomSeed} />)}</ElSelect>;
  }
});

// src/components/YoungWeekday.tsx
var import_vue612 = require("vue");
var Weeks = ["\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D", "\u5468\u65E5"];
var YoungWeekday_default = (0, import_vue612.defineComponent)({
  props: {
    modelValue: {
      type: Object,
      required: true
    }
  },
  emits: ["update:modelValue", "change"],
  setup(props, { attrs, emit }) {
    const randomSeed = ne();
    const update = (v3) => {
      emit("update:modelValue", v3);
      emit("change", v3);
    };
    return () => <ElCheckboxGroup {...attrs} modelValue={props.modelValue} onChange={update}>{Weeks.map((w3, i) => <ElCheckbox label={i + 1} key={i + randomSeed}>{w3}</ElCheckbox>)}</ElCheckboxGroup>;
  }
});

// src/components/YoungTimeRange.tsx
var import_vue613 = require("vue");
var YoungTimeRange_default = (0, import_vue613.defineComponent)({
  props: {
    start: {
      type: String,
      required: true
    },
    end: {
      type: String,
      required: true
    },
    startTime: {
      type: String,
      default: "00:00"
    },
    endTime: {
      type: String,
      default: "23:59"
    },
    step: {
      type: String,
      default: "00:01"
    },
    /**
     * 是否精确到秒
     */
    second: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:start", "update:end", "change"],
  setup(props, { attrs, emit }) {
    const timePicker = (0, import_vue613.ref)();
    (0, import_vue613.watchEffect)(() => {
      if (props.start && props.end) {
        timePicker.value = [
          /* @__PURE__ */ new Date(`2022 02 02 ${props.start}`),
          /* @__PURE__ */ new Date(`2022 02 02 ${props.end}${props.second ? ":59" : ""}`)
        ];
      } else {
        timePicker.value = void 0;
      }
    });
    const update = (v3) => {
      if (!v3) {
        emit("update:start", "");
        emit("update:end", "");
      } else {
        const [start, end2] = v3;
        emit("update:start", start.toLocaleString().match(/\d\d:\d\d:\d\d/)?.[0] ?? "");
        emit("update:end", end2.toLocaleString().match(/\d\d:\d\d:\d\d/)?.[0] ?? "");
      }
      emit("change");
    };
    return () => !props.second ? <>
      <ElTimeSelect
        {...attrs}
        modelValue={props.start}
        class="w-120px mr-2"
        maxTime={props.end}
        placeholder={"\u5F00\u59CB\u65F6\u95F4"}
        start={props.startTime}
        step={props.step}
        end={props.endTime}
        onUpdate:modelValue={(v3) => emit("update:start", v3)}
      />
      {"- \xA0"}
      <ElTimeSelect
        {...attrs}
        modelValue={props.end}
        class="w-120px"
        minTime={props.start}
        placeholder={"\u7ED3\u675F\u65F6\u95F4"}
        start={props.startTime}
        step={props.step}
        end={props.endTime}
        onUpdate:modelValue={(v3) => emit("update:end", v3)}
      />
    </> : <ElTimePicker
      {...attrs}
      modelValue={timePicker.value}
      isRange
      startPlaceholder={"\u5F00\u59CB\u65F6\u95F4"}
      endPlaceholder={"\u7ED3\u675F\u65F6\u95F4"}
      onUpdate:modelValue={update}
    />;
  }
});

// src/components/YoungDateRange.tsx
var import_vue614 = require("vue");
var shortcuts = [
  {
    text: "\u4ECA\u5929",
    value: (() => {
      const end2 = /* @__PURE__ */ new Date();
      const start = /* @__PURE__ */ new Date();
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u6628\u5929",
    value: (() => {
      const end2 = /* @__PURE__ */ new Date();
      const start = /* @__PURE__ */ new Date();
      end2.setTime(start.getTime() - 3600 * 1e3 * 24 * 1);
      start.setTime(start.getTime() - 3600 * 1e3 * 24 * 1);
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u672C\u5468",
    value: (() => {
      const end2 = /* @__PURE__ */ new Date();
      const start = /* @__PURE__ */ new Date();
      var weekday = start.getDay() || 7;
      start.setDate(start.getDate() - weekday + 1);
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u4E0A\u5468",
    value: (() => {
      const now2 = /* @__PURE__ */ new Date();
      const weekStart = new Date(now2.getTime() - 7 * 24 * 3600 * 1e3);
      const weekEnd = new Date(now2.getTime() - 7 * 24 * 3600 * 1e3);
      const day = weekStart.getDay();
      const time = weekStart.getDate() - day + (day === 0 ? -6 : 1);
      const start = new Date(weekStart.setDate(time));
      const end2 = new Date(weekEnd.setDate(time + 6));
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u672C\u6708",
    value: (() => {
      const start = /* @__PURE__ */ new Date();
      const end2 = /* @__PURE__ */ new Date();
      start.setDate(1);
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u4E0A\u6708",
    value: (() => {
      const dayMSec = 24 * 3600 * 1e3;
      const today = /* @__PURE__ */ new Date();
      const start = new Date(today.getFullYear(), today.getMonth() - 1, 1);
      const nowMonthFirstDay = new Date(today.getFullYear(), today.getMonth(), 1);
      const lastMonthLastDayMSec = nowMonthFirstDay.getTime() - 1 * dayMSec;
      const end2 = new Date(lastMonthLastDayMSec);
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u6700\u8FD17\u5929",
    value: (() => {
      const end2 = /* @__PURE__ */ new Date();
      const start = /* @__PURE__ */ new Date();
      start.setTime(start.getTime() - 3600 * 1e3 * 24 * 6);
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  },
  {
    text: "\u6700\u8FD130\u5929",
    value: (() => {
      const end2 = /* @__PURE__ */ new Date();
      const start = /* @__PURE__ */ new Date();
      start.setTime(start.getTime() - 3600 * 1e3 * 24 * 30);
      start.setHours(0, 0, 0);
      end2.setHours(23, 59, 59);
      return [start, end2];
    })()
  }
];
var YoungDateRange_default = (0, import_vue614.defineComponent)({
  props: {
    start: {
      type: [String, Number],
      default: ""
    },
    end: {
      type: [String, Number],
      default: ""
    },
    unix: {
      type: Boolean,
      default: false
    },
    /**
     * 是否精确到秒
     */
    second: {
      type: Boolean,
      default: false
    },
    /**
     * 是否展示快捷选项
     * @cond1 传入 true，使用默认的快捷选项
     * @cond2 传入数组，使用数组作为快捷选项
     */
    shortcuts: {
      type: [Boolean, Array],
      default: false
    }
  },
  emits: ["update:start", "update:end", "change"],
  setup(props, { attrs, emit }) {
    const datePicker = (0, import_vue614.ref)();
    (0, import_vue614.watchEffect)(() => {
      if (props.start && props.end) {
        if (props.unix) {
          datePicker.value = [new Date(+props.start * 1e3), new Date(+props.end * 1e3)];
        } else {
          datePicker.value = [new Date(props.start), new Date(props.end)];
        }
      } else {
        datePicker.value = null;
      }
    });
    const update = (e) => {
      if (!e) {
        emit("update:start", void 0);
        emit("update:end", void 0);
        datePicker.value = null;
      } else {
        const [start, end2] = e;
        if (props.unix) {
          emit("update:start", Math.floor(start.getTime() / 1e3));
          emit("update:end", Math.floor(end2.getTime() / 1e3));
        } else {
          emit("update:start", start.getTime());
          emit("update:end", end2.getTime());
        }
      }
    };
    return () => <ElDatePicker
      {...attrs}
      modelValue={datePicker.value}
      type={props.second ? "datetimerange" : "daterange"}
      start-placeholder={"\u5F00\u59CB\u65E5\u671F"}
      end-placeholder={"\u7ED3\u675F\u65E5\u671F"}
      default-time={w()}
      shortcuts={props.shortcuts ? m(props.shortcuts) ? props.shortcuts : shortcuts : void 0}
      clearable
      onUpdate:modelValue={(e) => update(e)}
      onChange={() => emit("change")}
    />;
  }
});

// src/components/YoungImageViewer.tsx
var import_vue615 = require("vue");
var YoungImageViewer_default = (0, import_vue615.defineComponent)({
  props: {
    onDestroy: {
      type: Function,
      default: () => console.log("\u4E3A\u4E86\u8282\u7701\u6027\u80FD\uFF0C\u6B64\u65F6\u5E94\u8BE5\u9500\u6BC1dom")
    },
    zIndex: {
      type: Number,
      default: 9999
    }
  },
  setup(props, { expose }) {
    const showViewer = (0, import_vue615.ref)(false);
    const previewConfig = (0, import_vue615.reactive)({
      srcList: [],
      index: 0,
      zIndex: props.zIndex
    });
    function wheelHandler(e) {
      if (!e.ctrlKey)
        return;
      if (e.deltaY < 0) {
        e.preventDefault();
        return false;
      } else if (e.deltaY > 0) {
        e.preventDefault();
        return false;
      }
    }
    const stopWheelListener = useEventListener("wheel", wheelHandler, {
      passive: false
    });
    let prevOverflow;
    function show(conf) {
      previewConfig.srcList = conf.srcList;
      previewConfig.index = conf.index ?? 0;
      prevOverflow = document.body.style.overflow;
      document.body.style.overflow = "hidden";
      showViewer.value = true;
    }
    function close2() {
      stopWheelListener();
      document.body.style.overflow = prevOverflow;
      showViewer.value = false;
      props.onDestroy();
    }
    expose({
      show,
      close: close2
    });
    return () => showViewer.value && <ElImageViewer
      zIndex={previewConfig.zIndex}
      initialIndex={previewConfig.index}
      urlList={previewConfig.srcList}
      hideOnClickModal
      onClose={close2}
    />;
  }
});

// src/components/YoungSearchForm.tsx
var import_vue616 = require("vue");
var YoungSearchForm_default = (0, import_vue616.defineComponent)({
  props: {
    modelValue: Object,
    searchScheme: Object,
    fastSearch: {
      type: Boolean,
      default: true
    },
    onSearch: {
      type: Function,
      default: () => console.log("---\u8868\u5355\u5143\u7D20\u89E6\u53D1\u8BF7\u6C42---")
    },
    onReset: {
      type: Function,
      default: () => console.log("---\u89E6\u53D1\u91CD\u7F6E\u8BF7\u6C42---")
    },
    dateTimeKey: {
      type: Array,
      default: () => ["startcreatetime", "endcreatetime"]
    }
  },
  emits: ["update:modelValue"],
  setup(props, { attrs, emit, slots }) {
    const form = (0, import_vue616.ref)({});
    (0, import_vue616.watch)(
      () => props.modelValue,
      (v3) => {
        form.value = I(v3);
      },
      { immediate: true, deep: true }
    );
    const update = (up2 = true) => {
      emit("update:modelValue", { ...form.value });
      props.fastSearch && up2 && props.onSearch();
    };
    const renderItem = (key) => {
      const conf = props.searchScheme[key];
      if (!conf.attrs) {
        conf.attrs = {};
      }
      const wrapTip = (el, tip) => tip ? <ElFormItem label={conf.tip}>{el}</ElFormItem> : el;
      const [start, end2] = props.dateTimeKey;
      const EleMap = {
        input: () => {
          return wrapTip(
            <ElInput
              modelValue={form.value[key]}
              onUpdate:modelValue={(v3) => form.value[key] = v3?.trim?.()}
              onChange={() => update(false)}
              onKeyup={(e) => useKeyUp(e, () => update())}
              {...conf.attrs}
            />,
            conf.tip
          );
        },
        number: (key2) => wrapTip(
          <ElInputNumber
            modelValue={form.value[key2]}
            onUpdate:modelValue={(v3) => form.value[key2] = v3}
            onChange={() => update()}
            style={{ width: "120px" }}
            {...conf.attrs}
          />,
          conf.tip
        ),
        select: (key2) => wrapTip(
          <YoungSelect_default
            modelValue={form.value[key2]}
            options={conf.options || []}
            onUpdate:modelValue={(v3) => form.value[key2] = v3}
            onChange={() => update()}
            {...conf.attrs}
          />,
          conf.tip
        ),
        // ! 时间范围选择，通常全局只有一个
        datetimerange: (key2) => wrapTip(
          <YoungDateRange_default
            start={form.value[start]}
            end={form.value[end2]}
            onUpdate:start={(v3) => {
              form.value[start] = v3;
            }}
            onUpdate:end={(v3) => {
              form.value[end2] = v3;
            }}
            onChange={update}
            {...conf.attrs}
          />,
          conf.tip
        ),
        custom: (key2) => wrapTip(conf.render(), conf.tip)
      };
      const elRender = EleMap[conf.type];
      if (elRender) {
        return elRender(key);
      } else {
        throw new Error("unknown search form type");
      }
    };
    const randomSeed = ne();
    return () => <div style={{ maxWidth: "100%", margin: "auto", padding: "20px" }} {...attrs}><ElForm model={props.modelValue}>
      <div style={{ display: "flex", flexWrap: "wrap", gap: "10px 20px" }}>
        {Object.keys(props.searchScheme).map((key, index2) => <div key={index2 + randomSeed}>{renderItem(key)}</div>)}
        {
          /* 其他暂未包含的类型 */
        }
        <div>{slots.custom?.()}</div>
      </div>
      <div style={{ display: "flex" }}>
        <ElButton type="primary" onClick={() => props.onSearch()}>{"\u641C\u7D22"}</ElButton>
        <ElButton onClick={() => props.onReset()}>{"\u91CD\u7F6E"}</ElButton>
        {
          /* 其他按钮 */
        }
        {slots.btns?.()}
      </div>
    </ElForm></div>;
  }
});

// src/components/YoungRotateTip.tsx
var import_vue617 = require("vue");
var landscape = "https://g2021-cdn.laiyouxi.com/image/21Store/laiyouxi_guid/website/landscape.png";
var YoungRotateTip_default = (0, import_vue617.defineComponent)({
  props: {
    maxWidth: {
      type: Number,
      default: 768
    }
  },
  setup(props, { attrs }) {
    const element = (0, import_vue617.ref)();
    const showTip = (0, import_vue617.ref)(false);
    const show = () => showTip.value = true;
    const hide2 = () => showTip.value = false;
    const { width, height } = useWindowSize();
    const isSmallDevices = (0, import_vue617.computed)(
      () => width.value < height.value || width.value < props.maxWidth
    );
    (0, import_vue617.watchEffect)(() => {
      if (isSmallDevices.value) {
        show();
      } else {
        hide2();
      }
    });
    useEventListener(element, "animationend", (e) => {
      hide2();
    });
    return () => <>{showTip.value && <ElOverlay mask style={{ width: "100vw", height: "100vh" }} {...attrs}><div
      style={{
        width: "100%",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      }}
    >
      <style>{`
                @keyframes rotate {
                  from {
                    transform: rotate(0);
                  }
                
                  to {
                    transform: rotate(90deg);
                  }
                }
                .rotate-tip {
                  width: 200px;
                  animation-name: rotate;
                  animation-iteration-count: 6;
                  animation-duration: 1s;
                  animation-direction: alternate;
                  animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
                }
                `}</style>
      <img ref={element} src={landscape} class="rotate-tip" />
      <div
        style={{
          color: "white",
          marginTop: "2.5rem",
          fontSize: "1.25rem",
          lineHeight: "1.75rem"
        }}
      >{"\u4E3A\u4E86\u66F4\u597D\u7684\u7528\u6237\u4F53\u9A8C\uFF0C\u8BF7\u6A2A\u5C4F\u4F7F\u7528"}</div>
    </div></ElOverlay>}</>;
  }
});

// src/components/YoungTablePro.tsx
var import_vue620 = require("vue");

// src/components/sub/CustomHead.tsx
var import_vue619 = require("vue");

// src/components/sub/Drag.tsx
var import_vue618 = require("vue");
init_sortable_esm();
var Drag_default = (0, import_vue618.defineComponent)({
  props: {
    list: {
      required: true,
      type: Object
    }
  },
  emits: ["drag-end", "change"],
  setup(props, { emit }) {
    (0, import_vue618.onMounted)(() => {
      const el = document.querySelector(".young-drap-list");
      new sortable_esm_default(el, {
        animation: 150,
        onEnd: ({ oldIndex: oldIndex2, newIndex: newIndex2 }) => {
          oldIndex2--;
          newIndex2--;
          console.log(oldIndex2, newIndex2);
          if (oldIndex2 === newIndex2) {
            return;
          }
          const data = props.list;
          const row = I(data[oldIndex2]);
          data.splice(oldIndex2, 1);
          data.splice(newIndex2, 0, row);
          emit("drag-end", data);
        }
      });
    });
    function handleChangeCheck(item) {
      emit("change", item, !item.check);
    }
    return () => <div class="young-drap-list">
      <style>{`
          .young-drag-list {
            list-style: none;
          }
          
          .young-drag-list-item {
            cursor: move;
            border-radius: 4px;
            color: #333;
            height: 36px;
            line-height: 36px;
            text-align: center;
            display: flex;
            align-items: center;
          }
          
          .young-drag-list-item:hover {
            background: #eee;
          }
          
          .young-drag-list-item.active {
            color: #409eff !important;
          }
          
          .young-drag-list-item .label {
            text-align: left;
            cursor: pointer;
            flex: 1;
            padding: 0 12px 0 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* \u663E\u793A\u7701\u7565\u53F7 */
          }
          
          .young-drag-list-item .draggable {
            text-align: center;
            display: flex;
            align-items: center;
            padding: 0 12px;
            height: 100%;
          }
          `}</style>
      {props.list.map((item, index2) => <div class={`young-drag-list-item ${item.check ? "active" : ""}`} key={item.label}>
        <div class="draggable" title={"\u62D6\u52A8\u53EF\u6392\u5E8F"}><svg
          class="icon"
          viewBox="0 0 1024 1024"
          version="1.1"
          xmlns="http://www.w3.org/2000/svg"
          p-id="6483"
          width="16"
          height="16"
        >
          <path
            d="M867.995 459.647h-711.99c-27.921 0-52.353 24.434-52.353 52.353s24.434 52.353 52.353 52.353h711.99c27.921 0 52.353-24.434 52.353-52.353s-24.434-52.353-52.353-52.353z"
            p-id="6484"
          />
          <path
            d="M867.995 763.291h-711.99c-27.921 0-52.353 24.434-52.353 52.353s24.434 52.353 52.353 52.353h711.99c27.921 0 52.353-24.434 52.353-52.353s-24.434-52.353-52.353-52.353z"
            p-id="6485"
          />
          <path
            d="M156.005 260.709h711.99c27.921 0 52.353-24.434 52.353-52.353s-24.434-52.353-52.353-52.353h-711.99c-27.921 0-52.353 24.434-52.353 52.353s24.434 52.353 52.353 52.353z"
            p-id="6486"
          />
        </svg></div>
        <div
          class="label"
          onClick={(e) => {
            e.stopPropagation();
            handleChangeCheck(item);
          }}
          title={item.label}
          style={{
            display: "flex",
            justifyContent: "space-between"
          }}
          draggable={false}
        >
          <span>{item.label}</span>
          <ElSwitch modelValue={item.check} />
        </div>
      </div>)}
    </div>;
  }
});

// src/components/sub/CustomHead.tsx
var CustomHead_default = (0, import_vue619.defineComponent)({
  props: {
    tableHead: {
      required: true,
      type: Object
    }
  },
  emits: ["drag-end", "change", "save", "reset"],
  setup(props, { emit }) {
    const showPopover = (0, import_vue619.ref)(false);
    const handleDragend = (list) => {
      emit("drag-end", list);
    };
    const handleChange = (item, check) => {
      emit("change", item, check);
    };
    (0, import_vue619.onMounted)(() => {
      useEventListener("click", (e) => {
        showPopover.value = false;
      });
    });
    const ltSm = useMediaQuery("(max-width: 639.9px)");
    return () => <>
      <div
        style={{
          display: "flex",
          justifyContent: "flex-end",
          paddingBottom: "10px",
          cursor: "pointer"
        }}
        onClick={(e) => {
          e.stopPropagation();
          showPopover.value = true;
        }}
        title={"\u8868\u5934\u914D\u7F6E"}
      ><svg
        xmlns="http://www.w3.org/2000/svg"
        width="1.5rem"
        height="1.5rem"
        viewBox="0 0 24 24"
      ><path
        fill="currentColor"
        d="M13.875 22h-3.75q-.375 0-.65-.25t-.325-.625l-.3-2.325q-.325-.125-.613-.3t-.562-.375l-2.175.9q-.35.125-.7.025t-.55-.425L2.4 15.4q-.2-.325-.125-.7t.375-.6l1.875-1.425Q4.5 12.5 4.5 12.337v-.674q0-.163.025-.338L2.65 9.9q-.3-.225-.375-.6t.125-.7l1.85-3.225q.175-.35.537-.438t.713.038l2.175.9q.275-.2.575-.375t.6-.3l.3-2.325q.05-.375.325-.625t.65-.25h3.75q.375 0 .65.25t.325.625l.3 2.325q.325.125.613.3t.562.375l2.175-.9q.35-.125.7-.025t.55.425L21.6 8.6q.2.325.125.7t-.375.6l-1.875 1.425q.025.175.025.338v.674q0 .163-.05.338l1.875 1.425q.3.225.375.6t-.125.7l-1.85 3.2q-.2.325-.563.438t-.712-.013l-2.125-.9q-.275.2-.575.375t-.6.3l-.3 2.325q-.05.375-.325.625t-.65.25Zm-1.825-6.5q1.45 0 2.475-1.025T15.55 12q0-1.45-1.025-2.475T12.05 8.5q-1.475 0-2.488 1.025T8.55 12q0 1.45 1.012 2.475T12.05 15.5Zm0-2q-.625 0-1.063-.438T10.55 12q0-.625.438-1.063t1.062-.437q.625 0 1.063.438T13.55 12q0 .625-.438 1.063t-1.062.437ZM12 12Zm-1 8h1.975l.35-2.65q.775-.2 1.438-.588t1.212-.937l2.475 1.025l.975-1.7l-2.15-1.625q.125-.35.175-.737T17.5 12q0-.4-.05-.787t-.175-.738l2.15-1.625l-.975-1.7l-2.475 1.05q-.55-.575-1.212-.962t-1.438-.588L13 4h-1.975l-.35 2.65q-.775.2-1.437.588t-1.213.937L5.55 7.15l-.975 1.7l2.15 1.6q-.125.375-.175.75t-.05.8q0 .4.05.775t.175.75l-2.15 1.625l.975 1.7l2.475-1.05q.55.575 1.213.963t1.437.587L11 20Z"
      /></svg></div>
      <ElDrawer
        modelValue={showPopover.value}
        withHeader={false}
        onUpdate:modelValue={(e) => showPopover.value = e}
        size={ltSm.value ? "75%" : "30%"}
      >{{
        default: () => <>
          <div style={{ color: "#999", textAlign: "center", padding: "10px" }}>{"\u62D6\u52A8\u53EF\u6392\u5E8F\uFF0C\u70B9\u51FB\u53EF\u4EE5\u5207\u6362\u5C55\u793A\u72B6\u6001"}</div>
          <Drag_default list={props.tableHead} onDrag-end={handleDragend} onChange={handleChange} />
        </>,
        footer: () => <div style={{ textAlign: "left" }}>
          <ElTooltip content={"\u4FDD\u5B58\u914D\u7F6E\u5230\u672C\u5730\uFF0C\u5982\u679C\u4E0D\u4FDD\u5B58\uFF0C\u5219\u9875\u9762\u5237\u65B0\u4E4B\u540E\u4F1A\u4E22\u5931\u73B0\u6709\u7684\u4E2A\u6027\u5316\u914D\u7F6E"}><ElButton type="primary" onClick={() => emit("save")}>{"\u4FDD\u5B58"}</ElButton></ElTooltip>
          <ElTooltip content={"\u5FEB\u901F\u6062\u590D\u9ED8\u8BA4\u914D\u7F6E"}><ElButton onClick={() => emit("reset")}>{"\u91CD\u7F6E"}</ElButton></ElTooltip>
        </div>
      }}</ElDrawer>
    </>;
  }
});

// src/components/YoungTablePro.tsx
var YoungTablePro_default = (0, import_vue620.defineComponent)({
  props: {
    tableData: {
      type: Object,
      required: true
    },
    tableHead: {
      type: Object,
      required: true
    },
    /**
     * 默认勾选表头
     */
    tableHeadCheck: {
      type: Object,
      required: false
    },
    tableHeight: {
      type: [Number, String],
      default: "100%"
    },
    selectable: {
      type: Boolean,
      default: false
    },
    /**
     * 是否开启保存表头格式按钮
     */
    saveTableHead: {
      type: Boolean,
      default: true
    },
    /**
     * 使用历史保存的表头 没有历史表头使用默认勾选表头
     */
    history: {
      type: Boolean,
      default: true
    },
    /**
     * 存储历史id
     */
    historyId: {
      type: String,
      default: location.href.replace(location.origin, "")
    }
  },
  setup(props, { attrs, expose, slots }) {
    const tableRef = (0, import_vue620.ref)();
    (0, import_vue620.onActivated)(() => {
      (0, import_vue620.nextTick)(() => {
        tableRef.value.doLayout();
      });
    });
    const tableData_1 = (0, import_vue620.ref)([]);
    const tableHead_1 = (0, import_vue620.ref)([]);
    const tableHeadCheck_1 = (0, import_vue620.ref)([]);
    (0, import_vue620.watchEffect)(() => {
      tableData_1.value = props.tableData;
      (0, import_vue620.nextTick)(() => {
        initHead();
      });
    });
    const historyHead = useLocalStorage(`table_pro_tableHead_${props.historyId}`, {});
    const initHead = () => {
      if (props.history) {
        tableHead_1.value = historyHead.value?.tableHead ?? [];
        tableHeadCheck_1.value = historyHead.value?.tableHeadCheck ?? [];
        if (tableHeadCheck_1.value.length === 0) {
          initDefaultData();
        }
      } else {
        initDefaultData();
      }
    };
    const initDefaultData = () => {
      tableHead_1.value = I(props.tableHead);
      tableHeadCheck_1.value = props.tableHeadCheck?.length ? I(props.tableHeadCheck) : props.tableHead.map((t) => t.prop);
    };
    const initData = (0, import_vue620.computed)(() => {
      return tableHead_1.value.map((t) => {
        t.check = tableHeadCheck_1.value.includes(t.prop);
        return t;
      });
    });
    const filterHeader = (0, import_vue620.computed)(() => {
      return initData.value.filter((d2) => !d2.only_export && d2.check);
    });
    const handleChange = (item, check) => {
      const index2 = tableHeadCheck_1.value.findIndex((e) => e === item.prop);
      if (!check && index2 != -1) {
        tableHeadCheck_1.value.splice(index2, 1);
      } else {
        tableHeadCheck_1.value.push(item.prop);
      }
    };
    const handleDragend = (list) => {
      tableHead_1.value = list;
    };
    const saveTableHead = () => {
      historyHead.value = {
        tableHead: initData.value,
        tableHeadCheck: tableHeadCheck_1.value
      };
      ElMessage.success("\u4FDD\u5B58\u6210\u529F");
    };
    const resetTableHead = () => {
      ElMessageBox.confirm("\u786E\u5B9A\u91CD\u7F6E\u8868\u5934\u5417\uFF1F", "\u63D0\u793A", {
        confirmButtonText: "\u786E\u5B9A",
        cancelButtonText: "\u53D6\u6D88",
        type: "warning"
      }).then(() => {
        historyHead.value = {};
        ElMessage.success("\u91CD\u7F6E\u6210\u529F");
        (0, import_vue620.nextTick)(() => {
          initHead();
        });
      });
    };
    const randomKey = ne();
    expose({
      saveTableHead,
      resetTableHead
    });
    return () => <>
      <style>{`
          .nowarp {
            word-break: normal;
          }
          `}</style>
      <div>
        {props.saveTableHead && <CustomHead_default
          tableHead={initData.value.filter((th) => !th.only_export)}
          onDrag-end={handleDragend}
          onChange={handleChange}
          onSave={saveTableHead}
          onReset={resetTableHead}
        />}
        <div style="position: relative;"><ElTable
          ref={tableRef}
          header-cell-class-name="nowarp"
          data={tableData_1.value}
          style={{ width: "100%" }}
          height={props.tableHeight}
          border
          {...attrs}
        >
          {props.selectable && <ElTableColumn2 type="selection" width="55" />}
          {filterHeader.value.map((item, index2) => <ElTableColumn2
            key={item.prop.toString() + index2 + randomKey}
            prop={item.prop}
            label={item.label}
            width={item.width || ""}
            sortable={item.sortable || false}
            fixed={item.fixed || false}
            align={item.aligin || "left"}
            showOverflowTooltip={item.show_overflow_tooltip ?? true}
          >{{
            header: (scope) => {
              if (tableHead_1.value[index2].tool_content) {
                return <div
                  style={{
                    display: "flex",
                    justifyContent: "center",
                    alignItems: "center"
                  }}
                >
                  <span class="nowarp" title={item.label}>{scope.column.label}</span>
                  <ElTooltip
                    placement="bottom"
                    v-slots={{ content: () => tableHead_1.value[index2].tool_content }}
                  ><svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="1.2em"
                    height="1.2em"
                    viewBox="0 0 256 256"
                  ><path
                    fill="currentColor"
                    d="M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm0 168a12 12 0 1 1 12-12a12 12 0 0 1-12 12Zm8-48.72v.72a8 8 0 0 1-16 0v-8a8 8 0 0 1 8-8c13.23 0 24-9 24-20s-10.77-20-24-20s-24 9-24 20v4a8 8 0 0 1-16 0v-4c0-19.85 17.94-36 40-36s40 16.15 40 36c0 17.38-13.76 31.93-32 35.28Z"
                  /></svg></ElTooltip>
                </div>;
              } else {
                return <span class="nowarp" title={item.label}>{scope.column.label}</span>;
              }
            },
            default: ({ row, $index }) => {
              if (item.render) {
                return item.render(row, $index);
              } else {
                return <span>{row[item.prop]}</span>;
              }
            }
          }}</ElTableColumn2>)}
          {slots.switch?.()}
          {slots.operate?.()}
        </ElTable></div>
      </div>
    </>;
  }
});

// src/components/YoungUpload.tsx
var import_vue622 = require("vue");

// ../../node_modules/.pnpm/vue-cropper@1.0.9/node_modules/vue-cropper/dist/vue-cropper.es.js
var import_vue621 = require("vue");
var Y2 = {};
Y2.getData = (t) => new Promise((e, i) => {
  let s2 = {};
  I4(t).then((r) => {
    s2.arrayBuffer = r, s2.orientation = k(r), e(s2);
  }).catch((r) => {
    i(r);
  });
});
function I4(t) {
  let e = null;
  return new Promise((i, s2) => {
    if (t.src)
      if (/^data\:/i.test(t.src))
        e = L(t.src), i(e);
      else if (/^blob\:/i.test(t.src)) {
        var r = new FileReader();
        r.onload = function(h29) {
          e = h29.target.result, i(e);
        }, E3(t.src, function(h29) {
          r.readAsArrayBuffer(h29);
        });
      } else {
        var o2 = new XMLHttpRequest();
        o2.onload = function() {
          if (this.status == 200 || this.status === 0)
            e = o2.response, i(e);
          else
            throw "Could not load image";
          o2 = null;
        }, o2.open("GET", t.src, true), o2.responseType = "arraybuffer", o2.send(null);
      }
    else
      s2("img error");
  });
}
function E3(t, e) {
  var i = new XMLHttpRequest();
  i.open("GET", t, true), i.responseType = "blob", i.onload = function(s2) {
    (this.status == 200 || this.status === 0) && e(this.response);
  }, i.send();
}
function L(t) {
  t = t.replace(/^data\:([^\;]+)\;base64,/gmi, "");
  for (var e = atob(t), i = e.length, s2 = new ArrayBuffer(i), r = new Uint8Array(s2), o2 = 0; o2 < i; o2++)
    r[o2] = e.charCodeAt(o2);
  return s2;
}
function T2(t, e, i) {
  var s2 = "", r;
  for (r = e, i += e; r < i; r++)
    s2 += String.fromCharCode(t.getUint8(r));
  return s2;
}
function k(t) {
  var e = new DataView(t), i = e.byteLength, s2, r, o2, h29, n, l2, c2, a3, p2, f2;
  if (e.getUint8(0) === 255 && e.getUint8(1) === 216)
    for (p2 = 2; p2 < i; ) {
      if (e.getUint8(p2) === 255 && e.getUint8(p2 + 1) === 225) {
        c2 = p2;
        break;
      }
      p2++;
    }
  if (c2 && (r = c2 + 4, o2 = c2 + 10, T2(e, r, 4) === "Exif" && (l2 = e.getUint16(o2), n = l2 === 18761, (n || l2 === 19789) && e.getUint16(o2 + 2, n) === 42 && (h29 = e.getUint32(o2 + 4, n), h29 >= 8 && (a3 = o2 + h29)))), a3) {
    for (i = e.getUint16(a3, n), f2 = 0; f2 < i; f2++)
      if (p2 = a3 + f2 * 12 + 2, e.getUint16(p2, n) === 274) {
        p2 += 8, s2 = e.getUint16(p2, n);
        break;
      }
  }
  return s2;
}
var N3 = (t, e) => {
  const i = t.__vccOpts || t;
  for (const [s2, r] of e)
    i[s2] = r;
  return i;
};
var A2 = (0, import_vue621.defineComponent)({
  data: function() {
    return {
      // 容器高宽
      w: 0,
      h: 0,
      // 图片缩放比例
      scale: 1,
      // 图片偏移x轴
      x: 0,
      // 图片偏移y轴
      y: 0,
      // 图片加载
      loading: true,
      // 图片真实宽度
      trueWidth: 0,
      // 图片真实高度
      trueHeight: 0,
      move: true,
      // 移动的x
      moveX: 0,
      // 移动的y
      moveY: 0,
      // 开启截图
      crop: false,
      // 正在截图
      cropping: false,
      // 裁剪框大小
      cropW: 0,
      cropH: 0,
      cropOldW: 0,
      cropOldH: 0,
      // 判断是否能够改变
      canChangeX: false,
      canChangeY: false,
      // 改变的基准点
      changeCropTypeX: 1,
      changeCropTypeY: 1,
      // 裁剪框的坐标轴
      cropX: 0,
      cropY: 0,
      cropChangeX: 0,
      cropChangeY: 0,
      cropOffsertX: 0,
      cropOffsertY: 0,
      // 支持的滚动事件
      support: "",
      // 移动端手指缩放
      touches: [],
      touchNow: false,
      // 图片旋转
      rotate: 0,
      isIos: false,
      orientation: 0,
      imgs: "",
      // 图片缩放系数
      coe: 0.2,
      // 是否正在多次缩放
      scaling: false,
      scalingSet: "",
      coeStatus: "",
      // 控制emit触发频率
      isCanShow: true
    };
  },
  props: {
    img: {
      type: [String, Blob, null, File],
      default: ""
    },
    // 输出图片压缩比
    outputSize: {
      type: Number,
      default: 1
    },
    outputType: {
      type: String,
      default: "jpeg"
    },
    info: {
      type: Boolean,
      default: true
    },
    // 是否开启滚轮放大缩小
    canScale: {
      type: Boolean,
      default: true
    },
    // 是否自成截图框
    autoCrop: {
      type: Boolean,
      default: false
    },
    autoCropWidth: {
      type: [Number, String],
      default: 0
    },
    autoCropHeight: {
      type: [Number, String],
      default: 0
    },
    // 是否开启固定宽高比
    fixed: {
      type: Boolean,
      default: false
    },
    // 宽高比 w/h
    fixedNumber: {
      type: Array,
      default: () => [1, 1]
    },
    // 固定大小 禁止改变截图框大小
    fixedBox: {
      type: Boolean,
      default: false
    },
    // 输出截图是否缩放
    full: {
      type: Boolean,
      default: false
    },
    // 是否可以拖动图片
    canMove: {
      type: Boolean,
      default: true
    },
    // 是否可以拖动截图框
    canMoveBox: {
      type: Boolean,
      default: true
    },
    // 上传图片按照原始比例显示
    original: {
      type: Boolean,
      default: false
    },
    // 截图框能否超过图片
    centerBox: {
      type: Boolean,
      default: false
    },
    // 是否根据dpr输出高清图片
    high: {
      type: Boolean,
      default: true
    },
    // 截图框展示宽高类型
    infoTrue: {
      type: Boolean,
      default: false
    },
    // 可以压缩图片宽高  默认不超过200
    maxImgSize: {
      type: [Number, String],
      default: 2e3
    },
    // 倍数  可渲染当前截图框的n倍 0 - 1000;
    enlarge: {
      type: [Number, String],
      default: 1
    },
    // 自动预览的固定宽度
    preW: {
      type: [Number, String],
      default: 0
    },
    /*
      图片布局方式 mode 实现和css背景一样的效果
      contain  居中布局 默认不会缩放 保证图片在容器里面 mode: 'contain'
      cover    拉伸布局 填充整个容器  mode: 'cover'
      如果仅有一个数值被给定，这个数值将作为宽度值大小，高度值将被设定为auto。 mode: '50px'
      如果有两个数值被给定，第一个将作为宽度值大小，第二个作为高度值大小。 mode: '50px 60px'
    */
    mode: {
      type: String,
      default: "contain"
    },
    //限制最小区域,可传1以上的数字和字符串，限制长宽都是这么大
    // 也可以传数组[90,90] 
    limitMinSize: {
      type: [Number, Array, String],
      default: () => 10,
      validator: function(t) {
        return Array.isArray(t) ? Number(t[0]) >= 0 && Number(t[1]) >= 0 : Number(t) >= 0;
      }
    },
    // 导出时,填充背景颜色
    fillColor: {
      type: String,
      default: ""
    }
  },
  computed: {
    cropInfo() {
      let t = {};
      if (t.top = this.cropOffsertY > 21 ? "-21px" : "0px", t.width = this.cropW > 0 ? this.cropW : 0, t.height = this.cropH > 0 ? this.cropH : 0, this.infoTrue) {
        let e = 1;
        this.high && !this.full && (e = window.devicePixelRatio), this.enlarge !== 1 & !this.full && (e = Math.abs(Number(this.enlarge))), t.width = t.width * e, t.height = t.height * e, this.full && (t.width = t.width / this.scale, t.height = t.height / this.scale);
      }
      return t.width = t.width.toFixed(0), t.height = t.height.toFixed(0), t;
    },
    isIE() {
      return !!window.ActiveXObject || "ActiveXObject" in window;
    },
    passive() {
      return this.isIE ? null : {
        passive: false
      };
    }
  },
  watch: {
    // 如果图片改变， 重新布局
    img() {
      this.checkedImg();
    },
    imgs(t) {
      t !== "" && this.reload();
    },
    cropW() {
      this.showPreview();
    },
    cropH() {
      this.showPreview();
    },
    cropOffsertX() {
      this.showPreview();
    },
    cropOffsertY() {
      this.showPreview();
    },
    scale(t, e) {
      this.showPreview();
    },
    x() {
      this.showPreview();
    },
    y() {
      this.showPreview();
    },
    autoCrop(t) {
      t && this.goAutoCrop();
    },
    // 修改了自动截图框
    autoCropWidth() {
      this.autoCrop && this.goAutoCrop();
    },
    autoCropHeight() {
      this.autoCrop && this.goAutoCrop();
    },
    mode() {
      this.checkedImg();
    },
    rotate() {
      this.showPreview(), this.autoCrop ? this.goAutoCrop(this.cropW, this.cropH) : (this.cropW > 0 || this.cropH > 0) && this.goAutoCrop(this.cropW, this.cropH);
    }
  },
  methods: {
    getVersion(t) {
      var e = navigator.userAgent.split(" "), i = "";
      let s2 = 0;
      const r = new RegExp(t, "i");
      for (var o2 = 0; o2 < e.length; o2++)
        r.test(e[o2]) && (i = e[o2]);
      return i ? s2 = i.split("/")[1].split(".") : s2 = ["0", "0", "0"], s2;
    },
    checkOrientationImage(t, e, i, s2) {
      if (this.getVersion("chrome")[0] >= 81)
        e = -1;
      else if (this.getVersion("safari")[0] >= 605) {
        const h29 = this.getVersion("version");
        h29[0] > 13 && h29[1] > 1 && (e = -1);
      } else {
        const h29 = navigator.userAgent.toLowerCase().match(/cpu iphone os (.*?) like mac os/);
        if (h29) {
          let n = h29[1];
          n = n.split("_"), (n[0] > 13 || n[0] >= 13 && n[1] >= 4) && (e = -1);
        }
      }
      let r = document.createElement("canvas"), o2 = r.getContext("2d");
      switch (o2.save(), e) {
        case 2:
          r.width = i, r.height = s2, o2.translate(i, 0), o2.scale(-1, 1);
          break;
        case 3:
          r.width = i, r.height = s2, o2.translate(i / 2, s2 / 2), o2.rotate(180 * Math.PI / 180), o2.translate(-i / 2, -s2 / 2);
          break;
        case 4:
          r.width = i, r.height = s2, o2.translate(0, s2), o2.scale(1, -1);
          break;
        case 5:
          r.height = i, r.width = s2, o2.rotate(0.5 * Math.PI), o2.scale(1, -1);
          break;
        case 6:
          r.width = s2, r.height = i, o2.translate(s2 / 2, i / 2), o2.rotate(90 * Math.PI / 180), o2.translate(-i / 2, -s2 / 2);
          break;
        case 7:
          r.height = i, r.width = s2, o2.rotate(0.5 * Math.PI), o2.translate(i, -s2), o2.scale(-1, 1);
          break;
        case 8:
          r.height = i, r.width = s2, o2.translate(s2 / 2, i / 2), o2.rotate(-90 * Math.PI / 180), o2.translate(-i / 2, -s2 / 2);
          break;
        default:
          r.width = i, r.height = s2;
      }
      o2.drawImage(t, 0, 0, i, s2), o2.restore(), r.toBlob(
        (h29) => {
          let n = URL.createObjectURL(h29);
          URL.revokeObjectURL(this.imgs), this.imgs = n;
        },
        "image/" + this.outputType,
        1
      );
    },
    // checkout img
    checkedImg() {
      if (this.img === null || this.img === "") {
        this.imgs = "", this.clearCrop();
        return;
      }
      this.loading = true, this.scale = 1, this.rotate = 0, this.clearCrop();
      let t = new Image();
      if (t.onload = () => {
        if (this.img === "")
          return this.$emit("img-load", "error"), false;
        let i = t.width, s2 = t.height;
        Y2.getData(t).then((r) => {
          this.orientation = r.orientation || 1;
          let o2 = Number(this.maxImgSize);
          if (!this.orientation && i < o2 & s2 < o2) {
            this.imgs = this.img;
            return;
          }
          i > o2 && (s2 = s2 / i * o2, i = o2), s2 > o2 && (i = i / s2 * o2, s2 = o2), this.checkOrientationImage(t, this.orientation, i, s2);
        });
      }, t.onerror = () => {
        this.$emit("img-load", "error");
      }, this.img.substr(0, 4) !== "data" && (t.crossOrigin = ""), this.isIE) {
        var e = new XMLHttpRequest();
        e.onload = function() {
          var i = URL.createObjectURL(this.response);
          t.src = i;
        }, e.open("GET", this.img, true), e.responseType = "blob", e.send();
      } else
        t.src = this.img;
    },
    // 当按下鼠标键
    startMove(t) {
      if (t.preventDefault(), this.move && !this.crop) {
        if (!this.canMove)
          return false;
        this.moveX = ("clientX" in t ? t.clientX : t.touches[0].clientX) - this.x, this.moveY = ("clientY" in t ? t.clientY : t.touches[0].clientY) - this.y, t.touches ? (window.addEventListener("touchmove", this.moveImg), window.addEventListener("touchend", this.leaveImg), t.touches.length == 2 && (this.touches = t.touches, window.addEventListener("touchmove", this.touchScale), window.addEventListener("touchend", this.cancelTouchScale))) : (window.addEventListener("mousemove", this.moveImg), window.addEventListener("mouseup", this.leaveImg)), this.$emit("img-moving", {
          moving: true,
          axis: this.getImgAxis()
        });
      } else
        this.cropping = true, window.addEventListener("mousemove", this.createCrop), window.addEventListener("mouseup", this.endCrop), window.addEventListener("touchmove", this.createCrop), window.addEventListener("touchend", this.endCrop), this.cropOffsertX = t.offsetX ? t.offsetX : t.touches[0].pageX - this.$refs.cropper.offsetLeft, this.cropOffsertY = t.offsetY ? t.offsetY : t.touches[0].pageY - this.$refs.cropper.offsetTop, this.cropX = "clientX" in t ? t.clientX : t.touches[0].clientX, this.cropY = "clientY" in t ? t.clientY : t.touches[0].clientY, this.cropChangeX = this.cropOffsertX, this.cropChangeY = this.cropOffsertY, this.cropW = 0, this.cropH = 0;
    },
    // 移动端缩放
    touchScale(t) {
      t.preventDefault();
      let e = this.scale;
      var i = {
        x: this.touches[0].clientX,
        y: this.touches[0].clientY
      }, s2 = {
        x: t.touches[0].clientX,
        y: t.touches[0].clientY
      }, r = {
        x: this.touches[1].clientX,
        y: this.touches[1].clientY
      }, o2 = {
        x: t.touches[1].clientX,
        y: t.touches[1].clientY
      }, h29 = Math.sqrt(
        Math.pow(i.x - r.x, 2) + Math.pow(i.y - r.y, 2)
      ), n = Math.sqrt(
        Math.pow(s2.x - o2.x, 2) + Math.pow(s2.y - o2.y, 2)
      ), l2 = n - h29, c2 = 1;
      c2 = c2 / this.trueWidth > c2 / this.trueHeight ? c2 / this.trueHeight : c2 / this.trueWidth, c2 = c2 > 0.1 ? 0.1 : c2;
      var a3 = c2 * l2;
      if (!this.touchNow) {
        if (this.touchNow = true, l2 > 0 ? e += Math.abs(a3) : l2 < 0 && e > Math.abs(a3) && (e -= Math.abs(a3)), this.touches = t.touches, setTimeout(() => {
          this.touchNow = false;
        }, 8), !this.checkoutImgAxis(this.x, this.y, e))
          return false;
        this.scale = e;
      }
    },
    cancelTouchScale(t) {
      window.removeEventListener("touchmove", this.touchScale);
    },
    // 移动图片
    moveImg(t) {
      if (t.preventDefault(), t.touches && t.touches.length === 2)
        return this.touches = t.touches, window.addEventListener("touchmove", this.touchScale), window.addEventListener("touchend", this.cancelTouchScale), window.removeEventListener("touchmove", this.moveImg), false;
      let e = "clientX" in t ? t.clientX : t.touches[0].clientX, i = "clientY" in t ? t.clientY : t.touches[0].clientY, s2, r;
      s2 = e - this.moveX, r = i - this.moveY, this.$nextTick(() => {
        if (this.centerBox) {
          let o2 = this.getImgAxis(s2, r, this.scale), h29 = this.getCropAxis(), n = this.trueHeight * this.scale, l2 = this.trueWidth * this.scale, c2, a3, p2, f2;
          switch (this.rotate) {
            case 1:
            case -1:
            case 3:
            case -3:
              c2 = this.cropOffsertX - this.trueWidth * (1 - this.scale) / 2 + (n - l2) / 2, a3 = this.cropOffsertY - this.trueHeight * (1 - this.scale) / 2 + (l2 - n) / 2, p2 = c2 - n + this.cropW, f2 = a3 - l2 + this.cropH;
              break;
            default:
              c2 = this.cropOffsertX - this.trueWidth * (1 - this.scale) / 2, a3 = this.cropOffsertY - this.trueHeight * (1 - this.scale) / 2, p2 = c2 - l2 + this.cropW, f2 = a3 - n + this.cropH;
              break;
          }
          o2.x1 >= h29.x1 && (s2 = c2), o2.y1 >= h29.y1 && (r = a3), o2.x2 <= h29.x2 && (s2 = p2), o2.y2 <= h29.y2 && (r = f2);
        }
        this.x = s2, this.y = r, this.$emit("img-moving", {
          moving: true,
          axis: this.getImgAxis()
        });
      });
    },
    // 移动图片结束
    leaveImg(t) {
      window.removeEventListener("mousemove", this.moveImg), window.removeEventListener("touchmove", this.moveImg), window.removeEventListener("mouseup", this.leaveImg), window.removeEventListener("touchend", this.leaveImg), this.$emit("img-moving", {
        moving: false,
        axis: this.getImgAxis()
      });
    },
    // 缩放图片
    scaleImg() {
      this.canScale && window.addEventListener(this.support, this.changeSize, this.passive);
    },
    // 移出框
    cancelScale() {
      this.canScale && window.removeEventListener(this.support, this.changeSize);
    },
    // 改变大小函数
    changeSize(t) {
      t.preventDefault();
      let e = this.scale;
      var i = t.deltaY || t.wheelDelta, s2 = navigator.userAgent.indexOf("Firefox");
      i = s2 > 0 ? i * 30 : i, this.isIE && (i = -i);
      var r = this.coe;
      r = r / this.trueWidth > r / this.trueHeight ? r / this.trueHeight : r / this.trueWidth;
      var o2 = r * i;
      o2 < 0 ? e += Math.abs(o2) : e > Math.abs(o2) && (e -= Math.abs(o2));
      let h29 = o2 < 0 ? "add" : "reduce";
      if (h29 !== this.coeStatus && (this.coeStatus = h29, this.coe = 0.2), this.scaling || (this.scalingSet = setTimeout(() => {
        this.scaling = false, this.coe = this.coe += 0.01;
      }, 50)), this.scaling = true, !this.checkoutImgAxis(this.x, this.y, e))
        return false;
      this.scale = e;
    },
    // 修改图片大小函数
    changeScale(t) {
      let e = this.scale;
      t = t || 1;
      var i = 20;
      if (i = i / this.trueWidth > i / this.trueHeight ? i / this.trueHeight : i / this.trueWidth, t = t * i, t > 0 ? e += Math.abs(t) : e > Math.abs(t) && (e -= Math.abs(t)), !this.checkoutImgAxis(this.x, this.y, e))
        return false;
      this.scale = e;
    },
    // 创建截图框
    createCrop(t) {
      t.preventDefault();
      var e = "clientX" in t ? t.clientX : t.touches ? t.touches[0].clientX : 0, i = "clientY" in t ? t.clientY : t.touches ? t.touches[0].clientY : 0;
      this.$nextTick(() => {
        var s2 = e - this.cropX, r = i - this.cropY;
        if (s2 > 0 ? (this.cropW = s2 + this.cropChangeX > this.w ? this.w - this.cropChangeX : s2, this.cropOffsertX = this.cropChangeX) : (this.cropW = this.w - this.cropChangeX + Math.abs(s2) > this.w ? this.cropChangeX : Math.abs(s2), this.cropOffsertX = this.cropChangeX + s2 > 0 ? this.cropChangeX + s2 : 0), !this.fixed)
          r > 0 ? (this.cropH = r + this.cropChangeY > this.h ? this.h - this.cropChangeY : r, this.cropOffsertY = this.cropChangeY) : (this.cropH = this.h - this.cropChangeY + Math.abs(r) > this.h ? this.cropChangeY : Math.abs(r), this.cropOffsertY = this.cropChangeY + r > 0 ? this.cropChangeY + r : 0);
        else {
          var o2 = this.cropW / this.fixedNumber[0] * this.fixedNumber[1];
          o2 + this.cropOffsertY > this.h ? (this.cropH = this.h - this.cropOffsertY, this.cropW = this.cropH / this.fixedNumber[1] * this.fixedNumber[0], s2 > 0 ? this.cropOffsertX = this.cropChangeX : this.cropOffsertX = this.cropChangeX - this.cropW) : this.cropH = o2, this.cropOffsertY = this.cropOffsertY;
        }
      });
    },
    // 改变截图框大小
    changeCropSize(t, e, i, s2, r) {
      t.preventDefault(), window.addEventListener("mousemove", this.changeCropNow), window.addEventListener("mouseup", this.changeCropEnd), window.addEventListener("touchmove", this.changeCropNow), window.addEventListener("touchend", this.changeCropEnd), this.canChangeX = e, this.canChangeY = i, this.changeCropTypeX = s2, this.changeCropTypeY = r, this.cropX = "clientX" in t ? t.clientX : t.touches[0].clientX, this.cropY = "clientY" in t ? t.clientY : t.touches[0].clientY, this.cropOldW = this.cropW, this.cropOldH = this.cropH, this.cropChangeX = this.cropOffsertX, this.cropChangeY = this.cropOffsertY, this.fixed && this.canChangeX && this.canChangeY && (this.canChangeY = 0), this.$emit("change-crop-size", {
        width: this.cropW,
        height: this.cropH
      });
    },
    // 正在改变
    changeCropNow(t) {
      t.preventDefault();
      var e = "clientX" in t ? t.clientX : t.touches ? t.touches[0].clientX : 0, i = "clientY" in t ? t.clientY : t.touches ? t.touches[0].clientY : 0;
      let s2 = this.w, r = this.h, o2 = 0, h29 = 0;
      if (this.centerBox) {
        let c2 = this.getImgAxis(), a3 = c2.x2, p2 = c2.y2;
        o2 = c2.x1 > 0 ? c2.x1 : 0, h29 = c2.y1 > 0 ? c2.y1 : 0, s2 > a3 && (s2 = a3), r > p2 && (r = p2);
      }
      const [n, l2] = this.checkCropLimitSize();
      this.$nextTick(() => {
        var c2 = e - this.cropX, a3 = i - this.cropY;
        if (this.canChangeX && (this.changeCropTypeX === 1 ? this.cropOldW - c2 < n ? (this.cropW = n, this.cropOffsertX = this.cropOldW + this.cropChangeX - o2 - n) : this.cropOldW - c2 > 0 ? (this.cropW = s2 - this.cropChangeX - c2 <= s2 - o2 ? this.cropOldW - c2 : this.cropOldW + this.cropChangeX - o2, this.cropOffsertX = s2 - this.cropChangeX - c2 <= s2 - o2 ? this.cropChangeX + c2 : o2) : (this.cropW = Math.abs(c2) + this.cropChangeX <= s2 ? Math.abs(c2) - this.cropOldW : s2 - this.cropOldW - this.cropChangeX, this.cropOffsertX = this.cropChangeX + this.cropOldW) : this.changeCropTypeX === 2 && (this.cropOldW + c2 < n ? this.cropW = n : this.cropOldW + c2 > 0 ? (this.cropW = this.cropOldW + c2 + this.cropOffsertX <= s2 ? this.cropOldW + c2 : s2 - this.cropOffsertX, this.cropOffsertX = this.cropChangeX) : (this.cropW = s2 - this.cropChangeX + Math.abs(c2 + this.cropOldW) <= s2 - o2 ? Math.abs(c2 + this.cropOldW) : this.cropChangeX - o2, this.cropOffsertX = s2 - this.cropChangeX + Math.abs(c2 + this.cropOldW) <= s2 - o2 ? this.cropChangeX - Math.abs(c2 + this.cropOldW) : o2))), this.canChangeY && (this.changeCropTypeY === 1 ? this.cropOldH - a3 < l2 ? (this.cropH = l2, this.cropOffsertY = this.cropOldH + this.cropChangeY - h29 - l2) : this.cropOldH - a3 > 0 ? (this.cropH = r - this.cropChangeY - a3 <= r - h29 ? this.cropOldH - a3 : this.cropOldH + this.cropChangeY - h29, this.cropOffsertY = r - this.cropChangeY - a3 <= r - h29 ? this.cropChangeY + a3 : h29) : (this.cropH = Math.abs(a3) + this.cropChangeY <= r ? Math.abs(a3) - this.cropOldH : r - this.cropOldH - this.cropChangeY, this.cropOffsertY = this.cropChangeY + this.cropOldH) : this.changeCropTypeY === 2 && (this.cropOldH + a3 < l2 ? this.cropH = l2 : this.cropOldH + a3 > 0 ? (this.cropH = this.cropOldH + a3 + this.cropOffsertY <= r ? this.cropOldH + a3 : r - this.cropOffsertY, this.cropOffsertY = this.cropChangeY) : (this.cropH = r - this.cropChangeY + Math.abs(a3 + this.cropOldH) <= r - h29 ? Math.abs(a3 + this.cropOldH) : this.cropChangeY - h29, this.cropOffsertY = r - this.cropChangeY + Math.abs(a3 + this.cropOldH) <= r - h29 ? this.cropChangeY - Math.abs(a3 + this.cropOldH) : h29))), this.canChangeX && this.fixed) {
          var p2 = this.cropW / this.fixedNumber[0] * this.fixedNumber[1];
          p2 < l2 ? (this.cropH = l2, this.cropW = this.fixedNumber[0] * l2 / this.fixedNumber[1], this.changeCropTypeX === 1 && (this.cropOffsertX = this.cropChangeX + (this.cropOldW - this.cropW))) : p2 + this.cropOffsertY > r ? (this.cropH = r - this.cropOffsertY, this.cropW = this.cropH / this.fixedNumber[1] * this.fixedNumber[0], this.changeCropTypeX === 1 && (this.cropOffsertX = this.cropChangeX + (this.cropOldW - this.cropW))) : this.cropH = p2;
        }
        if (this.canChangeY && this.fixed) {
          var f2 = this.cropH / this.fixedNumber[1] * this.fixedNumber[0];
          f2 < n ? (this.cropW = n, this.cropH = this.fixedNumber[1] * n / this.fixedNumber[0], this.cropOffsertY = this.cropOldH + this.cropChangeY - this.cropH) : f2 + this.cropOffsertX > s2 ? (this.cropW = s2 - this.cropOffsertX, this.cropH = this.cropW / this.fixedNumber[0] * this.fixedNumber[1]) : this.cropW = f2;
        }
      });
    },
    checkCropLimitSize() {
      let { cropW: t, cropH: e, limitMinSize: i } = this, s2 = new Array();
      return Array.isArray(i) ? s2 = i : s2 = [i, i], t = parseFloat(s2[0]), e = parseFloat(s2[1]), [t, e];
    },
    // 结束改变
    changeCropEnd(t) {
      window.removeEventListener("mousemove", this.changeCropNow), window.removeEventListener("mouseup", this.changeCropEnd), window.removeEventListener("touchmove", this.changeCropNow), window.removeEventListener("touchend", this.changeCropEnd);
    },
    // 根据比例x/y，最小宽度，最小高度，现有宽度，现有高度，得到应该有的宽度和高度
    calculateSize(t, e, i, s2, r, o2) {
      const h29 = t / e;
      let n = r, l2 = o2;
      return n < i && (n = i, l2 = Math.ceil(n / h29)), l2 < s2 && (l2 = s2, n = Math.ceil(l2 * h29), n < i && (n = i, l2 = Math.ceil(n / h29))), n < r && (n = r, l2 = Math.ceil(n / h29)), l2 < o2 && (l2 = o2, n = Math.ceil(l2 * h29)), { width: n, height: l2 };
    },
    // 创建完成
    endCrop() {
      this.cropW === 0 && this.cropH === 0 && (this.cropping = false);
      let [t, e] = this.checkCropLimitSize();
      const { width: i, height: s2 } = this.fixed ? this.calculateSize(
        this.fixedNumber[0],
        this.fixedNumber[1],
        t,
        e,
        this.cropW,
        this.cropH
      ) : { width: t, height: e };
      i > this.cropW && (this.cropW = i, this.cropOffsertX + i > this.w && (this.cropOffsertX = this.w - i)), s2 > this.cropH && (this.cropH = s2, this.cropOffsertY + s2 > this.h && (this.cropOffsertY = this.h - s2)), window.removeEventListener("mousemove", this.createCrop), window.removeEventListener("mouseup", this.endCrop), window.removeEventListener("touchmove", this.createCrop), window.removeEventListener("touchend", this.endCrop);
    },
    // 开始截图
    startCrop() {
      this.crop = true;
    },
    // 停止截图
    stopCrop() {
      this.crop = false;
    },
    // 清除截图
    clearCrop() {
      this.cropping = false, this.cropW = 0, this.cropH = 0;
    },
    // 截图移动
    cropMove(t) {
      if (t.preventDefault(), !this.canMoveBox)
        return this.crop = false, this.startMove(t), false;
      if (t.touches && t.touches.length === 2)
        return this.crop = false, this.startMove(t), this.leaveCrop(), false;
      window.addEventListener("mousemove", this.moveCrop), window.addEventListener("mouseup", this.leaveCrop), window.addEventListener("touchmove", this.moveCrop), window.addEventListener("touchend", this.leaveCrop);
      let e = "clientX" in t ? t.clientX : t.touches[0].clientX, i = "clientY" in t ? t.clientY : t.touches[0].clientY, s2, r;
      s2 = e - this.cropOffsertX, r = i - this.cropOffsertY, this.cropX = s2, this.cropY = r, this.$emit("crop-moving", {
        moving: true,
        axis: this.getCropAxis()
      });
    },
    moveCrop(t, e) {
      let i = 0, s2 = 0;
      t && (t.preventDefault(), i = "clientX" in t ? t.clientX : t.touches[0].clientX, s2 = "clientY" in t ? t.clientY : t.touches[0].clientY), this.$nextTick(() => {
        let r, o2, h29 = i - this.cropX, n = s2 - this.cropY;
        if (e && (h29 = this.cropOffsertX, n = this.cropOffsertY), h29 <= 0 ? r = 0 : h29 + this.cropW > this.w ? r = this.w - this.cropW : r = h29, n <= 0 ? o2 = 0 : n + this.cropH > this.h ? o2 = this.h - this.cropH : o2 = n, this.centerBox) {
          let l2 = this.getImgAxis();
          r <= l2.x1 && (r = l2.x1), r + this.cropW > l2.x2 && (r = l2.x2 - this.cropW), o2 <= l2.y1 && (o2 = l2.y1), o2 + this.cropH > l2.y2 && (o2 = l2.y2 - this.cropH);
        }
        this.cropOffsertX = r, this.cropOffsertY = o2, this.$emit("crop-moving", {
          moving: true,
          axis: this.getCropAxis()
        });
      });
    },
    // 算出不同场景下面 图片相对于外层容器的坐标轴
    getImgAxis(t, e, i) {
      t = t || this.x, e = e || this.y, i = i || this.scale;
      let s2 = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      }, r = this.trueWidth * i, o2 = this.trueHeight * i;
      switch (this.rotate) {
        case 0:
          s2.x1 = t + this.trueWidth * (1 - i) / 2, s2.x2 = s2.x1 + this.trueWidth * i, s2.y1 = e + this.trueHeight * (1 - i) / 2, s2.y2 = s2.y1 + this.trueHeight * i;
          break;
        case 1:
        case -1:
        case 3:
        case -3:
          s2.x1 = t + this.trueWidth * (1 - i) / 2 + (r - o2) / 2, s2.x2 = s2.x1 + this.trueHeight * i, s2.y1 = e + this.trueHeight * (1 - i) / 2 + (o2 - r) / 2, s2.y2 = s2.y1 + this.trueWidth * i;
          break;
        default:
          s2.x1 = t + this.trueWidth * (1 - i) / 2, s2.x2 = s2.x1 + this.trueWidth * i, s2.y1 = e + this.trueHeight * (1 - i) / 2, s2.y2 = s2.y1 + this.trueHeight * i;
          break;
      }
      return s2;
    },
    // 获取截图框的坐标轴
    getCropAxis() {
      let t = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      };
      return t.x1 = this.cropOffsertX, t.x2 = t.x1 + this.cropW, t.y1 = this.cropOffsertY, t.y2 = t.y1 + this.cropH, t;
    },
    leaveCrop(t) {
      window.removeEventListener("mousemove", this.moveCrop), window.removeEventListener("mouseup", this.leaveCrop), window.removeEventListener("touchmove", this.moveCrop), window.removeEventListener("touchend", this.leaveCrop), this.$emit("crop-moving", {
        moving: false,
        axis: this.getCropAxis()
      });
    },
    getCropChecked(t) {
      let e = document.createElement("canvas"), i = new Image(), s2 = this.rotate, r = this.trueWidth, o2 = this.trueHeight, h29 = this.cropOffsertX, n = this.cropOffsertY;
      i.onload = () => {
        if (this.cropW !== 0) {
          let a3 = e.getContext("2d"), p2 = 1;
          this.high & !this.full && (p2 = window.devicePixelRatio), this.enlarge !== 1 & !this.full && (p2 = Math.abs(Number(this.enlarge)));
          let f2 = this.cropW * p2, w3 = this.cropH * p2, u2 = r * this.scale * p2, d2 = o2 * this.scale * p2, g = (this.x - h29 + this.trueWidth * (1 - this.scale) / 2) * p2, m3 = (this.y - n + this.trueHeight * (1 - this.scale) / 2) * p2;
          switch (c2(f2, w3), a3.save(), this.fillColor && (a3.fillStyle = this.fillColor, a3.fillRect(0, 0, e.width, e.height)), s2) {
            case 0:
              this.full ? (c2(f2 / this.scale, w3 / this.scale), a3.drawImage(
                i,
                g / this.scale,
                m3 / this.scale,
                u2 / this.scale,
                d2 / this.scale
              )) : a3.drawImage(i, g, m3, u2, d2);
              break;
            case 1:
            case -3:
              this.full ? (c2(f2 / this.scale, w3 / this.scale), g = g / this.scale + (u2 / this.scale - d2 / this.scale) / 2, m3 = m3 / this.scale + (d2 / this.scale - u2 / this.scale) / 2, a3.rotate(s2 * 90 * Math.PI / 180), a3.drawImage(
                i,
                m3,
                -g - d2 / this.scale,
                u2 / this.scale,
                d2 / this.scale
              )) : (g = g + (u2 - d2) / 2, m3 = m3 + (d2 - u2) / 2, a3.rotate(s2 * 90 * Math.PI / 180), a3.drawImage(i, m3, -g - d2, u2, d2));
              break;
            case 2:
            case -2:
              this.full ? (c2(f2 / this.scale, w3 / this.scale), a3.rotate(s2 * 90 * Math.PI / 180), g = g / this.scale, m3 = m3 / this.scale, a3.drawImage(
                i,
                -g - u2 / this.scale,
                -m3 - d2 / this.scale,
                u2 / this.scale,
                d2 / this.scale
              )) : (a3.rotate(s2 * 90 * Math.PI / 180), a3.drawImage(i, -g - u2, -m3 - d2, u2, d2));
              break;
            case 3:
            case -1:
              this.full ? (c2(f2 / this.scale, w3 / this.scale), g = g / this.scale + (u2 / this.scale - d2 / this.scale) / 2, m3 = m3 / this.scale + (d2 / this.scale - u2 / this.scale) / 2, a3.rotate(s2 * 90 * Math.PI / 180), a3.drawImage(
                i,
                -m3 - u2 / this.scale,
                g,
                u2 / this.scale,
                d2 / this.scale
              )) : (g = g + (u2 - d2) / 2, m3 = m3 + (d2 - u2) / 2, a3.rotate(s2 * 90 * Math.PI / 180), a3.drawImage(i, -m3 - u2, g, u2, d2));
              break;
            default:
              this.full ? (c2(f2 / this.scale, w3 / this.scale), a3.drawImage(
                i,
                g / this.scale,
                m3 / this.scale,
                u2 / this.scale,
                d2 / this.scale
              )) : a3.drawImage(i, g, m3, u2, d2);
          }
          a3.restore();
        } else {
          let a3 = r * this.scale, p2 = o2 * this.scale, f2 = e.getContext("2d");
          switch (f2.save(), this.fillColor && (f2.fillStyle = this.fillColor, f2.fillRect(0, 0, e.width, e.height)), s2) {
            case 0:
              c2(a3, p2), f2.drawImage(i, 0, 0, a3, p2);
              break;
            case 1:
            case -3:
              c2(p2, a3), f2.rotate(s2 * 90 * Math.PI / 180), f2.drawImage(i, 0, -p2, a3, p2);
              break;
            case 2:
            case -2:
              c2(a3, p2), f2.rotate(s2 * 90 * Math.PI / 180), f2.drawImage(i, -a3, -p2, a3, p2);
              break;
            case 3:
            case -1:
              c2(p2, a3), f2.rotate(s2 * 90 * Math.PI / 180), f2.drawImage(i, -a3, 0, a3, p2);
              break;
            default:
              c2(a3, p2), f2.drawImage(i, 0, 0, a3, p2);
          }
          f2.restore();
        }
        t(e);
      };
      var l2 = this.img.substr(0, 4);
      l2 !== "data" && (i.crossOrigin = "Anonymous"), i.src = this.imgs;
      function c2(a3, p2) {
        e.width = Math.round(a3), e.height = Math.round(p2);
      }
    },
    // 获取转换成base64 的图片信息
    getCropData(t) {
      this.getCropChecked((e) => {
        t(e.toDataURL("image/" + this.outputType, this.outputSize));
      });
    },
    //canvas获取为blob对象
    getCropBlob(t) {
      this.getCropChecked((e) => {
        e.toBlob(
          (i) => t(i),
          "image/" + this.outputType,
          this.outputSize
        );
      });
    },
    // 自动预览函数
    showPreview() {
      if (this.isCanShow)
        this.isCanShow = false, setTimeout(() => {
          this.isCanShow = true;
        }, 16);
      else
        return false;
      let t = this.cropW, e = this.cropH, i = this.scale;
      var s2 = {};
      s2.div = {
        width: `${t}px`,
        height: `${e}px`
      };
      let r = (this.x - this.cropOffsertX) / i, o2 = (this.y - this.cropOffsertY) / i, h29 = 0;
      s2.w = t, s2.h = e, s2.url = this.imgs, s2.img = {
        width: `${this.trueWidth}px`,
        height: `${this.trueHeight}px`,
        transform: `scale(${i})translate3d(${r}px, ${o2}px, ${h29}px)rotateZ(${this.rotate * 90}deg)`
      }, s2.html = `
      <div class="show-preview" style="width: ${s2.w}px; height: ${s2.h}px,; overflow: hidden">
        <div style="width: ${t}px; height: ${e}px">
          <img src=${s2.url} style="width: ${this.trueWidth}px; height: ${this.trueHeight}px; transform:
          scale(${i})translate3d(${r}px, ${o2}px, ${h29}px)rotateZ(${this.rotate * 90}deg)">
        </div>
      </div>`, this.$emit("real-time", s2);
    },
    // reload 图片布局函数
    reload() {
      let t = new Image();
      t.onload = () => {
        this.w = parseFloat(window.getComputedStyle(this.$refs.cropper).width), this.h = parseFloat(window.getComputedStyle(this.$refs.cropper).height), this.trueWidth = t.width, this.trueHeight = t.height, this.original ? this.scale = 1 : this.scale = this.checkedMode(), this.$nextTick(() => {
          this.x = -(this.trueWidth - this.trueWidth * this.scale) / 2 + (this.w - this.trueWidth * this.scale) / 2, this.y = -(this.trueHeight - this.trueHeight * this.scale) / 2 + (this.h - this.trueHeight * this.scale) / 2, this.loading = false, this.autoCrop && this.goAutoCrop(), this.$emit("img-load", "success"), setTimeout(() => {
            this.showPreview();
          }, 20);
        });
      }, t.onerror = () => {
        this.$emit("img-load", "error");
      }, t.src = this.imgs;
    },
    // 背景布局的函数
    checkedMode() {
      let t = 1, e = this.trueWidth, i = this.trueHeight;
      const s2 = this.mode.split(" ");
      switch (s2[0]) {
        case "contain":
          this.trueWidth > this.w && (t = this.w / this.trueWidth), this.trueHeight * t > this.h && (t = this.h / this.trueHeight);
          break;
        case "cover":
          e = this.w, t = e / this.trueWidth, i = i * t, i < this.h && (i = this.h, t = i / this.trueHeight);
          break;
        default:
          try {
            let r = s2[0];
            if (r.search("px") !== -1) {
              r = r.replace("px", ""), e = parseFloat(r);
              const o2 = e / this.trueWidth;
              let h29 = 1, n = s2[1];
              n.search("px") !== -1 && (n = n.replace("px", ""), i = parseFloat(n), h29 = i / this.trueHeight), t = Math.min(o2, h29);
            }
            if (r.search("%") !== -1 && (r = r.replace("%", ""), e = parseFloat(r) / 100 * this.w, t = e / this.trueWidth), s2.length === 2 && r === "auto") {
              let o2 = s2[1];
              o2.search("px") !== -1 && (o2 = o2.replace("px", ""), i = parseFloat(o2), t = i / this.trueHeight), o2.search("%") !== -1 && (o2 = o2.replace("%", ""), i = parseFloat(o2) / 100 * this.h, t = i / this.trueHeight);
            }
          } catch {
            t = 1;
          }
      }
      return t;
    },
    // 自动截图函数
    goAutoCrop(t, e) {
      if (this.imgs === "" || this.imgs === null)
        return;
      this.clearCrop(), this.cropping = true;
      let i = this.w, s2 = this.h;
      if (this.centerBox) {
        const h29 = Math.abs(this.rotate) % 2 > 0;
        let n = (h29 ? this.trueHeight : this.trueWidth) * this.scale, l2 = (h29 ? this.trueWidth : this.trueHeight) * this.scale;
        i = n < i ? n : i, s2 = l2 < s2 ? l2 : s2;
      }
      var r = t || parseFloat(this.autoCropWidth), o2 = e || parseFloat(this.autoCropHeight);
      (r === 0 || o2 === 0) && (r = i * 0.8, o2 = s2 * 0.8), r = r > i ? i : r, o2 = o2 > s2 ? s2 : o2, this.fixed && (o2 = r / this.fixedNumber[0] * this.fixedNumber[1]), o2 > this.h && (o2 = this.h, r = o2 / this.fixedNumber[1] * this.fixedNumber[0]), this.changeCrop(r, o2);
    },
    // 手动改变截图框大小函数
    changeCrop(t, e) {
      if (this.centerBox) {
        let i = this.getImgAxis();
        t > i.x2 - i.x1 && (t = i.x2 - i.x1, e = t / this.fixedNumber[0] * this.fixedNumber[1]), e > i.y2 - i.y1 && (e = i.y2 - i.y1, t = e / this.fixedNumber[1] * this.fixedNumber[0]);
      }
      this.cropW = t, this.cropH = e, this.checkCropLimitSize(), this.$nextTick(() => {
        this.cropOffsertX = (this.w - this.cropW) / 2, this.cropOffsertY = (this.h - this.cropH) / 2, this.centerBox && this.moveCrop(null, true);
      });
    },
    // 重置函数， 恢复组件置初始状态
    refresh() {
      this.img, this.imgs = "", this.scale = 1, this.crop = false, this.rotate = 0, this.w = 0, this.h = 0, this.trueWidth = 0, this.trueHeight = 0, this.clearCrop(), this.$nextTick(() => {
        this.checkedImg();
      });
    },
    // 向左边旋转
    rotateLeft() {
      this.rotate = this.rotate <= -3 ? 0 : this.rotate - 1;
    },
    // 向右边旋转
    rotateRight() {
      this.rotate = this.rotate >= 3 ? 0 : this.rotate + 1;
    },
    // 清除旋转
    rotateClear() {
      this.rotate = 0;
    },
    // 图片坐标点校验
    checkoutImgAxis(t, e, i) {
      t = t || this.x, e = e || this.y, i = i || this.scale;
      let s2 = true;
      if (this.centerBox) {
        let r = this.getImgAxis(t, e, i), o2 = this.getCropAxis();
        r.x1 >= o2.x1 && (s2 = false), r.x2 <= o2.x2 && (s2 = false), r.y1 >= o2.y1 && (s2 = false), r.y2 <= o2.y2 && (s2 = false);
      }
      return s2;
    }
  },
  mounted() {
    this.support = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    let t = this;
    var e = navigator.userAgent;
    this.isIOS = !!e.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
      value: function(i, s2, r) {
        for (var o2 = atob(this.toDataURL(s2, r).split(",")[1]), h29 = o2.length, n = new Uint8Array(h29), l2 = 0; l2 < h29; l2++)
          n[l2] = o2.charCodeAt(l2);
        i(new Blob([n], { type: t.type || "image/png" }));
      }
    }), this.showPreview(), this.checkedImg();
  },
  unmounted() {
    window.removeEventListener("mousemove", this.moveCrop), window.removeEventListener("mouseup", this.leaveCrop), window.removeEventListener("touchmove", this.moveCrop), window.removeEventListener("touchend", this.leaveCrop), this.cancelScale();
  }
});
var $ = {
  key: 0,
  class: "cropper-box"
};
var z = ["src"];
var B2 = { class: "cropper-view-box" };
var P3 = ["src"];
var D2 = { key: 1 };
function U3(t, e, i, s2, r, o2) {
  return (0, import_vue621.openBlock)(), (0, import_vue621.createElementBlock)("div", {
    class: "vue-cropper",
    ref: "cropper",
    onMouseover: e[28] || (e[28] = (...h29) => t.scaleImg && t.scaleImg(...h29)),
    onMouseout: e[29] || (e[29] = (...h29) => t.cancelScale && t.cancelScale(...h29))
  }, [
    t.imgs ? ((0, import_vue621.openBlock)(), (0, import_vue621.createElementBlock)("div", $, [
      (0, import_vue621.withDirectives)((0, import_vue621.createElementVNode)("div", {
        class: "cropper-box-canvas",
        style: (0, import_vue621.normalizeStyle)({
          width: t.trueWidth + "px",
          height: t.trueHeight + "px",
          transform: "scale(" + t.scale + "," + t.scale + ") translate3d(" + t.x / t.scale + "px," + t.y / t.scale + "px,0)rotateZ(" + t.rotate * 90 + "deg)"
        })
      }, [
        (0, import_vue621.createElementVNode)("img", {
          src: t.imgs,
          alt: "cropper-img",
          ref: "cropperImg"
        }, null, 8, z)
      ], 4), [
        [import_vue621.vShow, !t.loading]
      ])
    ])) : (0, import_vue621.createCommentVNode)("", true),
    (0, import_vue621.createElementVNode)("div", {
      class: (0, import_vue621.normalizeClass)(["cropper-drag-box", { "cropper-move": t.move && !t.crop, "cropper-crop": t.crop, "cropper-modal": t.cropping }]),
      onMousedown: e[0] || (e[0] = (...h29) => t.startMove && t.startMove(...h29)),
      onTouchstart: e[1] || (e[1] = (...h29) => t.startMove && t.startMove(...h29))
    }, null, 34),
    (0, import_vue621.withDirectives)((0, import_vue621.createElementVNode)("div", {
      class: "cropper-crop-box",
      style: (0, import_vue621.normalizeStyle)({
        width: t.cropW + "px",
        height: t.cropH + "px",
        transform: "translate3d(" + t.cropOffsertX + "px," + t.cropOffsertY + "px,0)"
      })
    }, [
      (0, import_vue621.createElementVNode)("span", B2, [
        (0, import_vue621.createElementVNode)("img", {
          style: (0, import_vue621.normalizeStyle)({
            width: t.trueWidth + "px",
            height: t.trueHeight + "px",
            transform: "scale(" + t.scale + "," + t.scale + ") translate3d(" + (t.x - t.cropOffsertX) / t.scale + "px," + (t.y - t.cropOffsertY) / t.scale + "px,0)rotateZ(" + t.rotate * 90 + "deg)"
          }),
          src: t.imgs,
          alt: "cropper-img"
        }, null, 12, P3)
      ]),
      (0, import_vue621.createElementVNode)("span", {
        class: "cropper-face cropper-move",
        onMousedown: e[2] || (e[2] = (...h29) => t.cropMove && t.cropMove(...h29)),
        onTouchstart: e[3] || (e[3] = (...h29) => t.cropMove && t.cropMove(...h29))
      }, null, 32),
      t.info ? ((0, import_vue621.openBlock)(), (0, import_vue621.createElementBlock)("span", {
        key: 0,
        class: "crop-info",
        style: (0, import_vue621.normalizeStyle)({ top: t.cropInfo.top })
      }, (0, import_vue621.toDisplayString)(t.cropInfo.width) + " \xD7 " + (0, import_vue621.toDisplayString)(t.cropInfo.height), 5)) : (0, import_vue621.createCommentVNode)("", true),
      t.fixedBox ? (0, import_vue621.createCommentVNode)("", true) : ((0, import_vue621.openBlock)(), (0, import_vue621.createElementBlock)("span", D2, [
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-line line-w",
          onMousedown: e[4] || (e[4] = (h29) => t.changeCropSize(h29, false, true, 0, 1)),
          onTouchstart: e[5] || (e[5] = (h29) => t.changeCropSize(h29, false, true, 0, 1))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-line line-a",
          onMousedown: e[6] || (e[6] = (h29) => t.changeCropSize(h29, true, false, 1, 0)),
          onTouchstart: e[7] || (e[7] = (h29) => t.changeCropSize(h29, true, false, 1, 0))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-line line-s",
          onMousedown: e[8] || (e[8] = (h29) => t.changeCropSize(h29, false, true, 0, 2)),
          onTouchstart: e[9] || (e[9] = (h29) => t.changeCropSize(h29, false, true, 0, 2))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-line line-d",
          onMousedown: e[10] || (e[10] = (h29) => t.changeCropSize(h29, true, false, 2, 0)),
          onTouchstart: e[11] || (e[11] = (h29) => t.changeCropSize(h29, true, false, 2, 0))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point1",
          onMousedown: e[12] || (e[12] = (h29) => t.changeCropSize(h29, true, true, 1, 1)),
          onTouchstart: e[13] || (e[13] = (h29) => t.changeCropSize(h29, true, true, 1, 1))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point2",
          onMousedown: e[14] || (e[14] = (h29) => t.changeCropSize(h29, false, true, 0, 1)),
          onTouchstart: e[15] || (e[15] = (h29) => t.changeCropSize(h29, false, true, 0, 1))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point3",
          onMousedown: e[16] || (e[16] = (h29) => t.changeCropSize(h29, true, true, 2, 1)),
          onTouchstart: e[17] || (e[17] = (h29) => t.changeCropSize(h29, true, true, 2, 1))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point4",
          onMousedown: e[18] || (e[18] = (h29) => t.changeCropSize(h29, true, false, 1, 0)),
          onTouchstart: e[19] || (e[19] = (h29) => t.changeCropSize(h29, true, false, 1, 0))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point5",
          onMousedown: e[20] || (e[20] = (h29) => t.changeCropSize(h29, true, false, 2, 0)),
          onTouchstart: e[21] || (e[21] = (h29) => t.changeCropSize(h29, true, false, 2, 0))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point6",
          onMousedown: e[22] || (e[22] = (h29) => t.changeCropSize(h29, true, true, 1, 2)),
          onTouchstart: e[23] || (e[23] = (h29) => t.changeCropSize(h29, true, true, 1, 2))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point7",
          onMousedown: e[24] || (e[24] = (h29) => t.changeCropSize(h29, false, true, 0, 2)),
          onTouchstart: e[25] || (e[25] = (h29) => t.changeCropSize(h29, false, true, 0, 2))
        }, null, 32),
        (0, import_vue621.createElementVNode)("span", {
          class: "crop-point point8",
          onMousedown: e[26] || (e[26] = (h29) => t.changeCropSize(h29, true, true, 2, 2)),
          onTouchstart: e[27] || (e[27] = (h29) => t.changeCropSize(h29, true, true, 2, 2))
        }, null, 32)
      ]))
    ], 4), [
      [import_vue621.vShow, t.cropping]
    ])
  ], 544);
}
var W2 = /* @__PURE__ */ N3(A2, [["render", U3], ["__scopeId", "data-v-18751258"]]);

// src/components/YoungUpload.tsx
var YoungUpload_default = (0, import_vue622.defineComponent)({
  props: {
    modelValue: {
      type: Array,
      required: true
    },
    limit: {
      type: Number,
      default: 1
    },
    type: {
      type: String,
      default: "image"
    },
    accept: {
      type: String,
      default: ""
    },
    uploadFn: {
      type: Function,
      required: true
    },
    cropper: {
      type: Boolean,
      default: false
    },
    aspt: {
      type: Object,
      default: () => [1, 1]
    },
    cropperAttrs: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:modelValue", "change"],
  setup(props, { emit }) {
    const files = (0, import_vue622.computed)(
      () => props.modelValue.map((url2, index2) => ({
        uid: index2,
        name: url2,
        status: "success",
        url: url2
      }))
    );
    const exceed = () => ElMessage.error("\u8D85\u51FA\u6570\u91CF\u9650\u5236\uFF01\uFF01\uFF01");
    const del2 = (_2, all) => {
      const arr = all.map((item) => item.url);
      emit("update:modelValue", arr);
      emit("change", arr);
    };
    const upload = async (file) => {
      if (file) {
        if (props.type === "image" && props.cropper) {
          showClipPopup.value = true;
          await (0, import_vue622.nextTick)();
          coverFile.value = URL.createObjectURL(file.raw);
          cropper.value.startCrop();
        } else {
          const url2 = await props.uploadFn(file.raw);
          const arr = [
            ...files.value.filter((item) => item.status === "success").map((item) => item.url),
            url2
          ];
          emit("update:modelValue", arr);
          emit("change", arr);
        }
      }
    };
    const preView = (url2) => {
      const index2 = props.modelValue.indexOf(url2);
      useImagePreview({
        srcList: props.modelValue,
        index: index2 === -1 ? 0 : index2
      });
    };
    const limitStyle = (0, import_vue622.computed)(
      () => props.modelValue.length < props.limit ? "inline-flex" : "none"
    );
    const id2 = "young-upload-" + ne();
    const cropper = (0, import_vue622.ref)();
    const coverFile = (0, import_vue622.ref)();
    const showClipPopup = (0, import_vue622.ref)(false);
    const sureClip = () => {
      cropper.value.getCropBlob(async (blob) => {
        const url2 = await props.uploadFn(blob);
        const arr = [
          ...files.value.filter((item) => item.status === "success").map((item) => item.url),
          url2
        ];
        emit("update:modelValue", arr);
        emit("change", arr);
        coverFile.value = "";
      });
      showClipPopup.value = false;
    };
    const cancelClip = () => {
      coverFile.value = "";
      showClipPopup.value = false;
      const arr = [
        ...files.value.filter((item) => item.status === "success").map((item) => item.url)
      ];
      emit("update:modelValue", arr);
      emit("change", arr);
    };
    const ltLg = useMediaQuery("(max-width: 1023.9px)");
    return () => <div id={id2}>
      <style>{`
          #${id2} .el-upload--picture-card {
            display: ${limitStyle.value};
          }
          `}</style>
      <ElUpload
        accept={props.accept ? props.accept : props.type === "image" ? "image/*" : "*"}
        limit={props.limit}
        listType={props.type === "image" ? "picture-card" : void 0}
        multiple={props.limit > 1}
        fileList={files.value}
        autoUpload={false}
        onExceed={exceed}
        onChange={upload}
        onRemove={del2}
        onPreview={({ url: url2 }) => props.type === "image" && preView(url2)}
        style={{ maxWidth: "500px" }}
      >
        <div>{props.modelValue.length < props.limit && props.type === "image" ? <div
          style={{
            fontSize: "1.875rem",
            lineHeight: "2.25rem"
          }}
        ><svg
          xmlns="http://www.w3.org/2000/svg"
          width="1em"
          height="1em"
          viewBox="0 0 24 24"
        ><path
          fill="currentColor"
          d="M18 12.998h-5v5a1 1 0 0 1-2 0v-5H6a1 1 0 0 1 0-2h5v-5a1 1 0 0 1 2 0v5h5a1 1 0 0 1 0 2z"
        /></svg></div> : props.modelValue.length < props.limit ? <div style={{ marginRight: "0.5rem" }}><ElButton type="primary">{"\u4E0A\u4F20\u6587\u4EF6"}</ElButton></div> : <div style={{ cursor: "not-allowed", pointerEvents: "none" }}>{"\u5DF2\u8FBE\u6570\u91CF\u4E0A\u9650"}</div>}</div>
        <div>
          {"("}
          {props.modelValue.length}
          {" / "}
          {props.limit}
          {")"}
        </div>
      </ElUpload>
      <YoungDialog_default
        modelValue={showClipPopup.value}
        onUpdate:modelValue={(v3) => showClipPopup.value = v3}
        top="0"
        width="96%"
        realTitle={"\u56FE\u7247\u88C1\u526A"}
        showCancel={false}
        showSure={false}
      >{{
        body: () => <div
          style={{
            width: "100%",
            height: "100%",
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
          }}
        >
          <div
            style={{
              width: ltLg.value ? "90vw" : "800px",
              height: ltLg.value ? "90vh" : "72vh"
            }}
          ><W2
            ref={cropper}
            autoCrop
            centerBox
            fixedNumber={props.aspt}
            img={coverFile.value}
            outputType="webp"
            fixed
            {...props.cropperAttrs}
          /></div>
          <div
            style={{
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              height: "80px",
              width: "96%",
              padding: "0 20px"
            }}
          >
            <ElButton style={{ width: "48%" }} onClick={cancelClip}>{"\u53D6\u6D88"}</ElButton>
            <ElButton style={{ width: "48%" }} type="primary" onClick={sureClip}>{"\u88C1\u526A"}</ElButton>
          </div>
        </div>
      }}</YoungDialog_default>
    </div>;
  }
});

// src/hooks/useAutoLoad.ts
var import_vue623 = require("vue");
var useAutoLoad = (list, allData, pageSize = 10, pause = (0, import_vue623.ref)(false)) => {
  const elArr = (0, import_vue623.ref)([]);
  const touchEndEl = (0, import_vue623.ref)(false);
  const page = (0, import_vue623.ref)(1);
  const load = () => {
    const { stop } = useIntersectionObserver(
      elArr.value[list.value.length - 1],
      ([{ isIntersecting }]) => {
        if (isIntersecting) {
          touchEndEl.value = isIntersecting;
          stop();
        }
      }
    );
  };
  (0, import_vue623.watchEffect)(async () => {
    if (pause.value) {
      return;
    }
    if (touchEndEl.value) {
      if (list.value.length === allData.value.length) {
        return;
      }
      page.value++;
      const slicePart = allData.value.slice(pageSize * (page.value - 1), pageSize * page.value);
      if (slicePart.length === 0) {
        return;
      }
      list.value.push(...slicePart);
      touchEndEl.value = false;
      await (0, import_vue623.nextTick)();
      load();
    }
  });
  return {
    elArr,
    touchEndEl,
    page,
    load
  };
};

// src/hooks/useFormMode.ts
var import_vue624 = require("vue");
var useFormMode = (FORM_TEMP, { addCbk, modCbk, delCbk, cpEffect, cgEffect, clearEffect, disableclear }, tip = "\u786E\u8BA4\u5220\u9664\u8BE5\u6761\u6570\u636E\uFF1F") => {
  const isAdd = (0, import_vue624.ref)(false);
  const isEdit = (0, import_vue624.ref)(false);
  const isMore = (0, import_vue624.ref)(false);
  const form = (0, import_vue624.ref)(I(FORM_TEMP));
  const formRef = (0, import_vue624.ref)();
  const validForm = async () => {
    const res = await new Promise((resolve) => {
      formRef.value?.validate(async (valid) => {
        if (valid) {
          resolve(true);
        }
      }).catch((err) => {
        resolve(false);
      });
    });
    return res;
  };
  const clear = () => {
    isAdd.value = false;
    isEdit.value = false;
    isMore.value = false;
    clearEffect?.();
    form.value = I(FORM_TEMP);
  };
  const del2 = (row) => {
    ElMessageBox.confirm(tip, "\u63D0\u793A", {
      confirmButtonText: "\u786E\u8BA4",
      cancelButtonText: "\u53D6\u6D88",
      type: "warning"
    }).then(async () => {
      await delCbk?.(row);
      cgEffect?.();
    }).catch(() => null);
  };
  const sure = async () => {
    if (isAdd.value) {
      const res = await addCbk?.();
      if (res === false) {
        return;
      }
    } else {
      const res = await modCbk?.();
      if (res === false) {
        return;
      }
    }
    !disableclear && clear();
    cgEffect?.();
  };
  const edit = async (row) => {
    const res = await cpEffect?.(row);
    form.value = I(res || row);
    isEdit.value = true;
  };
  const more = async (row) => {
    const res = await cpEffect?.(row);
    form.value = I(res || row);
    isMore.value = true;
  };
  return {
    isAdd,
    isEdit,
    isMore,
    clear,
    edit,
    more,
    form,
    del: del2,
    sure,
    formRef,
    validForm
  };
};

// src/hooks/useExport.ts
var import_server_renderer = require("vue/server-renderer");

// src/hooks/tools/export2excel.ts
var import_file_saver = require("file-saver");
var import_xlsx = require("xlsx");
function sheet_from_array_of_arrays(data) {
  const ws = {};
  const range3 = {
    s: {
      c: 1e7,
      r: 1e7
    },
    e: {
      c: 0,
      r: 0
    }
  };
  for (let R2 = 0; R2 != data.length; ++R2) {
    for (let C3 = 0; C3 != data[R2].length; ++C3) {
      if (range3.s.r > R2)
        range3.s.r = R2;
      if (range3.s.c > C3)
        range3.s.c = C3;
      if (range3.e.r < R2)
        range3.e.r = R2;
      if (range3.e.c < C3)
        range3.e.c = C3;
      const cell = {
        v: data[R2][C3]
      };
      if (cell.v == null)
        continue;
      const cell_ref = import_xlsx.utils.encode_cell({
        c: C3,
        r: R2
      });
      if (typeof cell.v === "number") {
        cell.t = "n";
      } else if (typeof cell.v === "boolean") {
        cell.t = "b";
      } else {
        cell.t = "s";
      }
      ws[cell_ref] = cell;
    }
  }
  if (range3.s.c < 1e7) {
    ws["!ref"] = import_xlsx.utils.encode_range(range3);
  }
  return ws;
}
var Workbook = class {
  SheetNames = [];
  Sheets = {};
};
var s2ab = (s2) => {
  const buf = new ArrayBuffer(s2.length);
  const view = new Uint8Array(buf);
  for (let i = 0; i < s2.length; ++i) {
    view[i] = s2.charCodeAt(i) & 255;
  }
  return buf;
};
var export_json_to_excel = ({ header, data, filename }) => {
  data = I(data);
  data.unshift(header);
  const ws_name = "SheetJS";
  const wb = new Workbook();
  const ws = sheet_from_array_of_arrays(data);
  const colWidth = data.map((row) => {
    return row.map((val) => {
      if (val == null) {
        return {
          wch: 10
        };
      } else if (val.toString().charCodeAt(0) > 255) {
        return {
          wch: val.toString().length * 2
        };
      } else {
        return {
          wch: val.toString().length
        };
      }
    });
  });
  let result = colWidth[0];
  for (let i = 1; i < colWidth.length; i++) {
    for (let j = 0; j < colWidth[i].length; j++) {
      if (result[j]["wch"] < colWidth[i][j]["wch"]) {
        result[j]["wch"] = colWidth[i][j]["wch"];
      }
    }
  }
  ws["!cols"] = result;
  wb.SheetNames.push(ws_name);
  wb.Sheets[ws_name] = ws;
  const wbout = (0, import_xlsx.write)(wb, {
    bookType: "xlsx",
    bookSST: false,
    type: "binary"
  });
  (0, import_file_saver.saveAs)(
    new Blob([s2ab(wbout)], {
      type: "application/octet-stream"
    }),
    `${filename}.xlsx`
  );
};

// src/hooks/useExport.ts
var useExport2Excel = async ({ filename, tableHead, tableData }) => {
  const tagReplace = (htmlText) => {
    let reg = /<\/?.+?\/?>/g;
    if (reg.test(htmlText)) {
      return htmlText.replace(reg, "");
    } else {
      return htmlText;
    }
  };
  const formatJson = async (tableHead2, tableData2) => {
    const arr = [];
    for (const it2 of tableData2) {
      const row = [];
      const len = tableHead2.length;
      for (let i = 0; i < len; i++) {
        const item = tableHead2[i];
        let r = it2[item.prop];
        if (item.render) {
          const vnode = item.render(it2, i);
          if (vnode && Array.isArray(vnode.children) && vnode.children.length > 1) {
            vnode.children.forEach((v3) => {
              if (v3 && typeof v3.children === "string") {
                v3.children += "\n";
              }
            });
          }
          r = await (0, import_server_renderer.renderToString)(vnode);
        }
        r = tagReplace(r);
        row.push(r);
      }
      arr.push(row);
    }
    return arr;
  };
  const ths = tableHead.filter((item) => !item.only_display);
  const header = ths.map((item) => item.label);
  const loading = Loading({
    lock: true,
    text: "\u6570\u636E\u5BFC\u51FA\u4E2D...",
    background: "rgba(0, 0, 0, 0.7)"
  });
  return new Promise((resolve) => {
    setTimeout(async () => {
      const data = await formatJson(ths, tableData);
      await export_json_to_excel({
        header,
        data,
        filename
      });
      loading.close();
      ElMessage.success("\u5BFC\u51FA\u6210\u529F\uFF01");
      resolve(true);
    }, 500);
  });
};

// src/hooks/useVerifyCode.ts
var import_vue625 = require("vue");
var useVerifyCode = (cbk, default_wait = 60, default_tip = "\u83B7\u53D6\u9A8C\u8BC1\u7801") => {
  const count = (0, import_vue625.ref)(default_wait);
  const tip = (0, import_vue625.ref)(default_tip);
  const timer = (0, import_vue625.ref)();
  const startCountDown = () => {
    count.value--;
    tip.value = `${count.value} \u79D2\u540E\u91CD\u8BD5`;
    timer.value = setInterval(() => {
      if (count.value > 0) {
        count.value--;
        tip.value = `${count.value} \u79D2\u540E\u91CD\u8BD5`;
      } else {
        endCountDown();
      }
    }, 1e3);
  };
  const endCountDown = () => {
    count.value = default_wait;
    tip.value = default_tip;
    clearInterval(timer.value);
  };
  const showSlider = (0, import_vue625.ref)(false);
  const start = () => {
    showSlider.value = true;
  };
  const pass = async () => {
    console.log("\u9A8C\u8BC1\u901A\u8FC7");
    showSlider.value = false;
    await cbk();
    startCountDown();
  };
  const cancel = () => {
    console.log("\u53D6\u6D88\u9A8C\u8BC1");
    showSlider.value = false;
  };
  const getCode = () => {
    if (count.value !== default_wait) {
      return;
    }
    start();
  };
  return {
    getCode,
    tip,
    showSlider,
    pass,
    cancel
  };
};

// src/hooks/useImagePreview.ts
var import_vue626 = require("vue");
var useImagePreview = (conf, zIndex2 = 9999) => {
  const appendTo = document.createElement("div");
  const vnode = (0, import_vue626.createVNode)(YoungImageViewer_default, {
    onDestroy: () => {
      document.body.removeChild(appendTo);
    },
    zIndex: zIndex2
  });
  (0, import_vue626.render)(vnode, appendTo);
  document.body.appendChild(appendTo);
  vnode.component.exposed?.show(conf);
};

// src/hooks/useKeyboardFn.ts
var useKeyUp = (e, fn2, key = "enter") => {
  if (e.key.toLocaleLowerCase() === key) {
    e.preventDefault();
    fn2();
  }
};

// src/hooks/useQuery.ts
var import_vue627 = require("vue");
var useQuery = (QUERY_TEMP, cbk) => {
  const query = (0, import_vue627.ref)(I(QUERY_TEMP));
  const reset = () => {
    query.value = I(QUERY_TEMP);
    cbk();
  };
  return {
    query,
    reset
  };
};

// src/hooks/useRemoteSearch.ts
var import_vue628 = require("vue");
var useRemoteSearch = (cbk) => {
  const loading = (0, import_vue628.ref)(false);
  const searchStr = (0, import_vue628.ref)("");
  const options = (0, import_vue628.ref)([]);
  const search = async (str) => {
    str = str.trim();
    const res = await cbk(str);
    if (res) {
      options.value = res;
    }
  };
  const init = (0, import_vue628.ref)(false);
  return {
    loading,
    search,
    searchStr,
    options,
    init
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  YoungDateRange,
  YoungDialog,
  YoungImageViewer,
  YoungPagination,
  YoungRotateTip,
  YoungSearchForm,
  YoungSelect,
  YoungTable,
  YoungTablePro,
  YoungTimeRange,
  YoungUpload,
  YoungWeekday,
  useAutoLoad,
  useExport2Excel,
  useFormMode,
  useImagePreview,
  useKeyUp,
  useQuery,
  useRemoteSearch,
  useVerifyCode
});
/*! Bundled license information:

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@element-plus/icons-vue/dist/index.js:
  (*! Element Plus Icons Vue v2.0.10 *)

normalize-wheel-es/dist/index.mjs:
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)
*/
