"use strict";

/*
 * Polyfill service v4.8.0
 * Disable minification (remove `.min` from URL path) for more info
*/

(function (self, undefined) {
  function Call(t, l) {
    var n = arguments.length > 2 ? arguments[2] : [];
    if (!1 === IsCallable(t)) throw new TypeError(Object.prototype.toString.call(t) + "is not a function.");
    return t.apply(l, n);
  }
  function CreateMethodProperty(e, r, t) {
    var a = {
      value: t,
      writable: !0,
      enumerable: !1,
      configurable: !0
    };
    Object.defineProperty(e, r, a);
  }
  function Get(n, t) {
    return n[t];
  }
  function HasOwnProperty(r, t) {
    return Object.prototype.hasOwnProperty.call(r, t);
  }
  function IsCallable(n) {
    return "function" == typeof n;
  }
  function ToObject(r) {
    if (null === r || void 0 === r) throw TypeError();
    return Object(r);
  }
  function GetV(t, e) {
    return ToObject(t)[e];
  }
  function GetMethod(e, l) {
    var t = GetV(e, l);
    if (null !== t && void 0 !== t) {
      if (!1 === IsCallable(t)) throw new TypeError("Method not callable: " + l);
      return t;
    }
  }
  function Type(e) {
    switch (typeof e) {
      case "undefined":
        return "undefined";
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
      case "symbol":
        return "symbol";
      default:
        return null === e ? "null" : "Symbol" in self && (e instanceof self.Symbol || e.constructor === self.Symbol) ? "symbol" : "object";
    }
  }
  function OrdinaryToPrimitive(r, t) {
    if ("string" === t) var e = ["toString", "valueOf"];else e = ["valueOf", "toString"];
    for (var i = 0; i < e.length; ++i) {
      var n = e[i],
        a = Get(r, n);
      if (IsCallable(a)) {
        var o = Call(a, r);
        if ("object" !== Type(o)) return o;
      }
    }
    throw new TypeError("Cannot convert to primitive.");
  }
  function ToPrimitive(e) {
    var t = arguments.length > 1 ? arguments[1] : void 0;
    if ("object" === Type(e)) {
      if (arguments.length < 2) var i = "default";else t === String ? i = "string" : t === Number && (i = "number");
      var r = "function" == typeof self.Symbol && "symbol" == typeof self.Symbol.toPrimitive ? GetMethod(e, self.Symbol.toPrimitive) : void 0;
      if (void 0 !== r) {
        var o = Call(r, e, [i]);
        if ("object" !== Type(o)) return o;
        throw new TypeError("Cannot convert exotic object to primitive.");
      }
      return "default" === i && (i = "number"), OrdinaryToPrimitive(e, i);
    }
    return e;
  }
  function ToString(t) {
    switch (Type(t)) {
      case "symbol":
        throw new TypeError("Cannot convert a Symbol value to a string");
      case "object":
        return ToString(ToPrimitive(t, String));
      default:
        return String(t);
    }
  }
  function ToPropertyKey(r) {
    var i = ToPrimitive(r, String);
    return "symbol" === Type(i) ? i : ToString(i);
  }
  CreateMethodProperty(Object, "hasOwn", function e(r, t) {
    var o = ToObject(r),
      n = ToPropertyKey(t);
    return HasOwnProperty(o, n);
  });
})('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});